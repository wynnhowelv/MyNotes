diff --git a/external/exfat-fuse/Android.mk b/external/exfat-fuse/Android.mk
new file mode 100755
index 0000000000..7cd6f881e2
--- /dev/null
+++ b/external/exfat-fuse/Android.mk
@@ -0,0 +1,49 @@
+EXFAT_ROOT := $(call my-dir)
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+EXFAT_CFLAGS := -D__GLIBC__ \
+                -D_FILE_OFFSET_BITS=64 \
+                -DALWAYS_USE_SYNC_OPTION=1 \
+                -DUSE_TRANSITIONAL_LFS=1 \
+                -I$(EXFAT_ROOT)/libexfat \
+                -I$(EXFAT_ROOT)/../fuse/include \
+		-Wno-error=format-security \
+		-Wno-unused-result \
+		-D__ANDROID_O \
+		-Wno-unused-variable \
+		-Wno-sign-compare \
+		-Wno-pointer-sign \
+		-Wno-unused-function \
+		-Wno-unused-parameter \
+		-Wno-unused-variable \
+		-Wno-implicit-function-declaration \
+		-Wno-unused-result \
+		-Wno-address-of-packed-member \
+		-Wno-missing-field-initializers \
+		-Wno-pointer-arith
+
+LOCAL_MODULE := mount.exfat
+LOCAL_SRC_FILES := main.c
+LOCAL_STATIC_LIBRARIES += libexfat_mount libexfat_fsck libexfat_mkfs libexfat_dump libexfat_label
+LOCAL_STATIC_LIBRARIES += libexfat libfuse
+include $(BUILD_EXECUTABLE)
+
+LINKS := fsck.exfat mkfs.exfat
+SYMLINKS := $(addprefix $(TARGET_OUT)/bin/,$(LINKS))
+$(SYMLINKS): EXFAT_BINARY := $(LOCAL_MODULE)
+$(SYMLINKS): $(LOCAL_INSTALLED_MODULE) $(LOCAL_PATH)/Android.mk
+	@echo "Symlink: $@ -> $(EXFAT_BINARY)"
+	@mkdir -p $(dir $@)
+	@rm -rf $@
+	$(hide) ln -sf $(EXFAT_BINARY) $@
+
+ALL_DEFAULT_INSTALLED_MODULES += $(SYMLINKS)
+
+include $(EXFAT_ROOT)/libexfat/Android.mk
+include $(EXFAT_ROOT)/fuse/Android.mk
+include $(EXFAT_ROOT)/mkfs/Android.mk
+include $(EXFAT_ROOT)/fsck/Android.mk
+include $(EXFAT_ROOT)/dump/Android.mk
+include $(EXFAT_ROOT)/label/Android.mk
diff --git a/external/exfat-fuse/COPYING b/external/exfat-fuse/COPYING
new file mode 100755
index 0000000000..d159169d10
--- /dev/null
+++ b/external/exfat-fuse/COPYING
@@ -0,0 +1,339 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff --git a/external/exfat-fuse/ChangeLog b/external/exfat-fuse/ChangeLog
new file mode 100755
index 0000000000..a741eae547
--- /dev/null
+++ b/external/exfat-fuse/ChangeLog
@@ -0,0 +1,122 @@
+1.1.1 (2014-11-15)
+
+* Fixed mkfs crash on some sectors-per-cluster (-s option) values.
+
+1.1.0 (2014-07-08)
+
+* Relicensed the project from GPLv3+ to GPLv2+.
+* OpenBSD support [Helg Bredow].
+* Improved I/O errors handling.
+* Implemented fsync() and fsyncdir().
+* Fixed crash on Mac OS X 10.5 caused by non-standard use of realpath(). Also
+fixed TrueCrypt disks unmounting.
+* Avoid extra erase on writes to the end of a file. This should improve linear
+write speed.
+* Allow arbitrary changing of lower 9 bits of mode. Allow owner/group changing
+to the same owner/group. This fixes rsync.
+* Fixed buffers overflows when handling lengthy file names.
+* Fixed "real size does not equal to size" error on volumes with pagefile.sys.
+* Fixed negative IUsed in "df -i" output.
+
+1.0.1 (2013-02-02)
+
+* Fixed unexpected removal of a directory if it is moved into itself.
+* Fixed "Operation not permitted" error on reading an empty file.
+
+1.0.0 (2013-01-19)
+
+* Fixed crash when renaming a file within a single directory and a new name
+differs only in case.
+* Fixed clusters allocation: a cluster beyond valid clusters range could be
+allocated.
+* Fixed crash when a volume is unmounted while some files are open.
+* SConscript now respects AR and RANLIB environment variables.
+* Improved error handling.
+
+Linux:
+
+* Enabled big_writes. This improves write speed (larger block size means less
+switches between kernel- and user-space).
+* Do BLKROGET ioctl to make sure the device is not read-only: after
+"blockdev --setro" kernel still allows to open the device in read-write mode
+but fails writes.
+
+OS X:
+
+* Fixed OS X 10.8 support.
+* Switched to 64-bit inode numbers (now Mac OS X 10.5 or later is required).
+* Switched from unmaintained MacFUSE to OSXFUSE (http://osxfuse.github.com).
+* Fixed device size detection. Now mkfs works.
+* Workarounded some utilities failures due to missing chmod() support.
+* Disabled (senseless) permission checks made by FUSE.
+
+0.9.8 (2012-08-09)
+
+* The mkfs utility can now create huge file systems (up to several exabytes).
+* Fixed handling of characters beyond Basic Multilingual Plane.
+* Echo messages to syslog only if stderr is not connected to a terminal.
+
+0.9.7 (2012-03-08)
+
+* Out-of-the-box FreeBSD support (via ublio library).
+* Fixed "missing EOD entry" error (could happen while reading directory that
+consists of several clusters).
+* Fixed interpretation of minutes field in files timestamps (minutes could be
+displayed incorrectly).
+* Fixed mtime seconds field initialization for newly created file (mtime could
+be 1 sec less than creation time).
+* SConscript now respects CC, CCFLAGS and LDFLAGS environment variables.
+
+0.9.6 (2012-01-14)
+
+* Fixed write performance regression introduced in 0.9.4.
+* Mount in read-only mode if the device is write-protected.
+* Set ctime to mtime to ensure we don't break programs that rely on ctime
+(e.g. rsync considered that all files are outdated) [Eldad Zack].
+* Indicate that FS in not clean when it was not cleanly unmounted.
+* Utilities are now compatible with GNU/Hurd.
+* Fixed several memory leaks that could occur on error handling paths.
+* Improved handling of corrupted file systems.
+
+0.9.5 (2011-05-15)
+
+* Fixed erasing of the root directory cluster when creating a new FS with
+mkexfatfs. This bug could cause mkexfatfs to produce invalid FS.
+* Utilities are not linked with libfuse anymore.
+* Ensure that the path being opened is either a device or a regular file.
+
+0.9.4 (2011-03-05)
+
+* Introduced exfat-utils: dumpexfat, exfatfsck, mkexfatfs, exfatlabel.
+* Fixed "Invalid argument" error while mounting a volume from a disk with sector size greater than 512 bytes.
+* Wait for all data to be flushed to disk on unmount.
+* Kernel cache is no longer flushed on open. This can slightly improve read performance by avoiding extra read requests from kernel to user-space.
+* Allow to unmount volumes as user (fusermount -u) if they were mounted from the very same user [Tino Lange].
+* Errors and warnings are now duplicated to syslog.
+
+0.9.3 (2010-09-25)
+
+* Directories now can shrink.
+* Improved timestamps resolution from 2 sec to 1 sec.
+* Fixed timestamps displaying under Mac OS X when compiled for i386 or ppc.
+* Fixed FS size displaying for non-GNU systems.
+
+0.9.2 (2010-07-24)
+
+* Fixed a bug which could cause the whole directory to become unreadable after renaming a file in it.
+* Support for Solaris and various *BSD [Albert Lee].
+* Improved error handling on corrupted volumes.
+* Improved allowed file name characters filter.
+* Added man page.
+
+0.9.1 (2010-06-12)
+
+* Implemented automounting (util-linux-ng 2.18 or later is required).
+* Fixed mounting when cluster bitmap is larger than expected.
+* Fixed crash on statfs() when root directory contains error.
+* Fixed bugs specific to big-endian machines.
+* Other bugfixes.
+
+0.9.0 (2010-03-21)
+
+* Initial release.
diff --git a/external/exfat-fuse/README.md b/external/exfat-fuse/README.md
new file mode 100755
index 0000000000..7b90c2e711
--- /dev/null
+++ b/external/exfat-fuse/README.md
@@ -0,0 +1,27 @@
+Based on [exfat 1.1.1 r422 sources](https://code.google.com/p/exfat/source/list). Initial Android project and modifications were taken from [OUYA repository](https://github.com/ouya/android_external_exfat).
+
+The changes made are:
+* Several patches to keep the file system consistent as much as possible. The original version keeps cluster map in memory, and flushes it to the disk only at unmount event. Also, it updates the file system information about changed files only on file close. This is unreliable for mobile use, especially when SD card is heavily used by applications. Moreover, modern Android does not unmout SD card (mounted not by `vold`) before reboot or power off. You can read a discussion with Andrew Nayenko (the exFAT author) [here](https://groups.google.com/forum/#!topic/exfat/u5Ldpmy3vkA).
+* Original source code uses 64-bit off_t type version, but Android NDK toolchain and libraries ignore `_FILE_OFFSET_BITS=64` define. Changed to `off64_t`, and also switched to `lseek64`, `pread64`, `pwrite64`.
+**Note:** It is not good to typedef `off_t` as 64-bit integer before including other headers, because it has side effect, in particular, it breaks stream I/O functions in Bionic libc.
+* Replaced `abort()` with exit`()` on emergency quit, because under Android `abort()` produces crash dump.
+* Starting from 1.0.4, Android build is default to "`noatime`" option, and ignores other values ("`atime`", "`relatime`") provided from the command line.
+
+This project produces only one binary file: `mount.exfat`. To have the full set of exFAT utilities, and/or for applications that expect other executable names, you have to run all or some of the following commands:
+
+    ln -s mount.exfat mount.exfat-fuse
+    ln -s mount.exfat dumpexfat
+    ln -s mount.exfat exfatfsck
+    ln -s mount.exfat exfatlabel
+    ln -s mount.exfat mkexfatfs
+    ln -s mount.exfat fsck.exfat
+    ln -s mount.exfat mkfs.exfat
+
+My auto-mount script creates all the links, if required.
+
+**Note regarding the file system consistency**
+All the changes to the functionality, compared to the original code, is active only if the volume was mounted with `sync` option. This `sync` option _does not_ sync every write with the underlying device, it only flushes file system changes earlier and more often, that the original version (or if mounted without `sync` option).
+
+Starting from [1.0.3](https://github.com/Lurker00/Android-fs/releases), this is the default behaviour for my Android builds: no `sync` option is required, and this safer behaviour can't be disabled under Android. 
+
+Starting from [1.0.4](https://github.com/Lurker00/Android-fs/releases), it marks the volume as opened only before making any changes to the file system, and unmarks it as soon as the files being written are closed, and changes are flushed to the device. Short operations (create/rename/delete files and directories) are finished with `fsync` to the device. Files under 32 MB are flushed and `fsync`ed on number of occupied clusters growth. For files bigger than 32 MB `fsync` is not used until closing, for the sake of performance.
diff --git a/external/exfat-fuse/SConstruct b/external/exfat-fuse/SConstruct
new file mode 100755
index 0000000000..6fadd8cd18
--- /dev/null
+++ b/external/exfat-fuse/SConstruct
@@ -0,0 +1,134 @@
+#
+#	SConstruct (10.09.09)
+#	SConscript for all components.
+#
+#	Free exFAT implementation.
+#	Copyright (C) 2010-2014  Andrew Nayenko
+#
+#	This program is free software; you can redistribute it and/or modify
+#	it under the terms of the GNU General Public License as published by
+#	the Free Software Foundation, either version 2 of the License, or
+#	(at your option) any later version.
+#
+#	This program is distributed in the hope that it will be useful,
+#	but WITHOUT ANY WARRANTY; without even the implied warranty of
+#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#	GNU General Public License for more details.
+#
+#	You should have received a copy of the GNU General Public License along
+#	with this program; if not, write to the Free Software Foundation, Inc.,
+#	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+
+import os
+import platform
+import SCons
+
+env = Environment(**ARGUMENTS)
+for var in ['PATH', 'SYSROOT']:
+	if var in os.environ:
+		env['ENV'][var] = os.environ[var]
+
+destdir = env.get('DESTDIR', '/sbin');
+libs = ['exfat']
+libfuse = 'fuse'
+
+if not env.GetOption('clean'):
+	conf = Configure(env)
+
+	if 'AR' in os.environ:
+		conf.env.Replace(AR = os.environ['AR'])
+	if 'RANLIB' in os.environ:
+		conf.env.Replace(RANLIB = os.environ['RANLIB'])
+	if 'CC' in os.environ:
+		conf.env.Replace(CC = os.environ['CC'])
+	if 'CCFLAGS' in os.environ:
+		conf.env.Replace(CCFLAGS = os.environ['CCFLAGS'])
+	# Set default CCFLAGS for known compilers
+	if not conf.env['CCFLAGS']:
+		if conf.env['CC'] == 'gcc':
+			conf.env.Replace(CCFLAGS = '-Wall -O2 -ggdb -std=c99')
+		elif conf.env['CC'] == 'clang':
+			conf.env.Replace(CCFLAGS = '-Wall -O2 -g -std=c99')
+	if 'CPPFLAGS' in os.environ:
+		conf.env.Replace(CPPFLAGS = os.environ['CPPFLAGS'])
+	conf.env.Append(CPPDEFINES = {'_FILE_OFFSET_BITS' : 64})
+	conf.env.Append(CPPPATH = ['libexfat'])
+	if 'LDFLAGS' in os.environ:
+		conf.env.Append(LINKFLAGS = os.environ['LDFLAGS'])
+	conf.env.Append(LIBPATH = ['libexfat'])
+
+	# GNU/Linux requires _BSD_SOURCE define for vsyslog(), _XOPEN_SOURCE >= 500
+	# for pread(), pwrite(), snprintf(), strdup(), etc. Everything needed is
+	# enabled by _GNU_SOURCE.
+	if platform.system() == 'Linux':
+		conf.env.Append(CPPDEFINES = '_GNU_SOURCE');
+
+	# Use 64-bit inode numbers (introduced in Mac OS X 10.5 Leopard). Require
+	# OSXFUSE (http://osxfuse.github.com).
+	if platform.system() == 'Darwin':
+		conf.env.Append(CPPDEFINES = '_DARWIN_USE_64_BIT_INODE')
+		conf.env.Append(CPPDEFINES = {'__DARWIN_UNIX03' : 1})
+		conf.env.Append(CPPPATH = ['/usr/local/include/osxfuse'])
+		conf.env.Append(CFLAGS    = '-mmacosx-version-min=10.5')
+		conf.env.Append(LINKFLAGS = '-mmacosx-version-min=10.5')
+		libfuse = 'osxfuse_i64'
+
+	# FreeBSD does not support block devices, only raw devices. Ublio is
+	# required for unaligned I/O and caching.
+	if platform.system() == 'FreeBSD':
+		conf.env.Append(CPPDEFINES = 'USE_UBLIO')
+		libs.append('ublio')
+		conf.env.Append(CPPPATH = ['/usr/local/include'])
+		conf.env.Append(LIBPATH = ['/usr/local/lib'])
+
+	if not conf.CheckCC():
+		print '''
+	A working C compiler is needed very much.
+'''
+		Exit(1)
+
+	if not conf.CheckTypeSize('off_t', '#include <sys/types.h>', 'C', 8):
+		print '''
+	The size of off_t type must be 64 bits. File systems larger than
+	2 GB will be corrupted with 32-bit off_t.
+'''
+		Exit(1)
+
+	env = conf.Finish()
+
+
+
+def make_symlink(dir, target, link_name):
+	workdir = os.getcwd()
+	os.chdir(dir)
+	try:
+		os.remove(link_name)
+	except OSError:
+		pass
+	os.symlink(target, link_name)
+	os.chdir(workdir)
+
+symlink = SCons.Action.ActionFactory(make_symlink,
+		lambda dir, target, link_name:
+				'make_symlink("%s", "%s", "%s")' % (dir, target, link_name))
+
+def program(pattern, output, alias, libs):
+	sources = Glob(pattern)
+	if not sources:
+		return
+	target = env.Program(output, sources, LIBS = libs)
+	if alias:
+		Clean(Alias('install', Install(destdir, target),
+				symlink(destdir, os.path.basename(output), alias)),
+				destdir + '/' + alias)
+	else:
+		Alias('install', Install(destdir, target))
+
+env.Library('libexfat/exfat', Glob('libexfat/*.c'))
+
+program('fuse/*.c', 'fuse/mount.exfat-fuse', 'mount.exfat', [libs + [libfuse]])
+program('dump/*.c', 'dump/dumpexfat', None, libs)
+program('fsck/*.c', 'fsck/exfatfsck', 'fsck.exfat', libs)
+program('mkfs/*.c', 'mkfs/mkexfatfs', 'mkfs.exfat', libs)
+program('label/*.c', 'label/exfatlabel', None, libs)
diff --git a/external/exfat-fuse/dump/Android.mk b/external/exfat-fuse/dump/Android.mk
new file mode 100755
index 0000000000..a79761c209
--- /dev/null
+++ b/external/exfat-fuse/dump/Android.mk
@@ -0,0 +1,9 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_MODULE    := libexfat_dump
+LOCAL_SRC_FILES := main.c
+
+LOCAL_CFLAGS := $(EXFAT_CFLAGS)
+LOCAL_C_INCLUDES += $(LOCAL_PATH)
+include $(BUILD_STATIC_LIBRARY)
diff --git a/external/exfat-fuse/dump/dumpexfat.8 b/external/exfat-fuse/dump/dumpexfat.8
new file mode 100755
index 0000000000..1228134194
--- /dev/null
+++ b/external/exfat-fuse/dump/dumpexfat.8
@@ -0,0 +1,46 @@
+.\" Copyright (C) 2011-2014  Andrew Nayenko
+.\"
+.TH DUMPEXFAT 8 "February 2011"
+.SH NAME
+.B dumpexfat
+\- dump exFAT file system
+.SH SYNOPSIS
+.B exfatlabel
+[
+.B \-s
+]
+[
+.B \-u
+]
+[
+.B \-V
+]
+.I device
+
+.SH DESCRIPTION
+.B dumpexfat
+dumps details about exFAT file system including low-level info. All sizes are
+in bytes.
+
+.SH OPTIONS
+Command line options available:
+.TP
+.B \-s
+Dump only info from super block. May be useful for heavily corrupted file
+systems.
+.TP
+.B \-u
+Dump ranges of used sectors starting from 0 and separated with spaces. May be
+useful for backup tools.
+.TP
+.BI \-V
+Print version and copyright.
+
+.SH EXIT CODES
+Zero is returned on success. Any other code means an error.
+
+.SH AUTHOR
+Andrew Nayenko
+
+.SH SEE ALSO
+.BR mkexfatfs (8)
diff --git a/external/exfat-fuse/dump/main.c b/external/exfat-fuse/dump/main.c
new file mode 100755
index 0000000000..122d256d24
--- /dev/null
+++ b/external/exfat-fuse/dump/main.c
@@ -0,0 +1,184 @@
+/*
+	main.c (08.11.10)
+	Prints detailed information about exFAT volume.
+
+	Free exFAT implementation.
+	Copyright (C) 2011-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+#include <exfat.h>
+
+static void print_generic_info(const struct exfat_super_block* sb)
+{
+	printf("Volume serial number      0x%08x\n",
+			le32_to_cpu(sb->volume_serial));
+	printf("FS version                       %hhu.%hhu\n",
+			sb->version.major, sb->version.minor);
+	printf("Sector size               %10u\n",
+			SECTOR_SIZE(*sb));
+	printf("Cluster size              %10u\n",
+			CLUSTER_SIZE(*sb));
+}
+
+static void print_sector_info(const struct exfat_super_block* sb)
+{
+	printf("Sectors count             %10"PRIu64"\n",
+			le64_to_cpu(sb->sector_count));
+}
+
+static void print_cluster_info(const struct exfat_super_block* sb)
+{
+	printf("Clusters count            %10u\n",
+			le32_to_cpu(sb->cluster_count));
+}
+
+static void print_other_info(const struct exfat_super_block* sb)
+{
+	printf("First sector              %10"PRIu64"\n",
+			le64_to_cpu(sb->sector_start));
+	printf("FAT first sector          %10u\n",
+			le32_to_cpu(sb->fat_sector_start));
+	printf("FAT sectors count         %10u\n",
+			le32_to_cpu(sb->fat_sector_count));
+	printf("First cluster sector      %10u\n",
+			le32_to_cpu(sb->cluster_sector_start));
+	printf("Root directory cluster    %10u\n",
+			le32_to_cpu(sb->rootdir_cluster));
+	printf("Volume state                  0x%04hx\n",
+			le16_to_cpu(sb->volume_state));
+	printf("FATs count                %10hhu\n",
+			sb->fat_count);
+	printf("Drive number                    0x%02hhx\n",
+			sb->drive_no);
+	printf("Allocated space           %9hhu%%\n",
+			sb->allocated_percent);
+}
+
+static int dump_sb(const char* spec)
+{
+	struct exfat_dev* dev;
+	struct exfat_super_block sb;
+
+	dev = exfat_open(spec, EXFAT_MODE_RO);
+	if (dev == NULL)
+		return 1;
+
+	if (exfat_read(dev, &sb, sizeof(struct exfat_super_block)) < 0)
+	{
+		exfat_close(dev);
+		exfat_error("failed to read from '%s'", spec);
+		return 1;
+	}
+	if (memcmp(sb.oem_name, "EXFAT   ", sizeof(sb.oem_name)) != 0)
+	{
+		exfat_close(dev);
+		exfat_error("exFAT file system is not found on '%s'", spec);
+		return 1;
+	}
+
+	print_generic_info(&sb);
+	print_sector_info(&sb);
+	print_cluster_info(&sb);
+	print_other_info(&sb);
+
+	exfat_close(dev);
+	return 0;
+}
+
+static void dump_sectors(struct exfat* ef)
+{
+	off64_t a = 0, b = 0;
+
+	printf("Used sectors ");
+	while (exfat_find_used_sectors(ef, &a, &b) == 0)
+		printf(" %"PRIu64"-%"PRIu64, a, b);
+	puts("");
+}
+
+static int dump_full(const char* spec, bool used_sectors)
+{
+	struct exfat ef;
+	uint32_t free_clusters;
+	uint64_t free_sectors;
+
+	if (exfat_mount(&ef, spec, "ro") != 0)
+		return 1;
+
+	free_clusters = exfat_count_free_clusters(&ef);
+	free_sectors = (uint64_t) free_clusters << ef.sb->spc_bits;
+
+	printf("Volume label         %15s\n", exfat_get_label(&ef));
+	print_generic_info(ef.sb);
+	print_sector_info(ef.sb);
+	printf("Free sectors              %10"PRIu64"\n", free_sectors);
+	print_cluster_info(ef.sb);
+	printf("Free clusters             %10u\n", free_clusters);
+	print_other_info(ef.sb);
+	if (used_sectors)
+		dump_sectors(&ef);
+
+	exfat_unmount(&ef);
+	return 0;
+}
+
+static void usage(const char* prog)
+{
+	fprintf(stderr, "Usage: %s [-s] [-u] [-V] <device>\n", prog);
+	exit(1);
+}
+
+int dumpexfat_main(int argc, char* argv[])
+{
+	int opt;
+	const char* spec = NULL;
+	bool sb_only = false;
+	bool used_sectors = false;
+
+	printf("dumpexfat %u.%u.%u\n",
+			EXFAT_VERSION_MAJOR, EXFAT_VERSION_MINOR, EXFAT_VERSION_PATCH);
+
+	while ((opt = getopt(argc, argv, "suV")) != -1)
+	{
+		switch (opt)
+		{
+		case 's':
+			sb_only = true;
+			break;
+		case 'u':
+			used_sectors = true;
+			break;
+		case 'V':
+			puts("Copyright (C) 2011-2014  Andrew Nayenko");
+			return 0;
+		default:
+			usage(argv[0]);
+		}
+	}
+	if (argc - optind != 1)
+		usage(argv[0]);
+	spec = argv[optind];
+
+	if (sb_only)
+		return dump_sb(spec);
+
+	return dump_full(spec, used_sectors);
+}
diff --git a/external/exfat-fuse/fsck/Android.mk b/external/exfat-fuse/fsck/Android.mk
new file mode 100755
index 0000000000..dda8e6ee77
--- /dev/null
+++ b/external/exfat-fuse/fsck/Android.mk
@@ -0,0 +1,9 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_MODULE    := libexfat_fsck
+LOCAL_SRC_FILES := main.c
+
+LOCAL_CFLAGS := $(EXFAT_CFLAGS)
+LOCAL_C_INCLUDES += $(LOCAL_PATH)
+include $(BUILD_STATIC_LIBRARY)
diff --git a/external/exfat-fuse/fsck/exfatfsck.8 b/external/exfat-fuse/fsck/exfatfsck.8
new file mode 100755
index 0000000000..826abecda2
--- /dev/null
+++ b/external/exfat-fuse/fsck/exfatfsck.8
@@ -0,0 +1,32 @@
+.\" Copyright (C) 2011-2014  Andrew Nayenko
+.\"
+.TH EXFATFSCK 8 "February 2011"
+.SH NAME
+.B exfatfsck
+\- check an exFAT file system
+.SH SYNOPSIS
+.B exfatfsck
+[
+.B \-V
+]
+.I device
+
+.SH DESCRIPTION
+.B exfatfsck
+checks an exFAT file system for errors. Note that it cannot repair corrupted
+FS, it just reports found errors.
+
+.SH COMMAND LINE OPTIONS
+Command line options available:
+.TP
+.BI \-V
+Print version and copyright.
+
+.SH EXIT CODES
+Zero is returned if errors were not found. Any other code means an error.
+
+.SH AUTHOR
+Andrew Nayenko
+
+.SH SEE ALSO
+.BR fsck (8)
diff --git a/external/exfat-fuse/fsck/main.c b/external/exfat-fuse/fsck/main.c
new file mode 100755
index 0000000000..386c421f5d
--- /dev/null
+++ b/external/exfat-fuse/fsck/main.c
@@ -0,0 +1,200 @@
+/*
+	main.c (02.09.09)
+	exFAT file system checker.
+
+	Free exFAT implementation.
+	Copyright (C) 2011-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include <stdio.h>
+#include <string.h>
+#include <exfat.h>
+#include <exfatfs.h>
+#include <inttypes.h>
+#include <unistd.h>
+
+#define exfat_debug(format, ...)
+
+uint64_t files_count, directories_count;
+
+static int nodeck(struct exfat* ef, struct exfat_node* node)
+{
+	const cluster_t cluster_size = CLUSTER_SIZE(*ef->sb);
+	cluster_t clusters = (node->size + cluster_size - 1) / cluster_size;
+	cluster_t c = node->start_cluster;
+	int rc = 0;
+
+	while (clusters--)
+	{
+		if (CLUSTER_INVALID(c))
+		{
+			char name[UTF8_BYTES(EXFAT_NAME_MAX) + 1];
+
+			exfat_get_name(node, name, sizeof(name) - 1);
+			exfat_error("file '%s' has invalid cluster 0x%x", name, c);
+			rc = 1;
+			break;
+		}
+		if (BMAP_GET(ef->cmap.chunk, c - EXFAT_FIRST_DATA_CLUSTER) == 0)
+		{
+			char name[UTF8_BYTES(EXFAT_NAME_MAX) + 1];
+
+			exfat_get_name(node, name, sizeof(name) - 1);
+			exfat_error("cluster 0x%x of file '%s' is not allocated", c, name);
+			rc = 1;
+		}
+		c = exfat_next_cluster(ef, node, c);
+	}
+	return rc;
+}
+
+static void dirck(struct exfat* ef, const char* path)
+{
+	struct exfat_node* parent;
+	struct exfat_node* node;
+	struct exfat_iterator it;
+	int rc;
+	size_t path_length;
+	char* entry_path;
+
+	if (exfat_lookup(ef, &parent, path) != 0)
+		exfat_bug("directory '%s' is not found", path);
+	if (!(parent->flags & EXFAT_ATTRIB_DIR))
+		exfat_bug("'%s' is not a directory (0x%x)", path, parent->flags);
+	if (nodeck(ef, parent) != 0)
+	{
+		exfat_put_node(ef, parent);
+		return;
+	}
+
+	path_length = strlen(path);
+	entry_path = malloc(path_length + 1 + UTF8_BYTES(EXFAT_NAME_MAX) + 1);
+	if (entry_path == NULL)
+	{
+		exfat_put_node(ef, parent);
+		exfat_error("out of memory");
+		return;
+	}
+	strcpy(entry_path, path);
+	strcat(entry_path, "/");
+
+	rc = exfat_opendir(ef, parent, &it);
+	if (rc != 0)
+	{
+		free(entry_path);
+		exfat_put_node(ef, parent);
+		return;
+	}
+	while ((node = exfat_readdir(ef, &it)))
+	{
+		exfat_get_name(node, entry_path + path_length + 1,
+				UTF8_BYTES(EXFAT_NAME_MAX));
+		exfat_debug("%s: %s, %"PRIu64" bytes, cluster %u", entry_path,
+				IS_CONTIGUOUS(*node) ? "contiguous" : "fragmented",
+				node->size, node->start_cluster);
+		if (node->flags & EXFAT_ATTRIB_DIR)
+		{
+			directories_count++;
+			dirck(ef, entry_path);
+		}
+		else
+		{
+			files_count++;
+			nodeck(ef, node);
+		}
+		exfat_put_node(ef, node);
+	}
+	exfat_closedir(ef, &it);
+	exfat_put_node(ef, parent);
+	free(entry_path);
+}
+
+static void fsck(struct exfat* ef)
+{
+	exfat_print_info(ef->sb, exfat_count_free_clusters(ef));
+	dirck(ef, "");
+}
+
+static void usage(const char* prog)
+{
+	fprintf(stderr, "Usage: %s [-Vf] <device>\n", prog);
+	exit(1);
+}
+
+int exfatfsck_main(int argc, char* argv[])
+{
+	int opt;
+	const char* spec = NULL;
+	struct exfat ef;
+	bool do_fix = false;
+
+	printf("exfatfsck %u.%u.%u\n",
+			EXFAT_VERSION_MAJOR, EXFAT_VERSION_MINOR, EXFAT_VERSION_PATCH);
+
+	while ((opt = getopt(argc, argv, "Vf")) != -1)
+	{
+		switch (opt)
+		{
+		case 'V':
+			puts("Copyright (C) 2011-2014  Andrew Nayenko");
+			return 0;
+		case 'f':
+			do_fix = true;
+			break;
+		default:
+			usage(argv[0]);
+			break;
+		}
+	}
+	if (argc - optind != 1)
+		usage(argv[0]);
+	spec = argv[optind];
+
+	if (exfat_mount(&ef, spec, "ro") != 0)
+		return 1;
+
+	printf("Checking file system on %s.\n", spec);
+	fsck(&ef);
+	printf("Totally %"PRIu64" directories and %"PRIu64" files.\n",
+			directories_count, files_count);
+
+	puts("File system checking finished.");
+
+	if ( do_fix && exfat_errors == 0 && (le16_to_cpu(ef.sb->volume_state) & EXFAT_STATE_MOUNTED) != 0 )
+	{
+		puts("Closing the volume...");
+		exfat_unmount(&ef);
+		if ( exfat_mount(&ef, spec, "rw") != 0 )
+		{
+			puts("Failed to mount for writing!");
+			puts("No errors found.");
+			return 0;
+		}
+		ef.was_dirty = false; // The following unmount will clear EXFAT_STATE_MOUNTED!
+		puts("Done!");
+	}
+
+	exfat_unmount(&ef);
+	if ( exfat_errors != 0 )
+	{
+		printf("ERRORS FOUND: %d.\n", exfat_errors);
+		return 1;
+	}
+
+	puts("No errors found.");
+	return 0;
+}
diff --git a/external/exfat-fuse/fuse/Android.mk b/external/exfat-fuse/fuse/Android.mk
new file mode 100755
index 0000000000..579cdcea11
--- /dev/null
+++ b/external/exfat-fuse/fuse/Android.mk
@@ -0,0 +1,9 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_MODULE    := libexfat_mount
+LOCAL_SRC_FILES := main.c 
+
+LOCAL_CFLAGS := $(EXFAT_CFLAGS)
+LOCAL_C_INCLUDES += $(LOCAL_PATH)
+include $(BUILD_STATIC_LIBRARY)
diff --git a/external/exfat-fuse/fuse/main.c b/external/exfat-fuse/fuse/main.c
new file mode 100755
index 0000000000..2d3a7f69c7
--- /dev/null
+++ b/external/exfat-fuse/fuse/main.c
@@ -0,0 +1,656 @@
+/*
+	main.c (01.09.09)
+	FUSE-based exFAT implementation. Requires FUSE 2.6 or later.
+
+	Free exFAT implementation.
+	Copyright (C) 2010-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#define FUSE_USE_VERSION 26
+#include <fuse.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <exfat.h>
+#include <inttypes.h>
+#include <limits.h>
+#include <sys/types.h>
+#include <pwd.h>
+#include <unistd.h>
+
+#ifndef DEBUG
+	#define exfat_debug(format, ...)
+#endif
+
+#if !defined(FUSE_VERSION) || (FUSE_VERSION < 26)
+	#error FUSE 2.6 or later is required
+#endif
+
+const char* default_options = "ro_fallback,allow_other,blkdev,big_writes,"
+		"default_permissions";
+
+struct exfat ef;
+
+static struct exfat_node* get_node(const struct fuse_file_info* fi)
+{
+	return (struct exfat_node*) (size_t) fi->fh;
+}
+
+static void set_node(struct fuse_file_info* fi, struct exfat_node* node)
+{
+	fi->fh = (uint64_t) (size_t) node;
+}
+
+static int fuse_exfat_getattr(const char* path, struct stat* stbuf)
+{
+	struct exfat_node* node;
+	int rc;
+
+	exfat_debug("[%s] %s", __func__, path);
+
+	rc = exfat_lookup(&ef, &node, path);
+	if (rc != 0)
+		return rc;
+
+	exfat_stat(&ef, node, stbuf);
+	exfat_put_node(&ef, node);
+	return 0;
+}
+
+static int fuse_exfat_truncate(const char* path, off64_t size)
+{
+	struct exfat_node* node;
+	int rc;
+
+	exfat_debug("[%s] %s, %"PRId64, __func__, path, size);
+
+	rc = exfat_lookup(&ef, &node, path);
+	if (rc != 0)
+		return rc;
+
+	exfat_dirty(&ef, true);
+	rc = exfat_truncate(&ef, node, size, true);
+	if (rc != 0)
+	{
+		exfat_flush_node(&ef, node);	/* ignore return code */
+		exfat_put_node(&ef, node);
+		return rc;
+	}
+	rc = exfat_flush_node(&ef, node);
+	exfat_put_node(&ef, node);
+	return rc;
+}
+
+static int fuse_exfat_readdir(const char* path, void* buffer,
+		fuse_fill_dir_t filler, off64_t offset, struct fuse_file_info* fi)
+{
+	struct exfat_node* parent;
+	struct exfat_node* node;
+	struct exfat_iterator it;
+	int rc;
+	char name[UTF8_BYTES(EXFAT_NAME_MAX) + 1];
+
+	exfat_debug("[%s] %s", __func__, path);
+
+	rc = exfat_lookup(&ef, &parent, path);
+	if (rc != 0)
+		return rc;
+	if (!(parent->flags & EXFAT_ATTRIB_DIR))
+	{
+		exfat_put_node(&ef, parent);
+		exfat_error("'%s' is not a directory (0x%x)", path, parent->flags);
+		return -ENOTDIR;
+	}
+
+	filler(buffer, ".", NULL, 0);
+	filler(buffer, "..", NULL, 0);
+
+	rc = exfat_opendir(&ef, parent, &it);
+	if (rc != 0)
+	{
+		exfat_put_node(&ef, parent);
+		exfat_error("failed to open directory '%s'", path);
+		return rc;
+	}
+	while ((node = exfat_readdir(&ef, &it)))
+	{
+		exfat_get_name(node, name, sizeof(name) - 1);
+		exfat_debug("[%s] %s: %s, %"PRId64" bytes, cluster 0x%x", __func__,
+				name, IS_CONTIGUOUS(*node) ? "contiguous" : "fragmented",
+				node->size, node->start_cluster);
+		filler(buffer, name, NULL, 0);
+		exfat_put_node(&ef, node);
+	}
+	exfat_closedir(&ef, &it);
+	exfat_put_node(&ef, parent);
+	return 0;
+}
+
+static int fuse_exfat_open(const char* path, struct fuse_file_info* fi)
+{
+	struct exfat_node* node;
+	int rc;
+
+	exfat_debug("[%s] %s", __func__, path);
+
+	rc = exfat_lookup(&ef, &node, path);
+	if (rc != 0)
+		return rc;
+	set_node(fi, node);
+	fi->keep_cache = 1;
+	return 0;
+}
+
+static int fuse_exfat_release(const char* path, struct fuse_file_info* fi)
+{
+	/*
+	   This handler is called by FUSE on close() syscall. If the FUSE
+	   implementation does not call flush handler, we will flush node here.
+	   But in this case we will not be able to return an error to the caller.
+	   See fuse_exfat_flush() below.
+	*/
+	exfat_debug("[%s] %s", __func__, path);
+	exfat_flush_node(&ef, get_node(fi));
+	exfat_put_node(&ef, get_node(fi));
+	return 0; /* FUSE ignores this return value */
+}
+
+static int fuse_exfat_flush(const char* path, struct fuse_file_info* fi)
+{
+	/*
+	   This handler may be called by FUSE on close() syscall. FUSE also deals
+	   with removals of open files, so we don't free clusters on close but
+	   only on rmdir and unlink. If the FUSE implementation does not call this
+	   handler we will flush node on release. See fuse_exfat_relase() above.
+	*/
+	exfat_debug("[%s] %s", __func__, path);
+	return exfat_flush_node(&ef, get_node(fi));
+}
+
+static int fuse_exfat_fsync(const char* path, int datasync,
+		struct fuse_file_info *fi)
+{
+	int rc;
+
+	exfat_debug("[%s] %s", __func__, path);
+	rc = exfat_flush(&ef);
+	if (rc != 0)
+		return rc;
+	return exfat_sync(&ef);
+}
+
+static int fuse_exfat_read(const char* path, char* buffer, size_t size,
+		off64_t offset, struct fuse_file_info* fi)
+{
+	ssize_t ret;
+	struct exfat_node* node;
+
+	exfat_debug("[%s] %s (%zu bytes)", __func__, path, size);
+	node = get_node(fi);
+	ret = exfat_generic_pread(&ef, node, buffer, size, offset);
+	if (ret < 0)
+		return -EIO;
+#if !defined(ALWAYS_USE_SYNC_OPTION) || !ALWAYS_USE_SYNC_OPTION
+	if ( ef.sync )
+#endif
+	{
+		if ( !ef.ro && ef.noatime && (node->flags & EXFAT_ATTRIB_DIRTY) != 0 )
+			exfat_flush_node(&ef, node);
+	}
+	return ret;
+}
+
+static int fuse_exfat_write(const char* path, const char* buffer, size_t size,
+		off64_t offset, struct fuse_file_info* fi)
+{
+	struct exfat_node* node = get_node(fi);
+	exfat_debug("[%s] %s (%zu bytes)", __func__, path, size);
+	exfat_dirty(&ef, true);
+
+	uint32_t c1 = exfat_bytes2clusters(&ef, node->size);
+	ssize_t ret = exfat_generic_pwrite(&ef, node, buffer, size, offset);
+	uint32_t c2 = exfat_bytes2clusters(&ef, node->size);
+
+	if (ret < 0)
+		return -EIO;
+
+#if !defined(ALWAYS_USE_SYNC_OPTION) || !ALWAYS_USE_SYNC_OPTION
+	if ( ef->sync )
+#endif
+	{
+		if ( c1 != c2 )
+		{
+			// Keep FAT, free clusters map and metadata consistent,
+			// but don't close the volume, and don't sync!
+			// Here we sacrifice the consistency for the sake of write performance :(
+			// But we may end up with inconsistent cmap/FAT/metadata only on power loss
+			// or card removal during the long write.
+			ef.in_write = true;
+			int rc = exfat_flush_node(&ef, node);
+			ef.in_write = false;
+			if ( rc != 0 )
+				return -1;
+		}
+		ef.bytes_written += ret;
+		if ( (offset < 1024*1024 && c1 != c2) // every new cluster for small files, or at the file beginning
+		  || (offset < 16*1024*1024 && ef.bytes_written >= 2*1024*1024)
+		  || (offset < 32*1024*1024 && ef.bytes_written >= 8*1024*1024)
+		   )
+		{
+			// Sync every so many bytes written, but not for files >32 MB.
+			exfat_sync(&ef);
+		}
+	}
+	return ret;
+}
+
+static int fuse_exfat_unlink(const char* path)
+{
+	struct exfat_node* node;
+	int rc;
+
+	exfat_debug("[%s] %s", __func__, path);
+
+	rc = exfat_lookup(&ef, &node, path);
+	if (rc != 0)
+		return rc;
+
+	exfat_dirty(&ef, true);
+	rc = exfat_unlink(&ef, node);
+	exfat_put_node(&ef, node);
+	if (rc == 0)
+		rc = exfat_cleanup_node(&ef, node);
+	exfat_dirty(&ef, false);
+	return rc;
+}
+
+static int fuse_exfat_rmdir(const char* path)
+{
+	struct exfat_node* node;
+	int rc;
+
+	exfat_debug("[%s] %s", __func__, path);
+
+	rc = exfat_lookup(&ef, &node, path);
+	if (rc != 0)
+		return rc;
+
+	exfat_dirty(&ef, true);
+	rc = exfat_rmdir(&ef, node);
+	exfat_put_node(&ef, node);
+	if (rc == 0)
+		rc = exfat_cleanup_node(&ef, node);
+	exfat_dirty(&ef, false);
+	return rc;
+}
+
+static int fuse_exfat_mknod(const char* path, mode_t mode, dev_t dev)
+{
+	int rc;
+	exfat_debug("[%s] %s 0%ho", __func__, path, mode);
+	exfat_dirty(&ef, true);
+	rc = exfat_mknod(&ef, path);
+	exfat_dirty(&ef, false);
+	return rc;
+}
+
+static int fuse_exfat_mkdir(const char* path, mode_t mode)
+{
+	int rc;
+	exfat_debug("[%s] %s 0%ho", __func__, path, mode);
+	exfat_dirty(&ef, true);
+	rc = exfat_mkdir(&ef, path);
+	exfat_dirty(&ef, false);
+	return rc;
+}
+
+static int fuse_exfat_rename(const char* old_path, const char* new_path)
+{
+	int rc;
+	exfat_debug("[%s] %s => %s", __func__, old_path, new_path);
+	exfat_dirty(&ef, true);
+	rc = exfat_rename(&ef, old_path, new_path);
+	exfat_dirty(&ef, false);
+	return rc;
+}
+
+static int fuse_exfat_utimens(const char* path, const struct timespec tv[2])
+{
+	struct exfat_node* node;
+	int rc;
+
+	exfat_debug("[%s] %s", __func__, path);
+
+	rc = exfat_lookup(&ef, &node, path);
+	if (rc != 0)
+		return rc;
+
+	exfat_utimes(node, tv);
+	rc = exfat_flush_node(&ef, node);
+	exfat_put_node(&ef, node);
+	return rc;
+}
+
+static int fuse_exfat_chmod(const char* path, mode_t mode)
+{
+	const mode_t VALID_MODE_MASK = S_IFREG | S_IFDIR |
+			S_IRWXU | S_IRWXG | S_IRWXO;
+
+	exfat_debug("[%s] %s 0%ho", __func__, path, mode);
+	if (mode & ~VALID_MODE_MASK)
+		return -EPERM;
+	return 0;
+}
+
+static int fuse_exfat_chown(const char* path, uid_t uid, gid_t gid)
+{
+	exfat_debug("[%s] %s %u:%u", __func__, path, uid, gid);
+	if (uid != ef.uid || gid != ef.gid)
+		return -EPERM;
+	return 0;
+}
+
+static int fuse_exfat_statfs(const char* path, struct statvfs* sfs)
+{
+	exfat_debug("[%s]", __func__);
+
+	sfs->f_bsize = CLUSTER_SIZE(*ef.sb);
+	sfs->f_frsize = CLUSTER_SIZE(*ef.sb);
+	sfs->f_blocks = le64_to_cpu(ef.sb->sector_count) >> ef.sb->spc_bits;
+	sfs->f_bavail = exfat_count_free_clusters(&ef);
+	sfs->f_bfree = sfs->f_bavail;
+	sfs->f_namemax = EXFAT_NAME_MAX;
+
+	/*
+	   Below are fake values because in exFAT there is
+	   a) no simple way to count files;
+	   b) no such thing as inode;
+	   So here we assume that inode = cluster.
+	*/
+	sfs->f_files = le32_to_cpu(ef.sb->cluster_count);
+	sfs->f_favail = sfs->f_bfree >> ef.sb->spc_bits;
+	sfs->f_ffree = sfs->f_bavail;
+
+	return 0;
+}
+
+static void* fuse_exfat_init(struct fuse_conn_info* fci)
+{
+	exfat_debug("[%s]", __func__);
+#ifdef FUSE_CAP_BIG_WRITES
+	fci->want |= FUSE_CAP_BIG_WRITES;
+#endif
+	return NULL;
+}
+
+static void fuse_exfat_destroy(void* unused)
+{
+	exfat_debug("[%s]", __func__);
+	exfat_unmount(&ef);
+}
+
+static void usage(const char* prog)
+{
+	fprintf(stderr, "Usage: %s [-d] [-o options] [-V] <device> <dir>\n", prog);
+	exit(1);
+}
+
+static struct fuse_operations fuse_exfat_ops =
+{
+	.getattr  = fuse_exfat_getattr,
+	.truncate = fuse_exfat_truncate,
+	.readdir  = fuse_exfat_readdir,
+	.open     = fuse_exfat_open,
+	.release  = fuse_exfat_release,
+	.flush    = fuse_exfat_flush,
+	.fsync    = fuse_exfat_fsync,
+	.fsyncdir = fuse_exfat_fsync,
+	.read     = fuse_exfat_read,
+	.write    = fuse_exfat_write,
+	.unlink   = fuse_exfat_unlink,
+	.rmdir    = fuse_exfat_rmdir,
+	.mknod    = fuse_exfat_mknod,
+	.mkdir    = fuse_exfat_mkdir,
+	.rename   = fuse_exfat_rename,
+	.utimens  = fuse_exfat_utimens,
+	.chmod    = fuse_exfat_chmod,
+	.chown    = fuse_exfat_chown,
+	.statfs   = fuse_exfat_statfs,
+	.init     = fuse_exfat_init,
+	.destroy  = fuse_exfat_destroy,
+};
+
+static char* add_option(char* options, const char* name, const char* value)
+{
+	size_t size;
+	char* optionsf = options;
+
+	if (value)
+		size = strlen(options) + strlen(name) + strlen(value) + 3;
+	else
+		size = strlen(options) + strlen(name) + 2;
+
+	options = realloc(options, size);
+	if (options == NULL)
+	{
+		free(optionsf);
+		exfat_error("failed to reallocate options string");
+		return NULL;
+	}
+	strcat(options, ",");
+	strcat(options, name);
+	if (value)
+	{
+		strcat(options, "=");
+		strcat(options, value);
+	}
+	return options;
+}
+
+static char* add_user_option(char* options)
+{
+	struct passwd* pw;
+
+	if (getuid() == 0)
+		return options;
+
+	pw = getpwuid(getuid());
+	if (pw == NULL || pw->pw_name == NULL)
+	{
+		free(options);
+		exfat_error("failed to determine username");
+		return NULL;
+	}
+	return add_option(options, "user", pw->pw_name);
+}
+
+static char* add_blksize_option(char* options, long cluster_size)
+{
+	long page_size = sysconf(_SC_PAGESIZE);
+	char blksize[20];
+
+	if (page_size < 1)
+		page_size = 0x1000;
+
+	snprintf(blksize, sizeof(blksize), "%ld", MIN(page_size, cluster_size));
+	return add_option(options, "blksize", blksize);
+}
+
+static char* add_fuse_options(char* options, const char* spec)
+{
+	options = add_option(options, "fsname", spec);
+	if (options == NULL)
+		return NULL;
+	options = add_user_option(options);
+	if (options == NULL)
+		return NULL;
+	options = add_blksize_option(options, CLUSTER_SIZE(*ef.sb));
+	if (options == NULL)
+		return NULL;
+
+	return options;
+}
+
+int mount_exfat_main(int argc, char* argv[])
+{
+	struct fuse_args mount_args = FUSE_ARGS_INIT(0, NULL);
+	struct fuse_args newfs_args = FUSE_ARGS_INIT(0, NULL);
+	const char* spec = NULL;
+	const char* mount_point = NULL;
+	char* mount_options;
+	int debug = 0;
+	struct fuse_chan* fc = NULL;
+	struct fuse* fh = NULL;
+	int opt;
+
+	printf("FUSE exfat %u.%u.%u\n",
+			EXFAT_VERSION_MAJOR, EXFAT_VERSION_MINOR, EXFAT_VERSION_PATCH);
+	fflush(stdout);
+
+	mount_options = strdup(default_options);
+	if (mount_options == NULL)
+	{
+		exfat_error("failed to allocate options string");
+		return 1;
+	}
+
+	while ((opt = getopt(argc, argv, "dno:Vv")) != -1)
+	{
+		switch (opt)
+		{
+		case 'd':
+			debug = 1;
+			break;
+		case 'n':
+			break;
+		case 'o':
+			mount_options = add_option(mount_options, optarg, NULL);
+			if (mount_options == NULL)
+				return 1;
+			break;
+		case 'V':
+			free(mount_options);
+			puts("Copyright (C) 2010-2014  Andrew Nayenko");
+			return 0;
+		case 'v':
+			break;
+		default:
+			free(mount_options);
+			usage(argv[0]);
+			break;
+		}
+	}
+	if (argc - optind != 2)
+	{
+		free(mount_options);
+		usage(argv[0]);
+	}
+	spec = argv[optind];
+	mount_point = argv[optind + 1];
+
+	if (exfat_mount(&ef, spec, mount_options) != 0)
+	{
+		free(mount_options);
+		return 1;
+	}
+
+	if (ef.ro == -1) /* read-only fallback was used */
+	{
+		mount_options = add_option(mount_options, "ro", NULL);
+		if (mount_options == NULL)
+		{
+			exfat_unmount(&ef);
+			return 1;
+		}
+	}
+
+	mount_options = add_fuse_options(mount_options, spec);
+	if (mount_options == NULL)
+	{
+		exfat_unmount(&ef);
+		return 1;
+	}
+
+	/* create arguments for fuse_mount() */
+	if (fuse_opt_add_arg(&mount_args, "exfat") != 0 ||
+		fuse_opt_add_arg(&mount_args, "-o") != 0 ||
+		fuse_opt_add_arg(&mount_args, mount_options) != 0)
+	{
+		exfat_unmount(&ef);
+		free(mount_options);
+		return 1;
+	}
+
+	free(mount_options);
+
+	/* create FUSE mount point */
+	fc = fuse_mount(mount_point, &mount_args);
+	fuse_opt_free_args(&mount_args);
+	if (fc == NULL)
+	{
+		exfat_unmount(&ef);
+		return 1;
+	}
+
+	/* create arguments for fuse_new() */
+	if (fuse_opt_add_arg(&newfs_args, "") != 0 ||
+		(debug && fuse_opt_add_arg(&newfs_args, "-d") != 0))
+	{
+		fuse_unmount(mount_point, fc);
+		exfat_unmount(&ef);
+		return 1;
+	}
+
+	/* create new FUSE file system */
+	fh = fuse_new(fc, &newfs_args, &fuse_exfat_ops,
+			sizeof(struct fuse_operations), NULL);
+	fuse_opt_free_args(&newfs_args);
+	if (fh == NULL)
+	{
+		fuse_unmount(mount_point, fc);
+		exfat_unmount(&ef);
+		return 1;
+	}
+
+	/* exit session on HUP, TERM and INT signals and ignore PIPE signal */
+	if (fuse_set_signal_handlers(fuse_get_session(fh)) != 0)
+	{
+		fuse_unmount(mount_point, fc);
+		fuse_destroy(fh);
+		exfat_unmount(&ef);
+		exfat_error("failed to set signal handlers");
+		return 1;
+	}
+
+	/* go to background (unless "-d" option is passed) and run FUSE
+	   main loop */
+	if (fuse_daemonize(debug) == 0)
+	{
+		if (fuse_loop(fh) != 0)
+			exfat_error("FUSE loop failure");
+	}
+	else
+		exfat_error("failed to daemonize");
+
+	fuse_remove_signal_handlers(fuse_get_session(fh));
+	/* note that fuse_unmount() must be called BEFORE fuse_destroy() */
+	fuse_unmount(mount_point, fc);
+	fuse_destroy(fh);
+	return 0;
+}
diff --git a/external/exfat-fuse/fuse/mount.exfat-fuse.8 b/external/exfat-fuse/fuse/mount.exfat-fuse.8
new file mode 100755
index 0000000000..79d2f3fe66
--- /dev/null
+++ b/external/exfat-fuse/fuse/mount.exfat-fuse.8
@@ -0,0 +1,88 @@
+.\" Copyright (C) 2010-2014  Andrew Nayenko
+.\"
+.TH EXFAT-FUSE 8 "July 2010"
+.SH NAME
+mount.exfat-fuse \- mount an exFAT file system
+.SH SYNOPSIS
+.B mount.exfat-fuse
+[
+.B \-d
+]
+[
+.B \-n
+]
+[
+.B \-o
+.I options
+]
+[
+.B \-V
+]
+[
+.B \-v
+]
+.I device dir
+
+.SH DESCRIPTION
+.B mount.exfat-fuse
+is a free exFAT file system implementation with write support. exFAT is a
+simple file system created by Microsoft. It is intended to replace FAT32
+removing some of its limitations. exFAT is a standard FS for SDXC memory
+cards.
+
+.SH COMMAND LINE OPTIONS
+Command line options available:
+.TP
+.BI \-d
+Enable debug logging and do not detach from shell.
+.TP
+.BI \-n
+Ignored.
+.TP
+.BI \-o " options"
+File system specific options. For more details see
+.B FILE SYSTEM OPTIONS
+section below.
+.TP
+.BI \-V
+Print version and copyright.
+.TP
+.BI \-v
+Ignored.
+
+.SH FILE SYSTEM OPTIONS
+.TP
+.BI umask= value
+Set the umask (the bitmask of the permissions that are
+.B not
+present, in octal).
+The default is the umask of the current process.
+.TP
+.BI dmask= value
+Set the umask for directories only.
+.TP
+.BI fmask= value
+Set the umask for files only.
+.TP
+.BI uid= n
+Set the owner for all files and directories.
+The default is the owner of the current process.
+.TP
+.BI gid= n
+Set the group for all files and directories.
+The default is the group of the current process.
+.TP
+.BI ro
+Mount the file system in read only mode.
+.TP
+.BI noatime
+Do not update access time when file is read.
+
+.SH EXIT CODES
+Zero is returned on successful mount. Any other code means an error.
+
+.SH AUTHOR
+Andrew Nayenko
+
+.SH SEE ALSO
+.BR mount (8)
diff --git a/external/exfat-fuse/label/Android.mk b/external/exfat-fuse/label/Android.mk
new file mode 100755
index 0000000000..ca35e42556
--- /dev/null
+++ b/external/exfat-fuse/label/Android.mk
@@ -0,0 +1,9 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_MODULE    := libexfat_label
+LOCAL_SRC_FILES := main.c
+
+LOCAL_CFLAGS := $(EXFAT_CFLAGS)
+LOCAL_C_INCLUDES += $(LOCAL_PATH)
+include $(BUILD_STATIC_LIBRARY)
diff --git a/external/exfat-fuse/label/exfatlabel.8 b/external/exfat-fuse/label/exfatlabel.8
new file mode 100755
index 0000000000..b427dec6f6
--- /dev/null
+++ b/external/exfat-fuse/label/exfatlabel.8
@@ -0,0 +1,48 @@
+.\" Copyright (C) 2011-2014  Andrew Nayenko
+.\"
+.TH EXFATLABEL 8 "February 2011"
+.SH NAME
+.B exfatlabel
+\- get or set an exFAT file system label
+.SH SYNOPSIS
+.B exfatlabel
+[
+.B \-V
+]
+.I device
+[
+.I label
+]
+
+.SH DESCRIPTION
+.B exfatlabel
+reads or changes an exFAT file system label (volume name).
+
+If
+.I label
+argument is present,
+.B exfatlabel
+sets the new volume name. Label can be up to 15 characters. This limit is
+shorter if characters beyond Unicode BMP are used because internally label
+is stored in UTF-16.
+
+If
+.I label
+argument is omitted,
+.B exfatlabel
+just prints current volume name.
+
+.SH COMMAND LINE OPTIONS
+Command line options available:
+.TP
+.BI \-V
+Print version and copyright.
+
+.SH EXIT CODES
+Zero is returned on success. Any other code means an error.
+
+.SH AUTHOR
+Andrew Nayenko
+
+.SH SEE ALSO
+.BR mkexfatfs (8)
diff --git a/external/exfat-fuse/label/main.c b/external/exfat-fuse/label/main.c
new file mode 100755
index 0000000000..fdabd1e59e
--- /dev/null
+++ b/external/exfat-fuse/label/main.c
@@ -0,0 +1,63 @@
+/*
+	main.c (20.01.11)
+	Prints or changes exFAT volume label.
+
+	Free exFAT implementation.
+	Copyright (C) 2011-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include <stdio.h>
+#include <string.h>
+#include <exfat.h>
+
+int exfatlabel_main(int argc, char* argv[])
+{
+	char** pp;
+	struct exfat ef;
+	int rc = 0;
+
+	for (pp = argv + 1; *pp; pp++)
+		if (strcmp(*pp, "-V") == 0)
+		{
+			printf("exfatlabel %u.%u.%u\n", EXFAT_VERSION_MAJOR,
+					EXFAT_VERSION_MINOR, EXFAT_VERSION_PATCH);
+			puts("Copyright (C) 2011-2014  Andrew Nayenko");
+			return 0;
+		}
+
+	if (argc != 2 && argc != 3)
+	{
+		fprintf(stderr, "Usage: %s [-V] <device> [label]\n", argv[0]);
+		return 1;
+	}
+
+	if (argv[2])
+	{
+		if (exfat_mount(&ef, argv[1], "") != 0)
+			return 1;
+		rc = (exfat_set_label(&ef, argv[2]) != 0);
+	}
+	else
+	{
+		if (exfat_mount(&ef, argv[1], "ro") != 0)
+			return 1;
+		puts(exfat_get_label(&ef));
+	}
+
+	exfat_unmount(&ef);
+	return rc;
+}
diff --git a/external/exfat-fuse/libexfat/Android.mk b/external/exfat-fuse/libexfat/Android.mk
new file mode 100755
index 0000000000..78c1700fa8
--- /dev/null
+++ b/external/exfat-fuse/libexfat/Android.mk
@@ -0,0 +1,9 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_MODULE    := libexfat
+LOCAL_SRC_FILES := cluster.c io.c log.c lookup.c mount.c node.c time.c utf.c utils.c 
+
+LOCAL_CFLAGS := $(EXFAT_CFLAGS)
+LOCAL_C_INCLUDES += $(LOCAL_PATH)
+include $(BUILD_STATIC_LIBRARY)
diff --git a/external/exfat-fuse/libexfat/byteorder.h b/external/exfat-fuse/libexfat/byteorder.h
new file mode 100755
index 0000000000..dd039f2830
--- /dev/null
+++ b/external/exfat-fuse/libexfat/byteorder.h
@@ -0,0 +1,67 @@
+/*
+	byteorder.h (12.01.10)
+	Endianness stuff. exFAT uses little-endian byte order.
+
+	Free exFAT implementation.
+	Copyright (C) 2010-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#ifndef BYTEORDER_H_INCLUDED
+#define BYTEORDER_H_INCLUDED
+
+#include <stdint.h>
+#include "platform.h"
+
+typedef struct { uint16_t __u16; } le16_t;
+typedef struct { uint32_t __u32; } le32_t;
+typedef struct { uint64_t __u64; } le64_t;
+
+#if EXFAT_BYTE_ORDER == EXFAT_LITTLE_ENDIAN
+
+static inline uint16_t le16_to_cpu(le16_t v) { return v.__u16; }
+static inline uint32_t le32_to_cpu(le32_t v) { return v.__u32; }
+static inline uint64_t le64_to_cpu(le64_t v) { return v.__u64; }
+
+static inline le16_t cpu_to_le16(uint16_t v) { le16_t t = {v}; return t; }
+static inline le32_t cpu_to_le32(uint32_t v) { le32_t t = {v}; return t; }
+static inline le64_t cpu_to_le64(uint64_t v) { le64_t t = {v}; return t; }
+
+typedef size_t bitmap_t;
+
+#elif EXFAT_BYTE_ORDER == EXFAT_BIG_ENDIAN
+
+static inline uint16_t le16_to_cpu(le16_t v)
+	{ return exfat_bswap16(v.__u16); }
+static inline uint32_t le32_to_cpu(le32_t v)
+	{ return exfat_bswap32(v.__u32); }
+static inline uint64_t le64_to_cpu(le64_t v)
+	{ return exfat_bswap64(v.__u64); }
+
+static inline le16_t cpu_to_le16(uint16_t v)
+	{ le16_t t = {exfat_bswap16(v)}; return t; }
+static inline le32_t cpu_to_le32(uint32_t v)
+	{ le32_t t = {exfat_bswap32(v)}; return t; }
+static inline le64_t cpu_to_le64(uint64_t v)
+	{ le64_t t = {exfat_bswap64(v)}; return t; }
+
+typedef unsigned char bitmap_t;
+
+#else
+#error Wow! You have a PDP machine?!
+#endif
+
+#endif /* ifndef BYTEORDER_H_INCLUDED */
diff --git a/external/exfat-fuse/libexfat/cluster.c b/external/exfat-fuse/libexfat/cluster.c
new file mode 100755
index 0000000000..26df594e73
--- /dev/null
+++ b/external/exfat-fuse/libexfat/cluster.c
@@ -0,0 +1,500 @@
+/*
+	cluster.c (03.09.09)
+	exFAT file system implementation library.
+
+	Free exFAT implementation.
+	Copyright (C) 2010-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include "exfat.h"
+#include <errno.h>
+#include <string.h>
+#include <inttypes.h>
+
+/*
+ * Sector to absolute offset.
+ */
+static off64_t s2o(const struct exfat* ef, off64_t sector)
+{
+	return sector << ef->sb->sector_bits;
+}
+
+/*
+ * Cluster to sector.
+ */
+static off64_t c2s(const struct exfat* ef, cluster_t cluster)
+{
+	if (cluster < EXFAT_FIRST_DATA_CLUSTER)
+		exfat_bug("invalid cluster number %u", cluster);
+	return le32_to_cpu(ef->sb->cluster_sector_start) +
+		((off64_t) (cluster - EXFAT_FIRST_DATA_CLUSTER) << ef->sb->spc_bits);
+}
+
+/*
+ * Cluster to absolute offset.
+ */
+off64_t exfat_c2o(const struct exfat* ef, cluster_t cluster)
+{
+	return s2o(ef, c2s(ef, cluster));
+}
+
+/*
+ * Sector to cluster.
+ */
+static cluster_t s2c(const struct exfat* ef, off64_t sector)
+{
+	return ((sector - le32_to_cpu(ef->sb->cluster_sector_start)) >>
+			ef->sb->spc_bits) + EXFAT_FIRST_DATA_CLUSTER;
+}
+
+/*
+ * Size in bytes to size in clusters (rounded upwards).
+ */
+uint32_t exfat_bytes2clusters(const struct exfat* ef, uint64_t bytes)
+{
+	uint64_t cluster_size = CLUSTER_SIZE(*ef->sb);
+	return (bytes + cluster_size - 1) / cluster_size;
+}
+
+cluster_t exfat_next_cluster(const struct exfat* ef,
+		const struct exfat_node* node, cluster_t cluster)
+{
+	le32_t next;
+	off64_t fat_offset;
+
+	if (cluster < EXFAT_FIRST_DATA_CLUSTER)
+		exfat_bug("bad cluster 0x%x", cluster);
+
+	if (IS_CONTIGUOUS(*node))
+		return cluster + 1;
+	fat_offset = s2o(ef, le32_to_cpu(ef->sb->fat_sector_start))
+		+ cluster * sizeof(next);
+	if (exfat_pread(ef->dev, &next, sizeof(next), fat_offset) < 0)
+		return EXFAT_CLUSTER_BAD; /* the caller should handle this and print
+		                             appropriate error message */
+	return le32_to_cpu(next);
+}
+
+cluster_t exfat_advance_cluster(const struct exfat* ef,
+		struct exfat_node* node, uint32_t count)
+{
+	uint32_t i;
+
+	if (node->fptr_index > count)
+	{
+		node->fptr_index = 0;
+		node->fptr_cluster = node->start_cluster;
+	}
+
+	for (i = node->fptr_index; i < count; i++)
+	{
+		node->fptr_cluster = exfat_next_cluster(ef, node, node->fptr_cluster);
+		if (CLUSTER_INVALID(node->fptr_cluster))
+			break; /* the caller should handle this and print appropriate 
+			          error message */
+	}
+	node->fptr_index = count;
+	return node->fptr_cluster;
+}
+
+static cluster_t find_bit_and_set(bitmap_t* bitmap, size_t start, size_t end)
+{
+	const size_t start_index = start / sizeof(bitmap_t) / 8;
+	const size_t end_index = DIV_ROUND_UP(end, sizeof(bitmap_t) * 8);
+	size_t i;
+	size_t start_bitindex;
+	size_t end_bitindex;
+	size_t c;
+
+	for (i = start_index; i < end_index; i++)
+	{
+		if (bitmap[i] == ~((bitmap_t) 0))
+			continue;
+		start_bitindex = MAX(i * sizeof(bitmap_t) * 8, start);
+		end_bitindex = MIN((i + 1) * sizeof(bitmap_t) * 8, end);
+		for (c = start_bitindex; c < end_bitindex; c++)
+			if (BMAP_GET(bitmap, c) == 0)
+			{
+				BMAP_SET(bitmap, c);
+				return c + EXFAT_FIRST_DATA_CLUSTER;
+			}
+	}
+	return EXFAT_CLUSTER_END;
+}
+
+static int flush_nodes(struct exfat* ef, struct exfat_node* node)
+{
+	struct exfat_node* p;
+
+	for (p = node->child; p != NULL; p = p->next)
+	{
+		int rc = flush_nodes(ef, p);
+		if (rc != 0)
+			return rc;
+	}
+	return exfat_flush_node(ef, node);
+}
+
+int exfat_flush(struct exfat* ef)
+{
+	int rc = flush_nodes(ef, ef->root);
+
+	if ( !exfat_flush_cmap(ef) )
+		return -EIO;
+
+	return rc;
+}
+
+bool exfat_flush_cmap(struct exfat* ef)
+{
+	if (ef->cmap.dirty)
+	{
+		if (exfat_pwrite(ef->dev, ef->cmap.chunk,
+				BMAP_SIZE(ef->cmap.chunk_size),
+				exfat_c2o(ef, ef->cmap.start_cluster)) < 0)
+		{
+			exfat_error("failed to write clusters bitmap");
+			ef->was_dirty = true; // Leaves the volume "mounted", to force chkdsk on it.
+			return false;
+		}
+		ef->cmap.dirty = false;
+	}
+	if ( ef->in_write )
+		return true;
+	return exfat_dirty(ef, false) == 0;
+}
+
+static bool set_next_cluster(struct exfat* ef, bool contiguous,
+		cluster_t current, cluster_t next)
+{
+	off64_t fat_offset;
+	le32_t next_le32;
+
+	if (contiguous)
+		return true;
+	fat_offset = s2o(ef, le32_to_cpu(ef->sb->fat_sector_start))
+		+ current * sizeof(next_le32);
+	next_le32 = cpu_to_le32(next);
+	if (exfat_pwrite(ef->dev, &next_le32, sizeof(next_le32), fat_offset) < 0)
+	{
+		exfat_error("failed to write the next cluster %#x after %#x", next,
+				current);
+		ef->was_dirty = true; // Leaves the volume "mounted", to force chkdsk on it.
+		return false;
+	}
+	return true;
+}
+
+static cluster_t allocate_cluster(struct exfat* ef, cluster_t hint)
+{
+	cluster_t cluster;
+
+	hint -= EXFAT_FIRST_DATA_CLUSTER;
+	if (hint >= ef->cmap.chunk_size)
+		hint = 0;
+
+	cluster = find_bit_and_set(ef->cmap.chunk, hint, ef->cmap.chunk_size);
+	if (cluster == EXFAT_CLUSTER_END)
+		cluster = find_bit_and_set(ef->cmap.chunk, 0, hint);
+	if (cluster == EXFAT_CLUSTER_END)
+	{
+		exfat_error("no free space left");
+		return EXFAT_CLUSTER_END;
+	}
+
+	ef->cmap.dirty = true;
+	return cluster;
+}
+
+static void free_cluster(struct exfat* ef, cluster_t cluster)
+{
+	if (CLUSTER_INVALID(cluster))
+		exfat_bug("freeing invalid cluster 0x%x", cluster);
+	if (cluster - EXFAT_FIRST_DATA_CLUSTER >= ef->cmap.size)
+		exfat_bug("freeing non-existing cluster 0x%x (0x%x)", cluster,
+				ef->cmap.size);
+
+	BMAP_CLR(ef->cmap.chunk, cluster - EXFAT_FIRST_DATA_CLUSTER);
+	ef->cmap.dirty = true;
+}
+
+static bool make_noncontiguous(struct exfat* ef, cluster_t first,
+		cluster_t last)
+{
+	cluster_t c;
+
+	for (c = first; c < last; c++)
+		if (!set_next_cluster(ef, false, c, c + 1))
+			return false;
+	return true;
+}
+
+static int shrink_file(struct exfat* ef, struct exfat_node* node,
+		uint32_t current, uint32_t difference);
+
+static int grow_file(struct exfat* ef, struct exfat_node* node,
+		uint32_t current, uint32_t difference)
+{
+	cluster_t previous;
+	cluster_t next;
+	uint32_t allocated = 0;
+
+	if (difference == 0)
+		exfat_bug("zero clusters count passed");
+
+	if (node->start_cluster != EXFAT_CLUSTER_FREE)
+	{
+		/* get the last cluster of the file */
+		previous = exfat_advance_cluster(ef, node, current - 1);
+		if (CLUSTER_INVALID(previous))
+		{
+			exfat_error("invalid cluster 0x%x while growing", previous);
+			return -EIO;
+		}
+	}
+	else
+	{
+		if (node->fptr_index != 0)
+			exfat_bug("non-zero pointer index (%u)", node->fptr_index);
+		/* file does not have clusters (i.e. is empty), allocate
+		   the first one for it */
+		previous = allocate_cluster(ef, 0);
+		if (CLUSTER_INVALID(previous))
+			return -ENOSPC;
+		node->fptr_cluster = node->start_cluster = previous;
+		allocated = 1;
+		/* file consists of only one cluster, so it's contiguous */
+		node->flags |= EXFAT_ATTRIB_CONTIGUOUS;
+	}
+
+	while (allocated < difference)
+	{
+		next = allocate_cluster(ef, previous + 1);
+		if (CLUSTER_INVALID(next))
+		{
+			if (allocated != 0)
+				shrink_file(ef, node, current + allocated, allocated);
+			return -ENOSPC;
+		}
+		if (next != previous - 1 && IS_CONTIGUOUS(*node))
+		{
+			/* it's a pity, but we are not able to keep the file contiguous
+			   anymore */
+			if (!make_noncontiguous(ef, node->start_cluster, previous))
+				return -EIO;
+			node->flags &= ~EXFAT_ATTRIB_CONTIGUOUS;
+			node->flags |= EXFAT_ATTRIB_DIRTY;
+		}
+		if (!set_next_cluster(ef, IS_CONTIGUOUS(*node), previous, next))
+			return -EIO;
+		previous = next;
+		allocated++;
+	}
+
+	if (!set_next_cluster(ef, IS_CONTIGUOUS(*node), previous,
+			EXFAT_CLUSTER_END))
+		return -EIO;
+	return 0;
+}
+
+static int shrink_file(struct exfat* ef, struct exfat_node* node,
+		uint32_t current, uint32_t difference)
+{
+	cluster_t previous;
+	cluster_t next;
+
+	if (difference == 0)
+		exfat_bug("zero difference passed");
+	if (node->start_cluster == EXFAT_CLUSTER_FREE)
+		exfat_bug("unable to shrink empty file (%u clusters)", current);
+	if (current < difference)
+		exfat_bug("file underflow (%u < %u)", current, difference);
+
+	/* crop the file */
+	if (current > difference)
+	{
+		cluster_t last = exfat_advance_cluster(ef, node,
+				current - difference - 1);
+		if (CLUSTER_INVALID(last))
+		{
+			exfat_error("invalid cluster 0x%x while shrinking", last);
+			return -EIO;
+		}
+		previous = exfat_next_cluster(ef, node, last);
+		if (!set_next_cluster(ef, IS_CONTIGUOUS(*node), last,
+				EXFAT_CLUSTER_END))
+			return -EIO;
+	}
+	else
+	{
+		previous = node->start_cluster;
+		node->start_cluster = EXFAT_CLUSTER_FREE;
+		node->flags |= EXFAT_ATTRIB_DIRTY;
+	}
+	node->fptr_index = 0;
+	node->fptr_cluster = node->start_cluster;
+
+	/* free remaining clusters */
+	while (difference--)
+	{
+		if (CLUSTER_INVALID(previous))
+		{
+			exfat_error("invalid cluster 0x%x while freeing after shrink",
+					previous);
+			return -EIO;
+		}
+		next = exfat_next_cluster(ef, node, previous);
+		if (!set_next_cluster(ef, IS_CONTIGUOUS(*node), previous,
+				EXFAT_CLUSTER_FREE))
+			return -EIO;
+		free_cluster(ef, previous);
+		previous = next;
+	}
+	return 0;
+}
+
+static bool erase_raw(struct exfat* ef, size_t size, off64_t offset)
+{
+	if (exfat_pwrite(ef->dev, ef->zero_cluster, size, offset) < 0)
+	{
+		exfat_error("failed to erase %zu bytes at %"PRId64, size, offset);
+		return false;
+	}
+	return true;
+}
+
+static int erase_range(struct exfat* ef, struct exfat_node* node,
+		uint64_t begin, uint64_t end)
+{
+	uint64_t cluster_boundary;
+	cluster_t cluster;
+
+	if (begin >= end)
+		return 0;
+
+	cluster_boundary = (begin | (CLUSTER_SIZE(*ef->sb) - 1)) + 1;
+	cluster = exfat_advance_cluster(ef, node,
+			begin / CLUSTER_SIZE(*ef->sb));
+	if (CLUSTER_INVALID(cluster))
+	{
+		exfat_error("invalid cluster 0x%x while erasing", cluster);
+		return -EIO;
+	}
+	/* erase from the beginning to the closest cluster boundary */
+	if (!erase_raw(ef, MIN(cluster_boundary, end) - begin,
+			exfat_c2o(ef, cluster) + begin % CLUSTER_SIZE(*ef->sb)))
+		return -EIO;
+	/* erase whole clusters */
+	while (cluster_boundary < end)
+	{
+		cluster = exfat_next_cluster(ef, node, cluster);
+		/* the cluster cannot be invalid because we have just allocated it */
+		if (CLUSTER_INVALID(cluster))
+			exfat_bug("invalid cluster 0x%x after allocation", cluster);
+		if (!erase_raw(ef, CLUSTER_SIZE(*ef->sb), exfat_c2o(ef, cluster)))
+			return -EIO;
+		cluster_boundary += CLUSTER_SIZE(*ef->sb);
+	}
+	return 0;
+}
+
+int exfat_truncate(struct exfat* ef, struct exfat_node* node, uint64_t size,
+		bool erase)
+{
+	uint32_t c1 = exfat_bytes2clusters(ef, node->size);
+	uint32_t c2 = exfat_bytes2clusters(ef, size);
+	int rc = 0;
+
+	if (node->references == 0 && node->parent)
+		exfat_bug("no references, node changes can be lost");
+
+	if (node->size == size)
+		return 0;
+
+	if (c1 < c2)
+		rc = grow_file(ef, node, c1, c2 - c1);
+	else if (c1 > c2)
+		rc = shrink_file(ef, node, c1, c1 - c2);
+
+	if (rc != 0)
+		return rc;
+
+	if (erase)
+	{
+		rc = erase_range(ef, node, node->size, size);
+		if (rc != 0)
+			return rc;
+	}
+
+	exfat_update_mtime(node);
+	node->size = size;
+	node->flags |= EXFAT_ATTRIB_DIRTY;
+	return 0;
+}
+
+uint32_t exfat_count_free_clusters(const struct exfat* ef)
+{
+	uint32_t free_clusters = 0;
+	uint32_t i;
+
+	for (i = 0; i < ef->cmap.size; i++)
+		if (BMAP_GET(ef->cmap.chunk, i) == 0)
+			free_clusters++;
+	return free_clusters;
+}
+
+static int find_used_clusters(const struct exfat* ef,
+		cluster_t* a, cluster_t* b)
+{
+	const cluster_t end = le32_to_cpu(ef->sb->cluster_count);
+
+	/* find first used cluster */
+	for (*a = *b + 1; *a < end; (*a)++)
+		if (BMAP_GET(ef->cmap.chunk, *a - EXFAT_FIRST_DATA_CLUSTER))
+			break;
+	if (*a >= end)
+		return 1;
+
+	/* find last contiguous used cluster */
+	for (*b = *a; *b < end; (*b)++)
+		if (BMAP_GET(ef->cmap.chunk, *b - EXFAT_FIRST_DATA_CLUSTER) == 0)
+		{
+			(*b)--;
+			break;
+		}
+
+	return 0;
+}
+
+int exfat_find_used_sectors(const struct exfat* ef, off64_t* a, off64_t* b)
+{
+	cluster_t ca, cb;
+
+	if (*a == 0 && *b == 0)
+		ca = cb = EXFAT_FIRST_DATA_CLUSTER - 1;
+	else
+	{
+		ca = s2c(ef, *a);
+		cb = s2c(ef, *b);
+	}
+	if (find_used_clusters(ef, &ca, &cb) != 0)
+		return 1;
+	if (*a != 0 || *b != 0)
+		*a = c2s(ef, ca);
+	*b = c2s(ef, cb) + (CLUSTER_SIZE(*ef->sb) - 1) / SECTOR_SIZE(*ef->sb);
+	return 0;
+}
diff --git a/external/exfat-fuse/libexfat/compiler.h b/external/exfat-fuse/libexfat/compiler.h
new file mode 100755
index 0000000000..816289c531
--- /dev/null
+++ b/external/exfat-fuse/libexfat/compiler.h
@@ -0,0 +1,66 @@
+/*
+	compiler.h (09.06.13)
+	Compiler-specific definitions. Note that unknown compiler is not a
+	showstopper.
+
+	Free exFAT implementation.
+	Copyright (C) 2010-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#ifndef COMPILER_H_INCLUDED
+#define COMPILER_H_INCLUDED
+
+#if __STDC_VERSION__ < 199901L
+#error C99-compliant compiler is required
+#endif
+
+#if defined(__clang__)
+
+#define PRINTF __attribute__((format(printf, 1, 2)))
+#define NORETURN __attribute__((noreturn))
+#define PACKED __attribute__((packed))
+#if __has_extension(c_static_assert)
+#define USE_C11_STATIC_ASSERT
+#endif
+
+#elif defined(__GNUC__)
+
+#define PRINTF __attribute__((format(printf, 1, 2)))
+#define NORETURN __attribute__((noreturn))
+#define PACKED __attribute__((packed))
+#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)
+#define USE_C11_STATIC_ASSERT
+#endif
+
+#else
+
+#define PRINTF
+#define NORETURN
+#define PACKED
+
+#endif
+
+#ifdef USE_C11_STATIC_ASSERT
+#define STATIC_ASSERT(cond) _Static_assert(cond, #cond)
+#else
+#define CONCAT2(a, b) a ## b
+#define CONCAT1(a, b) CONCAT2(a, b)
+#define STATIC_ASSERT(cond) \
+	extern void CONCAT1(static_assert, __LINE__)(int x[(cond) ? 1 : -1])
+#endif
+
+#endif /* ifndef COMPILER_H_INCLUDED */
diff --git a/external/exfat-fuse/libexfat/exfat.h b/external/exfat-fuse/libexfat/exfat.h
new file mode 100755
index 0000000000..a67bad69f3
--- /dev/null
+++ b/external/exfat-fuse/libexfat/exfat.h
@@ -0,0 +1,227 @@
+/*
+	exfat.h (29.08.09)
+	Definitions of structures and constants used in exFAT file system
+	implementation.
+
+	Free exFAT implementation.
+	Copyright (C) 2010-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#ifndef EXFAT_H_INCLUDED
+#define EXFAT_H_INCLUDED
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include <stdbool.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include "compiler.h"
+#include "exfatfs.h"
+#include "version.h"
+
+#define EXFAT_NAME_MAX 256
+#define EXFAT_ATTRIB_CONTIGUOUS 0x10000
+#define EXFAT_ATTRIB_CACHED     0x20000
+#define EXFAT_ATTRIB_DIRTY      0x40000
+#define EXFAT_ATTRIB_UNLINKED   0x80000
+#define IS_CONTIGUOUS(node) (((node).flags & EXFAT_ATTRIB_CONTIGUOUS) != 0)
+#define SECTOR_SIZE(sb) (1 << (sb).sector_bits)
+#define CLUSTER_SIZE(sb) (SECTOR_SIZE(sb) << (sb).spc_bits)
+#define CLUSTER_INVALID(c) \
+	((c) < EXFAT_FIRST_DATA_CLUSTER || (c) > EXFAT_LAST_DATA_CLUSTER)
+
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+#define MAX(a, b) ((a) > (b) ? (a) : (b))
+#define DIV_ROUND_UP(x, d) (((x) + (d) - 1) / (d))
+#define ROUND_UP(x, d) (DIV_ROUND_UP(x, d) * (d))
+#define UTF8_BYTES(c) ((c) * 6) /* UTF-8 character can occupy up to 6 bytes */
+
+#define BMAP_SIZE(count) (ROUND_UP(count, sizeof(bitmap_t) * 8) / 8)
+#define BMAP_BLOCK(index) ((index) / sizeof(bitmap_t) / 8)
+#define BMAP_MASK(index) ((bitmap_t) 1 << ((index) % (sizeof(bitmap_t) * 8)))
+#define BMAP_GET(bitmap, index) \
+	((bitmap)[BMAP_BLOCK(index)] & BMAP_MASK(index))
+#define BMAP_SET(bitmap, index) \
+	((bitmap)[BMAP_BLOCK(index)] |= BMAP_MASK(index))
+#define BMAP_CLR(bitmap, index) \
+	((bitmap)[BMAP_BLOCK(index)] &= ~BMAP_MASK(index))
+
+struct exfat_node
+{
+	struct exfat_node* parent;
+	struct exfat_node* child;
+	struct exfat_node* next;
+	struct exfat_node* prev;
+
+	int references;
+	uint32_t fptr_index;
+	cluster_t fptr_cluster;
+	cluster_t entry_cluster;
+	off64_t entry_offset;
+	cluster_t start_cluster;
+	int flags;
+	uint64_t size;
+	time_t mtime, atime;
+	le16_t name[EXFAT_NAME_MAX + 1];
+};
+
+enum exfat_mode
+{
+	EXFAT_MODE_RO,
+	EXFAT_MODE_RW,
+	EXFAT_MODE_ANY,
+};
+
+struct exfat_dev;
+
+struct exfat
+{
+	struct exfat_dev* dev;
+	struct exfat_super_block* sb;
+	le16_t* upcase;
+	size_t upcase_chars;
+	struct exfat_node* root;
+	struct
+	{
+		cluster_t start_cluster;
+		uint32_t size;				/* in bits */
+		bitmap_t* chunk;
+		uint32_t chunk_size;		/* in bits */
+		bool dirty;
+	}
+	cmap;
+	char label[UTF8_BYTES(EXFAT_ENAME_MAX) + 1];
+	void* zero_cluster;
+	int dmask, fmask;
+	uid_t uid;
+	gid_t gid;
+	int ro;
+	bool noatime;
+	bool sync;
+	bool was_dirty;
+	bool in_write;
+	uint64_t bytes_written;
+};
+
+/* in-core nodes iterator */
+struct exfat_iterator
+{
+	struct exfat_node* parent;
+	struct exfat_node* current;
+};
+
+struct exfat_human_bytes
+{
+	uint64_t value;
+	const char* unit;
+};
+
+extern int exfat_errors;
+
+void exfat_bug(const char* format, ...) PRINTF NORETURN;
+void exfat_error(const char* format, ...) PRINTF;
+void exfat_warn(const char* format, ...) PRINTF;
+void exfat_debug(const char* format, ...) PRINTF;
+
+struct exfat_dev* exfat_open(const char* spec, enum exfat_mode mode);
+int exfat_close(struct exfat_dev* dev);
+int exfat_fsync(struct exfat_dev* dev);
+int exfat_sync(struct exfat* ef);
+enum exfat_mode exfat_get_mode(const struct exfat_dev* dev);
+off64_t exfat_get_size(const struct exfat_dev* dev);
+off64_t exfat_seek(struct exfat_dev* dev, off64_t offset, int whence);
+ssize_t exfat_read(struct exfat_dev* dev, void* buffer, size_t size);
+ssize_t exfat_write(struct exfat_dev* dev, const void* buffer, size_t size);
+ssize_t exfat_pread(struct exfat_dev* dev, void* buffer, size_t size,
+		off64_t offset);
+ssize_t exfat_pwrite(struct exfat_dev* dev, const void* buffer, size_t size,
+		off64_t offset);
+ssize_t exfat_generic_pread(const struct exfat* ef, struct exfat_node* node,
+		void* buffer, size_t size, off64_t offset);
+ssize_t exfat_generic_pwrite(struct exfat* ef, struct exfat_node* node,
+		const void* buffer, size_t size, off64_t offset);
+
+int exfat_opendir(struct exfat* ef, struct exfat_node* dir,
+		struct exfat_iterator* it);
+void exfat_closedir(struct exfat* ef, struct exfat_iterator* it);
+struct exfat_node* exfat_readdir(struct exfat* ef, struct exfat_iterator* it);
+int exfat_lookup(struct exfat* ef, struct exfat_node** node,
+		const char* path);
+int exfat_split(struct exfat* ef, struct exfat_node** parent,
+		struct exfat_node** node, le16_t* name, const char* path);
+
+off64_t exfat_c2o(const struct exfat* ef, cluster_t cluster);
+uint32_t exfat_bytes2clusters(const struct exfat* ef, uint64_t bytes);
+cluster_t exfat_next_cluster(const struct exfat* ef,
+		const struct exfat_node* node, cluster_t cluster);
+cluster_t exfat_advance_cluster(const struct exfat* ef,
+		struct exfat_node* node, uint32_t count);
+int exfat_flush(struct exfat* ef);
+bool exfat_flush_cmap(struct exfat* ef);
+int exfat_truncate(struct exfat* ef, struct exfat_node* node, uint64_t size,
+		bool erase);
+uint32_t exfat_count_free_clusters(const struct exfat* ef);
+int exfat_find_used_sectors(const struct exfat* ef, off64_t* a, off64_t* b);
+
+void exfat_stat(const struct exfat* ef, const struct exfat_node* node,
+		struct stat* stbuf);
+void exfat_get_name(const struct exfat_node* node, char* buffer, size_t n);
+uint16_t exfat_start_checksum(const struct exfat_entry_meta1* entry);
+uint16_t exfat_add_checksum(const void* entry, uint16_t sum);
+le16_t exfat_calc_checksum(const struct exfat_entry_meta1* meta1,
+		const struct exfat_entry_meta2* meta2, const le16_t* name);
+uint32_t exfat_vbr_start_checksum(const void* sector, size_t size);
+uint32_t exfat_vbr_add_checksum(const void* sector, size_t size, uint32_t sum);
+le16_t exfat_calc_name_hash(const struct exfat* ef, const le16_t* name);
+void exfat_humanize_bytes(uint64_t value, struct exfat_human_bytes* hb);
+void exfat_print_info(const struct exfat_super_block* sb,
+		uint32_t free_clusters);
+
+int utf16_to_utf8(char* output, const le16_t* input, size_t outsize,
+		size_t insize);
+int utf8_to_utf16(le16_t* output, const char* input, size_t outsize,
+		size_t insize);
+size_t utf16_length(const le16_t* str);
+
+struct exfat_node* exfat_get_node(struct exfat_node* node);
+void exfat_put_node(struct exfat* ef, struct exfat_node* node);
+int exfat_cleanup_node(struct exfat* ef, struct exfat_node* node);
+int exfat_cache_directory(struct exfat* ef, struct exfat_node* dir);
+void exfat_reset_cache(struct exfat* ef);
+int exfat_flush_node(struct exfat* ef, struct exfat_node* node);
+int exfat_unlink(struct exfat* ef, struct exfat_node* node);
+int exfat_rmdir(struct exfat* ef, struct exfat_node* node);
+int exfat_mknod(struct exfat* ef, const char* path);
+int exfat_mkdir(struct exfat* ef, const char* path);
+int exfat_rename(struct exfat* ef, const char* old_path, const char* new_path);
+void exfat_utimes(struct exfat_node* node, const struct timespec tv[2]);
+void exfat_update_atime(struct exfat_node* node);
+void exfat_update_mtime(struct exfat_node* node);
+const char* exfat_get_label(struct exfat* ef);
+int exfat_set_label(struct exfat* ef, const char* label);
+
+int exfat_dirty(struct exfat* ef, bool dirty);
+int exfat_mount(struct exfat* ef, const char* spec, const char* options);
+void exfat_unmount(struct exfat* ef);
+
+time_t exfat_exfat2unix(le16_t date, le16_t time, uint8_t centisec);
+void exfat_unix2exfat(time_t unix_time, le16_t* date, le16_t* time,
+		uint8_t* centisec);
+void exfat_tzset(void);
+
+#endif /* ifndef EXFAT_H_INCLUDED */
diff --git a/external/exfat-fuse/libexfat/exfatfs.h b/external/exfat-fuse/libexfat/exfatfs.h
new file mode 100755
index 0000000000..fbec79f602
--- /dev/null
+++ b/external/exfat-fuse/libexfat/exfatfs.h
@@ -0,0 +1,173 @@
+/*
+	exfatfs.h (29.08.09)
+	Definitions of structures and constants used in exFAT file system.
+
+	Free exFAT implementation.
+	Copyright (C) 2010-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#ifndef EXFATFS_H_INCLUDED
+#define EXFATFS_H_INCLUDED
+
+#include "byteorder.h"
+
+typedef uint32_t cluster_t;		/* cluster number */
+
+#define EXFAT_FIRST_DATA_CLUSTER 2
+#define EXFAT_LAST_DATA_CLUSTER 0xfffffff6
+
+#define EXFAT_CLUSTER_FREE         0 /* free cluster */
+#define EXFAT_CLUSTER_BAD 0xfffffff7 /* cluster contains bad sector */
+#define EXFAT_CLUSTER_END 0xffffffff /* final cluster of file or directory */
+
+#define EXFAT_STATE_MOUNTED 2
+
+struct exfat_super_block
+{
+	uint8_t jump[3];				/* 0x00 jmp and nop instructions */
+	uint8_t oem_name[8];			/* 0x03 "EXFAT   " */
+	uint8_t	__unused1[53];			/* 0x0B always 0 */
+	le64_t sector_start;			/* 0x40 partition first sector */
+	le64_t sector_count;			/* 0x48 partition sectors count */
+	le32_t fat_sector_start;		/* 0x50 FAT first sector */
+	le32_t fat_sector_count;		/* 0x54 FAT sectors count */
+	le32_t cluster_sector_start;	/* 0x58 first cluster sector */
+	le32_t cluster_count;			/* 0x5C total clusters count */
+	le32_t rootdir_cluster;			/* 0x60 first cluster of the root dir */
+	le32_t volume_serial;			/* 0x64 volume serial number */
+	struct							/* 0x68 FS version */
+	{
+		uint8_t minor;
+		uint8_t major;
+	}
+	version;
+	le16_t volume_state;			/* 0x6A volume state flags */
+	uint8_t sector_bits;			/* 0x6C sector size as (1 << n) */
+	uint8_t spc_bits;				/* 0x6D sectors per cluster as (1 << n) */
+	uint8_t fat_count;				/* 0x6E always 1 */
+	uint8_t drive_no;				/* 0x6F always 0x80 */
+	uint8_t allocated_percent;		/* 0x70 percentage of allocated space */
+	uint8_t __unused2[397];			/* 0x71 always 0 */
+	le16_t boot_signature;			/* the value of 0xAA55 */
+}
+PACKED;
+STATIC_ASSERT(sizeof(struct exfat_super_block) == 512);
+
+#define EXFAT_ENTRY_VALID     0x80
+#define EXFAT_ENTRY_CONTINUED 0x40
+
+#define EXFAT_ENTRY_BITMAP    (0x01 | EXFAT_ENTRY_VALID)
+#define EXFAT_ENTRY_UPCASE    (0x02 | EXFAT_ENTRY_VALID)
+#define EXFAT_ENTRY_LABEL     (0x03 | EXFAT_ENTRY_VALID)
+#define EXFAT_ENTRY_FILE      (0x05 | EXFAT_ENTRY_VALID)
+#define EXFAT_ENTRY_FILE_INFO (0x00 | EXFAT_ENTRY_VALID | EXFAT_ENTRY_CONTINUED)
+#define EXFAT_ENTRY_FILE_NAME (0x01 | EXFAT_ENTRY_VALID | EXFAT_ENTRY_CONTINUED)
+
+struct exfat_entry					/* common container for all entries */
+{
+	uint8_t type;					/* any of EXFAT_ENTRY_xxx */
+	uint8_t data[31];
+}
+PACKED;
+STATIC_ASSERT(sizeof(struct exfat_entry) == 32);
+
+#define EXFAT_ENAME_MAX 15
+
+struct exfat_entry_bitmap			/* allocated clusters bitmap */
+{
+	uint8_t type;					/* EXFAT_ENTRY_BITMAP */
+	uint8_t __unknown1[19];
+	le32_t start_cluster;
+	le64_t size;					/* in bytes */
+}
+PACKED;
+STATIC_ASSERT(sizeof(struct exfat_entry_bitmap) == 32);
+
+struct exfat_entry_upcase			/* upper case translation table */
+{
+	uint8_t type;					/* EXFAT_ENTRY_UPCASE */
+	uint8_t __unknown1[3];
+	le32_t checksum;
+	uint8_t __unknown2[12];
+	le32_t start_cluster;
+	le64_t size;					/* in bytes */
+}
+PACKED;
+STATIC_ASSERT(sizeof(struct exfat_entry_upcase) == 32);
+
+struct exfat_entry_label			/* volume label */
+{
+	uint8_t type;					/* EXFAT_ENTRY_LABEL */
+	uint8_t length;					/* number of characters */
+	le16_t name[EXFAT_ENAME_MAX];	/* in UTF-16LE */
+}
+PACKED;
+STATIC_ASSERT(sizeof(struct exfat_entry_label) == 32);
+
+#define EXFAT_ATTRIB_RO     0x01
+#define EXFAT_ATTRIB_HIDDEN 0x02
+#define EXFAT_ATTRIB_SYSTEM 0x04
+#define EXFAT_ATTRIB_VOLUME 0x08
+#define EXFAT_ATTRIB_DIR    0x10
+#define EXFAT_ATTRIB_ARCH   0x20
+
+struct exfat_entry_meta1			/* file or directory info (part 1) */
+{
+	uint8_t type;					/* EXFAT_ENTRY_FILE */
+	uint8_t continuations;
+	le16_t checksum;
+	le16_t attrib;					/* combination of EXFAT_ATTRIB_xxx */
+	le16_t __unknown1;
+	le16_t crtime, crdate;			/* creation date and time */
+	le16_t mtime, mdate;			/* latest modification date and time */
+	le16_t atime, adate;			/* latest access date and time */
+	uint8_t crtime_cs;				/* creation time in cs (centiseconds) */
+	uint8_t mtime_cs;				/* latest modification time in cs */
+	uint8_t __unknown2[10];
+}
+PACKED;
+STATIC_ASSERT(sizeof(struct exfat_entry_meta1) == 32);
+
+#define EXFAT_FLAG_ALWAYS1		(1u << 0)
+#define EXFAT_FLAG_CONTIGUOUS	(1u << 1)
+
+struct exfat_entry_meta2			/* file or directory info (part 2) */
+{
+	uint8_t type;					/* EXFAT_ENTRY_FILE_INFO */
+	uint8_t flags;					/* combination of EXFAT_FLAG_xxx */
+	uint8_t __unknown1;
+	uint8_t name_length;
+	le16_t name_hash;
+	le16_t __unknown2;
+	le64_t valid_size;				/* in bytes, less or equal to size */
+	uint8_t __unknown3[4];
+	le32_t start_cluster;
+	le64_t size;					/* in bytes */
+}
+PACKED;
+STATIC_ASSERT(sizeof(struct exfat_entry_meta2) == 32);
+
+struct exfat_entry_name				/* file or directory name */
+{
+	uint8_t type;					/* EXFAT_ENTRY_FILE_NAME */
+	uint8_t __unknown;
+	le16_t name[EXFAT_ENAME_MAX];	/* in UTF-16LE */
+}
+PACKED;
+STATIC_ASSERT(sizeof(struct exfat_entry_name) == 32);
+
+#endif /* ifndef EXFATFS_H_INCLUDED */
diff --git a/external/exfat-fuse/libexfat/io.c b/external/exfat-fuse/libexfat/io.c
new file mode 100755
index 0000000000..615f0f2d97
--- /dev/null
+++ b/external/exfat-fuse/libexfat/io.c
@@ -0,0 +1,453 @@
+/*
+	io.c (02.09.09)
+	exFAT file system implementation library.
+
+	Free exFAT implementation.
+	Copyright (C) 2010-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include "exfat.h"
+#include <inttypes.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#if defined(__APPLE__)
+#include <sys/disk.h>
+#elif defined(__OpenBSD__)
+#include <sys/param.h>
+#include <sys/disklabel.h>
+#include <sys/dkio.h>
+#include <sys/ioctl.h>
+#endif
+#include <sys/mount.h>
+#ifdef USE_UBLIO
+#include <sys/uio.h>
+#include <ublio.h>
+#endif
+
+struct exfat_dev
+{
+	int fd;
+	enum exfat_mode mode;
+	off64_t size; /* in bytes */
+#ifdef USE_UBLIO
+	off64_t pos;
+	ublio_filehandle_t ufh;
+#endif
+};
+
+static int open_ro(const char* spec)
+{
+	return open(spec, O_RDONLY);
+}
+
+static int open_rw(const char* spec)
+{
+	int fd = open(spec, O_RDWR);
+#ifdef __linux__
+	int ro = 0;
+
+	/*
+	   This ioctl is needed because after "blockdev --setro" kernel still
+	   allows to open the device in read-write mode but fails writes.
+	*/
+	if (fd != -1 && ioctl(fd, BLKROGET, &ro) == 0 && ro)
+	{
+		close(fd);
+		errno = EROFS;
+		return -1;
+	}
+#endif
+	return fd;
+}
+
+struct exfat_dev* exfat_open(const char* spec, enum exfat_mode mode)
+{
+	struct exfat_dev* dev;
+	struct stat stbuf;
+#ifdef USE_UBLIO
+	struct ublio_param up;
+#endif
+
+	dev = malloc(sizeof(struct exfat_dev));
+	if (dev == NULL)
+	{
+		exfat_error("failed to allocate memory for device structure");
+		return NULL;
+	}
+
+	switch (mode)
+	{
+	case EXFAT_MODE_RO:
+		dev->fd = open_ro(spec);
+		if (dev->fd == -1)
+		{
+			free(dev);
+			exfat_error("failed to open '%s' in read-only mode: %s", spec,
+					strerror(errno));
+			return NULL;
+		}
+		dev->mode = EXFAT_MODE_RO;
+		break;
+	case EXFAT_MODE_RW:
+		dev->fd = open_rw(spec);
+		if (dev->fd == -1)
+		{
+			free(dev);
+			exfat_error("failed to open '%s' in read-write mode: %s", spec,
+					strerror(errno));
+			return NULL;
+		}
+		dev->mode = EXFAT_MODE_RW;
+		break;
+	case EXFAT_MODE_ANY:
+		dev->fd = open_rw(spec);
+		if (dev->fd != -1)
+		{
+			dev->mode = EXFAT_MODE_RW;
+			break;
+		}
+		dev->fd = open_ro(spec);
+		if (dev->fd != -1)
+		{
+			dev->mode = EXFAT_MODE_RO;
+			exfat_warn("'%s' is write-protected, mounting read-only", spec);
+			break;
+		}
+		free(dev);
+		exfat_error("failed to open '%s': %s", spec, strerror(errno));
+		return NULL;
+	}
+
+	if (fstat(dev->fd, &stbuf) != 0)
+	{
+		close(dev->fd);
+		free(dev);
+		exfat_error("failed to fstat '%s'", spec);
+		return NULL;
+	}
+	if (!S_ISBLK(stbuf.st_mode) &&
+		!S_ISCHR(stbuf.st_mode) &&
+		!S_ISREG(stbuf.st_mode))
+	{
+		close(dev->fd);
+		free(dev);
+		exfat_error("'%s' is neither a device, nor a regular file", spec);
+		return NULL;
+	}
+
+#if defined(__APPLE__)
+	if (!S_ISREG(stbuf.st_mode))
+	{
+		uint32_t block_size = 0;
+		uint64_t blocks = 0;
+
+		if (ioctl(dev->fd, DKIOCGETBLOCKSIZE, &block_size) != 0)
+		{
+			close(dev->fd);
+			free(dev);
+			exfat_error("failed to get block size");
+			return NULL;
+		}
+		if (ioctl(dev->fd, DKIOCGETBLOCKCOUNT, &blocks) != 0)
+		{
+			close(dev->fd);
+			free(dev);
+			exfat_error("failed to get blocks count");
+			return NULL;
+		}
+		dev->size = blocks * block_size;
+	}
+	else
+#elif defined(__OpenBSD__)
+	if (!S_ISREG(stbuf.st_mode))
+	{
+		struct disklabel lab;
+		struct partition* pp;
+		char* partition;
+
+		if (ioctl(dev->fd, DIOCGDINFO, &lab) == -1)
+		{
+			close(dev->fd);
+			free(dev);
+			exfat_error("failed to get disklabel");
+			return NULL;
+		}
+
+		/* Don't need to check that partition letter is valid as we won't get
+		   this far otherwise. */
+		partition = strchr(spec, '\0') - 1;
+		pp = &(lab.d_partitions[*partition - 'a']);
+		dev->size = DL_GETPSIZE(pp) * lab.d_secsize;
+
+		if (pp->p_fstype != FS_NTFS)
+			exfat_warn("partition type is not 0x07 (NTFS/exFAT); "
+					"you can fix this with fdisk(8)");
+	}
+	else
+#endif
+	{
+		/* works for Linux, FreeBSD, Solaris */
+		dev->size = exfat_seek(dev, 0, SEEK_END);
+		if (dev->size <= 0)
+		{
+			close(dev->fd);
+			free(dev);
+			exfat_error("failed to get size of '%s'", spec);
+			return NULL;
+		}
+		if (exfat_seek(dev, 0, SEEK_SET) == -1)
+		{
+			close(dev->fd);
+			free(dev);
+			exfat_error("failed to seek to the beginning of '%s'", spec);
+			return NULL;
+		}
+	}
+
+#ifdef USE_UBLIO
+	memset(&up, 0, sizeof(struct ublio_param));
+	up.up_blocksize = 256 * 1024;
+	up.up_items = 64;
+	up.up_grace = 32;
+	up.up_priv = &dev->fd;
+
+	dev->pos = 0;
+	dev->ufh = ublio_open(&up);
+	if (dev->ufh == NULL)
+	{
+		close(dev->fd);
+		free(dev);
+		exfat_error("failed to initialize ublio");
+		return NULL;
+	}
+#endif
+
+	return dev;
+}
+
+int exfat_close(struct exfat_dev* dev)
+{
+	int rc = 0;
+
+#ifdef USE_UBLIO
+	if (ublio_close(dev->ufh) != 0)
+	{
+		exfat_error("failed to close ublio");
+		rc = -EIO;
+	}
+#endif
+	if (close(dev->fd) != 0)
+	{
+		exfat_error("failed to close device: %s", strerror(errno));
+		rc = -EIO;
+	}
+	free(dev);
+	return rc;
+}
+
+int exfat_fsync(struct exfat_dev* dev)
+{
+	int rc = 0;
+
+#ifdef USE_UBLIO
+	if (ublio_fsync(dev->ufh) != 0)
+	{
+		exfat_error("ublio fsync failed");
+		rc = -EIO;
+	}
+#endif
+	if (fsync(dev->fd) != 0)
+	{
+		exfat_error("fsync failed: %s", strerror(errno));
+		rc = -EIO;
+	}
+	return rc;
+}
+
+int exfat_sync(struct exfat* ef)
+{
+	ef->bytes_written = 0;
+	return exfat_fsync(ef->dev);
+}
+
+enum exfat_mode exfat_get_mode(const struct exfat_dev* dev)
+{
+	return dev->mode;
+}
+
+off64_t exfat_get_size(const struct exfat_dev* dev)
+{
+	return dev->size;
+}
+
+off64_t exfat_seek(struct exfat_dev* dev, off64_t offset, int whence)
+{
+#ifdef USE_UBLIO
+	/* XXX SEEK_CUR will be handled incorrectly */
+	return dev->pos = lseek(dev->fd, offset, whence);
+#elif defined(USE_TRANSITIONAL_LFS) && USE_TRANSITIONAL_LFS
+	return lseek64(dev->fd, offset, whence);
+#else
+	return lseek(dev->fd, offset, whence);
+#endif
+}
+
+ssize_t exfat_read(struct exfat_dev* dev, void* buffer, size_t size)
+{
+#ifdef USE_UBLIO
+	ssize_t result = ublio_pread(dev->ufh, buffer, size, dev->pos);
+	if (result >= 0)
+		dev->pos += size;
+	return result;
+#else
+	return read(dev->fd, buffer, size);
+#endif
+}
+
+ssize_t exfat_write(struct exfat_dev* dev, const void* buffer, size_t size)
+{
+#ifdef USE_UBLIO
+	ssize_t result = ublio_pwrite(dev->ufh, buffer, size, dev->pos);
+	if (result >= 0)
+		dev->pos += size;
+	return result;
+#else
+	return write(dev->fd, buffer, size);
+#endif
+}
+
+ssize_t exfat_pread(struct exfat_dev* dev, void* buffer, size_t size,
+		off64_t offset)
+{
+#ifdef USE_UBLIO
+	return ublio_pread(dev->ufh, buffer, size, offset);
+#elif defined(USE_TRANSITIONAL_LFS) && USE_TRANSITIONAL_LFS
+	return pread64(dev->fd, buffer, size, offset);
+#else
+	return pread(dev->fd, buffer, size, offset);
+#endif
+}
+
+ssize_t exfat_pwrite(struct exfat_dev* dev, const void* buffer, size_t size,
+		off64_t offset)
+{
+#ifdef USE_UBLIO
+	return ublio_pwrite(dev->ufh, buffer, size, offset);
+#elif defined(USE_TRANSITIONAL_LFS) && USE_TRANSITIONAL_LFS
+	return pwrite64(dev->fd, buffer, size, offset);
+#else
+	return pwrite(dev->fd, buffer, size, offset);
+#endif
+}
+
+ssize_t exfat_generic_pread(const struct exfat* ef, struct exfat_node* node,
+		void* buffer, size_t size, off64_t offset)
+{
+	cluster_t cluster;
+	char* bufp = buffer;
+	off64_t lsize, loffset, remainder;
+
+	if (offset >= node->size)
+		return 0;
+	if (size == 0)
+		return 0;
+
+	cluster = exfat_advance_cluster(ef, node, offset / CLUSTER_SIZE(*ef->sb));
+	if (CLUSTER_INVALID(cluster))
+	{
+		exfat_error("invalid cluster 0x%x while reading", cluster);
+		return -1;
+	}
+
+	loffset = offset % CLUSTER_SIZE(*ef->sb);
+	remainder = MIN(size, node->size - offset);
+	while (remainder > 0)
+	{
+		if (CLUSTER_INVALID(cluster))
+		{
+			exfat_error("invalid cluster 0x%x while reading", cluster);
+			return -1;
+		}
+		lsize = MIN(CLUSTER_SIZE(*ef->sb) - loffset, remainder);
+		if (exfat_pread(ef->dev, bufp, lsize,
+					exfat_c2o(ef, cluster) + loffset) < 0)
+		{
+			exfat_error("failed to read cluster %#x", cluster);
+			return -1;
+		}
+		bufp += lsize;
+		loffset = 0;
+		remainder -= lsize;
+		cluster = exfat_next_cluster(ef, node, cluster);
+	}
+	if (!ef->ro && !ef->noatime)
+		exfat_update_atime(node);
+	return MIN(size, node->size - offset) - remainder;
+}
+
+ssize_t exfat_generic_pwrite(struct exfat* ef, struct exfat_node* node,
+		const void* buffer, size_t size, off64_t offset)
+{
+	cluster_t cluster;
+	const char* bufp = buffer;
+	off64_t lsize, loffset, remainder;
+
+	if (offset > node->size)
+		if (exfat_truncate(ef, node, offset, true) != 0)
+			return -1;
+	if (offset + size > node->size)
+		if (exfat_truncate(ef, node, offset + size, false) != 0)
+			return -1;
+	if (size == 0)
+		return 0;
+
+	cluster = exfat_advance_cluster(ef, node, offset / CLUSTER_SIZE(*ef->sb));
+	if (CLUSTER_INVALID(cluster))
+	{
+		exfat_error("invalid cluster 0x%x while writing", cluster);
+		return -1;
+	}
+
+	loffset = offset % CLUSTER_SIZE(*ef->sb);
+	remainder = size;
+	while (remainder > 0)
+	{
+		if (CLUSTER_INVALID(cluster))
+		{
+			exfat_error("invalid cluster 0x%x while writing", cluster);
+			return -1;
+		}
+		lsize = MIN(CLUSTER_SIZE(*ef->sb) - loffset, remainder);
+		if (exfat_pwrite(ef->dev, bufp, lsize,
+				exfat_c2o(ef, cluster) + loffset) < 0)
+		{
+			exfat_error("failed to write cluster %#x", cluster);
+			ef->was_dirty = true; // Leaves the volume "mounted", to force chkdsk on it.
+			return -1;
+		}
+		bufp += lsize;
+		loffset = 0;
+		remainder -= lsize;
+		cluster = exfat_next_cluster(ef, node, cluster);
+	}
+	exfat_update_mtime(node);
+	return size - remainder;
+}
diff --git a/external/exfat-fuse/libexfat/log.c b/external/exfat-fuse/libexfat/log.c
new file mode 100755
index 0000000000..6a7cb28c17
--- /dev/null
+++ b/external/exfat-fuse/libexfat/log.c
@@ -0,0 +1,114 @@
+/*
+	log.c (02.09.09)
+	exFAT file system implementation library.
+
+	Free exFAT implementation.
+	Copyright (C) 2010-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include "exfat.h"
+#include <stdarg.h>
+#include <syslog.h>
+#include <unistd.h>
+
+int exfat_errors;
+
+/*
+ * This message means an internal bug in exFAT implementation.
+ */
+void exfat_bug(const char* format, ...)
+{
+	va_list ap, aq;
+
+	va_start(ap, format);
+	va_copy(aq, ap);
+
+	fflush(stdout);
+	fputs("BUG: ", stderr);
+	vfprintf(stderr, format, ap);
+	va_end(ap);
+	fputs(".\n", stderr);
+
+	if (!isatty(STDERR_FILENO))
+		vsyslog(LOG_CRIT, format, aq);
+	va_end(aq);
+
+#if defined(__ANDROID__)
+    exit(-1);
+#else
+	abort();
+#endif
+}
+
+/*
+ * This message means an error in exFAT file system.
+ */
+void exfat_error(const char* format, ...)
+{
+	va_list ap, aq;
+
+	exfat_errors++;
+	va_start(ap, format);
+	va_copy(aq, ap);
+
+	fflush(stdout);
+	fputs("ERROR: ", stderr);
+	vfprintf(stderr, format, ap);
+	va_end(ap);
+	fputs(".\n", stderr);
+
+	if (!isatty(STDERR_FILENO))
+		vsyslog(LOG_ERR, format, aq);
+	va_end(aq);
+}
+
+/*
+ * This message means that there is something unexpected in exFAT file system
+ * that can be a potential problem.
+ */
+void exfat_warn(const char* format, ...)
+{
+	va_list ap, aq;
+
+	va_start(ap, format);
+	va_copy(aq, ap);
+
+	fflush(stdout);
+	fputs("WARN: ", stderr);
+	vfprintf(stderr, format, ap);
+	va_end(ap);
+	fputs(".\n", stderr);
+
+	if (!isatty(STDERR_FILENO))
+		vsyslog(LOG_WARNING, format, aq);
+	va_end(aq);
+}
+
+/*
+ * Just debug message. Disabled by default.
+ */
+void exfat_debug(const char* format, ...)
+{
+	va_list ap;
+
+	fflush(stdout);
+	fputs("DEBUG: ", stderr);
+	va_start(ap, format);
+	vfprintf(stderr, format, ap);
+	va_end(ap);
+	fputs(".\n", stderr);
+}
diff --git a/external/exfat-fuse/libexfat/lookup.c b/external/exfat-fuse/libexfat/lookup.c
new file mode 100755
index 0000000000..51915e630e
--- /dev/null
+++ b/external/exfat-fuse/libexfat/lookup.c
@@ -0,0 +1,225 @@
+/*
+	lookup.c (02.09.09)
+	exFAT file system implementation library.
+
+	Free exFAT implementation.
+	Copyright (C) 2010-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include "exfat.h"
+#include <string.h>
+#include <errno.h>
+#include <inttypes.h>
+
+int exfat_opendir(struct exfat* ef, struct exfat_node* dir,
+		struct exfat_iterator* it)
+{
+	int rc;
+
+	exfat_get_node(dir);
+	it->parent = dir;
+	it->current = NULL;
+	rc = exfat_cache_directory(ef, dir);
+	if (rc != 0)
+		exfat_put_node(ef, dir);
+	return rc;
+}
+
+void exfat_closedir(struct exfat* ef, struct exfat_iterator* it)
+{
+	exfat_put_node(ef, it->parent);
+	it->parent = NULL;
+	it->current = NULL;
+}
+
+struct exfat_node* exfat_readdir(struct exfat* ef, struct exfat_iterator* it)
+{
+	if (it->current == NULL)
+		it->current = it->parent->child;
+	else
+		it->current = it->current->next;
+
+	if (it->current != NULL)
+		return exfat_get_node(it->current);
+	else
+		return NULL;
+}
+
+static int compare_char(struct exfat* ef, uint16_t a, uint16_t b)
+{
+	if (a >= ef->upcase_chars || b >= ef->upcase_chars)
+		return (int) a - (int) b;
+
+	return (int) le16_to_cpu(ef->upcase[a]) - (int) le16_to_cpu(ef->upcase[b]);
+}
+
+static int compare_name(struct exfat* ef, const le16_t* a, const le16_t* b)
+{
+	while (le16_to_cpu(*a) && le16_to_cpu(*b))
+	{
+		int rc = compare_char(ef, le16_to_cpu(*a), le16_to_cpu(*b));
+		if (rc != 0)
+			return rc;
+		a++;
+		b++;
+	}
+	return compare_char(ef, le16_to_cpu(*a), le16_to_cpu(*b));
+}
+
+static int lookup_name(struct exfat* ef, struct exfat_node* parent,
+		struct exfat_node** node, const char* name, size_t n)
+{
+	struct exfat_iterator it;
+	le16_t buffer[EXFAT_NAME_MAX + 1];
+	int rc;
+
+	*node = NULL;
+
+	rc = utf8_to_utf16(buffer, name, EXFAT_NAME_MAX, n);
+	if (rc != 0)
+		return rc;
+
+	rc = exfat_opendir(ef, parent, &it);
+	if (rc != 0)
+		return rc;
+	while ((*node = exfat_readdir(ef, &it)))
+	{
+		if (compare_name(ef, buffer, (*node)->name) == 0)
+		{
+			exfat_closedir(ef, &it);
+			return 0;
+		}
+		exfat_put_node(ef, *node);
+	}
+	exfat_closedir(ef, &it);
+	return -ENOENT;
+}
+
+static size_t get_comp(const char* path, const char** comp)
+{
+	const char* end;
+
+	*comp = path + strspn(path, "/");				/* skip leading slashes */
+	end = strchr(*comp, '/');
+	if (end == NULL)
+		return strlen(*comp);
+	else
+		return end - *comp;
+}
+
+int exfat_lookup(struct exfat* ef, struct exfat_node** node,
+		const char* path)
+{
+	struct exfat_node* parent;
+	const char* p;
+	size_t n;
+	int rc;
+
+	/* start from the root directory */
+	parent = *node = exfat_get_node(ef->root);
+	for (p = path; (n = get_comp(p, &p)); p += n)
+	{
+		if (n == 1 && *p == '.')				/* skip "." component */
+			continue;
+		rc = lookup_name(ef, parent, node, p, n);
+		if (rc != 0)
+		{
+			exfat_put_node(ef, parent);
+			return rc;
+		}
+		exfat_put_node(ef, parent);
+		parent = *node;
+	}
+	return 0;
+}
+
+static bool is_last_comp(const char* comp, size_t length)
+{
+	const char* p = comp + length;
+
+	return get_comp(p, &p) == 0;
+}
+
+static bool is_allowed(const char* comp, size_t length)
+{
+	size_t i;
+
+	for (i = 0; i < length; i++)
+		switch (comp[i])
+		{
+		case 0x01 ... 0x1f:
+		case '/':
+		case '\\':
+		case ':':
+		case '*':
+		case '?':
+		case '"':
+		case '<':
+		case '>':
+		case '|':
+			return false;
+		}
+	return true;
+}
+
+int exfat_split(struct exfat* ef, struct exfat_node** parent,
+		struct exfat_node** node, le16_t* name, const char* path)
+{
+	const char* p;
+	size_t n;
+	int rc;
+
+	memset(name, 0, (EXFAT_NAME_MAX + 1) * sizeof(le16_t));
+	*parent = *node = exfat_get_node(ef->root);
+	for (p = path; (n = get_comp(p, &p)); p += n)
+	{
+		if (n == 1 && *p == '.')
+			continue;
+		if (is_last_comp(p, n))
+		{
+			if (!is_allowed(p, n))
+			{
+				/* contains characters that are not allowed */
+				exfat_put_node(ef, *parent);
+				return -ENOENT;
+			}
+			rc = utf8_to_utf16(name, p, EXFAT_NAME_MAX, n);
+			if (rc != 0)
+			{
+				exfat_put_node(ef, *parent);
+				return rc;
+			}
+
+			rc = lookup_name(ef, *parent, node, p, n);
+			if (rc != 0 && rc != -ENOENT)
+			{
+				exfat_put_node(ef, *parent);
+				return rc;
+			}
+			return 0;
+		}
+		rc = lookup_name(ef, *parent, node, p, n);
+		if (rc != 0)
+		{
+			exfat_put_node(ef, *parent);
+			return rc;
+		}
+		exfat_put_node(ef, *parent);
+		*parent = *node;
+	}
+	exfat_bug("impossible");
+}
diff --git a/external/exfat-fuse/libexfat/mount.c b/external/exfat-fuse/libexfat/mount.c
new file mode 100755
index 0000000000..c16750d376
--- /dev/null
+++ b/external/exfat-fuse/libexfat/mount.c
@@ -0,0 +1,449 @@
+/*
+	mount.c (22.10.09)
+	exFAT file system implementation library.
+
+	Free exFAT implementation.
+	Copyright (C) 2010-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include "exfat.h"
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <inttypes.h>
+#include <unistd.h>
+#include <sys/types.h>
+
+static uint64_t rootdir_size(const struct exfat* ef)
+{
+	uint64_t clusters = 0;
+	cluster_t rootdir_cluster = le32_to_cpu(ef->sb->rootdir_cluster);
+
+	while (!CLUSTER_INVALID(rootdir_cluster))
+	{
+		clusters++;
+		/* root directory cannot be contiguous because there is no flag
+		   to indicate this */
+		rootdir_cluster = exfat_next_cluster(ef, ef->root, rootdir_cluster);
+	}
+	if (rootdir_cluster != EXFAT_CLUSTER_END)
+	{
+		exfat_error("bad cluster %#x while reading root directory",
+				rootdir_cluster);
+		return 0;
+	}
+	return clusters * CLUSTER_SIZE(*ef->sb);
+}
+
+static const char* get_option(const char* options, const char* option_name)
+{
+	const char* p;
+	size_t length = strlen(option_name);
+
+	for (p = strstr(options, option_name); p; p = strstr(p + 1, option_name))
+		if ((p == options || p[-1] == ',') && p[length] == '=')
+			return p + length + 1;
+	return NULL;
+}
+
+static int get_int_option(const char* options, const char* option_name,
+		int base, int default_value)
+{
+	const char* p = get_option(options, option_name);
+
+	if (p == NULL)
+		return default_value;
+	return strtol(p, NULL, base);
+}
+
+static bool match_option(const char* options, const char* option_name)
+{
+	const char* p;
+	size_t length = strlen(option_name);
+
+	for (p = strstr(options, option_name); p; p = strstr(p + 1, option_name))
+		if ((p == options || p[-1] == ',') &&
+				(p[length] == ',' || p[length] == '\0'))
+			return true;
+	return false;
+}
+
+static void parse_options(struct exfat* ef, const char* options)
+{
+	int opt_umask;
+
+	opt_umask = get_int_option(options, "umask", 8, 0);
+	ef->dmask = get_int_option(options, "dmask", 8, opt_umask);
+	ef->fmask = get_int_option(options, "fmask", 8, opt_umask);
+
+	ef->uid = get_int_option(options, "uid", 10, geteuid());
+	ef->gid = get_int_option(options, "gid", 10, getegid());
+
+#if defined(__ANDROID__)
+	ef->noatime = true;
+#else
+	ef->noatime = match_option(options, "noatime");
+#endif
+	ef->sync    = match_option(options, "sync");
+}
+
+static bool verify_vbr_checksum(struct exfat_dev* dev, void* sector,
+		off64_t sector_size)
+{
+	uint32_t vbr_checksum;
+	int i;
+
+	if (exfat_pread(dev, sector, sector_size, 0) < 0)
+	{
+		exfat_error("failed to read boot sector");
+		return false;
+	}
+	vbr_checksum = exfat_vbr_start_checksum(sector, sector_size);
+	for (i = 1; i < 11; i++)
+	{
+		if (exfat_pread(dev, sector, sector_size, i * sector_size) < 0)
+		{
+			exfat_error("failed to read VBR sector");
+			return false;
+		}
+		vbr_checksum = exfat_vbr_add_checksum(sector, sector_size,
+				vbr_checksum);
+	}
+	if (exfat_pread(dev, sector, sector_size, i * sector_size) < 0)
+	{
+		exfat_error("failed to read VBR checksum sector");
+		return false;
+	}
+	for (i = 0; i < sector_size / sizeof(vbr_checksum); i++)
+		if (le32_to_cpu(((const le32_t*) sector)[i]) != vbr_checksum)
+		{
+			exfat_error("invalid VBR checksum 0x%x (expected 0x%x)",
+					le32_to_cpu(((const le32_t*) sector)[i]), vbr_checksum);
+			return false;
+		}
+	return true;
+}
+
+static int commit_super_block(struct exfat* ef)
+{
+	if (exfat_pwrite(ef->dev, ef->sb, sizeof(struct exfat_super_block), 0) < 0)
+	{
+		exfat_error("failed to write super block");
+		ef->was_dirty = true; // Leaves the volume "mounted", to force chkdsk on it.
+		return 1;
+	}
+	return 0;
+}
+
+static int prepare_super_block(struct exfat* ef)
+{
+	ef->bytes_written = 0;
+	if (le16_to_cpu(ef->sb->volume_state) & EXFAT_STATE_MOUNTED)
+	{
+		exfat_warn("volume was not unmounted cleanly");
+		// This will prevent from clearing of EXFAT_STATE_MOUNTED on unmount:
+		ef->was_dirty = true;
+	}
+
+	if (ef->ro)
+		return 0;
+
+#if !defined(ALWAYS_USE_SYNC_OPTION) || !ALWAYS_USE_SYNC_OPTION
+	if ( !ef->sync )
+	{
+		ef->sb->volume_state = cpu_to_le16(
+				le16_to_cpu(ef->sb->volume_state) | EXFAT_STATE_MOUNTED);
+		int rc1 = commit_super_block(ef);
+		int rc2 = exfat_sync(ef);
+		return rc2 == 0 ? rc1 : rc2;
+	}
+#endif
+	return 0;
+}
+
+static int finalize_super_block(struct exfat* ef)
+{
+	bool changed = false;
+	if (ef->ro)
+		return 0;
+
+	if ( !ef->was_dirty && (le16_to_cpu(ef->sb->volume_state) & EXFAT_STATE_MOUNTED) != 0 )
+	{
+		ef->sb->volume_state = cpu_to_le16(
+				le16_to_cpu(ef->sb->volume_state) & ~EXFAT_STATE_MOUNTED);
+		changed = true;
+	}
+
+	/* Some implementations set the percentage of allocated space to 0xff
+	   on FS creation and never update it. In this case leave it as is. */
+	if (ef->sb->allocated_percent != 0xff)
+	{
+		uint32_t free, total;
+		uint8_t percent;
+
+		free    = exfat_count_free_clusters(ef);
+		total   = le32_to_cpu(ef->sb->cluster_count);
+		percent = ((total - free) * 100 + total / 2) / total;
+
+		if ( ef->sb->allocated_percent != percent )
+		{
+			ef->sb->allocated_percent = percent;
+			changed = true;
+		}
+	}
+
+	if ( changed )
+	{
+		int rc1 = commit_super_block(ef);
+		int rc2 = exfat_sync(ef);
+		return rc2 == 0 ? rc1 : rc2;
+	}
+	else
+		return 0;
+}
+
+static void count_dirty_nodes(struct exfat* ef, struct exfat_node* node, uint32_t *count)
+{
+	struct exfat_node* p;
+
+	for (p = node->child; p != NULL; p = p->next)
+		count_dirty_nodes(ef, p, count);
+	if ( count != NULL && (node->flags & EXFAT_ATTRIB_DIRTY) != 0 )
+		(*count)++;
+}
+
+int exfat_dirty(struct exfat* ef, bool dirty)
+{
+	if (ef->ro)
+		return 0;
+#if !defined(ALWAYS_USE_SYNC_OPTION) || !ALWAYS_USE_SYNC_OPTION
+	if ( !ef->sync )
+		return 0;
+#endif
+
+	if ( dirty && (le16_to_cpu(ef->sb->volume_state) & EXFAT_STATE_MOUNTED) == 0 )
+	{
+		ef->sb->volume_state = cpu_to_le16(
+				le16_to_cpu(ef->sb->volume_state) | EXFAT_STATE_MOUNTED);
+		return commit_super_block(ef);
+	}
+	else if ( !dirty && (le16_to_cpu(ef->sb->volume_state) & EXFAT_STATE_MOUNTED) != 0 )
+	{
+		if ( ef->was_dirty )
+			return exfat_sync(ef);
+
+		if ( ef->cmap.dirty )
+			return 0;
+
+		// Root directory can be marked as dirty, but it has no metadata to flush!
+		uint32_t count = -((ef->root->flags & EXFAT_ATTRIB_DIRTY) != 0);
+		count_dirty_nodes(ef, ef->root, &count);
+		if ( count > 0 )
+			return 0;
+
+		return finalize_super_block(ef);
+	}
+	else
+		return 0;
+}
+
+int exfat_mount(struct exfat* ef, const char* spec, const char* options)
+{
+	int rc;
+	enum exfat_mode mode;
+
+	exfat_tzset();
+	memset(ef, 0, sizeof(struct exfat));
+
+	parse_options(ef, options);
+
+	if (match_option(options, "ro"))
+		mode = EXFAT_MODE_RO;
+	else if (match_option(options, "ro_fallback"))
+		mode = EXFAT_MODE_ANY;
+	else
+		mode = EXFAT_MODE_RW;
+	ef->dev = exfat_open(spec, mode);
+	if (ef->dev == NULL)
+		return -EIO;
+	if (exfat_get_mode(ef->dev) == EXFAT_MODE_RO)
+	{
+		if (mode == EXFAT_MODE_ANY)
+			ef->ro = -1;
+		else
+			ef->ro = 1;
+	}
+
+	ef->sb = malloc(sizeof(struct exfat_super_block));
+	if (ef->sb == NULL)
+	{
+		exfat_close(ef->dev);
+		exfat_error("failed to allocate memory for the super block");
+		return -ENOMEM;
+	}
+	memset(ef->sb, 0, sizeof(struct exfat_super_block));
+
+	if (exfat_pread(ef->dev, ef->sb, sizeof(struct exfat_super_block), 0) < 0)
+	{
+		exfat_close(ef->dev);
+		free(ef->sb);
+		exfat_error("failed to read boot sector");
+		return -EIO;
+	}
+	if (memcmp(ef->sb->oem_name, "EXFAT   ", 8) != 0)
+	{
+		exfat_close(ef->dev);
+		free(ef->sb);
+		exfat_error("exFAT file system is not found");
+		return -EIO;
+	}
+	ef->zero_cluster = malloc(CLUSTER_SIZE(*ef->sb));
+	if (ef->zero_cluster == NULL)
+	{
+		exfat_close(ef->dev);
+		free(ef->sb);
+		exfat_error("failed to allocate zero sector");
+		return -ENOMEM;
+	}
+	/* use zero_cluster as a temporary buffer for VBR checksum verification */
+	if (!verify_vbr_checksum(ef->dev, ef->zero_cluster, SECTOR_SIZE(*ef->sb)))
+	{
+		free(ef->zero_cluster);
+		exfat_close(ef->dev);
+		free(ef->sb);
+		return -EIO;
+	}
+	memset(ef->zero_cluster, 0, CLUSTER_SIZE(*ef->sb));
+	if (ef->sb->version.major != 1 || ef->sb->version.minor != 0)
+	{
+		free(ef->zero_cluster);
+		exfat_close(ef->dev);
+		exfat_error("unsupported exFAT version: %hhu.%hhu",
+				ef->sb->version.major, ef->sb->version.minor);
+		free(ef->sb);
+		return -EIO;
+	}
+	if (ef->sb->fat_count != 1)
+	{
+		free(ef->zero_cluster);
+		exfat_close(ef->dev);
+		exfat_error("unsupported FAT count: %hhu", ef->sb->fat_count);
+		free(ef->sb);
+		return -EIO;
+	}
+	/* officially exFAT supports cluster size up to 32 MB */
+	if ((int) ef->sb->sector_bits + (int) ef->sb->spc_bits > 25)
+	{
+		free(ef->zero_cluster);
+		exfat_close(ef->dev);
+		exfat_error("too big cluster size: 2^%d",
+				(int) ef->sb->sector_bits + (int) ef->sb->spc_bits);
+		free(ef->sb);
+		return -EIO;
+	}
+	if (le64_to_cpu(ef->sb->sector_count) * SECTOR_SIZE(*ef->sb) >
+			exfat_get_size(ef->dev))
+	{
+		free(ef->zero_cluster);
+		exfat_error("file system is larger than underlying device: "
+				"%"PRIu64" > %"PRIu64,
+				le64_to_cpu(ef->sb->sector_count) * SECTOR_SIZE(*ef->sb),
+				exfat_get_size(ef->dev));
+		exfat_close(ef->dev);
+		free(ef->sb);
+		return -EIO;
+	}
+
+	ef->root = malloc(sizeof(struct exfat_node));
+	if (ef->root == NULL)
+	{
+		free(ef->zero_cluster);
+		exfat_close(ef->dev);
+		free(ef->sb);
+		exfat_error("failed to allocate root node");
+		return -ENOMEM;
+	}
+	memset(ef->root, 0, sizeof(struct exfat_node));
+	ef->root->flags = EXFAT_ATTRIB_DIR;
+	ef->root->start_cluster = le32_to_cpu(ef->sb->rootdir_cluster);
+	ef->root->fptr_cluster = ef->root->start_cluster;
+	ef->root->name[0] = cpu_to_le16('\0');
+	ef->root->size = rootdir_size(ef);
+	if (ef->root->size == 0)
+	{
+		free(ef->root);
+		free(ef->zero_cluster);
+		exfat_close(ef->dev);
+		free(ef->sb);
+		return -EIO;
+	}
+	/* exFAT does not have time attributes for the root directory */
+	ef->root->mtime = 0;
+	ef->root->atime = 0;
+	/* always keep at least 1 reference to the root node */
+	exfat_get_node(ef->root);
+
+	rc = exfat_cache_directory(ef, ef->root);
+	if (rc != 0)
+		goto error;
+	if (ef->upcase == NULL)
+	{
+		exfat_error("upcase table is not found");
+		goto error;
+	}
+	if (ef->cmap.chunk == NULL)
+	{
+		exfat_error("clusters bitmap is not found");
+		goto error;
+	}
+
+	if (prepare_super_block(ef) != 0)
+		goto error;
+
+	return 0;
+
+error:
+	exfat_put_node(ef, ef->root);
+	exfat_reset_cache(ef);
+	free(ef->root);
+	free(ef->zero_cluster);
+	exfat_close(ef->dev);
+	free(ef->sb);
+	return -EIO;
+}
+
+void exfat_unmount(struct exfat* ef)
+{
+	exfat_flush(ef);	/* ignore return code */
+	exfat_put_node(ef, ef->root);
+	exfat_reset_cache(ef);
+	free(ef->root);
+	ef->root = NULL;
+	finalize_super_block(ef);
+	exfat_sync(ef);
+	exfat_close(ef->dev);	/* close descriptor immediately after fsync */
+	ef->dev = NULL;
+	free(ef->zero_cluster);
+	ef->zero_cluster = NULL;
+	free(ef->cmap.chunk);
+	ef->cmap.chunk = NULL;
+	free(ef->sb);
+	ef->sb = NULL;
+	free(ef->upcase);
+	ef->upcase = NULL;
+	ef->upcase_chars = 0;
+}
diff --git a/external/exfat-fuse/libexfat/node.c b/external/exfat-fuse/libexfat/node.c
new file mode 100755
index 0000000000..e2442d2b5b
--- /dev/null
+++ b/external/exfat-fuse/libexfat/node.c
@@ -0,0 +1,1264 @@
+/*
+	node.c (09.10.09)
+	exFAT file system implementation library.
+
+	Free exFAT implementation.
+	Copyright (C) 2010-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include "exfat.h"
+#include <errno.h>
+#include <string.h>
+#include <inttypes.h>
+
+/* on-disk nodes iterator */
+struct iterator
+{
+	cluster_t cluster;
+	off64_t offset;
+	int contiguous;
+	char* chunk;
+};
+
+struct exfat_node* exfat_get_node(struct exfat_node* node)
+{
+	/* if we switch to multi-threaded mode we will need atomic
+	   increment here and atomic decrement in exfat_put_node() */
+	node->references++;
+	return node;
+}
+
+void exfat_put_node(struct exfat* ef, struct exfat_node* node)
+{
+	char buffer[UTF8_BYTES(EXFAT_NAME_MAX) + 1];
+
+	--node->references;
+	if (node->references < 0)
+	{
+		exfat_get_name(node, buffer, sizeof(buffer) - 1);
+		exfat_bug("reference counter of '%s' is below zero", buffer);
+	}
+	else if (node->references == 0 && node != ef->root)
+	{
+		if (node->flags & EXFAT_ATTRIB_DIRTY)
+		{
+			exfat_get_name(node, buffer, sizeof(buffer) - 1);
+			exfat_warn("dirty node '%s' with zero references", buffer);
+		}
+	}
+}
+
+/**
+ * This function must be called on rmdir and unlink (after the last
+ * exfat_put_node()) to free clusters.
+ */
+int exfat_cleanup_node(struct exfat* ef, struct exfat_node* node)
+{
+	int rc = 0;
+
+	if (node->references != 0)
+		exfat_bug("unable to cleanup a node with %d references",
+				node->references);
+
+	if (node->flags & EXFAT_ATTRIB_UNLINKED)
+	{
+		/* free all clusters and node structure itself */
+		rc = exfat_truncate(ef, node, 0, true);
+		/* free the node even in case of error or its memory will be lost */
+		free(node);
+#if !defined(ALWAYS_USE_SYNC_OPTION) || !ALWAYS_USE_SYNC_OPTION
+		if ( ef->sync )
+#endif
+			exfat_flush_cmap(ef);
+	}
+	return rc;
+}
+
+/**
+ * Cluster + offset from the beginning of the directory to absolute offset.
+ */
+static off64_t co2o(struct exfat* ef, cluster_t cluster, off64_t offset)
+{
+	return exfat_c2o(ef, cluster) + offset % CLUSTER_SIZE(*ef->sb);
+}
+
+static int opendir(struct exfat* ef, const struct exfat_node* dir,
+		struct iterator* it)
+{
+	if (!(dir->flags & EXFAT_ATTRIB_DIR))
+		exfat_bug("not a directory");
+	it->cluster = dir->start_cluster;
+	it->offset = 0;
+	it->contiguous = IS_CONTIGUOUS(*dir);
+	it->chunk = malloc(CLUSTER_SIZE(*ef->sb));
+	if (it->chunk == NULL)
+	{
+		exfat_error("out of memory");
+		return -ENOMEM;
+	}
+	if (exfat_pread(ef->dev, it->chunk, CLUSTER_SIZE(*ef->sb),
+			exfat_c2o(ef, it->cluster)) < 0)
+	{
+		exfat_error("failed to read directory cluster %#x", it->cluster);
+		return -EIO;
+	}
+	return 0;
+}
+
+static void closedir(struct iterator* it)
+{
+	it->cluster = 0;
+	it->offset = 0;
+	it->contiguous = 0;
+	free(it->chunk);
+	it->chunk = NULL;
+}
+
+static bool fetch_next_entry(struct exfat* ef, const struct exfat_node* parent,
+		struct iterator* it)
+{
+	/* move iterator to the next entry in the directory */
+	it->offset += sizeof(struct exfat_entry);
+	/* fetch the next cluster if needed */
+	if ((it->offset & (CLUSTER_SIZE(*ef->sb) - 1)) == 0)
+	{
+		/* reached the end of directory; the caller should check this
+		   condition too */
+		if (it->offset >= parent->size)
+			return true;
+		it->cluster = exfat_next_cluster(ef, parent, it->cluster);
+		if (CLUSTER_INVALID(it->cluster))
+		{
+			exfat_error("invalid cluster 0x%x while reading directory",
+					it->cluster);
+			return false;
+		}
+		if (exfat_pread(ef->dev, it->chunk, CLUSTER_SIZE(*ef->sb),
+				exfat_c2o(ef, it->cluster)) < 0)
+		{
+			exfat_error("failed to read the next directory cluster %#x",
+					it->cluster);
+			return false;
+		}
+	}
+	return true;
+}
+
+static struct exfat_node* allocate_node(void)
+{
+	struct exfat_node* node = malloc(sizeof(struct exfat_node));
+	if (node == NULL)
+	{
+		exfat_error("failed to allocate node");
+		return NULL;
+	}
+	memset(node, 0, sizeof(struct exfat_node));
+	return node;
+}
+
+static void init_node_meta1(struct exfat_node* node,
+		const struct exfat_entry_meta1* meta1)
+{
+	node->flags = le16_to_cpu(meta1->attrib);
+	node->mtime = exfat_exfat2unix(meta1->mdate, meta1->mtime,
+			meta1->mtime_cs);
+	/* there is no centiseconds field for atime */
+	node->atime = exfat_exfat2unix(meta1->adate, meta1->atime, 0);
+}
+
+static void init_node_meta2(struct exfat_node* node,
+		const struct exfat_entry_meta2* meta2)
+{
+	node->size = le64_to_cpu(meta2->size);
+	node->start_cluster = le32_to_cpu(meta2->start_cluster);
+	node->fptr_cluster = node->start_cluster;
+	if (meta2->flags & EXFAT_FLAG_CONTIGUOUS)
+		node->flags |= EXFAT_ATTRIB_CONTIGUOUS;
+}
+
+static const struct exfat_entry* get_entry_ptr(const struct exfat* ef,
+		const struct iterator* it)
+{
+	return (const struct exfat_entry*)
+			(it->chunk + it->offset % CLUSTER_SIZE(*ef->sb));
+}
+
+static bool check_node(const struct exfat_node* node, uint16_t actual_checksum,
+		uint16_t reference_checksum, uint64_t valid_size)
+{
+	char buffer[UTF8_BYTES(EXFAT_NAME_MAX) + 1];
+
+	/*
+	   Validate checksum first. If it's invalid all other fields probably
+	   contain just garbage.
+	*/
+	if (actual_checksum != reference_checksum)
+	{
+		exfat_get_name(node, buffer, sizeof(buffer) - 1);
+		exfat_error("'%s' has invalid checksum (%#hx != %#hx)", buffer,
+				actual_checksum, reference_checksum);
+		return false;
+	}
+
+	/*
+	   exFAT does not support sparse files but allows files with uninitialized
+	   clusters. For such files valid_size means initialized data size and
+	   cannot be greater than file size. See SetFileValidData() function
+	   description in MSDN.
+	*/
+	if (valid_size > node->size)
+	{
+		exfat_get_name(node, buffer, sizeof(buffer) - 1);
+		exfat_error("'%s' has valid size (%"PRIu64") greater than size "
+				"(%"PRIu64")", buffer, valid_size, node->size);
+		return false;
+	}
+
+	return true;
+}
+
+/*
+ * Reads one entry in directory at position pointed by iterator and fills
+ * node structure.
+ */
+static int readdir(struct exfat* ef, const struct exfat_node* parent,
+		struct exfat_node** node, struct iterator* it)
+{
+	int rc = -EIO;
+	const struct exfat_entry* entry;
+	const struct exfat_entry_meta1* meta1;
+	const struct exfat_entry_meta2* meta2;
+	const struct exfat_entry_name* file_name;
+	const struct exfat_entry_upcase* upcase;
+	const struct exfat_entry_bitmap* bitmap;
+	const struct exfat_entry_label* label;
+	uint8_t continuations = 0;
+	le16_t* namep = NULL;
+	uint16_t reference_checksum = 0;
+	uint16_t actual_checksum = 0;
+	uint64_t valid_size = 0;
+
+	*node = NULL;
+
+	for (;;)
+	{
+		if (it->offset >= parent->size)
+		{
+			if (continuations != 0)
+			{
+				exfat_error("expected %hhu continuations", continuations);
+				goto error;
+			}
+			return -ENOENT; /* that's OK, means end of directory */
+		}
+
+		entry = get_entry_ptr(ef, it);
+		switch (entry->type)
+		{
+		case EXFAT_ENTRY_FILE:
+			if (continuations != 0)
+			{
+				exfat_error("expected %hhu continuations before new entry",
+						continuations);
+				goto error;
+			}
+			meta1 = (const struct exfat_entry_meta1*) entry;
+			continuations = meta1->continuations;
+			/* each file entry must have at least 2 continuations:
+			   info and name */
+			if (continuations < 2)
+			{
+				exfat_error("too few continuations (%hhu)", continuations);
+				goto error;
+			}
+			if (continuations > 1 +
+					DIV_ROUND_UP(EXFAT_NAME_MAX, EXFAT_ENAME_MAX))
+			{
+				exfat_error("too many continuations (%hhu)", continuations);
+				goto error;
+			}
+			reference_checksum = le16_to_cpu(meta1->checksum);
+			actual_checksum = exfat_start_checksum(meta1);
+			*node = allocate_node();
+			if (*node == NULL)
+			{
+				rc = -ENOMEM;
+				goto error;
+			}
+			/* new node has zero reference counter */
+			(*node)->entry_cluster = it->cluster;
+			(*node)->entry_offset = it->offset;
+			init_node_meta1(*node, meta1);
+			namep = (*node)->name;
+			break;
+
+		case EXFAT_ENTRY_FILE_INFO:
+			if (continuations < 2)
+			{
+				exfat_error("unexpected continuation (%hhu)",
+						continuations);
+				goto error;
+			}
+			meta2 = (const struct exfat_entry_meta2*) entry;
+			if (meta2->flags & ~(EXFAT_FLAG_ALWAYS1 | EXFAT_FLAG_CONTIGUOUS))
+			{
+				exfat_error("unknown flags in meta2 (0x%hhx)", meta2->flags);
+				goto error;
+			}
+			init_node_meta2(*node, meta2);
+			actual_checksum = exfat_add_checksum(entry, actual_checksum);
+			valid_size = le64_to_cpu(meta2->valid_size);
+			/* empty files must be marked as non-contiguous */
+			if ((*node)->size == 0 && (meta2->flags & EXFAT_FLAG_CONTIGUOUS))
+			{
+				exfat_error("empty file marked as contiguous (0x%hhx)",
+						meta2->flags);
+				goto error;
+			}
+			/* directories must be aligned on at cluster boundary */
+			if (((*node)->flags & EXFAT_ATTRIB_DIR) &&
+				(*node)->size % CLUSTER_SIZE(*ef->sb) != 0)
+			{
+				exfat_error("directory has invalid size %"PRIu64" bytes",
+						(*node)->size);
+				goto error;
+			}
+			--continuations;
+			break;
+
+		case EXFAT_ENTRY_FILE_NAME:
+			if (continuations == 0)
+			{
+				exfat_error("unexpected continuation");
+				goto error;
+			}
+			file_name = (const struct exfat_entry_name*) entry;
+			actual_checksum = exfat_add_checksum(entry, actual_checksum);
+
+			memcpy(namep, file_name->name,
+					MIN(EXFAT_ENAME_MAX,
+						((*node)->name + EXFAT_NAME_MAX - namep)) *
+					sizeof(le16_t));
+			namep += EXFAT_ENAME_MAX;
+			if (--continuations == 0)
+			{
+				if (!check_node(*node, actual_checksum, reference_checksum,
+						valid_size))
+					goto error;
+				if (!fetch_next_entry(ef, parent, it))
+					goto error;
+				return 0; /* entry completed */
+			}
+			break;
+
+		case EXFAT_ENTRY_UPCASE:
+			if (ef->upcase != NULL)
+				break;
+			upcase = (const struct exfat_entry_upcase*) entry;
+			if (CLUSTER_INVALID(le32_to_cpu(upcase->start_cluster)))
+			{
+				exfat_error("invalid cluster 0x%x in upcase table",
+						le32_to_cpu(upcase->start_cluster));
+				goto error;
+			}
+			if (le64_to_cpu(upcase->size) == 0 ||
+				le64_to_cpu(upcase->size) > 0xffff * sizeof(uint16_t) ||
+				le64_to_cpu(upcase->size) % sizeof(uint16_t) != 0)
+			{
+				exfat_error("bad upcase table size (%"PRIu64" bytes)",
+						le64_to_cpu(upcase->size));
+				goto error;
+			}
+			ef->upcase = malloc(le64_to_cpu(upcase->size));
+			if (ef->upcase == NULL)
+			{
+				exfat_error("failed to allocate upcase table (%"PRIu64" bytes)",
+						le64_to_cpu(upcase->size));
+				rc = -ENOMEM;
+				goto error;
+			}
+			ef->upcase_chars = le64_to_cpu(upcase->size) / sizeof(le16_t);
+
+			if (exfat_pread(ef->dev, ef->upcase, le64_to_cpu(upcase->size),
+					exfat_c2o(ef, le32_to_cpu(upcase->start_cluster))) < 0)
+			{
+				exfat_error("failed to read upper case table "
+						"(%"PRIu64" bytes starting at cluster %#x)",
+						le64_to_cpu(upcase->size),
+						le32_to_cpu(upcase->start_cluster));
+				goto error;
+			}
+			break;
+
+		case EXFAT_ENTRY_BITMAP:
+			bitmap = (const struct exfat_entry_bitmap*) entry;
+			ef->cmap.start_cluster = le32_to_cpu(bitmap->start_cluster);
+			if (CLUSTER_INVALID(ef->cmap.start_cluster))
+			{
+				exfat_error("invalid cluster 0x%x in clusters bitmap",
+						ef->cmap.start_cluster);
+				goto error;
+			}
+			ef->cmap.size = le32_to_cpu(ef->sb->cluster_count) -
+				EXFAT_FIRST_DATA_CLUSTER;
+			if (le64_to_cpu(bitmap->size) < DIV_ROUND_UP(ef->cmap.size, 8))
+			{
+				exfat_error("invalid clusters bitmap size: %"PRIu64
+						" (expected at least %u)",
+						le64_to_cpu(bitmap->size),
+						DIV_ROUND_UP(ef->cmap.size, 8));
+				goto error;
+			}
+			/* FIXME bitmap can be rather big, up to 512 MB */
+			ef->cmap.chunk_size = ef->cmap.size;
+			ef->cmap.chunk = malloc(BMAP_SIZE(ef->cmap.chunk_size));
+			if (ef->cmap.chunk == NULL)
+			{
+				exfat_error("failed to allocate clusters bitmap chunk "
+						"(%"PRIu64" bytes)", le64_to_cpu(bitmap->size));
+				rc = -ENOMEM;
+				goto error;
+			}
+
+			if (exfat_pread(ef->dev, ef->cmap.chunk,
+					BMAP_SIZE(ef->cmap.chunk_size),
+					exfat_c2o(ef, ef->cmap.start_cluster)) < 0)
+			{
+				exfat_error("failed to read clusters bitmap "
+						"(%"PRIu64" bytes starting at cluster %#x)",
+						le64_to_cpu(bitmap->size), ef->cmap.start_cluster);
+				goto error;
+			}
+			break;
+
+		case EXFAT_ENTRY_LABEL:
+			label = (const struct exfat_entry_label*) entry;
+			if (label->length > EXFAT_ENAME_MAX)
+			{
+				exfat_error("too long label (%hhu chars)", label->length);
+				goto error;
+			}
+			if (utf16_to_utf8(ef->label, label->name,
+						sizeof(ef->label) - 1, EXFAT_ENAME_MAX) != 0)
+				goto error;
+			break;
+
+		default:
+			if (entry->type & EXFAT_ENTRY_VALID)
+			{
+				exfat_error("unknown entry type 0x%hhx", entry->type);
+				goto error;
+			}
+			break;
+		}
+
+		if (!fetch_next_entry(ef, parent, it))
+			goto error;
+	}
+	/* we never reach here */
+
+error:
+	free(*node);
+	*node = NULL;
+	return rc;
+}
+
+int exfat_cache_directory(struct exfat* ef, struct exfat_node* dir)
+{
+	struct iterator it;
+	int rc;
+	struct exfat_node* node;
+	struct exfat_node* current = NULL;
+
+	if (dir->flags & EXFAT_ATTRIB_CACHED)
+		return 0; /* already cached */
+
+	rc = opendir(ef, dir, &it);
+	if (rc != 0)
+		return rc;
+	while ((rc = readdir(ef, dir, &node, &it)) == 0)
+	{
+		node->parent = dir;
+		if (current != NULL)
+		{
+			current->next = node;
+			node->prev = current;
+		}
+		else
+			dir->child = node;
+
+		current = node;
+	}
+	closedir(&it);
+
+	if (rc != -ENOENT)
+	{
+		/* rollback */
+		for (current = dir->child; current; current = node)
+		{
+			node = current->next;
+			free(current);
+		}
+		dir->child = NULL;
+		return rc;
+	}
+
+	dir->flags |= EXFAT_ATTRIB_CACHED;
+	return 0;
+}
+
+static void tree_attach(struct exfat_node* dir, struct exfat_node* node)
+{
+	node->parent = dir;
+	if (dir->child)
+	{
+		dir->child->prev = node;
+		node->next = dir->child;
+	}
+	dir->child = node;
+}
+
+static void tree_detach(struct exfat_node* node)
+{
+	if (node->prev)
+		node->prev->next = node->next;
+	else /* this is the first node in the list */
+		node->parent->child = node->next;
+	if (node->next)
+		node->next->prev = node->prev;
+	node->parent = NULL;
+	node->prev = NULL;
+	node->next = NULL;
+}
+
+static void reset_cache(struct exfat* ef, struct exfat_node* node)
+{
+	char buffer[UTF8_BYTES(EXFAT_NAME_MAX) + 1];
+
+	while (node->child)
+	{
+		struct exfat_node* p = node->child;
+		reset_cache(ef, p);
+		tree_detach(p);
+		free(p);
+	}
+	node->flags &= ~EXFAT_ATTRIB_CACHED;
+	if (node->references != 0)
+	{
+		exfat_get_name(node, buffer, sizeof(buffer) - 1);
+		exfat_warn("non-zero reference counter (%d) for '%s'",
+				node->references, buffer);
+	}
+	if (node != ef->root && (node->flags & EXFAT_ATTRIB_DIRTY))
+	{
+		exfat_get_name(node, buffer, sizeof(buffer) - 1);
+		exfat_bug("node '%s' is dirty", buffer);
+	}
+	while (node->references)
+		exfat_put_node(ef, node);
+}
+
+void exfat_reset_cache(struct exfat* ef)
+{
+	reset_cache(ef, ef->root);
+}
+
+static bool next_entry(struct exfat* ef, const struct exfat_node* parent,
+		cluster_t* cluster, off64_t* offset)
+{
+	*offset += sizeof(struct exfat_entry);
+	if (*offset % CLUSTER_SIZE(*ef->sb) == 0)
+	{
+		*cluster = exfat_next_cluster(ef, parent, *cluster);
+		if (CLUSTER_INVALID(*cluster))
+		{
+			exfat_error("invalid cluster %#x while getting next entry",
+					*cluster);
+			return false;
+		}
+	}
+	return true;
+}
+
+int exfat_flush_node(struct exfat* ef, struct exfat_node* node)
+{
+	cluster_t cluster;
+	off64_t offset;
+	off64_t meta1_offset, meta2_offset;
+	struct exfat_entry_meta1 meta1;
+	struct exfat_entry_meta2 meta2;
+
+	if (!(node->flags & EXFAT_ATTRIB_DIRTY))
+	{
+#if !defined(ALWAYS_USE_SYNC_OPTION) || !ALWAYS_USE_SYNC_OPTION
+		if ( ef->sync )
+#endif
+			exfat_flush_cmap(ef);
+		return 0; /* no need to flush */
+	}
+
+	if (ef->ro)
+		exfat_bug("unable to flush node to read-only FS");
+
+	if (node->parent == NULL)
+		return 0; /* do not flush unlinked node */
+
+	cluster = node->entry_cluster;
+	offset = node->entry_offset;
+	meta1_offset = co2o(ef, cluster, offset);
+	if (!next_entry(ef, node->parent, &cluster, &offset))
+		return -EIO;
+	meta2_offset = co2o(ef, cluster, offset);
+
+	if (exfat_pread(ef->dev, &meta1, sizeof(meta1), meta1_offset) < 0)
+	{
+		exfat_error("failed to read meta1 entry on flush");
+		return -EIO;
+	}
+	if (meta1.type != EXFAT_ENTRY_FILE)
+		exfat_bug("invalid type of meta1: 0x%hhx", meta1.type);
+	meta1.attrib = cpu_to_le16(node->flags);
+	exfat_unix2exfat(node->mtime, &meta1.mdate, &meta1.mtime, &meta1.mtime_cs);
+	exfat_unix2exfat(node->atime, &meta1.adate, &meta1.atime, NULL);
+
+	if (exfat_pread(ef->dev, &meta2, sizeof(meta2), meta2_offset) < 0)
+	{
+		exfat_error("failed to read meta2 entry on flush");
+		return -EIO;
+	}
+	if (meta2.type != EXFAT_ENTRY_FILE_INFO)
+		exfat_bug("invalid type of meta2: 0x%hhx", meta2.type);
+	meta2.size = meta2.valid_size = cpu_to_le64(node->size);
+	meta2.start_cluster = cpu_to_le32(node->start_cluster);
+	meta2.flags = EXFAT_FLAG_ALWAYS1;
+	/* empty files must not be marked as contiguous */
+	if (node->size != 0 && IS_CONTIGUOUS(*node))
+		meta2.flags |= EXFAT_FLAG_CONTIGUOUS;
+	/* name hash remains unchanged, no need to recalculate it */
+
+	meta1.checksum = exfat_calc_checksum(&meta1, &meta2, node->name);
+
+	if (exfat_pwrite(ef->dev, &meta1, sizeof(meta1), meta1_offset) < 0)
+	{
+		exfat_error("failed to write meta1 entry on flush");
+		ef->was_dirty = true; // Leaves the volume "mounted", to force chkdsk on it.
+		return -EIO;
+	}
+	if (exfat_pwrite(ef->dev, &meta2, sizeof(meta2), meta2_offset) < 0)
+	{
+		exfat_error("failed to write meta2 entry on flush");
+		ef->was_dirty = true; // Leaves the volume "mounted", to force chkdsk on it.
+		return -EIO;
+	}
+
+	node->flags &= ~EXFAT_ATTRIB_DIRTY;
+
+#if !defined(ALWAYS_USE_SYNC_OPTION) || !ALWAYS_USE_SYNC_OPTION
+	if ( ef->sync )
+#endif
+		exfat_flush_cmap(ef);
+
+	return 0;
+}
+
+static bool erase_entry(struct exfat* ef, struct exfat_node* node)
+{
+	cluster_t cluster = node->entry_cluster;
+	off64_t offset = node->entry_offset;
+	int name_entries = DIV_ROUND_UP(utf16_length(node->name), EXFAT_ENAME_MAX);
+	uint8_t entry_type;
+
+	entry_type = EXFAT_ENTRY_FILE & ~EXFAT_ENTRY_VALID;
+	if (exfat_pwrite(ef->dev, &entry_type, 1, co2o(ef, cluster, offset)) < 0)
+	{
+		exfat_error("failed to erase meta1 entry");
+		ef->was_dirty = true; // Leaves the volume "mounted", to force chkdsk on it.
+		return false;
+	}
+
+	if (!next_entry(ef, node->parent, &cluster, &offset))
+		return false;
+	entry_type = EXFAT_ENTRY_FILE_INFO & ~EXFAT_ENTRY_VALID;
+	if (exfat_pwrite(ef->dev, &entry_type, 1, co2o(ef, cluster, offset)) < 0)
+	{
+		exfat_error("failed to erase meta2 entry");
+		ef->was_dirty = true; // Leaves the volume "mounted", to force chkdsk on it.
+		return false;
+	}
+
+	while (name_entries--)
+	{
+		if (!next_entry(ef, node->parent, &cluster, &offset))
+			return false;
+		entry_type = EXFAT_ENTRY_FILE_NAME & ~EXFAT_ENTRY_VALID;
+		if (exfat_pwrite(ef->dev, &entry_type, 1,
+				co2o(ef, cluster, offset)) < 0)
+		{
+			exfat_error("failed to erase name entry");
+			ef->was_dirty = true; // Leaves the volume "mounted", to force chkdsk on it.
+			return false;
+		}
+	}
+	return true;
+}
+
+static int shrink_directory(struct exfat* ef, struct exfat_node* dir,
+		off64_t deleted_offset)
+{
+	const struct exfat_node* node;
+	const struct exfat_node* last_node;
+	uint64_t entries = 0;
+	uint64_t new_size;
+
+	if (!(dir->flags & EXFAT_ATTRIB_DIR))
+		exfat_bug("attempted to shrink a file");
+	if (!(dir->flags & EXFAT_ATTRIB_CACHED))
+		exfat_bug("attempted to shrink uncached directory");
+
+	for (last_node = node = dir->child; node; node = node->next)
+	{
+		if (deleted_offset < node->entry_offset)
+		{
+			/* there are other entries after the removed one, no way to shrink
+			   this directory */
+			return 0;
+		}
+		if (last_node->entry_offset < node->entry_offset)
+			last_node = node;
+	}
+
+	if (last_node)
+	{
+		/* offset of the last entry */
+		entries += last_node->entry_offset / sizeof(struct exfat_entry);
+		/* two subentries with meta info */
+		entries += 2;
+		/* subentries with file name */
+		entries += DIV_ROUND_UP(utf16_length(last_node->name),
+				EXFAT_ENAME_MAX);
+	}
+
+	new_size = DIV_ROUND_UP(entries * sizeof(struct exfat_entry),
+				 CLUSTER_SIZE(*ef->sb)) * CLUSTER_SIZE(*ef->sb);
+	if (new_size == 0) /* directory always has at least 1 cluster */
+		new_size = CLUSTER_SIZE(*ef->sb);
+	if (new_size == dir->size)
+		return 0;
+	return exfat_truncate(ef, dir, new_size, true);
+}
+
+static int delete(struct exfat* ef, struct exfat_node* node)
+{
+	struct exfat_node* parent = node->parent;
+	off64_t deleted_offset = node->entry_offset;
+	int rc;
+
+	exfat_get_node(parent);
+	if (!erase_entry(ef, node))
+	{
+		exfat_put_node(ef, parent);
+		return -EIO;
+	}
+	exfat_update_mtime(parent);
+	tree_detach(node);
+	rc = shrink_directory(ef, parent, deleted_offset);
+	node->flags |= EXFAT_ATTRIB_UNLINKED;
+	if (rc != 0)
+	{
+		exfat_flush_node(ef, parent);
+		exfat_put_node(ef, parent);
+		return rc;
+	}
+	rc = exfat_flush_node(ef, parent);
+	exfat_put_node(ef, parent);
+	return rc;
+}
+
+int exfat_unlink(struct exfat* ef, struct exfat_node* node)
+{
+	if (node->flags & EXFAT_ATTRIB_DIR)
+		return -EISDIR;
+	return delete(ef, node);
+}
+
+int exfat_rmdir(struct exfat* ef, struct exfat_node* node)
+{
+	int rc;
+
+	if (!(node->flags & EXFAT_ATTRIB_DIR))
+		return -ENOTDIR;
+	/* check that directory is empty */
+	rc = exfat_cache_directory(ef, node);
+	if (rc != 0)
+		return rc;
+	if (node->child)
+		return -ENOTEMPTY;
+	return delete(ef, node);
+}
+
+static int grow_directory(struct exfat* ef, struct exfat_node* dir,
+		uint64_t asize, uint32_t difference)
+{
+	return exfat_truncate(ef, dir,
+			DIV_ROUND_UP(asize + difference, CLUSTER_SIZE(*ef->sb))
+				* CLUSTER_SIZE(*ef->sb), true);
+}
+
+static int find_slot(struct exfat* ef, struct exfat_node* dir,
+		cluster_t* cluster, off64_t* offset, int subentries)
+{
+	struct iterator it;
+	int rc;
+	const struct exfat_entry* entry;
+	int contiguous = 0;
+
+	rc = opendir(ef, dir, &it);
+	if (rc != 0)
+		return rc;
+	for (;;)
+	{
+		if (contiguous == 0)
+		{
+			*cluster = it.cluster;
+			*offset = it.offset;
+		}
+		entry = get_entry_ptr(ef, &it);
+		if (entry->type & EXFAT_ENTRY_VALID)
+			contiguous = 0;
+		else
+			contiguous++;
+		if (contiguous == subentries)
+			break;	/* suitable slot is found */
+		if (it.offset + sizeof(struct exfat_entry) >= dir->size)
+		{
+			rc = grow_directory(ef, dir, dir->size,
+					(subentries - contiguous) * sizeof(struct exfat_entry));
+			if (rc != 0)
+			{
+				closedir(&it);
+				return rc;
+			}
+		}
+		if (!fetch_next_entry(ef, dir, &it))
+		{
+			closedir(&it);
+			return -EIO;
+		}
+	}
+	closedir(&it);
+	return 0;
+}
+
+static int write_entry(struct exfat* ef, struct exfat_node* dir,
+		const le16_t* name, cluster_t cluster, off64_t offset, uint16_t attrib)
+{
+	struct exfat_node* node;
+	struct exfat_entry_meta1 meta1;
+	struct exfat_entry_meta2 meta2;
+	const size_t name_length = utf16_length(name);
+	const int name_entries = DIV_ROUND_UP(name_length, EXFAT_ENAME_MAX);
+	int i;
+
+	node = allocate_node();
+	if (node == NULL)
+		return -ENOMEM;
+	node->entry_cluster = cluster;
+	node->entry_offset = offset;
+	memcpy(node->name, name, name_length * sizeof(le16_t));
+
+	memset(&meta1, 0, sizeof(meta1));
+	meta1.type = EXFAT_ENTRY_FILE;
+	meta1.continuations = 1 + name_entries;
+	meta1.attrib = cpu_to_le16(attrib);
+	exfat_unix2exfat(time(NULL), &meta1.crdate, &meta1.crtime,
+			&meta1.crtime_cs);
+	meta1.adate = meta1.mdate = meta1.crdate;
+	meta1.atime = meta1.mtime = meta1.crtime;
+	meta1.mtime_cs = meta1.crtime_cs; /* there is no atime_cs */
+
+	memset(&meta2, 0, sizeof(meta2));
+	meta2.type = EXFAT_ENTRY_FILE_INFO;
+	meta2.flags = EXFAT_FLAG_ALWAYS1;
+	meta2.name_length = name_length;
+	meta2.name_hash = exfat_calc_name_hash(ef, node->name);
+	meta2.start_cluster = cpu_to_le32(EXFAT_CLUSTER_FREE);
+
+	meta1.checksum = exfat_calc_checksum(&meta1, &meta2, node->name);
+
+	if (exfat_pwrite(ef->dev, &meta1, sizeof(meta1),
+			co2o(ef, cluster, offset)) < 0)
+	{
+		exfat_error("failed to write meta1 entry");
+		ef->was_dirty = true; // Leaves the volume "mounted", to force chkdsk on it.
+		return -EIO;
+	}
+	if (!next_entry(ef, dir, &cluster, &offset))
+		return -EIO;
+	if (exfat_pwrite(ef->dev, &meta2, sizeof(meta2),
+			co2o(ef, cluster, offset)) < 0)
+	{
+		exfat_error("failed to write meta2 entry");
+		ef->was_dirty = true; // Leaves the volume "mounted", to force chkdsk on it.
+		return -EIO;
+	}
+	for (i = 0; i < name_entries; i++)
+	{
+		struct exfat_entry_name name_entry = {EXFAT_ENTRY_FILE_NAME, 0};
+		memcpy(name_entry.name, node->name + i * EXFAT_ENAME_MAX,
+				MIN(EXFAT_ENAME_MAX, EXFAT_NAME_MAX - i * EXFAT_ENAME_MAX) *
+				sizeof(le16_t));
+		if (!next_entry(ef, dir, &cluster, &offset))
+			return -EIO;
+		if (exfat_pwrite(ef->dev, &name_entry, sizeof(name_entry),
+				co2o(ef, cluster, offset)) < 0)
+		{
+			exfat_error("failed to write name entry");
+			ef->was_dirty = true; // Leaves the volume "mounted", to force chkdsk on it.
+			return -EIO;
+		}
+	}
+
+	init_node_meta1(node, &meta1);
+	init_node_meta2(node, &meta2);
+
+	tree_attach(dir, node);
+	exfat_update_mtime(dir);
+	return 0;
+}
+
+static int create(struct exfat* ef, const char* path, uint16_t attrib)
+{
+	struct exfat_node* dir;
+	struct exfat_node* existing;
+	cluster_t cluster = EXFAT_CLUSTER_BAD;
+	off64_t offset = -1;
+	le16_t name[EXFAT_NAME_MAX + 1];
+	int rc;
+
+	rc = exfat_split(ef, &dir, &existing, name, path);
+	if (rc != 0)
+		return rc;
+	if (existing != NULL)
+	{
+		exfat_put_node(ef, existing);
+		exfat_put_node(ef, dir);
+		return -EEXIST;
+	}
+
+	rc = find_slot(ef, dir, &cluster, &offset,
+			2 + DIV_ROUND_UP(utf16_length(name), EXFAT_ENAME_MAX));
+	if (rc != 0)
+	{
+		exfat_put_node(ef, dir);
+		return rc;
+	}
+	rc = write_entry(ef, dir, name, cluster, offset, attrib);
+	if (rc != 0)
+	{
+		exfat_put_node(ef, dir);
+		return rc;
+	}
+	rc = exfat_flush_node(ef, dir);
+	exfat_put_node(ef, dir);
+	return rc;
+}
+
+int exfat_mknod(struct exfat* ef, const char* path)
+{
+	return create(ef, path, EXFAT_ATTRIB_ARCH);
+}
+
+int exfat_mkdir(struct exfat* ef, const char* path)
+{
+	int rc;
+	struct exfat_node* node;
+
+	rc = create(ef, path, EXFAT_ATTRIB_ARCH | EXFAT_ATTRIB_DIR);
+	if (rc != 0)
+		return rc;
+	rc = exfat_lookup(ef, &node, path);
+	if (rc != 0)
+		return 0;
+	/* directories always have at least one cluster */
+	rc = exfat_truncate(ef, node, CLUSTER_SIZE(*ef->sb), true);
+	if (rc != 0)
+	{
+		delete(ef, node);
+		exfat_put_node(ef, node);
+		return rc;
+	}
+	rc = exfat_flush_node(ef, node);
+	if (rc != 0)
+	{
+		delete(ef, node);
+		exfat_put_node(ef, node);
+		return rc;
+	}
+	exfat_put_node(ef, node);
+	return 0;
+}
+
+static int rename_entry(struct exfat* ef, struct exfat_node* dir,
+		struct exfat_node* node, const le16_t* name, cluster_t new_cluster,
+		off64_t new_offset)
+{
+	struct exfat_entry_meta1 meta1;
+	struct exfat_entry_meta2 meta2;
+	cluster_t old_cluster = node->entry_cluster;
+	off64_t old_offset = node->entry_offset;
+	const size_t name_length = utf16_length(name);
+	const int name_entries = DIV_ROUND_UP(name_length, EXFAT_ENAME_MAX);
+	int i;
+
+	if (exfat_pread(ef->dev, &meta1, sizeof(meta1),
+			co2o(ef, old_cluster, old_offset)) < 0)
+	{
+		exfat_error("failed to read meta1 entry on rename");
+		return -EIO;
+	}
+	if (!next_entry(ef, node->parent, &old_cluster, &old_offset))
+		return -EIO;
+	if (exfat_pread(ef->dev, &meta2, sizeof(meta2),
+			co2o(ef, old_cluster, old_offset)) < 0)
+	{
+		exfat_error("failed to read meta2 entry on rename");
+		return -EIO;
+	}
+	meta1.continuations = 1 + name_entries;
+	meta2.name_hash = exfat_calc_name_hash(ef, name);
+	meta2.name_length = name_length;
+	meta1.checksum = exfat_calc_checksum(&meta1, &meta2, name);
+
+	if (!erase_entry(ef, node))
+		return -EIO;
+
+	node->entry_cluster = new_cluster;
+	node->entry_offset = new_offset;
+
+	if (exfat_pwrite(ef->dev, &meta1, sizeof(meta1),
+			co2o(ef, new_cluster, new_offset)) < 0)
+	{
+		exfat_error("failed to write meta1 entry on rename");
+		ef->was_dirty = true; // Leaves the volume "mounted", to force chkdsk on it.
+		return -EIO;
+	}
+	if (!next_entry(ef, dir, &new_cluster, &new_offset))
+		return -EIO;
+	if (exfat_pwrite(ef->dev, &meta2, sizeof(meta2),
+			co2o(ef, new_cluster, new_offset)) < 0)
+	{
+		exfat_error("failed to write meta2 entry on rename");
+		ef->was_dirty = true; // Leaves the volume "mounted", to force chkdsk on it.
+		return -EIO;
+	}
+
+	for (i = 0; i < name_entries; i++)
+	{
+		struct exfat_entry_name name_entry = {EXFAT_ENTRY_FILE_NAME, 0};
+		memcpy(name_entry.name, name + i * EXFAT_ENAME_MAX,
+				EXFAT_ENAME_MAX * sizeof(le16_t));
+		if (!next_entry(ef, dir, &new_cluster, &new_offset))
+			return -EIO;
+		if (exfat_pwrite(ef->dev, &name_entry, sizeof(name_entry),
+				co2o(ef, new_cluster, new_offset)) < 0)
+		{
+			exfat_error("failed to write name entry on rename");
+			ef->was_dirty = true; // Leaves the volume "mounted", to force chkdsk on it.
+			return -EIO;
+		}
+	}
+
+	memcpy(node->name, name, (EXFAT_NAME_MAX + 1) * sizeof(le16_t));
+	tree_detach(node);
+	tree_attach(dir, node);
+	return 0;
+}
+
+int exfat_rename(struct exfat* ef, const char* old_path, const char* new_path)
+{
+	struct exfat_node* node;
+	struct exfat_node* existing;
+	struct exfat_node* dir;
+	cluster_t cluster = EXFAT_CLUSTER_BAD;
+	off64_t offset = -1;
+	le16_t name[EXFAT_NAME_MAX + 1];
+	int rc;
+
+	rc = exfat_lookup(ef, &node, old_path);
+	if (rc != 0)
+		return rc;
+
+	rc = exfat_split(ef, &dir, &existing, name, new_path);
+	if (rc != 0)
+	{
+		exfat_put_node(ef, node);
+		return rc;
+	}
+
+	/* check that target is not a subdirectory of the source */
+	if (node->flags & EXFAT_ATTRIB_DIR)
+	{
+		struct exfat_node* p;
+
+		for (p = dir; p; p = p->parent)
+			if (node == p)
+			{
+				if (existing != NULL)
+					exfat_put_node(ef, existing);
+				exfat_put_node(ef, dir);
+				exfat_put_node(ef, node);
+				return -EINVAL;
+			}
+	}
+
+	if (existing != NULL)
+	{
+		/* remove target if it's not the same node as source */
+		if (existing != node)
+		{
+			if (existing->flags & EXFAT_ATTRIB_DIR)
+			{
+				if (node->flags & EXFAT_ATTRIB_DIR)
+					rc = exfat_rmdir(ef, existing);
+				else
+					rc = -ENOTDIR;
+			}
+			else
+			{
+				if (!(node->flags & EXFAT_ATTRIB_DIR))
+					rc = exfat_unlink(ef, existing);
+				else
+					rc = -EISDIR;
+			}
+			exfat_put_node(ef, existing);
+			if (rc != 0)
+			{
+				exfat_put_node(ef, dir);
+				exfat_put_node(ef, node);
+				return rc;
+			}
+		}
+		else
+			exfat_put_node(ef, existing);
+	}
+
+	rc = find_slot(ef, dir, &cluster, &offset,
+			2 + DIV_ROUND_UP(utf16_length(name), EXFAT_ENAME_MAX));
+	if (rc != 0)
+	{
+		exfat_put_node(ef, dir);
+		exfat_put_node(ef, node);
+		return rc;
+	}
+	rc = rename_entry(ef, dir, node, name, cluster, offset);
+	exfat_put_node(ef, dir);
+	exfat_put_node(ef, node);
+	return rc;
+}
+
+void exfat_utimes(struct exfat_node* node, const struct timespec tv[2])
+{
+	node->atime = tv[0].tv_sec;
+	node->mtime = tv[1].tv_sec;
+	node->flags |= EXFAT_ATTRIB_DIRTY;
+}
+
+void exfat_update_atime(struct exfat_node* node)
+{
+	node->atime = time(NULL);
+	node->flags |= EXFAT_ATTRIB_DIRTY;
+}
+
+void exfat_update_mtime(struct exfat_node* node)
+{
+	node->mtime = time(NULL);
+	node->flags |= EXFAT_ATTRIB_DIRTY;
+}
+
+const char* exfat_get_label(struct exfat* ef)
+{
+	return ef->label;
+}
+
+static int find_label(struct exfat* ef, cluster_t* cluster, off64_t* offset)
+{
+	struct iterator it;
+	int rc;
+
+	rc = opendir(ef, ef->root, &it);
+	if (rc != 0)
+		return rc;
+
+	for (;;)
+	{
+		if (it.offset >= ef->root->size)
+		{
+			closedir(&it);
+			return -ENOENT;
+		}
+
+		if (get_entry_ptr(ef, &it)->type == EXFAT_ENTRY_LABEL)
+		{
+			*cluster = it.cluster;
+			*offset = it.offset;
+			closedir(&it);
+			return 0;
+		}
+
+		if (!fetch_next_entry(ef, ef->root, &it))
+		{
+			closedir(&it);
+			return -EIO;
+		}
+	}
+}
+
+int exfat_set_label(struct exfat* ef, const char* label)
+{
+	le16_t label_utf16[EXFAT_ENAME_MAX + 1];
+	int rc;
+	cluster_t cluster;
+	off64_t offset;
+	struct exfat_entry_label entry;
+
+	memset(label_utf16, 0, sizeof(label_utf16));
+	rc = utf8_to_utf16(label_utf16, label, EXFAT_ENAME_MAX, strlen(label));
+	if (rc != 0)
+		return rc;
+
+	rc = find_label(ef, &cluster, &offset);
+	if (rc == -ENOENT)
+		rc = find_slot(ef, ef->root, &cluster, &offset, 1);
+	if (rc != 0)
+		return rc;
+
+	entry.type = EXFAT_ENTRY_LABEL;
+	entry.length = utf16_length(label_utf16);
+	memcpy(entry.name, label_utf16, sizeof(entry.name));
+	if (entry.length == 0)
+		entry.type ^= EXFAT_ENTRY_VALID;
+
+	if (exfat_pwrite(ef->dev, &entry, sizeof(struct exfat_entry_label),
+			co2o(ef, cluster, offset)) < 0)
+	{
+		exfat_error("failed to write label entry");
+		ef->was_dirty = true; // Leaves the volume "mounted", to force chkdsk on it.
+		return -EIO;
+	}
+	strcpy(ef->label, label);
+	return 0;
+}
diff --git a/external/exfat-fuse/libexfat/platform.h b/external/exfat-fuse/libexfat/platform.h
new file mode 100755
index 0000000000..0e5dc9113a
--- /dev/null
+++ b/external/exfat-fuse/libexfat/platform.h
@@ -0,0 +1,63 @@
+/*
+	platform.h (14.05.13)
+	OS-specific code (libc-specific in fact). Note that systems with the
+	same kernel can use different libc implementations.
+
+	Free exFAT implementation.
+	Copyright (C) 2010-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#ifndef PLATFORM_H_INCLUDED
+#define PLATFORM_H_INCLUDED
+
+#if defined(__GLIBC__)
+
+#include <endian.h>
+#include <byteswap.h>
+#define exfat_bswap16(x) bswap_16(x)
+#define exfat_bswap32(x) bswap_32(x)
+#define exfat_bswap64(x) bswap_64(x)
+#define EXFAT_BYTE_ORDER __BYTE_ORDER
+#define EXFAT_LITTLE_ENDIAN __LITTLE_ENDIAN
+#define EXFAT_BIG_ENDIAN __BIG_ENDIAN
+
+#elif defined(__APPLE__)
+
+#include <machine/endian.h>
+#include <libkern/OSByteOrder.h>
+#define exfat_bswap16(x) OSSwapInt16(x)
+#define exfat_bswap32(x) OSSwapInt32(x)
+#define exfat_bswap64(x) OSSwapInt64(x)
+#define EXFAT_BYTE_ORDER BYTE_ORDER
+#define EXFAT_LITTLE_ENDIAN LITTLE_ENDIAN
+#define EXFAT_BIG_ENDIAN BIG_ENDIAN
+
+#elif defined(__FreeBSD__) || defined(__DragonFlyBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
+
+#include <sys/endian.h>
+#define exfat_bswap16(x) bswap16(x)
+#define exfat_bswap32(x) bswap32(x)
+#define exfat_bswap64(x) bswap64(x)
+#define EXFAT_BYTE_ORDER _BYTE_ORDER
+#define EXFAT_LITTLE_ENDIAN _LITTLE_ENDIAN
+#define EXFAT_BIG_ENDIAN _BIG_ENDIAN
+
+#else 
+#error Unknown platform
+#endif
+
+#endif /* ifndef PLATFORM_H_INCLUDED */
diff --git a/external/exfat-fuse/libexfat/time.c b/external/exfat-fuse/libexfat/time.c
new file mode 100755
index 0000000000..b264a999a9
--- /dev/null
+++ b/external/exfat-fuse/libexfat/time.c
@@ -0,0 +1,158 @@
+/*
+	time.c (03.02.12)
+	exFAT file system implementation library.
+
+	Free exFAT implementation.
+	Copyright (C) 2010-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include "exfat.h"
+
+/* timezone offset from UTC in seconds; positive for western timezones,
+   negative for eastern ones */
+static long exfat_timezone;
+
+#define SEC_IN_MIN 60ll
+#define SEC_IN_HOUR (60 * SEC_IN_MIN)
+#define SEC_IN_DAY (24 * SEC_IN_HOUR)
+#define SEC_IN_YEAR (365 * SEC_IN_DAY) /* not leap year */
+/* Unix epoch started at 0:00:00 UTC 1 January 1970 */
+#define UNIX_EPOCH_YEAR 1970
+/* exFAT epoch started at 0:00:00 UTC 1 January 1980 */
+#define EXFAT_EPOCH_YEAR 1980
+/* number of years from Unix epoch to exFAT epoch */
+#define EPOCH_DIFF_YEAR (EXFAT_EPOCH_YEAR - UNIX_EPOCH_YEAR)
+/* number of days from Unix epoch to exFAT epoch (considering leap days) */
+#define EPOCH_DIFF_DAYS (EPOCH_DIFF_YEAR * 365 + EPOCH_DIFF_YEAR / 4)
+/* number of seconds from Unix epoch to exFAT epoch (considering leap days) */
+#define EPOCH_DIFF_SEC (EPOCH_DIFF_DAYS * SEC_IN_DAY)
+/* number of leap years passed from exFAT epoch to the specified year
+   (excluding the specified year itself) */
+#define LEAP_YEARS(year) ((EXFAT_EPOCH_YEAR + (year) - 1) / 4 \
+		- (EXFAT_EPOCH_YEAR - 1) / 4)
+/* checks whether the specified year is leap */
+#define IS_LEAP_YEAR(year) ((EXFAT_EPOCH_YEAR + (year)) % 4 == 0)
+
+static const time_t days_in_year[] =
+{
+	/* Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec */
+	0,   0,  31,  59,  90, 120, 151, 181, 212, 243, 273, 304, 334
+};
+
+time_t exfat_exfat2unix(le16_t date, le16_t time, uint8_t centisec)
+{
+	time_t unix_time = EPOCH_DIFF_SEC;
+	uint16_t ndate = le16_to_cpu(date);
+	uint16_t ntime = le16_to_cpu(time);
+
+	uint16_t day    = ndate & 0x1f;      /* 5 bits, 1-31 */
+	uint16_t month  = ndate >> 5 & 0xf;  /* 4 bits, 1-12 */
+	uint16_t year   = ndate >> 9;        /* 7 bits, 1-127 (+1980) */
+
+	uint16_t twosec = ntime & 0x1f;      /* 5 bits, 0-29 (2 sec granularity) */
+	uint16_t min    = ntime >> 5 & 0x3f; /* 6 bits, 0-59 */
+	uint16_t hour   = ntime >> 11;       /* 5 bits, 0-23 */
+
+	if (day == 0 || month == 0 || month > 12)
+	{
+		exfat_error("bad date %u-%02hu-%02hu",
+				year + EXFAT_EPOCH_YEAR, month, day);
+		return 0;
+	}
+	if (hour > 23 || min > 59 || twosec > 29)
+	{
+		exfat_error("bad time %hu:%02hu:%02u",
+				hour, min, twosec * 2);
+		return 0;
+	}
+	if (centisec > 199)
+	{
+		exfat_error("bad centiseconds count %hhu", centisec);
+		return 0;
+	}
+
+	/* every 4th year between 1904 and 2096 is leap */
+	unix_time += year * SEC_IN_YEAR + LEAP_YEARS(year) * SEC_IN_DAY;
+	unix_time += days_in_year[month] * SEC_IN_DAY;
+	/* if it's leap year and February has passed we should add 1 day */
+	if ((EXFAT_EPOCH_YEAR + year) % 4 == 0 && month > 2)
+		unix_time += SEC_IN_DAY;
+	unix_time += (day - 1) * SEC_IN_DAY;
+
+	unix_time += hour * SEC_IN_HOUR;
+	unix_time += min * SEC_IN_MIN;
+	/* exFAT represents time with 2 sec granularity */
+	unix_time += twosec * 2;
+	unix_time += centisec / 100;
+
+	/* exFAT stores timestamps in local time, so we correct it to UTC */
+	unix_time += exfat_timezone;
+
+	return unix_time;
+}
+
+void exfat_unix2exfat(time_t unix_time, le16_t* date, le16_t* time,
+		uint8_t* centisec)
+{
+	time_t shift = EPOCH_DIFF_SEC + exfat_timezone;
+	uint16_t day, month, year;
+	uint16_t twosec, min, hour;
+	int days;
+	int i;
+
+	/* time before exFAT epoch cannot be represented */
+	if (unix_time < shift)
+		unix_time = shift;
+
+	unix_time -= shift;
+
+	days = unix_time / SEC_IN_DAY;
+	year = (4 * days) / (4 * 365 + 1);
+	days -= year * 365 + LEAP_YEARS(year);
+	month = 0;
+	for (i = 1; i <= 12; i++)
+	{
+		int leap_day = (IS_LEAP_YEAR(year) && i == 2);
+		int leap_sub = (IS_LEAP_YEAR(year) && i >= 3);
+
+		if (i == 12 || days - leap_sub < days_in_year[i + 1] + leap_day)
+		{
+			month = i;
+			days -= days_in_year[i] + leap_sub;
+			break;
+		}
+	}
+	day = days + 1;
+
+	hour = (unix_time % SEC_IN_DAY) / SEC_IN_HOUR;
+	min = (unix_time % SEC_IN_HOUR) / SEC_IN_MIN;
+	twosec = (unix_time % SEC_IN_MIN) / 2;
+
+	*date = cpu_to_le16(day | (month << 5) | (year << 9));
+	*time = cpu_to_le16(twosec | (min << 5) | (hour << 11));
+	if (centisec)
+		*centisec = (unix_time % 2) * 100;
+}
+
+void exfat_tzset(void)
+{
+	time_t now;
+
+	tzset();
+	now = time(NULL);
+	exfat_timezone = mktime(gmtime(&now)) - now;
+}
diff --git a/external/exfat-fuse/libexfat/utf.c b/external/exfat-fuse/libexfat/utf.c
new file mode 100755
index 0000000000..70fa856fcf
--- /dev/null
+++ b/external/exfat-fuse/libexfat/utf.c
@@ -0,0 +1,231 @@
+/*
+	utf.c (13.09.09)
+	exFAT file system implementation library.
+
+	Free exFAT implementation.
+	Copyright (C) 2010-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include "exfat.h"
+#include <errno.h>
+
+static char* wchar_to_utf8(char* output, wchar_t wc, size_t outsize)
+{
+	if (wc <= 0x7f)
+	{
+		if (outsize < 1)
+			return NULL;
+		*output++ = (char) wc;
+	}
+	else if (wc <= 0x7ff)
+	{
+		if (outsize < 2)
+			return NULL;
+		*output++ = 0xc0 | (wc >> 6);
+		*output++ = 0x80 | (wc & 0x3f);
+	}
+	else if (wc <= 0xffff)
+	{
+		if (outsize < 3)
+			return NULL;
+		*output++ = 0xe0 | (wc >> 12);
+		*output++ = 0x80 | ((wc >> 6) & 0x3f);
+		*output++ = 0x80 | (wc & 0x3f);
+	}
+	else if (wc <= 0x1fffff)
+	{
+		if (outsize < 4)
+			return NULL;
+		*output++ = 0xf0 | (wc >> 18);
+		*output++ = 0x80 | ((wc >> 12) & 0x3f);
+		*output++ = 0x80 | ((wc >> 6) & 0x3f);
+		*output++ = 0x80 | (wc & 0x3f);
+	}
+	else if (wc <= 0x3ffffff)
+	{
+		if (outsize < 5)
+			return NULL;
+		*output++ = 0xf8 | (wc >> 24);
+		*output++ = 0x80 | ((wc >> 18) & 0x3f);
+		*output++ = 0x80 | ((wc >> 12) & 0x3f);
+		*output++ = 0x80 | ((wc >> 6) & 0x3f);
+		*output++ = 0x80 | (wc & 0x3f);
+	}
+	else if (wc <= 0x7fffffff)
+	{
+		if (outsize < 6)
+			return NULL;
+		*output++ = 0xfc | (wc >> 30);
+		*output++ = 0x80 | ((wc >> 24) & 0x3f);
+		*output++ = 0x80 | ((wc >> 18) & 0x3f);
+		*output++ = 0x80 | ((wc >> 12) & 0x3f);
+		*output++ = 0x80 | ((wc >> 6) & 0x3f);
+		*output++ = 0x80 | (wc & 0x3f);
+	}
+	else
+		return NULL;
+
+	return output;
+}
+
+static const le16_t* utf16_to_wchar(const le16_t* input, wchar_t* wc,
+		size_t insize)
+{
+	if ((le16_to_cpu(input[0]) & 0xfc00) == 0xd800)
+	{
+		if (insize < 2 || (le16_to_cpu(input[1]) & 0xfc00) != 0xdc00)
+			return NULL;
+		*wc = ((wchar_t) (le16_to_cpu(input[0]) & 0x3ff) << 10);
+		*wc |= (le16_to_cpu(input[1]) & 0x3ff);
+		*wc += 0x10000;
+		return input + 2;
+	}
+	else
+	{
+		*wc = le16_to_cpu(*input);
+		return input + 1;
+	}
+}
+
+int utf16_to_utf8(char* output, const le16_t* input, size_t outsize,
+		size_t insize)
+{
+	const le16_t* inp = input;
+	char* outp = output;
+	wchar_t wc;
+
+	while (inp - input < insize && le16_to_cpu(*inp))
+	{
+		inp = utf16_to_wchar(inp, &wc, insize - (inp - input));
+		if (inp == NULL)
+		{
+			exfat_error("illegal UTF-16 sequence");
+			return -EILSEQ;
+		}
+		outp = wchar_to_utf8(outp, wc, outsize - (outp - output));
+		if (outp == NULL)
+		{
+			exfat_error("name is too long");
+			return -ENAMETOOLONG;
+		}
+	}
+	*outp = '\0';
+	return 0;
+}
+
+static const char* utf8_to_wchar(const char* input, wchar_t* wc,
+		size_t insize)
+{
+	if ((input[0] & 0x80) == 0 && insize >= 1)
+	{
+		*wc = (wchar_t) input[0];
+		return input + 1;
+	}
+	if ((input[0] & 0xe0) == 0xc0 && insize >= 2)
+	{
+		*wc = (((wchar_t) input[0] & 0x1f) << 6) |
+		       ((wchar_t) input[1] & 0x3f);
+		return input + 2;
+	}
+	if ((input[0] & 0xf0) == 0xe0 && insize >= 3)
+	{
+		*wc = (((wchar_t) input[0] & 0x0f) << 12) |
+		      (((wchar_t) input[1] & 0x3f) << 6) |
+		       ((wchar_t) input[2] & 0x3f);
+		return input + 3;
+	}
+	if ((input[0] & 0xf8) == 0xf0 && insize >= 4)
+	{
+		*wc = (((wchar_t) input[0] & 0x07) << 18) |
+		      (((wchar_t) input[1] & 0x3f) << 12) |
+		      (((wchar_t) input[2] & 0x3f) << 6) |
+		       ((wchar_t) input[3] & 0x3f);
+		return input + 4;
+	}
+	if ((input[0] & 0xfc) == 0xf8 && insize >= 5)
+	{
+		*wc = (((wchar_t) input[0] & 0x03) << 24) |
+		      (((wchar_t) input[1] & 0x3f) << 18) |
+		      (((wchar_t) input[2] & 0x3f) << 12) |
+		      (((wchar_t) input[3] & 0x3f) << 6) |
+		       ((wchar_t) input[4] & 0x3f);
+		return input + 5;
+	}
+	if ((input[0] & 0xfe) == 0xfc && insize >= 6)
+	{
+		*wc = (((wchar_t) input[0] & 0x01) << 30) |
+		      (((wchar_t) input[1] & 0x3f) << 24) |
+		      (((wchar_t) input[2] & 0x3f) << 18) |
+		      (((wchar_t) input[3] & 0x3f) << 12) |
+		      (((wchar_t) input[4] & 0x3f) << 6) |
+		       ((wchar_t) input[5] & 0x3f);
+		return input + 6;
+	}
+	return NULL;
+}
+
+static le16_t* wchar_to_utf16(le16_t* output, wchar_t wc, size_t outsize)
+{
+	if (wc <= 0xffff) /* if character is from BMP */
+	{
+		if (outsize == 0)
+			return NULL;
+		output[0] = cpu_to_le16(wc);
+		return output + 1;
+	}
+	if (outsize < 2)
+		return NULL;
+	wc -= 0x10000;
+	output[0] = cpu_to_le16(0xd800 | ((wc >> 10) & 0x3ff));
+	output[1] = cpu_to_le16(0xdc00 | (wc & 0x3ff));
+	return output + 2;
+}
+
+int utf8_to_utf16(le16_t* output, const char* input, size_t outsize,
+		size_t insize)
+{
+	const char* inp = input;
+	le16_t* outp = output;
+	wchar_t wc;
+
+	while (inp - input < insize && *inp)
+	{
+		inp = utf8_to_wchar(inp, &wc, insize - (inp - input));
+		if (inp == NULL)
+		{
+			exfat_error("illegal UTF-8 sequence");
+			return -EILSEQ;
+		}
+		outp = wchar_to_utf16(outp, wc, outsize - (outp - output));
+		if (outp == NULL)
+		{
+			exfat_error("name is too long");
+			return -ENAMETOOLONG;
+		}
+	}
+	*outp = cpu_to_le16(0);
+	return 0;
+}
+
+size_t utf16_length(const le16_t* str)
+{
+	size_t i = 0;
+
+	while (le16_to_cpu(str[i]))
+		i++;
+	return i;
+}
diff --git a/external/exfat-fuse/libexfat/utils.c b/external/exfat-fuse/libexfat/utils.c
new file mode 100755
index 0000000000..c0ecd56cc4
--- /dev/null
+++ b/external/exfat-fuse/libexfat/utils.c
@@ -0,0 +1,179 @@
+/*
+	utils.c (04.09.09)
+	exFAT file system implementation library.
+
+	Free exFAT implementation.
+	Copyright (C) 2010-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include "exfat.h"
+#include <string.h>
+#include <stdio.h>
+#include <inttypes.h>
+
+void exfat_stat(const struct exfat* ef, const struct exfat_node* node,
+		struct stat* stbuf)
+{
+	memset(stbuf, 0, sizeof(struct stat));
+	if (node->flags & EXFAT_ATTRIB_DIR)
+		stbuf->st_mode = S_IFDIR | (0777 & ~ef->dmask);
+	else
+		stbuf->st_mode = S_IFREG | (0777 & ~ef->fmask);
+	stbuf->st_nlink = 1;
+	stbuf->st_uid = ef->uid;
+	stbuf->st_gid = ef->gid;
+	stbuf->st_size = node->size;
+	stbuf->st_blocks = DIV_ROUND_UP(node->size, CLUSTER_SIZE(*ef->sb)) *
+		CLUSTER_SIZE(*ef->sb) / 512;
+	stbuf->st_mtime = node->mtime;
+	stbuf->st_atime = node->atime;
+	/* set ctime to mtime to ensure we don't break programs that rely on ctime
+	   (e.g. rsync) */
+	stbuf->st_ctime = node->mtime;
+}
+
+void exfat_get_name(const struct exfat_node* node, char* buffer, size_t n)
+{
+	if (utf16_to_utf8(buffer, node->name, n, EXFAT_NAME_MAX) != 0)
+		exfat_bug("failed to convert name to UTF-8");
+}
+
+uint16_t exfat_start_checksum(const struct exfat_entry_meta1* entry)
+{
+	uint16_t sum = 0;
+	int i;
+
+	for (i = 0; i < sizeof(struct exfat_entry); i++)
+		if (i != 2 && i != 3) /* skip checksum field itself */
+			sum = ((sum << 15) | (sum >> 1)) + ((const uint8_t*) entry)[i];
+	return sum;
+}
+
+uint16_t exfat_add_checksum(const void* entry, uint16_t sum)
+{
+	int i;
+
+	for (i = 0; i < sizeof(struct exfat_entry); i++)
+		sum = ((sum << 15) | (sum >> 1)) + ((const uint8_t*) entry)[i];
+	return sum;
+}
+
+le16_t exfat_calc_checksum(const struct exfat_entry_meta1* meta1,
+		const struct exfat_entry_meta2* meta2, const le16_t* name)
+{
+	uint16_t checksum;
+	const int name_entries = DIV_ROUND_UP(utf16_length(name), EXFAT_ENAME_MAX);
+	int i;
+
+	checksum = exfat_start_checksum(meta1);
+	checksum = exfat_add_checksum(meta2, checksum);
+	for (i = 0; i < name_entries; i++)
+	{
+		struct exfat_entry_name name_entry = {EXFAT_ENTRY_FILE_NAME, 0};
+		memcpy(name_entry.name, name + i * EXFAT_ENAME_MAX,
+				MIN(EXFAT_ENAME_MAX, EXFAT_NAME_MAX - i * EXFAT_ENAME_MAX) *
+				sizeof(le16_t));
+		checksum = exfat_add_checksum(&name_entry, checksum);
+	}
+	return cpu_to_le16(checksum);
+}
+
+uint32_t exfat_vbr_start_checksum(const void* sector, size_t size)
+{
+	size_t i;
+	uint32_t sum = 0;
+
+	for (i = 0; i < size; i++)
+		/* skip volume_state and allocated_percent fields */
+		if (i != 0x6a && i != 0x6b && i != 0x70)
+			sum = ((sum << 31) | (sum >> 1)) + ((const uint8_t*) sector)[i];
+	return sum;
+}
+
+uint32_t exfat_vbr_add_checksum(const void* sector, size_t size, uint32_t sum)
+{
+	size_t i;
+
+	for (i = 0; i < size; i++)
+		sum = ((sum << 31) | (sum >> 1)) + ((const uint8_t*) sector)[i];
+	return sum;
+}
+
+le16_t exfat_calc_name_hash(const struct exfat* ef, const le16_t* name)
+{
+	size_t i;
+	size_t length = utf16_length(name);
+	uint16_t hash = 0;
+
+	for (i = 0; i < length; i++)
+	{
+		uint16_t c = le16_to_cpu(name[i]);
+
+		/* convert to upper case */
+		if (c < ef->upcase_chars)
+			c = le16_to_cpu(ef->upcase[c]);
+
+		hash = ((hash << 15) | (hash >> 1)) + (c & 0xff);
+		hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
+	}
+	return cpu_to_le16(hash);
+}
+
+void exfat_humanize_bytes(uint64_t value, struct exfat_human_bytes* hb)
+{
+	size_t i;
+	/* 16 EB (minus 1 byte) is the largest size that can be represented by
+	   uint64_t */
+	const char* units[] = {"bytes", "KB", "MB", "GB", "TB", "PB", "EB"};
+	uint64_t divisor = 1;
+	uint64_t temp = 0;
+
+	for (i = 0; ; i++, divisor *= 1024)
+	{
+		temp = (value + divisor / 2) / divisor;
+
+		if (temp == 0)
+			break;
+		if (temp / 1024 * 1024 == temp)
+			continue;
+		if (temp < 10240)
+			break;
+	}
+	hb->value = temp;
+	hb->unit = units[i];
+}
+
+void exfat_print_info(const struct exfat_super_block* sb,
+		uint32_t free_clusters)
+{
+	struct exfat_human_bytes hb;
+	off64_t total_space = le64_to_cpu(sb->sector_count) * SECTOR_SIZE(*sb);
+	off64_t avail_space = (off64_t) free_clusters * CLUSTER_SIZE(*sb);
+
+	printf("File system version           %hhu.%hhu\n",
+			sb->version.major, sb->version.minor);
+	exfat_humanize_bytes(SECTOR_SIZE(*sb), &hb);
+	printf("Sector size          %10"PRIu64" %s\n", hb.value, hb.unit);
+	exfat_humanize_bytes(CLUSTER_SIZE(*sb), &hb);
+	printf("Cluster size         %10"PRIu64" %s\n", hb.value, hb.unit);
+	exfat_humanize_bytes(total_space, &hb);
+	printf("Volume size          %10"PRIu64" %s\n", hb.value, hb.unit);
+	exfat_humanize_bytes(total_space - avail_space, &hb);
+	printf("Used space           %10"PRIu64" %s\n", hb.value, hb.unit);
+	exfat_humanize_bytes(avail_space, &hb);
+	printf("Available space      %10"PRIu64" %s\n", hb.value, hb.unit);
+}
diff --git a/external/exfat-fuse/libexfat/version.h b/external/exfat-fuse/libexfat/version.h
new file mode 100755
index 0000000000..adabaadc49
--- /dev/null
+++ b/external/exfat-fuse/libexfat/version.h
@@ -0,0 +1,30 @@
+/*
+	version.h (12.06.10)
+	Version constants.
+
+	Free exFAT implementation.
+	Copyright (C) 2010-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#ifndef VERSION_H_INCLUDED
+#define VERSION_H_INCLUDED
+
+#define EXFAT_VERSION_MAJOR 1
+#define EXFAT_VERSION_MINOR 1
+#define EXFAT_VERSION_PATCH 1
+
+#endif /* ifndef VERSION_H_INCLUDED */
diff --git a/external/exfat-fuse/main.c b/external/exfat-fuse/main.c
new file mode 100755
index 0000000000..bc0b00e9e2
--- /dev/null
+++ b/external/exfat-fuse/main.c
@@ -0,0 +1,43 @@
+/*
+	exFAT file system multi-call binary
+
+	Copyright (C) 2011-2013  Andrew Nayenko
+	Copyright (C) 2013 The CyanogenMod Project
+
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <stdio.h>
+#include <string.h>
+
+extern int mkexfatfs_main(int argc, char* argv[]);
+extern int exfatfsck_main(int argc, char* argv[]);
+extern int mount_exfat_main(int argc, char* argv[]);
+extern int dumpexfat_main(int argc, char* argv[]);
+extern int exfatlabel_main(int argc, char* argv[]);
+
+int main(int argc, char* argv[])
+{
+	printf("exFAT multi-call binary, mod/build 1.0.4 by Lurker\n");
+	fflush(stdout);
+    if (strstr(argv[0], "mkfs.exfat") != NULL || strstr(argv[0], "mkexfatfs") != NULL)
+        return mkexfatfs_main(argc, argv);
+    if (strstr(argv[0], "fsck.exfat") != NULL || strstr(argv[0], "exfatfsck") != NULL)
+        return exfatfsck_main(argc, argv);
+    if (strstr(argv[0], "dumpexfat"))
+        return dumpexfat_main(argc, argv);
+    if (strstr(argv[0], "exfatlabel"))
+        return exfatlabel_main(argc, argv);
+    return mount_exfat_main(argc, argv);
+}
diff --git a/external/exfat-fuse/mkfs/Android.mk b/external/exfat-fuse/mkfs/Android.mk
new file mode 100755
index 0000000000..aacbae44ee
--- /dev/null
+++ b/external/exfat-fuse/mkfs/Android.mk
@@ -0,0 +1,9 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_MODULE    := libexfat_mkfs
+LOCAL_SRC_FILES := cbm.c fat.c main.c mkexfat.c rootdir.c uct.c uctc.c vbr.c
+
+LOCAL_CFLAGS := $(EXFAT_CFLAGS)
+LOCAL_C_INCLUDES += $(LOCAL_PATH)
+include $(BUILD_STATIC_LIBRARY)
diff --git a/external/exfat-fuse/mkfs/cbm.c b/external/exfat-fuse/mkfs/cbm.c
new file mode 100755
index 0000000000..62742e1cf0
--- /dev/null
+++ b/external/exfat-fuse/mkfs/cbm.c
@@ -0,0 +1,79 @@
+/*
+	cbm.c (09.11.10)
+	Clusters Bitmap creation code.
+
+	Free exFAT implementation.
+	Copyright (C) 2011-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include <limits.h>
+#include <string.h>
+#include "cbm.h"
+#include "fat.h"
+#include "uct.h"
+#include "rootdir.h"
+
+static off64_t cbm_alignment(void)
+{
+	return get_cluster_size();
+}
+
+static off64_t cbm_size(void)
+{
+	return DIV_ROUND_UP(
+			(get_volume_size() - get_position(&cbm)) / get_cluster_size(),
+			CHAR_BIT);
+}
+
+static int cbm_write(struct exfat_dev* dev)
+{
+	uint32_t allocated_clusters =
+			DIV_ROUND_UP(cbm.get_size(), get_cluster_size()) +
+			DIV_ROUND_UP(uct.get_size(), get_cluster_size()) +
+			DIV_ROUND_UP(rootdir.get_size(), get_cluster_size());
+	size_t bitmap_size = ROUND_UP(allocated_clusters, CHAR_BIT);
+	bitmap_t* bitmap = malloc(BMAP_SIZE(bitmap_size));
+	size_t i;
+
+	if (bitmap == NULL)
+	{
+		exfat_error("failed to allocate bitmap of %zu bytes",
+				BMAP_SIZE(bitmap_size));
+		return 1;
+	}
+	memset(bitmap, 0, BMAP_SIZE(bitmap_size));
+
+	for (i = 0; i < bitmap_size; i++)
+		if (i < allocated_clusters)
+			BMAP_SET(bitmap, i);
+	if (exfat_write(dev, bitmap, bitmap_size / CHAR_BIT) < 0)
+	{
+		free(bitmap);
+		exfat_error("failed to write bitmap of %zu bytes",
+				bitmap_size / CHAR_BIT);
+		return 1;
+	}
+	free(bitmap);
+	return 0;
+}
+
+const struct fs_object cbm =
+{
+	.get_alignment = cbm_alignment,
+	.get_size = cbm_size,
+	.write = cbm_write,
+};
diff --git a/external/exfat-fuse/mkfs/cbm.h b/external/exfat-fuse/mkfs/cbm.h
new file mode 100755
index 0000000000..f959124de3
--- /dev/null
+++ b/external/exfat-fuse/mkfs/cbm.h
@@ -0,0 +1,30 @@
+/*
+	cbm.h (09.11.10)
+	Clusters Bitmap creation code.
+
+	Free exFAT implementation.
+	Copyright (C) 2011-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#ifndef MKFS_CBM_H_INCLUDED
+#define MKFS_CBM_H_INCLUDED
+
+#include "mkexfat.h"
+
+extern const struct fs_object cbm;
+
+#endif /* ifndef MKFS_CBM_H_INCLUDED */
diff --git a/external/exfat-fuse/mkfs/fat.c b/external/exfat-fuse/mkfs/fat.c
new file mode 100755
index 0000000000..25d37a2e84
--- /dev/null
+++ b/external/exfat-fuse/mkfs/fat.c
@@ -0,0 +1,88 @@
+/*
+	fat.c (09.11.10)
+	File Allocation Table creation code.
+
+	Free exFAT implementation.
+	Copyright (C) 2011-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include <unistd.h>
+#include "fat.h"
+#include "cbm.h"
+#include "uct.h"
+#include "rootdir.h"
+
+static off64_t fat_alignment(void)
+{
+	return (off64_t) 128 * get_sector_size();
+}
+
+static off64_t fat_size(void)
+{
+	return get_volume_size() / get_cluster_size() * sizeof(cluster_t);
+}
+
+static cluster_t fat_write_entry(struct exfat_dev* dev, cluster_t cluster,
+		cluster_t value)
+{
+	le32_t fat_entry = cpu_to_le32(value);
+	if (exfat_write(dev, &fat_entry, sizeof(fat_entry)) < 0)
+	{
+		exfat_error("failed to write FAT entry 0x%x", value);
+		return 0;
+	}
+	return cluster + 1;
+}
+
+static cluster_t fat_write_entries(struct exfat_dev* dev, cluster_t cluster,
+		uint64_t length)
+{
+	cluster_t end = cluster + DIV_ROUND_UP(length, get_cluster_size());
+
+	while (cluster < end - 1)
+	{
+		cluster = fat_write_entry(dev, cluster, cluster + 1);
+		if (cluster == 0)
+			return 0;
+	}
+	return fat_write_entry(dev, cluster, EXFAT_CLUSTER_END);
+}
+
+static int fat_write(struct exfat_dev* dev)
+{
+	cluster_t c = 0;
+
+	if (!(c = fat_write_entry(dev, c, 0xfffffff8))) /* media type */
+		return 1;
+	if (!(c = fat_write_entry(dev, c, 0xffffffff))) /* some weird constant */
+		return 1;
+	if (!(c = fat_write_entries(dev, c, cbm.get_size())))
+		return 1;
+	if (!(c = fat_write_entries(dev, c, uct.get_size())))
+		return 1;
+	if (!(c = fat_write_entries(dev, c, rootdir.get_size())))
+		return 1;
+
+	return 0;
+}
+
+const struct fs_object fat =
+{
+	.get_alignment = fat_alignment,
+	.get_size = fat_size,
+	.write = fat_write,
+};
diff --git a/external/exfat-fuse/mkfs/fat.h b/external/exfat-fuse/mkfs/fat.h
new file mode 100755
index 0000000000..bd30fe3005
--- /dev/null
+++ b/external/exfat-fuse/mkfs/fat.h
@@ -0,0 +1,30 @@
+/*
+	fat.h (09.11.10)
+	File Allocation Table creation code.
+
+	Free exFAT implementation.
+	Copyright (C) 2011-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#ifndef MKFS_FAT_H_INCLUDED
+#define MKFS_FAT_H_INCLUDED
+
+#include "mkexfat.h"
+
+extern const struct fs_object fat;
+
+#endif /* ifndef MKFS_FAT_H_INCLUDED */
diff --git a/external/exfat-fuse/mkfs/main.c b/external/exfat-fuse/mkfs/main.c
new file mode 100755
index 0000000000..3d9230760d
--- /dev/null
+++ b/external/exfat-fuse/mkfs/main.c
@@ -0,0 +1,256 @@
+/*
+	main.c (15.08.10)
+	Creates exFAT file system.
+
+	Free exFAT implementation.
+	Copyright (C) 2011-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include <sys/types.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+#include <limits.h>
+#include <exfat.h>
+#include "mkexfat.h"
+#include "vbr.h"
+#include "fat.h"
+#include "cbm.h"
+#include "uct.h"
+#include "rootdir.h"
+
+const struct fs_object* objects[] =
+{
+	&vbr,
+	&vbr,
+	&fat,
+	/* clusters heap */
+	&cbm,
+	&uct,
+	&rootdir,
+	NULL,
+};
+
+static struct
+{
+	int sector_bits;
+	int spc_bits;
+	off64_t volume_size;
+	le16_t volume_label[EXFAT_ENAME_MAX + 1];
+	uint32_t volume_serial;
+	uint64_t first_sector;
+}
+param;
+
+int get_sector_bits(void)
+{
+	return param.sector_bits;
+}
+
+int get_spc_bits(void)
+{
+	return param.spc_bits;
+}
+
+off64_t get_volume_size(void)
+{
+	return param.volume_size;
+}
+
+const le16_t* get_volume_label(void)
+{
+	return param.volume_label;
+}
+
+uint32_t get_volume_serial(void)
+{
+	return param.volume_serial;
+}
+
+uint64_t get_first_sector(void)
+{
+	return param.first_sector;
+}
+
+int get_sector_size(void)
+{
+	return 1 << get_sector_bits();
+}
+
+int get_cluster_size(void)
+{
+	return get_sector_size() << get_spc_bits();
+}
+
+static int setup_spc_bits(int sector_bits, int user_defined, off64_t volume_size)
+{
+	int i;
+
+	if (user_defined != -1)
+	{
+		off64_t cluster_size = 1 << sector_bits << user_defined;
+		if (volume_size / cluster_size > EXFAT_LAST_DATA_CLUSTER)
+		{
+			struct exfat_human_bytes chb, vhb;
+
+			exfat_humanize_bytes(cluster_size, &chb);
+			exfat_humanize_bytes(volume_size, &vhb);
+			exfat_error("cluster size %"PRIu64" %s is too small for "
+					"%"PRIu64" %s volume, try -s %d",
+					chb.value, chb.unit,
+					vhb.value, vhb.unit,
+					1 << setup_spc_bits(sector_bits, -1, volume_size));
+			return -1;
+		}
+		return user_defined;
+	}
+
+	if (volume_size < 256ull * 1024 * 1024)
+		return MAX(0, 12 - sector_bits);	/* 4 KB */
+	if (volume_size < 32ull * 1024 * 1024 * 1024)
+		return MAX(0, 15 - sector_bits);	/* 32 KB */
+
+	for (i = 17; ; i++)						/* 128 KB or more */
+		if (DIV_ROUND_UP(volume_size, 1 << i) <= EXFAT_LAST_DATA_CLUSTER)
+			return MAX(0, i - sector_bits);
+}
+
+static int setup_volume_label(le16_t label[EXFAT_ENAME_MAX + 1], const char* s)
+{
+	memset(label, 0, (EXFAT_ENAME_MAX + 1) * sizeof(le16_t));
+	if (s == NULL)
+		return 0;
+	return utf8_to_utf16(label, s, EXFAT_ENAME_MAX, strlen(s));
+}
+
+static uint32_t setup_volume_serial(uint32_t user_defined)
+{
+	struct timeval now;
+
+	if (user_defined != 0)
+		return user_defined;
+
+	if (gettimeofday(&now, NULL) != 0)
+	{
+		exfat_error("failed to form volume id");
+		return 0;
+	}
+	return (now.tv_sec << 20) | now.tv_usec;
+}
+
+static int setup(struct exfat_dev* dev, int sector_bits, int spc_bits,
+		const char* volume_label, uint32_t volume_serial,
+		uint64_t first_sector)
+{
+	param.sector_bits = sector_bits;
+	param.first_sector = first_sector;
+	param.volume_size = exfat_get_size(dev);
+
+	param.spc_bits = setup_spc_bits(sector_bits, spc_bits, param.volume_size);
+	if (param.spc_bits == -1)
+		return 1;
+
+	if (setup_volume_label(param.volume_label, volume_label) != 0)
+		return 1;
+
+	param.volume_serial = setup_volume_serial(volume_serial);
+	if (param.volume_serial == 0)
+		return 1;
+
+	return mkfs(dev, param.volume_size);
+}
+
+static int logarithm2(int n)
+{
+	int i;
+
+	for (i = 0; i < sizeof(int) * CHAR_BIT - 1; i++)
+		if ((1 << i) == n)
+			return i;
+	return -1;
+}
+
+static void usage(const char* prog)
+{
+	fprintf(stderr, "Usage: %s [-i volume-id] [-n label] "
+			"[-p partition-first-sector] "
+			"[-s sectors-per-cluster] [-V] <device>\n", prog);
+	exit(1);
+}
+
+int mkexfatfs_main(int argc, char* argv[])
+{
+	const char* spec = NULL;
+	int opt;
+	int spc_bits = -1;
+	const char* volume_label = NULL;
+	uint32_t volume_serial = 0;
+	uint64_t first_sector = 0;
+	struct exfat_dev* dev;
+
+	printf("mkexfatfs %u.%u.%u\n",
+			EXFAT_VERSION_MAJOR, EXFAT_VERSION_MINOR, EXFAT_VERSION_PATCH);
+
+	while ((opt = getopt(argc, argv, "i:n:p:s:V")) != -1)
+	{
+		switch (opt)
+		{
+		case 'i':
+			volume_serial = strtol(optarg, NULL, 16);
+			break;
+		case 'n':
+			volume_label = optarg;
+			break;
+		case 'p':
+			first_sector = strtoll(optarg, NULL, 10);
+			break;
+		case 's':
+			spc_bits = logarithm2(atoi(optarg));
+			if (spc_bits < 0)
+			{
+				exfat_error("invalid option value: '%s'", optarg);
+				return 1;
+			}
+			break;
+		case 'V':
+			puts("Copyright (C) 2011-2014  Andrew Nayenko");
+			return 0;
+		default:
+			usage(argv[0]);
+			break;
+		}
+	}
+	if (argc - optind != 1)
+		usage(argv[0]);
+	spec = argv[optind];
+
+	dev = exfat_open(spec, EXFAT_MODE_RW);
+	if (dev == NULL)
+		return 1;
+	if (setup(dev, 9, spc_bits, volume_label, volume_serial,
+				first_sector) != 0)
+	{
+		exfat_close(dev);
+		return 1;
+	}
+	if (exfat_close(dev) != 0)
+		return 1;
+	printf("File system created successfully.\n");
+	return 0;
+}
diff --git a/external/exfat-fuse/mkfs/mkexfat.c b/external/exfat-fuse/mkfs/mkexfat.c
new file mode 100755
index 0000000000..df6391aabd
--- /dev/null
+++ b/external/exfat-fuse/mkfs/mkexfat.c
@@ -0,0 +1,162 @@
+/*
+	mkexfat.c (22.04.12)
+	FS creation engine.
+
+	Free exFAT implementation.
+	Copyright (C) 2011-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include <sys/types.h>
+#include <unistd.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+#include "mkexfat.h"
+
+static int check_size(off64_t volume_size)
+{
+	const struct fs_object** pp;
+	off64_t position = 0;
+
+	for (pp = objects; *pp; pp++)
+	{
+		position = ROUND_UP(position, (*pp)->get_alignment());
+		position += (*pp)->get_size();
+	}
+
+	if (position > volume_size)
+	{
+		struct exfat_human_bytes vhb;
+
+		exfat_humanize_bytes(volume_size, &vhb);
+		exfat_error("too small device (%"PRIu64" %s)", vhb.value, vhb.unit);
+		return 1;
+	}
+
+	return 0;
+
+}
+
+static int erase_object(struct exfat_dev* dev, const void* block,
+		size_t block_size, off64_t start, off64_t size)
+{
+	const off64_t block_count = DIV_ROUND_UP(size, block_size);
+	off64_t i;
+
+	if (exfat_seek(dev, start, SEEK_SET) == (off64_t) -1)
+	{
+		exfat_error("seek to 0x%"PRIx64" failed", start);
+		return 1;
+	}
+	for (i = 0; i < size; i += block_size)
+	{
+		if (exfat_write(dev, block, MIN(size - i, block_size)) < 0)
+		{
+			exfat_error("failed to erase block %"PRIu64"/%"PRIu64
+					" at 0x%"PRIx64, i + 1, block_count, start);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+static int erase(struct exfat_dev* dev)
+{
+	const struct fs_object** pp;
+	off64_t position = 0;
+	const size_t block_size = 1024 * 1024;
+	void* block = malloc(block_size);
+
+	if (block == NULL)
+	{
+		exfat_error("failed to allocate erase block of %zu bytes", block_size);
+		return 1;
+	}
+	memset(block, 0, block_size);
+
+	for (pp = objects; *pp; pp++)
+	{
+		position = ROUND_UP(position, (*pp)->get_alignment());
+		if (erase_object(dev, block, block_size, position,
+				(*pp)->get_size()) != 0)
+		{
+			free(block);
+			return 1;
+		}
+		position += (*pp)->get_size();
+	}
+
+	free(block);
+	return 0;
+}
+
+static int create(struct exfat_dev* dev)
+{
+	const struct fs_object** pp;
+	off64_t position = 0;
+
+	for (pp = objects; *pp; pp++)
+	{
+		position = ROUND_UP(position, (*pp)->get_alignment());
+		if (exfat_seek(dev, position, SEEK_SET) == (off64_t) -1)
+		{
+			exfat_error("seek to 0x%"PRIx64" failed", position);
+			return 1;
+		}
+		if ((*pp)->write(dev) != 0)
+			return 1;
+		position += (*pp)->get_size();
+	}
+	return 0;
+}
+
+int mkfs(struct exfat_dev* dev, off64_t volume_size)
+{
+	if (check_size(volume_size) != 0)
+		return 1;
+
+	fputs("Creating... ", stdout);
+	fflush(stdout);
+	if (erase(dev) != 0)
+		return 1;
+	if (create(dev) != 0)
+		return 1;
+	puts("done.");
+
+	fputs("Flushing... ", stdout);
+	fflush(stdout);
+	if (exfat_fsync(dev) != 0)
+		return 1;
+	puts("done.");
+
+	return 0;
+}
+
+off64_t get_position(const struct fs_object* object)
+{
+	const struct fs_object** pp;
+	off64_t position = 0;
+
+	for (pp = objects; *pp; pp++)
+	{
+		position = ROUND_UP(position, (*pp)->get_alignment());
+		if (*pp == object)
+			return position;
+		position += (*pp)->get_size();
+	}
+	exfat_bug("unknown object");
+}
diff --git a/external/exfat-fuse/mkfs/mkexfat.h b/external/exfat-fuse/mkfs/mkexfat.h
new file mode 100755
index 0000000000..a9e49488fe
--- /dev/null
+++ b/external/exfat-fuse/mkfs/mkexfat.h
@@ -0,0 +1,49 @@
+/*
+	mkexfat.h (09.11.10)
+	FS creation engine.
+
+	Free exFAT implementation.
+	Copyright (C) 2011-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#ifndef MKFS_MKEXFAT_H_INCLUDED
+#define MKFS_MKEXFAT_H_INCLUDED
+
+#include <exfat.h>
+
+struct fs_object
+{
+	off64_t (*get_alignment)(void);
+	off64_t (*get_size)(void);
+	int (*write)(struct exfat_dev* dev);
+};
+
+extern const struct fs_object* objects[];
+
+int get_sector_bits(void);
+int get_spc_bits(void);
+off64_t get_volume_size(void);
+const le16_t* get_volume_label(void);
+uint32_t get_volume_serial(void);
+uint64_t get_first_sector(void);
+int get_sector_size(void);
+int get_cluster_size(void);
+
+int mkfs(struct exfat_dev* dev, off64_t volume_size);
+off64_t get_position(const struct fs_object* object);
+
+#endif /* ifndef MKFS_MKEXFAT_H_INCLUDED */
diff --git a/external/exfat-fuse/mkfs/mkexfatfs.8 b/external/exfat-fuse/mkfs/mkexfatfs.8
new file mode 100755
index 0000000000..8f5e53bfc1
--- /dev/null
+++ b/external/exfat-fuse/mkfs/mkexfatfs.8
@@ -0,0 +1,71 @@
+.\" Copyright (C) 2011-2014  Andrew Nayenko
+.\"
+.TH MKEXFATFS 8 "January 2011"
+.SH NAME
+.B mkexfatfs
+\- create an exFAT file system
+.SH SYNOPSIS
+.B mkexfatfs
+[
+.B \-i
+.I volume-id
+]
+[
+.B \-n
+.I volume-name
+]
+[
+.B \-p
+.I partition-first-sector
+]
+[
+.B \-s
+.I sectors-per-cluster
+]
+[
+.B \-V
+]
+.I device
+
+.SH DESCRIPTION
+.B mkexfatfs
+creates an exFAT file system on a block device.
+.I device
+is a special file corresponding to the partition on the device. Note that if
+this is an MBR partition then the file system type should be set to 0x07
+(NTFS/exFAT) otherwise other operating systems may refuse to mount the
+file system.
+
+.SH OPTIONS
+Command line options available:
+.TP
+.BI \-i " volume-id"
+A 32-bit hexadecimal number. By default a value based on current time is set.
+.TP
+.BI \-n " volume-name"
+Volume name (label), up to 15 characters. By default no label is set.
+.TP
+.BI \-p " partition-first-sector"
+First sector of the partition starting from the beginning of the whole disk.
+exFAT super block has a field for this value but in fact it's optional and
+does not affect anything. Default is 0.
+.TP
+.BI \-s " sectors-per-cluster"
+Number of physical sectors per cluster (cluster is an allocation unit in
+exFAT). Must be a power of 2, i.e. 1, 2, 4, 8, etc. Cluster size can not
+exceed 32 MB. Default cluster sizes are:
+4 KB if volume size is less than 256 MB,
+32 KB if volume size is from 256 MB to 32 GB,
+128 KB if volume size is 32 GB or larger.
+.TP
+.BI \-V
+Print version and copyright.
+
+.SH EXIT CODES
+Zero is returned on successful creation. Any other code means an error.
+
+.SH AUTHOR
+Andrew Nayenko
+
+.SH SEE ALSO
+.BR mkfs (8), fdisk (8)
diff --git a/external/exfat-fuse/mkfs/rootdir.c b/external/exfat-fuse/mkfs/rootdir.c
new file mode 100755
index 0000000000..f453131f60
--- /dev/null
+++ b/external/exfat-fuse/mkfs/rootdir.c
@@ -0,0 +1,102 @@
+/*
+	rootdir.c (09.11.10)
+	Root directory creation code.
+
+	Free exFAT implementation.
+	Copyright (C) 2011-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include <string.h>
+#include "rootdir.h"
+#include "uct.h"
+#include "cbm.h"
+#include "uctc.h"
+
+static off64_t rootdir_alignment(void)
+{
+	return get_cluster_size();
+}
+
+static off64_t rootdir_size(void)
+{
+	return get_cluster_size();
+}
+
+static void init_label_entry(struct exfat_entry_label* label_entry)
+{
+	memset(label_entry, 0, sizeof(struct exfat_entry_label));
+	label_entry->type = EXFAT_ENTRY_LABEL ^ EXFAT_ENTRY_VALID;
+
+	if (utf16_length(get_volume_label()) == 0)
+		return;
+
+	memcpy(label_entry->name, get_volume_label(),
+			EXFAT_ENAME_MAX * sizeof(le16_t));
+	label_entry->length = utf16_length(get_volume_label());
+	label_entry->type |= EXFAT_ENTRY_VALID;
+}
+
+static void init_bitmap_entry(struct exfat_entry_bitmap* bitmap_entry)
+{
+	memset(bitmap_entry, 0, sizeof(struct exfat_entry_bitmap));
+	bitmap_entry->type = EXFAT_ENTRY_BITMAP;
+	bitmap_entry->start_cluster = cpu_to_le32(EXFAT_FIRST_DATA_CLUSTER);
+	bitmap_entry->size = cpu_to_le64(cbm.get_size());
+}
+
+static void init_upcase_entry(struct exfat_entry_upcase* upcase_entry)
+{
+	size_t i;
+	uint32_t sum = 0;
+
+	for (i = 0; i < sizeof(upcase_table); i++)
+		sum = ((sum << 31) | (sum >> 1)) + upcase_table[i];
+
+	memset(upcase_entry, 0, sizeof(struct exfat_entry_upcase));
+	upcase_entry->type = EXFAT_ENTRY_UPCASE;
+	upcase_entry->checksum = cpu_to_le32(sum);
+	upcase_entry->start_cluster = cpu_to_le32(
+			(get_position(&uct) - get_position(&cbm)) / get_cluster_size() +
+			EXFAT_FIRST_DATA_CLUSTER);
+	upcase_entry->size = cpu_to_le64(sizeof(upcase_table));
+}
+
+static int rootdir_write(struct exfat_dev* dev)
+{
+	struct exfat_entry_label label_entry;
+	struct exfat_entry_bitmap bitmap_entry;
+	struct exfat_entry_upcase upcase_entry;
+
+	init_label_entry(&label_entry);
+	init_bitmap_entry(&bitmap_entry);
+	init_upcase_entry(&upcase_entry);
+
+	if (exfat_write(dev, &label_entry, sizeof(struct exfat_entry)) < 0)
+		return 1;
+	if (exfat_write(dev, &bitmap_entry, sizeof(struct exfat_entry)) < 0)
+		return 1;
+	if (exfat_write(dev, &upcase_entry, sizeof(struct exfat_entry)) < 0)
+		return 1;
+	return 0;
+}
+
+const struct fs_object rootdir =
+{
+	.get_alignment = rootdir_alignment,
+	.get_size = rootdir_size,
+	.write = rootdir_write,
+};
diff --git a/external/exfat-fuse/mkfs/rootdir.h b/external/exfat-fuse/mkfs/rootdir.h
new file mode 100755
index 0000000000..ddf5f418fb
--- /dev/null
+++ b/external/exfat-fuse/mkfs/rootdir.h
@@ -0,0 +1,30 @@
+/*
+	rootdir.h (09.11.10)
+	Root directory creation code.
+
+	Free exFAT implementation.
+	Copyright (C) 2011-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#ifndef MKFS_ROOTDIR_H_INCLUDED
+#define MKFS_ROOTDIR_H_INCLUDED
+
+#include "mkexfat.h"
+
+extern const struct fs_object rootdir;
+
+#endif /* ifndef MKFS_ROOTDIR_H_INCLUDED */
diff --git a/external/exfat-fuse/mkfs/uct.c b/external/exfat-fuse/mkfs/uct.c
new file mode 100755
index 0000000000..9129403502
--- /dev/null
+++ b/external/exfat-fuse/mkfs/uct.c
@@ -0,0 +1,52 @@
+/*
+	uct.c (09.11.10)
+	Upper Case Table creation code.
+
+	Free exFAT implementation.
+	Copyright (C) 2011-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include "uct.h"
+#include "uctc.h"
+
+static off64_t uct_alignment(void)
+{
+	return get_cluster_size();
+}
+
+static off64_t uct_size(void)
+{
+	return sizeof(upcase_table);
+}
+
+static int uct_write(struct exfat_dev* dev)
+{
+	if (exfat_write(dev, upcase_table, sizeof(upcase_table)) < 0)
+	{
+		exfat_error("failed to write upcase table of %zu bytes",
+				sizeof(upcase_table));
+		return 1;
+	}
+	return 0;
+}
+
+const struct fs_object uct =
+{
+	.get_alignment = uct_alignment,
+	.get_size = uct_size,
+	.write = uct_write,
+};
diff --git a/external/exfat-fuse/mkfs/uct.h b/external/exfat-fuse/mkfs/uct.h
new file mode 100755
index 0000000000..6f276de47a
--- /dev/null
+++ b/external/exfat-fuse/mkfs/uct.h
@@ -0,0 +1,30 @@
+/*
+	uct.h (09.11.10)
+	Upper Case Table creation code.
+
+	Free exFAT implementation.
+	Copyright (C) 2011-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#ifndef MKFS_UCT_H_INCLUDED
+#define MKFS_UCT_H_INCLUDED
+
+#include "mkexfat.h"
+
+extern const struct fs_object uct;
+
+#endif /* ifndef MKFS_UCT_H_INCLUDED */
diff --git a/external/exfat-fuse/mkfs/uctc.c b/external/exfat-fuse/mkfs/uctc.c
new file mode 100755
index 0000000000..b5aa17d0fa
--- /dev/null
+++ b/external/exfat-fuse/mkfs/uctc.c
@@ -0,0 +1,757 @@
+/*
+	uctc.c (30.04.12)
+	Upper Case Table contents.
+
+	Free exFAT implementation.
+	Copyright (C) 2011-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include "uctc.h"
+
+uint8_t upcase_table[5836] =
+{
+	0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00,
+	0x04, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07, 0x00,
+	0x08, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x0b, 0x00,
+	0x0c, 0x00, 0x0d, 0x00, 0x0e, 0x00, 0x0f, 0x00,
+	0x10, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13, 0x00,
+	0x14, 0x00, 0x15, 0x00, 0x16, 0x00, 0x17, 0x00,
+	0x18, 0x00, 0x19, 0x00, 0x1a, 0x00, 0x1b, 0x00,
+	0x1c, 0x00, 0x1d, 0x00, 0x1e, 0x00, 0x1f, 0x00,
+	0x20, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x00,
+	0x24, 0x00, 0x25, 0x00, 0x26, 0x00, 0x27, 0x00,
+	0x28, 0x00, 0x29, 0x00, 0x2a, 0x00, 0x2b, 0x00,
+	0x2c, 0x00, 0x2d, 0x00, 0x2e, 0x00, 0x2f, 0x00,
+	0x30, 0x00, 0x31, 0x00, 0x32, 0x00, 0x33, 0x00,
+	0x34, 0x00, 0x35, 0x00, 0x36, 0x00, 0x37, 0x00,
+	0x38, 0x00, 0x39, 0x00, 0x3a, 0x00, 0x3b, 0x00,
+	0x3c, 0x00, 0x3d, 0x00, 0x3e, 0x00, 0x3f, 0x00,
+	0x40, 0x00, 0x41, 0x00, 0x42, 0x00, 0x43, 0x00,
+	0x44, 0x00, 0x45, 0x00, 0x46, 0x00, 0x47, 0x00,
+	0x48, 0x00, 0x49, 0x00, 0x4a, 0x00, 0x4b, 0x00,
+	0x4c, 0x00, 0x4d, 0x00, 0x4e, 0x00, 0x4f, 0x00,
+	0x50, 0x00, 0x51, 0x00, 0x52, 0x00, 0x53, 0x00,
+	0x54, 0x00, 0x55, 0x00, 0x56, 0x00, 0x57, 0x00,
+	0x58, 0x00, 0x59, 0x00, 0x5a, 0x00, 0x5b, 0x00,
+	0x5c, 0x00, 0x5d, 0x00, 0x5e, 0x00, 0x5f, 0x00,
+	0x60, 0x00, 0x41, 0x00, 0x42, 0x00, 0x43, 0x00,
+	0x44, 0x00, 0x45, 0x00, 0x46, 0x00, 0x47, 0x00,
+	0x48, 0x00, 0x49, 0x00, 0x4a, 0x00, 0x4b, 0x00,
+	0x4c, 0x00, 0x4d, 0x00, 0x4e, 0x00, 0x4f, 0x00,
+	0x50, 0x00, 0x51, 0x00, 0x52, 0x00, 0x53, 0x00,
+	0x54, 0x00, 0x55, 0x00, 0x56, 0x00, 0x57, 0x00,
+	0x58, 0x00, 0x59, 0x00, 0x5a, 0x00, 0x7b, 0x00,
+	0x7c, 0x00, 0x7d, 0x00, 0x7e, 0x00, 0x7f, 0x00,
+	0x80, 0x00, 0x81, 0x00, 0x82, 0x00, 0x83, 0x00,
+	0x84, 0x00, 0x85, 0x00, 0x86, 0x00, 0x87, 0x00,
+	0x88, 0x00, 0x89, 0x00, 0x8a, 0x00, 0x8b, 0x00,
+	0x8c, 0x00, 0x8d, 0x00, 0x8e, 0x00, 0x8f, 0x00,
+	0x90, 0x00, 0x91, 0x00, 0x92, 0x00, 0x93, 0x00,
+	0x94, 0x00, 0x95, 0x00, 0x96, 0x00, 0x97, 0x00,
+	0x98, 0x00, 0x99, 0x00, 0x9a, 0x00, 0x9b, 0x00,
+	0x9c, 0x00, 0x9d, 0x00, 0x9e, 0x00, 0x9f, 0x00,
+	0xa0, 0x00, 0xa1, 0x00, 0xa2, 0x00, 0xa3, 0x00,
+	0xa4, 0x00, 0xa5, 0x00, 0xa6, 0x00, 0xa7, 0x00,
+	0xa8, 0x00, 0xa9, 0x00, 0xaa, 0x00, 0xab, 0x00,
+	0xac, 0x00, 0xad, 0x00, 0xae, 0x00, 0xaf, 0x00,
+	0xb0, 0x00, 0xb1, 0x00, 0xb2, 0x00, 0xb3, 0x00,
+	0xb4, 0x00, 0xb5, 0x00, 0xb6, 0x00, 0xb7, 0x00,
+	0xb8, 0x00, 0xb9, 0x00, 0xba, 0x00, 0xbb, 0x00,
+	0xbc, 0x00, 0xbd, 0x00, 0xbe, 0x00, 0xbf, 0x00,
+	0xc0, 0x00, 0xc1, 0x00, 0xc2, 0x00, 0xc3, 0x00,
+	0xc4, 0x00, 0xc5, 0x00, 0xc6, 0x00, 0xc7, 0x00,
+	0xc8, 0x00, 0xc9, 0x00, 0xca, 0x00, 0xcb, 0x00,
+	0xcc, 0x00, 0xcd, 0x00, 0xce, 0x00, 0xcf, 0x00,
+	0xd0, 0x00, 0xd1, 0x00, 0xd2, 0x00, 0xd3, 0x00,
+	0xd4, 0x00, 0xd5, 0x00, 0xd6, 0x00, 0xd7, 0x00,
+	0xd8, 0x00, 0xd9, 0x00, 0xda, 0x00, 0xdb, 0x00,
+	0xdc, 0x00, 0xdd, 0x00, 0xde, 0x00, 0xdf, 0x00,
+	0xc0, 0x00, 0xc1, 0x00, 0xc2, 0x00, 0xc3, 0x00,
+	0xc4, 0x00, 0xc5, 0x00, 0xc6, 0x00, 0xc7, 0x00,
+	0xc8, 0x00, 0xc9, 0x00, 0xca, 0x00, 0xcb, 0x00,
+	0xcc, 0x00, 0xcd, 0x00, 0xce, 0x00, 0xcf, 0x00,
+	0xd0, 0x00, 0xd1, 0x00, 0xd2, 0x00, 0xd3, 0x00,
+	0xd4, 0x00, 0xd5, 0x00, 0xd6, 0x00, 0xf7, 0x00,
+	0xd8, 0x00, 0xd9, 0x00, 0xda, 0x00, 0xdb, 0x00,
+	0xdc, 0x00, 0xdd, 0x00, 0xde, 0x00, 0x78, 0x01,
+	0x00, 0x01, 0x00, 0x01, 0x02, 0x01, 0x02, 0x01,
+	0x04, 0x01, 0x04, 0x01, 0x06, 0x01, 0x06, 0x01,
+	0x08, 0x01, 0x08, 0x01, 0x0a, 0x01, 0x0a, 0x01,
+	0x0c, 0x01, 0x0c, 0x01, 0x0e, 0x01, 0x0e, 0x01,
+	0x10, 0x01, 0x10, 0x01, 0x12, 0x01, 0x12, 0x01,
+	0x14, 0x01, 0x14, 0x01, 0x16, 0x01, 0x16, 0x01,
+	0x18, 0x01, 0x18, 0x01, 0x1a, 0x01, 0x1a, 0x01,
+	0x1c, 0x01, 0x1c, 0x01, 0x1e, 0x01, 0x1e, 0x01,
+	0x20, 0x01, 0x20, 0x01, 0x22, 0x01, 0x22, 0x01,
+	0x24, 0x01, 0x24, 0x01, 0x26, 0x01, 0x26, 0x01,
+	0x28, 0x01, 0x28, 0x01, 0x2a, 0x01, 0x2a, 0x01,
+	0x2c, 0x01, 0x2c, 0x01, 0x2e, 0x01, 0x2e, 0x01,
+	0x30, 0x01, 0x31, 0x01, 0x32, 0x01, 0x32, 0x01,
+	0x34, 0x01, 0x34, 0x01, 0x36, 0x01, 0x36, 0x01,
+	0x38, 0x01, 0x39, 0x01, 0x39, 0x01, 0x3b, 0x01,
+	0x3b, 0x01, 0x3d, 0x01, 0x3d, 0x01, 0x3f, 0x01,
+	0x3f, 0x01, 0x41, 0x01, 0x41, 0x01, 0x43, 0x01,
+	0x43, 0x01, 0x45, 0x01, 0x45, 0x01, 0x47, 0x01,
+	0x47, 0x01, 0x49, 0x01, 0x4a, 0x01, 0x4a, 0x01,
+	0x4c, 0x01, 0x4c, 0x01, 0x4e, 0x01, 0x4e, 0x01,
+	0x50, 0x01, 0x50, 0x01, 0x52, 0x01, 0x52, 0x01,
+	0x54, 0x01, 0x54, 0x01, 0x56, 0x01, 0x56, 0x01,
+	0x58, 0x01, 0x58, 0x01, 0x5a, 0x01, 0x5a, 0x01,
+	0x5c, 0x01, 0x5c, 0x01, 0x5e, 0x01, 0x5e, 0x01,
+	0x60, 0x01, 0x60, 0x01, 0x62, 0x01, 0x62, 0x01,
+	0x64, 0x01, 0x64, 0x01, 0x66, 0x01, 0x66, 0x01,
+	0x68, 0x01, 0x68, 0x01, 0x6a, 0x01, 0x6a, 0x01,
+	0x6c, 0x01, 0x6c, 0x01, 0x6e, 0x01, 0x6e, 0x01,
+	0x70, 0x01, 0x70, 0x01, 0x72, 0x01, 0x72, 0x01,
+	0x74, 0x01, 0x74, 0x01, 0x76, 0x01, 0x76, 0x01,
+	0x78, 0x01, 0x79, 0x01, 0x79, 0x01, 0x7b, 0x01,
+	0x7b, 0x01, 0x7d, 0x01, 0x7d, 0x01, 0x7f, 0x01,
+	0x43, 0x02, 0x81, 0x01, 0x82, 0x01, 0x82, 0x01,
+	0x84, 0x01, 0x84, 0x01, 0x86, 0x01, 0x87, 0x01,
+	0x87, 0x01, 0x89, 0x01, 0x8a, 0x01, 0x8b, 0x01,
+	0x8b, 0x01, 0x8d, 0x01, 0x8e, 0x01, 0x8f, 0x01,
+	0x90, 0x01, 0x91, 0x01, 0x91, 0x01, 0x93, 0x01,
+	0x94, 0x01, 0xf6, 0x01, 0x96, 0x01, 0x97, 0x01,
+	0x98, 0x01, 0x98, 0x01, 0x3d, 0x02, 0x9b, 0x01,
+	0x9c, 0x01, 0x9d, 0x01, 0x20, 0x02, 0x9f, 0x01,
+	0xa0, 0x01, 0xa0, 0x01, 0xa2, 0x01, 0xa2, 0x01,
+	0xa4, 0x01, 0xa4, 0x01, 0xa6, 0x01, 0xa7, 0x01,
+	0xa7, 0x01, 0xa9, 0x01, 0xaa, 0x01, 0xab, 0x01,
+	0xac, 0x01, 0xac, 0x01, 0xae, 0x01, 0xaf, 0x01,
+	0xaf, 0x01, 0xb1, 0x01, 0xb2, 0x01, 0xb3, 0x01,
+	0xb3, 0x01, 0xb5, 0x01, 0xb5, 0x01, 0xb7, 0x01,
+	0xb8, 0x01, 0xb8, 0x01, 0xba, 0x01, 0xbb, 0x01,
+	0xbc, 0x01, 0xbc, 0x01, 0xbe, 0x01, 0xf7, 0x01,
+	0xc0, 0x01, 0xc1, 0x01, 0xc2, 0x01, 0xc3, 0x01,
+	0xc4, 0x01, 0xc5, 0x01, 0xc4, 0x01, 0xc7, 0x01,
+	0xc8, 0x01, 0xc7, 0x01, 0xca, 0x01, 0xcb, 0x01,
+	0xca, 0x01, 0xcd, 0x01, 0xcd, 0x01, 0xcf, 0x01,
+	0xcf, 0x01, 0xd1, 0x01, 0xd1, 0x01, 0xd3, 0x01,
+	0xd3, 0x01, 0xd5, 0x01, 0xd5, 0x01, 0xd7, 0x01,
+	0xd7, 0x01, 0xd9, 0x01, 0xd9, 0x01, 0xdb, 0x01,
+	0xdb, 0x01, 0x8e, 0x01, 0xde, 0x01, 0xde, 0x01,
+	0xe0, 0x01, 0xe0, 0x01, 0xe2, 0x01, 0xe2, 0x01,
+	0xe4, 0x01, 0xe4, 0x01, 0xe6, 0x01, 0xe6, 0x01,
+	0xe8, 0x01, 0xe8, 0x01, 0xea, 0x01, 0xea, 0x01,
+	0xec, 0x01, 0xec, 0x01, 0xee, 0x01, 0xee, 0x01,
+	0xf0, 0x01, 0xf1, 0x01, 0xf2, 0x01, 0xf1, 0x01,
+	0xf4, 0x01, 0xf4, 0x01, 0xf6, 0x01, 0xf7, 0x01,
+	0xf8, 0x01, 0xf8, 0x01, 0xfa, 0x01, 0xfa, 0x01,
+	0xfc, 0x01, 0xfc, 0x01, 0xfe, 0x01, 0xfe, 0x01,
+	0x00, 0x02, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02,
+	0x04, 0x02, 0x04, 0x02, 0x06, 0x02, 0x06, 0x02,
+	0x08, 0x02, 0x08, 0x02, 0x0a, 0x02, 0x0a, 0x02,
+	0x0c, 0x02, 0x0c, 0x02, 0x0e, 0x02, 0x0e, 0x02,
+	0x10, 0x02, 0x10, 0x02, 0x12, 0x02, 0x12, 0x02,
+	0x14, 0x02, 0x14, 0x02, 0x16, 0x02, 0x16, 0x02,
+	0x18, 0x02, 0x18, 0x02, 0x1a, 0x02, 0x1a, 0x02,
+	0x1c, 0x02, 0x1c, 0x02, 0x1e, 0x02, 0x1e, 0x02,
+	0x20, 0x02, 0x21, 0x02, 0x22, 0x02, 0x22, 0x02,
+	0x24, 0x02, 0x24, 0x02, 0x26, 0x02, 0x26, 0x02,
+	0x28, 0x02, 0x28, 0x02, 0x2a, 0x02, 0x2a, 0x02,
+	0x2c, 0x02, 0x2c, 0x02, 0x2e, 0x02, 0x2e, 0x02,
+	0x30, 0x02, 0x30, 0x02, 0x32, 0x02, 0x32, 0x02,
+	0x34, 0x02, 0x35, 0x02, 0x36, 0x02, 0x37, 0x02,
+	0x38, 0x02, 0x39, 0x02, 0x65, 0x2c, 0x3b, 0x02,
+	0x3b, 0x02, 0x3d, 0x02, 0x66, 0x2c, 0x3f, 0x02,
+	0x40, 0x02, 0x41, 0x02, 0x41, 0x02, 0x43, 0x02,
+	0x44, 0x02, 0x45, 0x02, 0x46, 0x02, 0x46, 0x02,
+	0x48, 0x02, 0x48, 0x02, 0x4a, 0x02, 0x4a, 0x02,
+	0x4c, 0x02, 0x4c, 0x02, 0x4e, 0x02, 0x4e, 0x02,
+	0x50, 0x02, 0x51, 0x02, 0x52, 0x02, 0x81, 0x01,
+	0x86, 0x01, 0x55, 0x02, 0x89, 0x01, 0x8a, 0x01,
+	0x58, 0x02, 0x8f, 0x01, 0x5a, 0x02, 0x90, 0x01,
+	0x5c, 0x02, 0x5d, 0x02, 0x5e, 0x02, 0x5f, 0x02,
+	0x93, 0x01, 0x61, 0x02, 0x62, 0x02, 0x94, 0x01,
+	0x64, 0x02, 0x65, 0x02, 0x66, 0x02, 0x67, 0x02,
+	0x97, 0x01, 0x96, 0x01, 0x6a, 0x02, 0x62, 0x2c,
+	0x6c, 0x02, 0x6d, 0x02, 0x6e, 0x02, 0x9c, 0x01,
+	0x70, 0x02, 0x71, 0x02, 0x9d, 0x01, 0x73, 0x02,
+	0x74, 0x02, 0x9f, 0x01, 0x76, 0x02, 0x77, 0x02,
+	0x78, 0x02, 0x79, 0x02, 0x7a, 0x02, 0x7b, 0x02,
+	0x7c, 0x02, 0x64, 0x2c, 0x7e, 0x02, 0x7f, 0x02,
+	0xa6, 0x01, 0x81, 0x02, 0x82, 0x02, 0xa9, 0x01,
+	0x84, 0x02, 0x85, 0x02, 0x86, 0x02, 0x87, 0x02,
+	0xae, 0x01, 0x44, 0x02, 0xb1, 0x01, 0xb2, 0x01,
+	0x45, 0x02, 0x8d, 0x02, 0x8e, 0x02, 0x8f, 0x02,
+	0x90, 0x02, 0x91, 0x02, 0xb7, 0x01, 0x93, 0x02,
+	0x94, 0x02, 0x95, 0x02, 0x96, 0x02, 0x97, 0x02,
+	0x98, 0x02, 0x99, 0x02, 0x9a, 0x02, 0x9b, 0x02,
+	0x9c, 0x02, 0x9d, 0x02, 0x9e, 0x02, 0x9f, 0x02,
+	0xa0, 0x02, 0xa1, 0x02, 0xa2, 0x02, 0xa3, 0x02,
+	0xa4, 0x02, 0xa5, 0x02, 0xa6, 0x02, 0xa7, 0x02,
+	0xa8, 0x02, 0xa9, 0x02, 0xaa, 0x02, 0xab, 0x02,
+	0xac, 0x02, 0xad, 0x02, 0xae, 0x02, 0xaf, 0x02,
+	0xb0, 0x02, 0xb1, 0x02, 0xb2, 0x02, 0xb3, 0x02,
+	0xb4, 0x02, 0xb5, 0x02, 0xb6, 0x02, 0xb7, 0x02,
+	0xb8, 0x02, 0xb9, 0x02, 0xba, 0x02, 0xbb, 0x02,
+	0xbc, 0x02, 0xbd, 0x02, 0xbe, 0x02, 0xbf, 0x02,
+	0xc0, 0x02, 0xc1, 0x02, 0xc2, 0x02, 0xc3, 0x02,
+	0xc4, 0x02, 0xc5, 0x02, 0xc6, 0x02, 0xc7, 0x02,
+	0xc8, 0x02, 0xc9, 0x02, 0xca, 0x02, 0xcb, 0x02,
+	0xcc, 0x02, 0xcd, 0x02, 0xce, 0x02, 0xcf, 0x02,
+	0xd0, 0x02, 0xd1, 0x02, 0xd2, 0x02, 0xd3, 0x02,
+	0xd4, 0x02, 0xd5, 0x02, 0xd6, 0x02, 0xd7, 0x02,
+	0xd8, 0x02, 0xd9, 0x02, 0xda, 0x02, 0xdb, 0x02,
+	0xdc, 0x02, 0xdd, 0x02, 0xde, 0x02, 0xdf, 0x02,
+	0xe0, 0x02, 0xe1, 0x02, 0xe2, 0x02, 0xe3, 0x02,
+	0xe4, 0x02, 0xe5, 0x02, 0xe6, 0x02, 0xe7, 0x02,
+	0xe8, 0x02, 0xe9, 0x02, 0xea, 0x02, 0xeb, 0x02,
+	0xec, 0x02, 0xed, 0x02, 0xee, 0x02, 0xef, 0x02,
+	0xf0, 0x02, 0xf1, 0x02, 0xf2, 0x02, 0xf3, 0x02,
+	0xf4, 0x02, 0xf5, 0x02, 0xf6, 0x02, 0xf7, 0x02,
+	0xf8, 0x02, 0xf9, 0x02, 0xfa, 0x02, 0xfb, 0x02,
+	0xfc, 0x02, 0xfd, 0x02, 0xfe, 0x02, 0xff, 0x02,
+	0x00, 0x03, 0x01, 0x03, 0x02, 0x03, 0x03, 0x03,
+	0x04, 0x03, 0x05, 0x03, 0x06, 0x03, 0x07, 0x03,
+	0x08, 0x03, 0x09, 0x03, 0x0a, 0x03, 0x0b, 0x03,
+	0x0c, 0x03, 0x0d, 0x03, 0x0e, 0x03, 0x0f, 0x03,
+	0x10, 0x03, 0x11, 0x03, 0x12, 0x03, 0x13, 0x03,
+	0x14, 0x03, 0x15, 0x03, 0x16, 0x03, 0x17, 0x03,
+	0x18, 0x03, 0x19, 0x03, 0x1a, 0x03, 0x1b, 0x03,
+	0x1c, 0x03, 0x1d, 0x03, 0x1e, 0x03, 0x1f, 0x03,
+	0x20, 0x03, 0x21, 0x03, 0x22, 0x03, 0x23, 0x03,
+	0x24, 0x03, 0x25, 0x03, 0x26, 0x03, 0x27, 0x03,
+	0x28, 0x03, 0x29, 0x03, 0x2a, 0x03, 0x2b, 0x03,
+	0x2c, 0x03, 0x2d, 0x03, 0x2e, 0x03, 0x2f, 0x03,
+	0x30, 0x03, 0x31, 0x03, 0x32, 0x03, 0x33, 0x03,
+	0x34, 0x03, 0x35, 0x03, 0x36, 0x03, 0x37, 0x03,
+	0x38, 0x03, 0x39, 0x03, 0x3a, 0x03, 0x3b, 0x03,
+	0x3c, 0x03, 0x3d, 0x03, 0x3e, 0x03, 0x3f, 0x03,
+	0x40, 0x03, 0x41, 0x03, 0x42, 0x03, 0x43, 0x03,
+	0x44, 0x03, 0x45, 0x03, 0x46, 0x03, 0x47, 0x03,
+	0x48, 0x03, 0x49, 0x03, 0x4a, 0x03, 0x4b, 0x03,
+	0x4c, 0x03, 0x4d, 0x03, 0x4e, 0x03, 0x4f, 0x03,
+	0x50, 0x03, 0x51, 0x03, 0x52, 0x03, 0x53, 0x03,
+	0x54, 0x03, 0x55, 0x03, 0x56, 0x03, 0x57, 0x03,
+	0x58, 0x03, 0x59, 0x03, 0x5a, 0x03, 0x5b, 0x03,
+	0x5c, 0x03, 0x5d, 0x03, 0x5e, 0x03, 0x5f, 0x03,
+	0x60, 0x03, 0x61, 0x03, 0x62, 0x03, 0x63, 0x03,
+	0x64, 0x03, 0x65, 0x03, 0x66, 0x03, 0x67, 0x03,
+	0x68, 0x03, 0x69, 0x03, 0x6a, 0x03, 0x6b, 0x03,
+	0x6c, 0x03, 0x6d, 0x03, 0x6e, 0x03, 0x6f, 0x03,
+	0x70, 0x03, 0x71, 0x03, 0x72, 0x03, 0x73, 0x03,
+	0x74, 0x03, 0x75, 0x03, 0x76, 0x03, 0x77, 0x03,
+	0x78, 0x03, 0x79, 0x03, 0x7a, 0x03, 0xfd, 0x03,
+	0xfe, 0x03, 0xff, 0x03, 0x7e, 0x03, 0x7f, 0x03,
+	0x80, 0x03, 0x81, 0x03, 0x82, 0x03, 0x83, 0x03,
+	0x84, 0x03, 0x85, 0x03, 0x86, 0x03, 0x87, 0x03,
+	0x88, 0x03, 0x89, 0x03, 0x8a, 0x03, 0x8b, 0x03,
+	0x8c, 0x03, 0x8d, 0x03, 0x8e, 0x03, 0x8f, 0x03,
+	0x90, 0x03, 0x91, 0x03, 0x92, 0x03, 0x93, 0x03,
+	0x94, 0x03, 0x95, 0x03, 0x96, 0x03, 0x97, 0x03,
+	0x98, 0x03, 0x99, 0x03, 0x9a, 0x03, 0x9b, 0x03,
+	0x9c, 0x03, 0x9d, 0x03, 0x9e, 0x03, 0x9f, 0x03,
+	0xa0, 0x03, 0xa1, 0x03, 0xa2, 0x03, 0xa3, 0x03,
+	0xa4, 0x03, 0xa5, 0x03, 0xa6, 0x03, 0xa7, 0x03,
+	0xa8, 0x03, 0xa9, 0x03, 0xaa, 0x03, 0xab, 0x03,
+	0x86, 0x03, 0x88, 0x03, 0x89, 0x03, 0x8a, 0x03,
+	0xb0, 0x03, 0x91, 0x03, 0x92, 0x03, 0x93, 0x03,
+	0x94, 0x03, 0x95, 0x03, 0x96, 0x03, 0x97, 0x03,
+	0x98, 0x03, 0x99, 0x03, 0x9a, 0x03, 0x9b, 0x03,
+	0x9c, 0x03, 0x9d, 0x03, 0x9e, 0x03, 0x9f, 0x03,
+	0xa0, 0x03, 0xa1, 0x03, 0xa3, 0x03, 0xa3, 0x03,
+	0xa4, 0x03, 0xa5, 0x03, 0xa6, 0x03, 0xa7, 0x03,
+	0xa8, 0x03, 0xa9, 0x03, 0xaa, 0x03, 0xab, 0x03,
+	0x8c, 0x03, 0x8e, 0x03, 0x8f, 0x03, 0xcf, 0x03,
+	0xd0, 0x03, 0xd1, 0x03, 0xd2, 0x03, 0xd3, 0x03,
+	0xd4, 0x03, 0xd5, 0x03, 0xd6, 0x03, 0xd7, 0x03,
+	0xd8, 0x03, 0xd8, 0x03, 0xda, 0x03, 0xda, 0x03,
+	0xdc, 0x03, 0xdc, 0x03, 0xde, 0x03, 0xde, 0x03,
+	0xe0, 0x03, 0xe0, 0x03, 0xe2, 0x03, 0xe2, 0x03,
+	0xe4, 0x03, 0xe4, 0x03, 0xe6, 0x03, 0xe6, 0x03,
+	0xe8, 0x03, 0xe8, 0x03, 0xea, 0x03, 0xea, 0x03,
+	0xec, 0x03, 0xec, 0x03, 0xee, 0x03, 0xee, 0x03,
+	0xf0, 0x03, 0xf1, 0x03, 0xf9, 0x03, 0xf3, 0x03,
+	0xf4, 0x03, 0xf5, 0x03, 0xf6, 0x03, 0xf7, 0x03,
+	0xf7, 0x03, 0xf9, 0x03, 0xfa, 0x03, 0xfa, 0x03,
+	0xfc, 0x03, 0xfd, 0x03, 0xfe, 0x03, 0xff, 0x03,
+	0x00, 0x04, 0x01, 0x04, 0x02, 0x04, 0x03, 0x04,
+	0x04, 0x04, 0x05, 0x04, 0x06, 0x04, 0x07, 0x04,
+	0x08, 0x04, 0x09, 0x04, 0x0a, 0x04, 0x0b, 0x04,
+	0x0c, 0x04, 0x0d, 0x04, 0x0e, 0x04, 0x0f, 0x04,
+	0x10, 0x04, 0x11, 0x04, 0x12, 0x04, 0x13, 0x04,
+	0x14, 0x04, 0x15, 0x04, 0x16, 0x04, 0x17, 0x04,
+	0x18, 0x04, 0x19, 0x04, 0x1a, 0x04, 0x1b, 0x04,
+	0x1c, 0x04, 0x1d, 0x04, 0x1e, 0x04, 0x1f, 0x04,
+	0x20, 0x04, 0x21, 0x04, 0x22, 0x04, 0x23, 0x04,
+	0x24, 0x04, 0x25, 0x04, 0x26, 0x04, 0x27, 0x04,
+	0x28, 0x04, 0x29, 0x04, 0x2a, 0x04, 0x2b, 0x04,
+	0x2c, 0x04, 0x2d, 0x04, 0x2e, 0x04, 0x2f, 0x04,
+	0x10, 0x04, 0x11, 0x04, 0x12, 0x04, 0x13, 0x04,
+	0x14, 0x04, 0x15, 0x04, 0x16, 0x04, 0x17, 0x04,
+	0x18, 0x04, 0x19, 0x04, 0x1a, 0x04, 0x1b, 0x04,
+	0x1c, 0x04, 0x1d, 0x04, 0x1e, 0x04, 0x1f, 0x04,
+	0x20, 0x04, 0x21, 0x04, 0x22, 0x04, 0x23, 0x04,
+	0x24, 0x04, 0x25, 0x04, 0x26, 0x04, 0x27, 0x04,
+	0x28, 0x04, 0x29, 0x04, 0x2a, 0x04, 0x2b, 0x04,
+	0x2c, 0x04, 0x2d, 0x04, 0x2e, 0x04, 0x2f, 0x04,
+	0x00, 0x04, 0x01, 0x04, 0x02, 0x04, 0x03, 0x04,
+	0x04, 0x04, 0x05, 0x04, 0x06, 0x04, 0x07, 0x04,
+	0x08, 0x04, 0x09, 0x04, 0x0a, 0x04, 0x0b, 0x04,
+	0x0c, 0x04, 0x0d, 0x04, 0x0e, 0x04, 0x0f, 0x04,
+	0x60, 0x04, 0x60, 0x04, 0x62, 0x04, 0x62, 0x04,
+	0x64, 0x04, 0x64, 0x04, 0x66, 0x04, 0x66, 0x04,
+	0x68, 0x04, 0x68, 0x04, 0x6a, 0x04, 0x6a, 0x04,
+	0x6c, 0x04, 0x6c, 0x04, 0x6e, 0x04, 0x6e, 0x04,
+	0x70, 0x04, 0x70, 0x04, 0x72, 0x04, 0x72, 0x04,
+	0x74, 0x04, 0x74, 0x04, 0x76, 0x04, 0x76, 0x04,
+	0x78, 0x04, 0x78, 0x04, 0x7a, 0x04, 0x7a, 0x04,
+	0x7c, 0x04, 0x7c, 0x04, 0x7e, 0x04, 0x7e, 0x04,
+	0x80, 0x04, 0x80, 0x04, 0x82, 0x04, 0x83, 0x04,
+	0x84, 0x04, 0x85, 0x04, 0x86, 0x04, 0x87, 0x04,
+	0x88, 0x04, 0x89, 0x04, 0x8a, 0x04, 0x8a, 0x04,
+	0x8c, 0x04, 0x8c, 0x04, 0x8e, 0x04, 0x8e, 0x04,
+	0x90, 0x04, 0x90, 0x04, 0x92, 0x04, 0x92, 0x04,
+	0x94, 0x04, 0x94, 0x04, 0x96, 0x04, 0x96, 0x04,
+	0x98, 0x04, 0x98, 0x04, 0x9a, 0x04, 0x9a, 0x04,
+	0x9c, 0x04, 0x9c, 0x04, 0x9e, 0x04, 0x9e, 0x04,
+	0xa0, 0x04, 0xa0, 0x04, 0xa2, 0x04, 0xa2, 0x04,
+	0xa4, 0x04, 0xa4, 0x04, 0xa6, 0x04, 0xa6, 0x04,
+	0xa8, 0x04, 0xa8, 0x04, 0xaa, 0x04, 0xaa, 0x04,
+	0xac, 0x04, 0xac, 0x04, 0xae, 0x04, 0xae, 0x04,
+	0xb0, 0x04, 0xb0, 0x04, 0xb2, 0x04, 0xb2, 0x04,
+	0xb4, 0x04, 0xb4, 0x04, 0xb6, 0x04, 0xb6, 0x04,
+	0xb8, 0x04, 0xb8, 0x04, 0xba, 0x04, 0xba, 0x04,
+	0xbc, 0x04, 0xbc, 0x04, 0xbe, 0x04, 0xbe, 0x04,
+	0xc0, 0x04, 0xc1, 0x04, 0xc1, 0x04, 0xc3, 0x04,
+	0xc3, 0x04, 0xc5, 0x04, 0xc5, 0x04, 0xc7, 0x04,
+	0xc7, 0x04, 0xc9, 0x04, 0xc9, 0x04, 0xcb, 0x04,
+	0xcb, 0x04, 0xcd, 0x04, 0xcd, 0x04, 0xc0, 0x04,
+	0xd0, 0x04, 0xd0, 0x04, 0xd2, 0x04, 0xd2, 0x04,
+	0xd4, 0x04, 0xd4, 0x04, 0xd6, 0x04, 0xd6, 0x04,
+	0xd8, 0x04, 0xd8, 0x04, 0xda, 0x04, 0xda, 0x04,
+	0xdc, 0x04, 0xdc, 0x04, 0xde, 0x04, 0xde, 0x04,
+	0xe0, 0x04, 0xe0, 0x04, 0xe2, 0x04, 0xe2, 0x04,
+	0xe4, 0x04, 0xe4, 0x04, 0xe6, 0x04, 0xe6, 0x04,
+	0xe8, 0x04, 0xe8, 0x04, 0xea, 0x04, 0xea, 0x04,
+	0xec, 0x04, 0xec, 0x04, 0xee, 0x04, 0xee, 0x04,
+	0xf0, 0x04, 0xf0, 0x04, 0xf2, 0x04, 0xf2, 0x04,
+	0xf4, 0x04, 0xf4, 0x04, 0xf6, 0x04, 0xf6, 0x04,
+	0xf8, 0x04, 0xf8, 0x04, 0xfa, 0x04, 0xfa, 0x04,
+	0xfc, 0x04, 0xfc, 0x04, 0xfe, 0x04, 0xfe, 0x04,
+	0x00, 0x05, 0x00, 0x05, 0x02, 0x05, 0x02, 0x05,
+	0x04, 0x05, 0x04, 0x05, 0x06, 0x05, 0x06, 0x05,
+	0x08, 0x05, 0x08, 0x05, 0x0a, 0x05, 0x0a, 0x05,
+	0x0c, 0x05, 0x0c, 0x05, 0x0e, 0x05, 0x0e, 0x05,
+	0x10, 0x05, 0x10, 0x05, 0x12, 0x05, 0x12, 0x05,
+	0x14, 0x05, 0x15, 0x05, 0x16, 0x05, 0x17, 0x05,
+	0x18, 0x05, 0x19, 0x05, 0x1a, 0x05, 0x1b, 0x05,
+	0x1c, 0x05, 0x1d, 0x05, 0x1e, 0x05, 0x1f, 0x05,
+	0x20, 0x05, 0x21, 0x05, 0x22, 0x05, 0x23, 0x05,
+	0x24, 0x05, 0x25, 0x05, 0x26, 0x05, 0x27, 0x05,
+	0x28, 0x05, 0x29, 0x05, 0x2a, 0x05, 0x2b, 0x05,
+	0x2c, 0x05, 0x2d, 0x05, 0x2e, 0x05, 0x2f, 0x05,
+	0x30, 0x05, 0x31, 0x05, 0x32, 0x05, 0x33, 0x05,
+	0x34, 0x05, 0x35, 0x05, 0x36, 0x05, 0x37, 0x05,
+	0x38, 0x05, 0x39, 0x05, 0x3a, 0x05, 0x3b, 0x05,
+	0x3c, 0x05, 0x3d, 0x05, 0x3e, 0x05, 0x3f, 0x05,
+	0x40, 0x05, 0x41, 0x05, 0x42, 0x05, 0x43, 0x05,
+	0x44, 0x05, 0x45, 0x05, 0x46, 0x05, 0x47, 0x05,
+	0x48, 0x05, 0x49, 0x05, 0x4a, 0x05, 0x4b, 0x05,
+	0x4c, 0x05, 0x4d, 0x05, 0x4e, 0x05, 0x4f, 0x05,
+	0x50, 0x05, 0x51, 0x05, 0x52, 0x05, 0x53, 0x05,
+	0x54, 0x05, 0x55, 0x05, 0x56, 0x05, 0x57, 0x05,
+	0x58, 0x05, 0x59, 0x05, 0x5a, 0x05, 0x5b, 0x05,
+	0x5c, 0x05, 0x5d, 0x05, 0x5e, 0x05, 0x5f, 0x05,
+	0x60, 0x05, 0x31, 0x05, 0x32, 0x05, 0x33, 0x05,
+	0x34, 0x05, 0x35, 0x05, 0x36, 0x05, 0x37, 0x05,
+	0x38, 0x05, 0x39, 0x05, 0x3a, 0x05, 0x3b, 0x05,
+	0x3c, 0x05, 0x3d, 0x05, 0x3e, 0x05, 0x3f, 0x05,
+	0x40, 0x05, 0x41, 0x05, 0x42, 0x05, 0x43, 0x05,
+	0x44, 0x05, 0x45, 0x05, 0x46, 0x05, 0x47, 0x05,
+	0x48, 0x05, 0x49, 0x05, 0x4a, 0x05, 0x4b, 0x05,
+	0x4c, 0x05, 0x4d, 0x05, 0x4e, 0x05, 0x4f, 0x05,
+	0x50, 0x05, 0x51, 0x05, 0x52, 0x05, 0x53, 0x05,
+	0x54, 0x05, 0x55, 0x05, 0x56, 0x05, 0xff, 0xff,
+	0xf6, 0x17, 0x63, 0x2c, 0x7e, 0x1d, 0x7f, 0x1d,
+	0x80, 0x1d, 0x81, 0x1d, 0x82, 0x1d, 0x83, 0x1d,
+	0x84, 0x1d, 0x85, 0x1d, 0x86, 0x1d, 0x87, 0x1d,
+	0x88, 0x1d, 0x89, 0x1d, 0x8a, 0x1d, 0x8b, 0x1d,
+	0x8c, 0x1d, 0x8d, 0x1d, 0x8e, 0x1d, 0x8f, 0x1d,
+	0x90, 0x1d, 0x91, 0x1d, 0x92, 0x1d, 0x93, 0x1d,
+	0x94, 0x1d, 0x95, 0x1d, 0x96, 0x1d, 0x97, 0x1d,
+	0x98, 0x1d, 0x99, 0x1d, 0x9a, 0x1d, 0x9b, 0x1d,
+	0x9c, 0x1d, 0x9d, 0x1d, 0x9e, 0x1d, 0x9f, 0x1d,
+	0xa0, 0x1d, 0xa1, 0x1d, 0xa2, 0x1d, 0xa3, 0x1d,
+	0xa4, 0x1d, 0xa5, 0x1d, 0xa6, 0x1d, 0xa7, 0x1d,
+	0xa8, 0x1d, 0xa9, 0x1d, 0xaa, 0x1d, 0xab, 0x1d,
+	0xac, 0x1d, 0xad, 0x1d, 0xae, 0x1d, 0xaf, 0x1d,
+	0xb0, 0x1d, 0xb1, 0x1d, 0xb2, 0x1d, 0xb3, 0x1d,
+	0xb4, 0x1d, 0xb5, 0x1d, 0xb6, 0x1d, 0xb7, 0x1d,
+	0xb8, 0x1d, 0xb9, 0x1d, 0xba, 0x1d, 0xbb, 0x1d,
+	0xbc, 0x1d, 0xbd, 0x1d, 0xbe, 0x1d, 0xbf, 0x1d,
+	0xc0, 0x1d, 0xc1, 0x1d, 0xc2, 0x1d, 0xc3, 0x1d,
+	0xc4, 0x1d, 0xc5, 0x1d, 0xc6, 0x1d, 0xc7, 0x1d,
+	0xc8, 0x1d, 0xc9, 0x1d, 0xca, 0x1d, 0xcb, 0x1d,
+	0xcc, 0x1d, 0xcd, 0x1d, 0xce, 0x1d, 0xcf, 0x1d,
+	0xd0, 0x1d, 0xd1, 0x1d, 0xd2, 0x1d, 0xd3, 0x1d,
+	0xd4, 0x1d, 0xd5, 0x1d, 0xd6, 0x1d, 0xd7, 0x1d,
+	0xd8, 0x1d, 0xd9, 0x1d, 0xda, 0x1d, 0xdb, 0x1d,
+	0xdc, 0x1d, 0xdd, 0x1d, 0xde, 0x1d, 0xdf, 0x1d,
+	0xe0, 0x1d, 0xe1, 0x1d, 0xe2, 0x1d, 0xe3, 0x1d,
+	0xe4, 0x1d, 0xe5, 0x1d, 0xe6, 0x1d, 0xe7, 0x1d,
+	0xe8, 0x1d, 0xe9, 0x1d, 0xea, 0x1d, 0xeb, 0x1d,
+	0xec, 0x1d, 0xed, 0x1d, 0xee, 0x1d, 0xef, 0x1d,
+	0xf0, 0x1d, 0xf1, 0x1d, 0xf2, 0x1d, 0xf3, 0x1d,
+	0xf4, 0x1d, 0xf5, 0x1d, 0xf6, 0x1d, 0xf7, 0x1d,
+	0xf8, 0x1d, 0xf9, 0x1d, 0xfa, 0x1d, 0xfb, 0x1d,
+	0xfc, 0x1d, 0xfd, 0x1d, 0xfe, 0x1d, 0xff, 0x1d,
+	0x00, 0x1e, 0x00, 0x1e, 0x02, 0x1e, 0x02, 0x1e,
+	0x04, 0x1e, 0x04, 0x1e, 0x06, 0x1e, 0x06, 0x1e,
+	0x08, 0x1e, 0x08, 0x1e, 0x0a, 0x1e, 0x0a, 0x1e,
+	0x0c, 0x1e, 0x0c, 0x1e, 0x0e, 0x1e, 0x0e, 0x1e,
+	0x10, 0x1e, 0x10, 0x1e, 0x12, 0x1e, 0x12, 0x1e,
+	0x14, 0x1e, 0x14, 0x1e, 0x16, 0x1e, 0x16, 0x1e,
+	0x18, 0x1e, 0x18, 0x1e, 0x1a, 0x1e, 0x1a, 0x1e,
+	0x1c, 0x1e, 0x1c, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+	0x20, 0x1e, 0x20, 0x1e, 0x22, 0x1e, 0x22, 0x1e,
+	0x24, 0x1e, 0x24, 0x1e, 0x26, 0x1e, 0x26, 0x1e,
+	0x28, 0x1e, 0x28, 0x1e, 0x2a, 0x1e, 0x2a, 0x1e,
+	0x2c, 0x1e, 0x2c, 0x1e, 0x2e, 0x1e, 0x2e, 0x1e,
+	0x30, 0x1e, 0x30, 0x1e, 0x32, 0x1e, 0x32, 0x1e,
+	0x34, 0x1e, 0x34, 0x1e, 0x36, 0x1e, 0x36, 0x1e,
+	0x38, 0x1e, 0x38, 0x1e, 0x3a, 0x1e, 0x3a, 0x1e,
+	0x3c, 0x1e, 0x3c, 0x1e, 0x3e, 0x1e, 0x3e, 0x1e,
+	0x40, 0x1e, 0x40, 0x1e, 0x42, 0x1e, 0x42, 0x1e,
+	0x44, 0x1e, 0x44, 0x1e, 0x46, 0x1e, 0x46, 0x1e,
+	0x48, 0x1e, 0x48, 0x1e, 0x4a, 0x1e, 0x4a, 0x1e,
+	0x4c, 0x1e, 0x4c, 0x1e, 0x4e, 0x1e, 0x4e, 0x1e,
+	0x50, 0x1e, 0x50, 0x1e, 0x52, 0x1e, 0x52, 0x1e,
+	0x54, 0x1e, 0x54, 0x1e, 0x56, 0x1e, 0x56, 0x1e,
+	0x58, 0x1e, 0x58, 0x1e, 0x5a, 0x1e, 0x5a, 0x1e,
+	0x5c, 0x1e, 0x5c, 0x1e, 0x5e, 0x1e, 0x5e, 0x1e,
+	0x60, 0x1e, 0x60, 0x1e, 0x62, 0x1e, 0x62, 0x1e,
+	0x64, 0x1e, 0x64, 0x1e, 0x66, 0x1e, 0x66, 0x1e,
+	0x68, 0x1e, 0x68, 0x1e, 0x6a, 0x1e, 0x6a, 0x1e,
+	0x6c, 0x1e, 0x6c, 0x1e, 0x6e, 0x1e, 0x6e, 0x1e,
+	0x70, 0x1e, 0x70, 0x1e, 0x72, 0x1e, 0x72, 0x1e,
+	0x74, 0x1e, 0x74, 0x1e, 0x76, 0x1e, 0x76, 0x1e,
+	0x78, 0x1e, 0x78, 0x1e, 0x7a, 0x1e, 0x7a, 0x1e,
+	0x7c, 0x1e, 0x7c, 0x1e, 0x7e, 0x1e, 0x7e, 0x1e,
+	0x80, 0x1e, 0x80, 0x1e, 0x82, 0x1e, 0x82, 0x1e,
+	0x84, 0x1e, 0x84, 0x1e, 0x86, 0x1e, 0x86, 0x1e,
+	0x88, 0x1e, 0x88, 0x1e, 0x8a, 0x1e, 0x8a, 0x1e,
+	0x8c, 0x1e, 0x8c, 0x1e, 0x8e, 0x1e, 0x8e, 0x1e,
+	0x90, 0x1e, 0x90, 0x1e, 0x92, 0x1e, 0x92, 0x1e,
+	0x94, 0x1e, 0x94, 0x1e, 0x96, 0x1e, 0x97, 0x1e,
+	0x98, 0x1e, 0x99, 0x1e, 0x9a, 0x1e, 0x9b, 0x1e,
+	0x9c, 0x1e, 0x9d, 0x1e, 0x9e, 0x1e, 0x9f, 0x1e,
+	0xa0, 0x1e, 0xa0, 0x1e, 0xa2, 0x1e, 0xa2, 0x1e,
+	0xa4, 0x1e, 0xa4, 0x1e, 0xa6, 0x1e, 0xa6, 0x1e,
+	0xa8, 0x1e, 0xa8, 0x1e, 0xaa, 0x1e, 0xaa, 0x1e,
+	0xac, 0x1e, 0xac, 0x1e, 0xae, 0x1e, 0xae, 0x1e,
+	0xb0, 0x1e, 0xb0, 0x1e, 0xb2, 0x1e, 0xb2, 0x1e,
+	0xb4, 0x1e, 0xb4, 0x1e, 0xb6, 0x1e, 0xb6, 0x1e,
+	0xb8, 0x1e, 0xb8, 0x1e, 0xba, 0x1e, 0xba, 0x1e,
+	0xbc, 0x1e, 0xbc, 0x1e, 0xbe, 0x1e, 0xbe, 0x1e,
+	0xc0, 0x1e, 0xc0, 0x1e, 0xc2, 0x1e, 0xc2, 0x1e,
+	0xc4, 0x1e, 0xc4, 0x1e, 0xc6, 0x1e, 0xc6, 0x1e,
+	0xc8, 0x1e, 0xc8, 0x1e, 0xca, 0x1e, 0xca, 0x1e,
+	0xcc, 0x1e, 0xcc, 0x1e, 0xce, 0x1e, 0xce, 0x1e,
+	0xd0, 0x1e, 0xd0, 0x1e, 0xd2, 0x1e, 0xd2, 0x1e,
+	0xd4, 0x1e, 0xd4, 0x1e, 0xd6, 0x1e, 0xd6, 0x1e,
+	0xd8, 0x1e, 0xd8, 0x1e, 0xda, 0x1e, 0xda, 0x1e,
+	0xdc, 0x1e, 0xdc, 0x1e, 0xde, 0x1e, 0xde, 0x1e,
+	0xe0, 0x1e, 0xe0, 0x1e, 0xe2, 0x1e, 0xe2, 0x1e,
+	0xe4, 0x1e, 0xe4, 0x1e, 0xe6, 0x1e, 0xe6, 0x1e,
+	0xe8, 0x1e, 0xe8, 0x1e, 0xea, 0x1e, 0xea, 0x1e,
+	0xec, 0x1e, 0xec, 0x1e, 0xee, 0x1e, 0xee, 0x1e,
+	0xf0, 0x1e, 0xf0, 0x1e, 0xf2, 0x1e, 0xf2, 0x1e,
+	0xf4, 0x1e, 0xf4, 0x1e, 0xf6, 0x1e, 0xf6, 0x1e,
+	0xf8, 0x1e, 0xf8, 0x1e, 0xfa, 0x1e, 0xfb, 0x1e,
+	0xfc, 0x1e, 0xfd, 0x1e, 0xfe, 0x1e, 0xff, 0x1e,
+	0x08, 0x1f, 0x09, 0x1f, 0x0a, 0x1f, 0x0b, 0x1f,
+	0x0c, 0x1f, 0x0d, 0x1f, 0x0e, 0x1f, 0x0f, 0x1f,
+	0x08, 0x1f, 0x09, 0x1f, 0x0a, 0x1f, 0x0b, 0x1f,
+	0x0c, 0x1f, 0x0d, 0x1f, 0x0e, 0x1f, 0x0f, 0x1f,
+	0x18, 0x1f, 0x19, 0x1f, 0x1a, 0x1f, 0x1b, 0x1f,
+	0x1c, 0x1f, 0x1d, 0x1f, 0x16, 0x1f, 0x17, 0x1f,
+	0x18, 0x1f, 0x19, 0x1f, 0x1a, 0x1f, 0x1b, 0x1f,
+	0x1c, 0x1f, 0x1d, 0x1f, 0x1e, 0x1f, 0x1f, 0x1f,
+	0x28, 0x1f, 0x29, 0x1f, 0x2a, 0x1f, 0x2b, 0x1f,
+	0x2c, 0x1f, 0x2d, 0x1f, 0x2e, 0x1f, 0x2f, 0x1f,
+	0x28, 0x1f, 0x29, 0x1f, 0x2a, 0x1f, 0x2b, 0x1f,
+	0x2c, 0x1f, 0x2d, 0x1f, 0x2e, 0x1f, 0x2f, 0x1f,
+	0x38, 0x1f, 0x39, 0x1f, 0x3a, 0x1f, 0x3b, 0x1f,
+	0x3c, 0x1f, 0x3d, 0x1f, 0x3e, 0x1f, 0x3f, 0x1f,
+	0x38, 0x1f, 0x39, 0x1f, 0x3a, 0x1f, 0x3b, 0x1f,
+	0x3c, 0x1f, 0x3d, 0x1f, 0x3e, 0x1f, 0x3f, 0x1f,
+	0x48, 0x1f, 0x49, 0x1f, 0x4a, 0x1f, 0x4b, 0x1f,
+	0x4c, 0x1f, 0x4d, 0x1f, 0x46, 0x1f, 0x47, 0x1f,
+	0x48, 0x1f, 0x49, 0x1f, 0x4a, 0x1f, 0x4b, 0x1f,
+	0x4c, 0x1f, 0x4d, 0x1f, 0x4e, 0x1f, 0x4f, 0x1f,
+	0x50, 0x1f, 0x59, 0x1f, 0x52, 0x1f, 0x5b, 0x1f,
+	0x54, 0x1f, 0x5d, 0x1f, 0x56, 0x1f, 0x5f, 0x1f,
+	0x58, 0x1f, 0x59, 0x1f, 0x5a, 0x1f, 0x5b, 0x1f,
+	0x5c, 0x1f, 0x5d, 0x1f, 0x5e, 0x1f, 0x5f, 0x1f,
+	0x68, 0x1f, 0x69, 0x1f, 0x6a, 0x1f, 0x6b, 0x1f,
+	0x6c, 0x1f, 0x6d, 0x1f, 0x6e, 0x1f, 0x6f, 0x1f,
+	0x68, 0x1f, 0x69, 0x1f, 0x6a, 0x1f, 0x6b, 0x1f,
+	0x6c, 0x1f, 0x6d, 0x1f, 0x6e, 0x1f, 0x6f, 0x1f,
+	0xba, 0x1f, 0xbb, 0x1f, 0xc8, 0x1f, 0xc9, 0x1f,
+	0xca, 0x1f, 0xcb, 0x1f, 0xda, 0x1f, 0xdb, 0x1f,
+	0xf8, 0x1f, 0xf9, 0x1f, 0xea, 0x1f, 0xeb, 0x1f,
+	0xfa, 0x1f, 0xfb, 0x1f, 0x7e, 0x1f, 0x7f, 0x1f,
+	0x88, 0x1f, 0x89, 0x1f, 0x8a, 0x1f, 0x8b, 0x1f,
+	0x8c, 0x1f, 0x8d, 0x1f, 0x8e, 0x1f, 0x8f, 0x1f,
+	0x88, 0x1f, 0x89, 0x1f, 0x8a, 0x1f, 0x8b, 0x1f,
+	0x8c, 0x1f, 0x8d, 0x1f, 0x8e, 0x1f, 0x8f, 0x1f,
+	0x98, 0x1f, 0x99, 0x1f, 0x9a, 0x1f, 0x9b, 0x1f,
+	0x9c, 0x1f, 0x9d, 0x1f, 0x9e, 0x1f, 0x9f, 0x1f,
+	0x98, 0x1f, 0x99, 0x1f, 0x9a, 0x1f, 0x9b, 0x1f,
+	0x9c, 0x1f, 0x9d, 0x1f, 0x9e, 0x1f, 0x9f, 0x1f,
+	0xa8, 0x1f, 0xa9, 0x1f, 0xaa, 0x1f, 0xab, 0x1f,
+	0xac, 0x1f, 0xad, 0x1f, 0xae, 0x1f, 0xaf, 0x1f,
+	0xa8, 0x1f, 0xa9, 0x1f, 0xaa, 0x1f, 0xab, 0x1f,
+	0xac, 0x1f, 0xad, 0x1f, 0xae, 0x1f, 0xaf, 0x1f,
+	0xb8, 0x1f, 0xb9, 0x1f, 0xb2, 0x1f, 0xbc, 0x1f,
+	0xb4, 0x1f, 0xb5, 0x1f, 0xb6, 0x1f, 0xb7, 0x1f,
+	0xb8, 0x1f, 0xb9, 0x1f, 0xba, 0x1f, 0xbb, 0x1f,
+	0xbc, 0x1f, 0xbd, 0x1f, 0xbe, 0x1f, 0xbf, 0x1f,
+	0xc0, 0x1f, 0xc1, 0x1f, 0xc2, 0x1f, 0xc3, 0x1f,
+	0xc4, 0x1f, 0xc5, 0x1f, 0xc6, 0x1f, 0xc7, 0x1f,
+	0xc8, 0x1f, 0xc9, 0x1f, 0xca, 0x1f, 0xcb, 0x1f,
+	0xc3, 0x1f, 0xcd, 0x1f, 0xce, 0x1f, 0xcf, 0x1f,
+	0xd8, 0x1f, 0xd9, 0x1f, 0xd2, 0x1f, 0xd3, 0x1f,
+	0xd4, 0x1f, 0xd5, 0x1f, 0xd6, 0x1f, 0xd7, 0x1f,
+	0xd8, 0x1f, 0xd9, 0x1f, 0xda, 0x1f, 0xdb, 0x1f,
+	0xdc, 0x1f, 0xdd, 0x1f, 0xde, 0x1f, 0xdf, 0x1f,
+	0xe8, 0x1f, 0xe9, 0x1f, 0xe2, 0x1f, 0xe3, 0x1f,
+	0xe4, 0x1f, 0xec, 0x1f, 0xe6, 0x1f, 0xe7, 0x1f,
+	0xe8, 0x1f, 0xe9, 0x1f, 0xea, 0x1f, 0xeb, 0x1f,
+	0xec, 0x1f, 0xed, 0x1f, 0xee, 0x1f, 0xef, 0x1f,
+	0xf0, 0x1f, 0xf1, 0x1f, 0xf2, 0x1f, 0xf3, 0x1f,
+	0xf4, 0x1f, 0xf5, 0x1f, 0xf6, 0x1f, 0xf7, 0x1f,
+	0xf8, 0x1f, 0xf9, 0x1f, 0xfa, 0x1f, 0xfb, 0x1f,
+	0xf3, 0x1f, 0xfd, 0x1f, 0xfe, 0x1f, 0xff, 0x1f,
+	0x00, 0x20, 0x01, 0x20, 0x02, 0x20, 0x03, 0x20,
+	0x04, 0x20, 0x05, 0x20, 0x06, 0x20, 0x07, 0x20,
+	0x08, 0x20, 0x09, 0x20, 0x0a, 0x20, 0x0b, 0x20,
+	0x0c, 0x20, 0x0d, 0x20, 0x0e, 0x20, 0x0f, 0x20,
+	0x10, 0x20, 0x11, 0x20, 0x12, 0x20, 0x13, 0x20,
+	0x14, 0x20, 0x15, 0x20, 0x16, 0x20, 0x17, 0x20,
+	0x18, 0x20, 0x19, 0x20, 0x1a, 0x20, 0x1b, 0x20,
+	0x1c, 0x20, 0x1d, 0x20, 0x1e, 0x20, 0x1f, 0x20,
+	0x20, 0x20, 0x21, 0x20, 0x22, 0x20, 0x23, 0x20,
+	0x24, 0x20, 0x25, 0x20, 0x26, 0x20, 0x27, 0x20,
+	0x28, 0x20, 0x29, 0x20, 0x2a, 0x20, 0x2b, 0x20,
+	0x2c, 0x20, 0x2d, 0x20, 0x2e, 0x20, 0x2f, 0x20,
+	0x30, 0x20, 0x31, 0x20, 0x32, 0x20, 0x33, 0x20,
+	0x34, 0x20, 0x35, 0x20, 0x36, 0x20, 0x37, 0x20,
+	0x38, 0x20, 0x39, 0x20, 0x3a, 0x20, 0x3b, 0x20,
+	0x3c, 0x20, 0x3d, 0x20, 0x3e, 0x20, 0x3f, 0x20,
+	0x40, 0x20, 0x41, 0x20, 0x42, 0x20, 0x43, 0x20,
+	0x44, 0x20, 0x45, 0x20, 0x46, 0x20, 0x47, 0x20,
+	0x48, 0x20, 0x49, 0x20, 0x4a, 0x20, 0x4b, 0x20,
+	0x4c, 0x20, 0x4d, 0x20, 0x4e, 0x20, 0x4f, 0x20,
+	0x50, 0x20, 0x51, 0x20, 0x52, 0x20, 0x53, 0x20,
+	0x54, 0x20, 0x55, 0x20, 0x56, 0x20, 0x57, 0x20,
+	0x58, 0x20, 0x59, 0x20, 0x5a, 0x20, 0x5b, 0x20,
+	0x5c, 0x20, 0x5d, 0x20, 0x5e, 0x20, 0x5f, 0x20,
+	0x60, 0x20, 0x61, 0x20, 0x62, 0x20, 0x63, 0x20,
+	0x64, 0x20, 0x65, 0x20, 0x66, 0x20, 0x67, 0x20,
+	0x68, 0x20, 0x69, 0x20, 0x6a, 0x20, 0x6b, 0x20,
+	0x6c, 0x20, 0x6d, 0x20, 0x6e, 0x20, 0x6f, 0x20,
+	0x70, 0x20, 0x71, 0x20, 0x72, 0x20, 0x73, 0x20,
+	0x74, 0x20, 0x75, 0x20, 0x76, 0x20, 0x77, 0x20,
+	0x78, 0x20, 0x79, 0x20, 0x7a, 0x20, 0x7b, 0x20,
+	0x7c, 0x20, 0x7d, 0x20, 0x7e, 0x20, 0x7f, 0x20,
+	0x80, 0x20, 0x81, 0x20, 0x82, 0x20, 0x83, 0x20,
+	0x84, 0x20, 0x85, 0x20, 0x86, 0x20, 0x87, 0x20,
+	0x88, 0x20, 0x89, 0x20, 0x8a, 0x20, 0x8b, 0x20,
+	0x8c, 0x20, 0x8d, 0x20, 0x8e, 0x20, 0x8f, 0x20,
+	0x90, 0x20, 0x91, 0x20, 0x92, 0x20, 0x93, 0x20,
+	0x94, 0x20, 0x95, 0x20, 0x96, 0x20, 0x97, 0x20,
+	0x98, 0x20, 0x99, 0x20, 0x9a, 0x20, 0x9b, 0x20,
+	0x9c, 0x20, 0x9d, 0x20, 0x9e, 0x20, 0x9f, 0x20,
+	0xa0, 0x20, 0xa1, 0x20, 0xa2, 0x20, 0xa3, 0x20,
+	0xa4, 0x20, 0xa5, 0x20, 0xa6, 0x20, 0xa7, 0x20,
+	0xa8, 0x20, 0xa9, 0x20, 0xaa, 0x20, 0xab, 0x20,
+	0xac, 0x20, 0xad, 0x20, 0xae, 0x20, 0xaf, 0x20,
+	0xb0, 0x20, 0xb1, 0x20, 0xb2, 0x20, 0xb3, 0x20,
+	0xb4, 0x20, 0xb5, 0x20, 0xb6, 0x20, 0xb7, 0x20,
+	0xb8, 0x20, 0xb9, 0x20, 0xba, 0x20, 0xbb, 0x20,
+	0xbc, 0x20, 0xbd, 0x20, 0xbe, 0x20, 0xbf, 0x20,
+	0xc0, 0x20, 0xc1, 0x20, 0xc2, 0x20, 0xc3, 0x20,
+	0xc4, 0x20, 0xc5, 0x20, 0xc6, 0x20, 0xc7, 0x20,
+	0xc8, 0x20, 0xc9, 0x20, 0xca, 0x20, 0xcb, 0x20,
+	0xcc, 0x20, 0xcd, 0x20, 0xce, 0x20, 0xcf, 0x20,
+	0xd0, 0x20, 0xd1, 0x20, 0xd2, 0x20, 0xd3, 0x20,
+	0xd4, 0x20, 0xd5, 0x20, 0xd6, 0x20, 0xd7, 0x20,
+	0xd8, 0x20, 0xd9, 0x20, 0xda, 0x20, 0xdb, 0x20,
+	0xdc, 0x20, 0xdd, 0x20, 0xde, 0x20, 0xdf, 0x20,
+	0xe0, 0x20, 0xe1, 0x20, 0xe2, 0x20, 0xe3, 0x20,
+	0xe4, 0x20, 0xe5, 0x20, 0xe6, 0x20, 0xe7, 0x20,
+	0xe8, 0x20, 0xe9, 0x20, 0xea, 0x20, 0xeb, 0x20,
+	0xec, 0x20, 0xed, 0x20, 0xee, 0x20, 0xef, 0x20,
+	0xf0, 0x20, 0xf1, 0x20, 0xf2, 0x20, 0xf3, 0x20,
+	0xf4, 0x20, 0xf5, 0x20, 0xf6, 0x20, 0xf7, 0x20,
+	0xf8, 0x20, 0xf9, 0x20, 0xfa, 0x20, 0xfb, 0x20,
+	0xfc, 0x20, 0xfd, 0x20, 0xfe, 0x20, 0xff, 0x20,
+	0x00, 0x21, 0x01, 0x21, 0x02, 0x21, 0x03, 0x21,
+	0x04, 0x21, 0x05, 0x21, 0x06, 0x21, 0x07, 0x21,
+	0x08, 0x21, 0x09, 0x21, 0x0a, 0x21, 0x0b, 0x21,
+	0x0c, 0x21, 0x0d, 0x21, 0x0e, 0x21, 0x0f, 0x21,
+	0x10, 0x21, 0x11, 0x21, 0x12, 0x21, 0x13, 0x21,
+	0x14, 0x21, 0x15, 0x21, 0x16, 0x21, 0x17, 0x21,
+	0x18, 0x21, 0x19, 0x21, 0x1a, 0x21, 0x1b, 0x21,
+	0x1c, 0x21, 0x1d, 0x21, 0x1e, 0x21, 0x1f, 0x21,
+	0x20, 0x21, 0x21, 0x21, 0x22, 0x21, 0x23, 0x21,
+	0x24, 0x21, 0x25, 0x21, 0x26, 0x21, 0x27, 0x21,
+	0x28, 0x21, 0x29, 0x21, 0x2a, 0x21, 0x2b, 0x21,
+	0x2c, 0x21, 0x2d, 0x21, 0x2e, 0x21, 0x2f, 0x21,
+	0x30, 0x21, 0x31, 0x21, 0x32, 0x21, 0x33, 0x21,
+	0x34, 0x21, 0x35, 0x21, 0x36, 0x21, 0x37, 0x21,
+	0x38, 0x21, 0x39, 0x21, 0x3a, 0x21, 0x3b, 0x21,
+	0x3c, 0x21, 0x3d, 0x21, 0x3e, 0x21, 0x3f, 0x21,
+	0x40, 0x21, 0x41, 0x21, 0x42, 0x21, 0x43, 0x21,
+	0x44, 0x21, 0x45, 0x21, 0x46, 0x21, 0x47, 0x21,
+	0x48, 0x21, 0x49, 0x21, 0x4a, 0x21, 0x4b, 0x21,
+	0x4c, 0x21, 0x4d, 0x21, 0x32, 0x21, 0x4f, 0x21,
+	0x50, 0x21, 0x51, 0x21, 0x52, 0x21, 0x53, 0x21,
+	0x54, 0x21, 0x55, 0x21, 0x56, 0x21, 0x57, 0x21,
+	0x58, 0x21, 0x59, 0x21, 0x5a, 0x21, 0x5b, 0x21,
+	0x5c, 0x21, 0x5d, 0x21, 0x5e, 0x21, 0x5f, 0x21,
+	0x60, 0x21, 0x61, 0x21, 0x62, 0x21, 0x63, 0x21,
+	0x64, 0x21, 0x65, 0x21, 0x66, 0x21, 0x67, 0x21,
+	0x68, 0x21, 0x69, 0x21, 0x6a, 0x21, 0x6b, 0x21,
+	0x6c, 0x21, 0x6d, 0x21, 0x6e, 0x21, 0x6f, 0x21,
+	0x60, 0x21, 0x61, 0x21, 0x62, 0x21, 0x63, 0x21,
+	0x64, 0x21, 0x65, 0x21, 0x66, 0x21, 0x67, 0x21,
+	0x68, 0x21, 0x69, 0x21, 0x6a, 0x21, 0x6b, 0x21,
+	0x6c, 0x21, 0x6d, 0x21, 0x6e, 0x21, 0x6f, 0x21,
+	0x80, 0x21, 0x81, 0x21, 0x82, 0x21, 0x83, 0x21,
+	0x83, 0x21, 0xff, 0xff, 0x4b, 0x03, 0xb6, 0x24,
+	0xb7, 0x24, 0xb8, 0x24, 0xb9, 0x24, 0xba, 0x24,
+	0xbb, 0x24, 0xbc, 0x24, 0xbd, 0x24, 0xbe, 0x24,
+	0xbf, 0x24, 0xc0, 0x24, 0xc1, 0x24, 0xc2, 0x24,
+	0xc3, 0x24, 0xc4, 0x24, 0xc5, 0x24, 0xc6, 0x24,
+	0xc7, 0x24, 0xc8, 0x24, 0xc9, 0x24, 0xca, 0x24,
+	0xcb, 0x24, 0xcc, 0x24, 0xcd, 0x24, 0xce, 0x24,
+	0xcf, 0x24, 0xff, 0xff, 0x46, 0x07, 0x00, 0x2c,
+	0x01, 0x2c, 0x02, 0x2c, 0x03, 0x2c, 0x04, 0x2c,
+	0x05, 0x2c, 0x06, 0x2c, 0x07, 0x2c, 0x08, 0x2c,
+	0x09, 0x2c, 0x0a, 0x2c, 0x0b, 0x2c, 0x0c, 0x2c,
+	0x0d, 0x2c, 0x0e, 0x2c, 0x0f, 0x2c, 0x10, 0x2c,
+	0x11, 0x2c, 0x12, 0x2c, 0x13, 0x2c, 0x14, 0x2c,
+	0x15, 0x2c, 0x16, 0x2c, 0x17, 0x2c, 0x18, 0x2c,
+	0x19, 0x2c, 0x1a, 0x2c, 0x1b, 0x2c, 0x1c, 0x2c,
+	0x1d, 0x2c, 0x1e, 0x2c, 0x1f, 0x2c, 0x20, 0x2c,
+	0x21, 0x2c, 0x22, 0x2c, 0x23, 0x2c, 0x24, 0x2c,
+	0x25, 0x2c, 0x26, 0x2c, 0x27, 0x2c, 0x28, 0x2c,
+	0x29, 0x2c, 0x2a, 0x2c, 0x2b, 0x2c, 0x2c, 0x2c,
+	0x2d, 0x2c, 0x2e, 0x2c, 0x5f, 0x2c, 0x60, 0x2c,
+	0x60, 0x2c, 0x62, 0x2c, 0x63, 0x2c, 0x64, 0x2c,
+	0x65, 0x2c, 0x66, 0x2c, 0x67, 0x2c, 0x67, 0x2c,
+	0x69, 0x2c, 0x69, 0x2c, 0x6b, 0x2c, 0x6b, 0x2c,
+	0x6d, 0x2c, 0x6e, 0x2c, 0x6f, 0x2c, 0x70, 0x2c,
+	0x71, 0x2c, 0x72, 0x2c, 0x73, 0x2c, 0x74, 0x2c,
+	0x75, 0x2c, 0x75, 0x2c, 0x77, 0x2c, 0x78, 0x2c,
+	0x79, 0x2c, 0x7a, 0x2c, 0x7b, 0x2c, 0x7c, 0x2c,
+	0x7d, 0x2c, 0x7e, 0x2c, 0x7f, 0x2c, 0x80, 0x2c,
+	0x80, 0x2c, 0x82, 0x2c, 0x82, 0x2c, 0x84, 0x2c,
+	0x84, 0x2c, 0x86, 0x2c, 0x86, 0x2c, 0x88, 0x2c,
+	0x88, 0x2c, 0x8a, 0x2c, 0x8a, 0x2c, 0x8c, 0x2c,
+	0x8c, 0x2c, 0x8e, 0x2c, 0x8e, 0x2c, 0x90, 0x2c,
+	0x90, 0x2c, 0x92, 0x2c, 0x92, 0x2c, 0x94, 0x2c,
+	0x94, 0x2c, 0x96, 0x2c, 0x96, 0x2c, 0x98, 0x2c,
+	0x98, 0x2c, 0x9a, 0x2c, 0x9a, 0x2c, 0x9c, 0x2c,
+	0x9c, 0x2c, 0x9e, 0x2c, 0x9e, 0x2c, 0xa0, 0x2c,
+	0xa0, 0x2c, 0xa2, 0x2c, 0xa2, 0x2c, 0xa4, 0x2c,
+	0xa4, 0x2c, 0xa6, 0x2c, 0xa6, 0x2c, 0xa8, 0x2c,
+	0xa8, 0x2c, 0xaa, 0x2c, 0xaa, 0x2c, 0xac, 0x2c,
+	0xac, 0x2c, 0xae, 0x2c, 0xae, 0x2c, 0xb0, 0x2c,
+	0xb0, 0x2c, 0xb2, 0x2c, 0xb2, 0x2c, 0xb4, 0x2c,
+	0xb4, 0x2c, 0xb6, 0x2c, 0xb6, 0x2c, 0xb8, 0x2c,
+	0xb8, 0x2c, 0xba, 0x2c, 0xba, 0x2c, 0xbc, 0x2c,
+	0xbc, 0x2c, 0xbe, 0x2c, 0xbe, 0x2c, 0xc0, 0x2c,
+	0xc0, 0x2c, 0xc2, 0x2c, 0xc2, 0x2c, 0xc4, 0x2c,
+	0xc4, 0x2c, 0xc6, 0x2c, 0xc6, 0x2c, 0xc8, 0x2c,
+	0xc8, 0x2c, 0xca, 0x2c, 0xca, 0x2c, 0xcc, 0x2c,
+	0xcc, 0x2c, 0xce, 0x2c, 0xce, 0x2c, 0xd0, 0x2c,
+	0xd0, 0x2c, 0xd2, 0x2c, 0xd2, 0x2c, 0xd4, 0x2c,
+	0xd4, 0x2c, 0xd6, 0x2c, 0xd6, 0x2c, 0xd8, 0x2c,
+	0xd8, 0x2c, 0xda, 0x2c, 0xda, 0x2c, 0xdc, 0x2c,
+	0xdc, 0x2c, 0xde, 0x2c, 0xde, 0x2c, 0xe0, 0x2c,
+	0xe0, 0x2c, 0xe2, 0x2c, 0xe2, 0x2c, 0xe4, 0x2c,
+	0xe5, 0x2c, 0xe6, 0x2c, 0xe7, 0x2c, 0xe8, 0x2c,
+	0xe9, 0x2c, 0xea, 0x2c, 0xeb, 0x2c, 0xec, 0x2c,
+	0xed, 0x2c, 0xee, 0x2c, 0xef, 0x2c, 0xf0, 0x2c,
+	0xf1, 0x2c, 0xf2, 0x2c, 0xf3, 0x2c, 0xf4, 0x2c,
+	0xf5, 0x2c, 0xf6, 0x2c, 0xf7, 0x2c, 0xf8, 0x2c,
+	0xf9, 0x2c, 0xfa, 0x2c, 0xfb, 0x2c, 0xfc, 0x2c,
+	0xfd, 0x2c, 0xfe, 0x2c, 0xff, 0x2c, 0xa0, 0x10,
+	0xa1, 0x10, 0xa2, 0x10, 0xa3, 0x10, 0xa4, 0x10,
+	0xa5, 0x10, 0xa6, 0x10, 0xa7, 0x10, 0xa8, 0x10,
+	0xa9, 0x10, 0xaa, 0x10, 0xab, 0x10, 0xac, 0x10,
+	0xad, 0x10, 0xae, 0x10, 0xaf, 0x10, 0xb0, 0x10,
+	0xb1, 0x10, 0xb2, 0x10, 0xb3, 0x10, 0xb4, 0x10,
+	0xb5, 0x10, 0xb6, 0x10, 0xb7, 0x10, 0xb8, 0x10,
+	0xb9, 0x10, 0xba, 0x10, 0xbb, 0x10, 0xbc, 0x10,
+	0xbd, 0x10, 0xbe, 0x10, 0xbf, 0x10, 0xc0, 0x10,
+	0xc1, 0x10, 0xc2, 0x10, 0xc3, 0x10, 0xc4, 0x10,
+	0xc5, 0x10, 0xff, 0xff, 0x1b, 0xd2, 0x21, 0xff,
+	0x22, 0xff, 0x23, 0xff, 0x24, 0xff, 0x25, 0xff,
+	0x26, 0xff, 0x27, 0xff, 0x28, 0xff, 0x29, 0xff,
+	0x2a, 0xff, 0x2b, 0xff, 0x2c, 0xff, 0x2d, 0xff,
+	0x2e, 0xff, 0x2f, 0xff, 0x30, 0xff, 0x31, 0xff,
+	0x32, 0xff, 0x33, 0xff, 0x34, 0xff, 0x35, 0xff,
+	0x36, 0xff, 0x37, 0xff, 0x38, 0xff, 0x39, 0xff,
+	0x3a, 0xff, 0x5b, 0xff, 0x5c, 0xff, 0x5d, 0xff,
+	0x5e, 0xff, 0x5f, 0xff, 0x60, 0xff, 0x61, 0xff,
+	0x62, 0xff, 0x63, 0xff, 0x64, 0xff, 0x65, 0xff,
+	0x66, 0xff, 0x67, 0xff, 0x68, 0xff, 0x69, 0xff,
+	0x6a, 0xff, 0x6b, 0xff, 0x6c, 0xff, 0x6d, 0xff,
+	0x6e, 0xff, 0x6f, 0xff, 0x70, 0xff, 0x71, 0xff,
+	0x72, 0xff, 0x73, 0xff, 0x74, 0xff, 0x75, 0xff,
+	0x76, 0xff, 0x77, 0xff, 0x78, 0xff, 0x79, 0xff,
+	0x7a, 0xff, 0x7b, 0xff, 0x7c, 0xff, 0x7d, 0xff,
+	0x7e, 0xff, 0x7f, 0xff, 0x80, 0xff, 0x81, 0xff,
+	0x82, 0xff, 0x83, 0xff, 0x84, 0xff, 0x85, 0xff,
+	0x86, 0xff, 0x87, 0xff, 0x88, 0xff, 0x89, 0xff,
+	0x8a, 0xff, 0x8b, 0xff, 0x8c, 0xff, 0x8d, 0xff,
+	0x8e, 0xff, 0x8f, 0xff, 0x90, 0xff, 0x91, 0xff,
+	0x92, 0xff, 0x93, 0xff, 0x94, 0xff, 0x95, 0xff,
+	0x96, 0xff, 0x97, 0xff, 0x98, 0xff, 0x99, 0xff,
+	0x9a, 0xff, 0x9b, 0xff, 0x9c, 0xff, 0x9d, 0xff,
+	0x9e, 0xff, 0x9f, 0xff, 0xa0, 0xff, 0xa1, 0xff,
+	0xa2, 0xff, 0xa3, 0xff, 0xa4, 0xff, 0xa5, 0xff,
+	0xa6, 0xff, 0xa7, 0xff, 0xa8, 0xff, 0xa9, 0xff,
+	0xaa, 0xff, 0xab, 0xff, 0xac, 0xff, 0xad, 0xff,
+	0xae, 0xff, 0xaf, 0xff, 0xb0, 0xff, 0xb1, 0xff,
+	0xb2, 0xff, 0xb3, 0xff, 0xb4, 0xff, 0xb5, 0xff,
+	0xb6, 0xff, 0xb7, 0xff, 0xb8, 0xff, 0xb9, 0xff,
+	0xba, 0xff, 0xbb, 0xff, 0xbc, 0xff, 0xbd, 0xff,
+	0xbe, 0xff, 0xbf, 0xff, 0xc0, 0xff, 0xc1, 0xff,
+	0xc2, 0xff, 0xc3, 0xff, 0xc4, 0xff, 0xc5, 0xff,
+	0xc6, 0xff, 0xc7, 0xff, 0xc8, 0xff, 0xc9, 0xff,
+	0xca, 0xff, 0xcb, 0xff, 0xcc, 0xff, 0xcd, 0xff,
+	0xce, 0xff, 0xcf, 0xff, 0xd0, 0xff, 0xd1, 0xff,
+	0xd2, 0xff, 0xd3, 0xff, 0xd4, 0xff, 0xd5, 0xff,
+	0xd6, 0xff, 0xd7, 0xff, 0xd8, 0xff, 0xd9, 0xff,
+	0xda, 0xff, 0xdb, 0xff, 0xdc, 0xff, 0xdd, 0xff,
+	0xde, 0xff, 0xdf, 0xff, 0xe0, 0xff, 0xe1, 0xff,
+	0xe2, 0xff, 0xe3, 0xff, 0xe4, 0xff, 0xe5, 0xff,
+	0xe6, 0xff, 0xe7, 0xff, 0xe8, 0xff, 0xe9, 0xff,
+	0xea, 0xff, 0xeb, 0xff, 0xec, 0xff, 0xed, 0xff,
+	0xee, 0xff, 0xef, 0xff, 0xf0, 0xff, 0xf1, 0xff,
+	0xf2, 0xff, 0xf3, 0xff, 0xf4, 0xff, 0xf5, 0xff,
+	0xf6, 0xff, 0xf7, 0xff, 0xf8, 0xff, 0xf9, 0xff,
+	0xfa, 0xff, 0xfb, 0xff, 0xfc, 0xff, 0xfd, 0xff,
+	0xfe, 0xff, 0xff, 0xff
+};
diff --git a/external/exfat-fuse/mkfs/uctc.h b/external/exfat-fuse/mkfs/uctc.h
new file mode 100755
index 0000000000..c492ec24c4
--- /dev/null
+++ b/external/exfat-fuse/mkfs/uctc.h
@@ -0,0 +1,30 @@
+/*
+	uctc.h (30.10.10)
+	Upper Case Table declaration.
+
+	Free exFAT implementation.
+	Copyright (C) 2011-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#ifndef MKFS_UCTC_H_INCLUDED
+#define MKFS_UCTC_H_INCLUDED
+
+#include <stdint.h>
+
+extern uint8_t upcase_table[5836];
+
+#endif /* ifndef MKFS_UCTC_H_INCLUDED */
diff --git a/external/exfat-fuse/mkfs/vbr.c b/external/exfat-fuse/mkfs/vbr.c
new file mode 100755
index 0000000000..b3889e5540
--- /dev/null
+++ b/external/exfat-fuse/mkfs/vbr.c
@@ -0,0 +1,148 @@
+/*
+	vbr.c (09.11.10)
+	Volume Boot Record creation code.
+
+	Free exFAT implementation.
+	Copyright (C) 2011-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include <string.h>
+#include "vbr.h"
+#include "fat.h"
+#include "cbm.h"
+#include "uct.h"
+#include "rootdir.h"
+
+static off64_t vbr_alignment(void)
+{
+	return get_sector_size();
+}
+
+static off64_t vbr_size(void)
+{
+	return 12 * get_sector_size();
+}
+
+static void init_sb(struct exfat_super_block* sb)
+{
+	uint32_t clusters_max;
+	uint32_t fat_sectors;
+
+	clusters_max = get_volume_size() / get_cluster_size();
+	fat_sectors = DIV_ROUND_UP((off64_t) clusters_max * sizeof(cluster_t),
+			get_sector_size());
+
+	memset(sb, 0, sizeof(struct exfat_super_block));
+	sb->jump[0] = 0xeb;
+	sb->jump[1] = 0x76;
+	sb->jump[2] = 0x90;
+	memcpy(sb->oem_name, "EXFAT   ", sizeof(sb->oem_name));
+	sb->sector_start = cpu_to_le64(get_first_sector());
+	sb->sector_count = cpu_to_le64(get_volume_size() / get_sector_size());
+	sb->fat_sector_start = cpu_to_le32(
+			fat.get_alignment() / get_sector_size());
+	sb->fat_sector_count = cpu_to_le32(ROUND_UP(
+			le32_to_cpu(sb->fat_sector_start) + fat_sectors,
+				1 << get_spc_bits()) -
+			le32_to_cpu(sb->fat_sector_start));
+	sb->cluster_sector_start = cpu_to_le32(
+			get_position(&cbm) / get_sector_size());
+	sb->cluster_count = cpu_to_le32(clusters_max -
+			((le32_to_cpu(sb->fat_sector_start) +
+			  le32_to_cpu(sb->fat_sector_count)) >> get_spc_bits()));
+	sb->rootdir_cluster = cpu_to_le32(
+			(get_position(&rootdir) - get_position(&cbm)) / get_cluster_size()
+			+ EXFAT_FIRST_DATA_CLUSTER);
+	sb->volume_serial = cpu_to_le32(get_volume_serial());
+	sb->version.major = 1;
+	sb->version.minor = 0;
+	sb->volume_state = cpu_to_le16(0);
+	sb->sector_bits = get_sector_bits();
+	sb->spc_bits = get_spc_bits();
+	sb->fat_count = 1;
+	sb->drive_no = 0x80;
+	sb->allocated_percent = 0;
+	sb->boot_signature = cpu_to_le16(0xaa55);
+}
+
+static int vbr_write(struct exfat_dev* dev)
+{
+	struct exfat_super_block sb;
+	uint32_t checksum;
+	le32_t* sector = malloc(get_sector_size());
+	size_t i;
+
+	if (sector == NULL)
+	{
+		exfat_error("failed to allocate sector-sized block of memory");
+		return 1;
+	}
+
+	init_sb(&sb);
+	if (exfat_write(dev, &sb, sizeof(struct exfat_super_block)) < 0)
+	{
+		free(sector);
+		exfat_error("failed to write super block sector");
+		return 1;
+	}
+	checksum = exfat_vbr_start_checksum(&sb, sizeof(struct exfat_super_block));
+
+	memset(sector, 0, get_sector_size());
+	sector[get_sector_size() / sizeof(sector[0]) - 1] =
+			cpu_to_le32(0xaa550000);
+	for (i = 0; i < 8; i++)
+	{
+		if (exfat_write(dev, sector, get_sector_size()) < 0)
+		{
+			free(sector);
+			exfat_error("failed to write a sector with boot signature");
+			return 1;
+		}
+		checksum = exfat_vbr_add_checksum(sector, get_sector_size(), checksum);
+	}
+
+	memset(sector, 0, get_sector_size());
+	for (i = 0; i < 2; i++)
+	{
+		if (exfat_write(dev, sector, get_sector_size()) < 0)
+		{
+			free(sector);
+			exfat_error("failed to write an empty sector");
+			return 1;
+		}
+		checksum = exfat_vbr_add_checksum(sector, get_sector_size(), checksum);
+	}
+
+	for (i = 0; i < get_sector_size() / sizeof(sector[0]); i++)
+		sector[i] = cpu_to_le32(checksum);
+	if (exfat_write(dev, sector, get_sector_size()) < 0)
+	{
+		free(sector);
+		exfat_error("failed to write checksum sector");
+		return 1;
+	}
+
+	free(sector);
+	return 0;
+}
+
+const struct fs_object vbr =
+{
+	.get_alignment = vbr_alignment,
+	.get_size = vbr_size,
+	.write = vbr_write,
+};
diff --git a/external/exfat-fuse/mkfs/vbr.h b/external/exfat-fuse/mkfs/vbr.h
new file mode 100755
index 0000000000..075938f470
--- /dev/null
+++ b/external/exfat-fuse/mkfs/vbr.h
@@ -0,0 +1,30 @@
+/*
+	vbr.h (09.11.10)
+	Volume Boot Record creation code.
+
+	Free exFAT implementation.
+	Copyright (C) 2011-2014  Andrew Nayenko
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License along
+	with this program; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#ifndef MKFS_VBR_H_INCLUDED
+#define MKFS_VBR_H_INCLUDED
+
+#include "mkexfat.h"
+
+extern const struct fs_object vbr;
+
+#endif /* ifndef MKFS_VBR_H_INCLUDED */
diff --git a/external/fuse/Android.mk b/external/fuse/Android.mk
new file mode 100755
index 0000000000..6437386851
--- /dev/null
+++ b/external/fuse/Android.mk
@@ -0,0 +1,62 @@
+# Copyright (C) 2009 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_CFLAGS := -Wall -O2 -std=c99
+
+LOCAL_SRC_FILES := \
+	buffer.c \
+	cuse_lowlevel.c \
+	fuse.c \
+	fuse_kern_chan.c \
+	fuse_loop.c \
+	fuse_loop_mt.c \
+	fuse_lowlevel.c \
+	fuse_mt.c fuse_opt.c \
+	fuse_session.c \
+	fuse_signals.c \
+	helper.c \
+	mount.c \
+	mount_util.c \
+	ulockmgr.c
+
+LOCAL_C_INCLUDES := \
+	$(LOCAL_PATH)/include
+
+LOCAL_SHARED_LIBRARIES := \
+	libutils libdl
+
+LOCAL_CFLAGS := \
+	-D_FILE_OFFSET_BITS=64 \
+	-DFUSE_USE_VERSION=26 \
+	-Wno-unused-variable \
+	-Wno-sign-compare \
+	-Wno-pointer-sign \
+	-Wno-unused-function \
+	-Wno-unused-parameter \
+	-Wno-unused-variable \
+	-Wno-implicit-function-declaration \
+	-Wno-unused-result \
+	-Wno-address-of-packed-member \
+	-Wno-missing-field-initializers \
+	-Wno-pointer-arith \
+	-Wno-logical-not-parentheses
+
+LOCAL_MODULE := libfuse
+LOCAL_MODULE_TAGS := optional
+
+include $(BUILD_STATIC_LIBRARY)
diff --git a/external/fuse/README b/external/fuse/README
new file mode 100755
index 0000000000..3d1f6f091f
--- /dev/null
+++ b/external/fuse/README
@@ -0,0 +1,12 @@
+Libfuse for Android
+
+FUSE[1] is a framework to develop userspace file systems for linux. Since Android is based on linux, it won't be too difficult to port libfuse to Android.
+
+The main problem of building and running libfuse on Android is that the bionic c library lacks support for pthread_cancel(), which is necessary for libfuse multi-thread code. This stackoverflow entry[2] has suggested a solution, which uses SIGUSR1 as an alternative. It seems to work.
+
+Libfuse can be build with Android NDK[3]. If success, you will get libfuse.a and an example program fusexmp. To run the example, the android kernel should be built with FUSE kernel support.
+
+References:
+[1]. http://fuse.sourceforge.net
+[2]. http://stackoverflow.com/questions/4610086/pthread-cancel-alternatives-in-android-ndk
+[3]. http://developer.android.com/sdk/ndk/index.html
diff --git a/external/fuse/buffer.c b/external/fuse/buffer.c
new file mode 100755
index 0000000000..053e396bc7
--- /dev/null
+++ b/external/fuse/buffer.c
@@ -0,0 +1,318 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2010  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB
+*/
+
+#define _GNU_SOURCE
+
+#include "config.h"
+#include "fuse_i.h"
+#include "fuse_lowlevel.h"
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <assert.h>
+
+size_t fuse_buf_size(const struct fuse_bufvec *bufv)
+{
+	size_t i;
+	size_t size = 0;
+
+	for (i = 0; i < bufv->count; i++) {
+		if (bufv->buf[i].size == SIZE_MAX)
+			size = SIZE_MAX;
+		else
+			size += bufv->buf[i].size;
+	}
+
+	return size;
+}
+
+static size_t min_size(size_t s1, size_t s2)
+{
+	return s1 < s2 ? s1 : s2;
+}
+
+static ssize_t fuse_buf_write(const struct fuse_buf *dst, size_t dst_off,
+			      const struct fuse_buf *src, size_t src_off,
+			      size_t len)
+{
+	ssize_t res = 0;
+	size_t copied = 0;
+
+	while (len) {
+		if (dst->flags & FUSE_BUF_FD_SEEK) {
+			res = pwrite(dst->fd, src->mem + src_off, len,
+				     dst->pos + dst_off);
+		} else {
+			res = write(dst->fd, src->mem + src_off, len);
+		}
+		if (res == -1) {
+			if (!copied)
+				return -errno;
+			break;
+		}
+		if (res == 0)
+			break;
+
+		copied += res;
+		if (!(dst->flags & FUSE_BUF_FD_RETRY))
+			break;
+
+		src_off += res;
+		dst_off += res;
+		len -= res;
+	}
+
+	return copied;
+}
+
+static ssize_t fuse_buf_read(const struct fuse_buf *dst, size_t dst_off,
+			     const struct fuse_buf *src, size_t src_off,
+			     size_t len)
+{
+	ssize_t res = 0;
+	size_t copied = 0;
+
+	while (len) {
+		if (src->flags & FUSE_BUF_FD_SEEK) {
+			res = pread(src->fd, dst->mem + dst_off, len,
+				     src->pos + src_off);
+		} else {
+			res = read(src->fd, dst->mem + dst_off, len);
+		}
+		if (res == -1) {
+			if (!copied)
+				return -errno;
+			break;
+		}
+		if (res == 0)
+			break;
+
+		copied += res;
+		if (!(src->flags & FUSE_BUF_FD_RETRY))
+			break;
+
+		dst_off += res;
+		src_off += res;
+		len -= res;
+	}
+
+	return copied;
+}
+
+static ssize_t fuse_buf_fd_to_fd(const struct fuse_buf *dst, size_t dst_off,
+				 const struct fuse_buf *src, size_t src_off,
+				 size_t len)
+{
+	char buf[4096];
+	struct fuse_buf tmp = {
+		.size = sizeof(buf),
+		.flags = 0,
+	};
+	ssize_t res;
+	size_t copied = 0;
+
+	tmp.mem = buf;
+
+	while (len) {
+		size_t this_len = min_size(tmp.size, len);
+		size_t read_len;
+
+		res = fuse_buf_read(&tmp, 0, src, src_off, this_len);
+		if (res < 0) {
+			if (!copied)
+				return res;
+			break;
+		}
+		if (res == 0)
+			break;
+
+		read_len = res;
+		res = fuse_buf_write(dst, dst_off, &tmp, 0, read_len);
+		if (res < 0) {
+			if (!copied)
+				return res;
+			break;
+		}
+		if (res == 0)
+			break;
+
+		copied += res;
+
+		if (res < this_len)
+			break;
+
+		dst_off += res;
+		src_off += res;
+		len -= res;
+	}
+
+	return copied;
+}
+
+#ifdef HAVE_SPLICE
+static ssize_t fuse_buf_splice(const struct fuse_buf *dst, size_t dst_off,
+			       const struct fuse_buf *src, size_t src_off,
+			       size_t len, enum fuse_buf_copy_flags flags)
+{
+	int splice_flags = 0;
+	off64_t *srcpos = NULL;
+	off64_t *dstpos = NULL;
+	off64_t srcpos_val;
+	off64_t dstpos_val;
+	ssize_t res;
+	size_t copied = 0;
+
+	if (flags & FUSE_BUF_SPLICE_MOVE)
+		splice_flags |= SPLICE_F_MOVE;
+	if (flags & FUSE_BUF_SPLICE_NONBLOCK)
+		splice_flags |= SPLICE_F_NONBLOCK;
+
+	if (src->flags & FUSE_BUF_FD_SEEK) {
+		srcpos_val = src->pos + src_off;
+		srcpos = &srcpos_val;
+	}
+	if (dst->flags & FUSE_BUF_FD_SEEK) {
+		dstpos_val = dst->pos + dst_off;
+		dstpos = &dstpos_val;
+	}
+
+	while (len) {
+		res = splice(src->fd, srcpos, dst->fd, dstpos, len,
+			     splice_flags);
+		if (res == -1) {
+			if (copied)
+				break;
+
+			if (errno != EINVAL || (flags & FUSE_BUF_FORCE_SPLICE))
+				return -errno;
+
+			/* Maybe splice is not supported for this combination */
+			return fuse_buf_fd_to_fd(dst, dst_off, src, src_off,
+						 len);
+		}
+		if (res == 0)
+			break;
+
+		copied += res;
+		if (!(src->flags & FUSE_BUF_FD_RETRY) &&
+		    !(dst->flags & FUSE_BUF_FD_RETRY)) {
+			break;
+		}
+
+		len -= res;
+	}
+
+	return copied;
+}
+#else
+static ssize_t fuse_buf_splice(const struct fuse_buf *dst, size_t dst_off,
+			       const struct fuse_buf *src, size_t src_off,
+			       size_t len, enum fuse_buf_copy_flags flags)
+{
+	(void) flags;
+
+	return fuse_buf_fd_to_fd(dst, dst_off, src, src_off, len);
+}
+#endif
+
+
+static ssize_t fuse_buf_copy_one(const struct fuse_buf *dst, size_t dst_off,
+				 const struct fuse_buf *src, size_t src_off,
+				 size_t len, enum fuse_buf_copy_flags flags)
+{
+	int src_is_fd = src->flags & FUSE_BUF_IS_FD;
+	int dst_is_fd = dst->flags & FUSE_BUF_IS_FD;
+
+	if (!src_is_fd && !dst_is_fd) {
+		void *dstmem = dst->mem + dst_off;
+		void *srcmem = src->mem + src_off;
+
+		if (dstmem != srcmem) {
+			if (dstmem + len <= srcmem || srcmem + len <= dstmem)
+				memcpy(dstmem, srcmem, len);
+			else
+				memmove(dstmem, srcmem, len);
+		}
+
+		return len;
+	} else if (!src_is_fd) {
+		return fuse_buf_write(dst, dst_off, src, src_off, len);
+	} else if (!dst_is_fd) {
+		return fuse_buf_read(dst, dst_off, src, src_off, len);
+	} else if (flags & FUSE_BUF_NO_SPLICE) {
+		return fuse_buf_fd_to_fd(dst, dst_off, src, src_off, len);
+	} else {
+		return fuse_buf_splice(dst, dst_off, src, src_off, len, flags);
+	}
+}
+
+static const struct fuse_buf *fuse_bufvec_current(struct fuse_bufvec *bufv)
+{
+	if (bufv->idx < bufv->count)
+		return &bufv->buf[bufv->idx];
+	else
+		return NULL;
+}
+
+static int fuse_bufvec_advance(struct fuse_bufvec *bufv, size_t len)
+{
+	const struct fuse_buf *buf = fuse_bufvec_current(bufv);
+
+	bufv->off += len;
+	assert(bufv->off <= buf->size);
+	if (bufv->off == buf->size) {
+		assert(bufv->idx < bufv->count);
+		bufv->idx++;
+		if (bufv->idx == bufv->count)
+			return 0;
+		bufv->off = 0;
+	}
+	return 1;
+}
+
+ssize_t fuse_buf_copy(struct fuse_bufvec *dstv, struct fuse_bufvec *srcv,
+		      enum fuse_buf_copy_flags flags)
+{
+	size_t copied = 0;
+
+	if (dstv == srcv)
+		return fuse_buf_size(dstv);
+
+	for (;;) {
+		const struct fuse_buf *src = fuse_bufvec_current(srcv);
+		const struct fuse_buf *dst = fuse_bufvec_current(dstv);
+		size_t src_len;
+		size_t dst_len;
+		size_t len;
+		ssize_t res;
+
+		if (src == NULL || dst == NULL)
+			break;
+
+		src_len = src->size - srcv->off;
+		dst_len = dst->size - dstv->off;
+		len = min_size(src_len, dst_len);
+
+		res = fuse_buf_copy_one(dst, dstv->off, src, srcv->off, len, flags);
+		if (res < 0) {
+			if (!copied)
+				return res;
+			break;
+		}
+		copied += res;
+
+		if (!fuse_bufvec_advance(srcv, res) ||
+		    !fuse_bufvec_advance(dstv, res))
+			break;
+
+		if (res < len)
+			break;
+	}
+
+	return copied;
+}
diff --git a/external/fuse/cuse_lowlevel.c b/external/fuse/cuse_lowlevel.c
new file mode 100755
index 0000000000..be49ad4738
--- /dev/null
+++ b/external/fuse/cuse_lowlevel.c
@@ -0,0 +1,371 @@
+/*
+  CUSE: Character device in Userspace
+  Copyright (C) 2008       SUSE Linux Products GmbH
+  Copyright (C) 2008       Tejun Heo <teheo@suse.de>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB.
+*/
+
+#include "cuse_lowlevel.h"
+#include "fuse_kernel.h"
+#include "fuse_i.h"
+#include "fuse_opt.h"
+#include "fuse_misc.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <errno.h>
+#include <unistd.h>
+
+struct cuse_data {
+	struct cuse_lowlevel_ops	clop;
+	unsigned			max_read;
+	unsigned			dev_major;
+	unsigned			dev_minor;
+	unsigned			flags;
+	unsigned			dev_info_len;
+	char				dev_info[];
+};
+
+static struct cuse_lowlevel_ops *req_clop(fuse_req_t req)
+{
+	return &req->f->cuse_data->clop;
+}
+
+static void cuse_fll_open(fuse_req_t req, fuse_ino_t ino,
+			  struct fuse_file_info *fi)
+{
+	(void)ino;
+	req_clop(req)->open(req, fi);
+}
+
+static void cuse_fll_read(fuse_req_t req, fuse_ino_t ino, size_t size,
+			  off64_t off, struct fuse_file_info *fi)
+{
+	(void)ino;
+	req_clop(req)->read(req, size, off, fi);
+}
+
+static void cuse_fll_write(fuse_req_t req, fuse_ino_t ino, const char *buf,
+			   size_t size, off64_t off, struct fuse_file_info *fi)
+{
+	(void)ino;
+	req_clop(req)->write(req, buf, size, off, fi);
+}
+
+static void cuse_fll_flush(fuse_req_t req, fuse_ino_t ino,
+			   struct fuse_file_info *fi)
+{
+	(void)ino;
+	req_clop(req)->flush(req, fi);
+}
+
+static void cuse_fll_release(fuse_req_t req, fuse_ino_t ino,
+			     struct fuse_file_info *fi)
+{
+	(void)ino;
+	req_clop(req)->release(req, fi);
+}
+
+static void cuse_fll_fsync(fuse_req_t req, fuse_ino_t ino, int datasync,
+			   struct fuse_file_info *fi)
+{
+	(void)ino;
+	req_clop(req)->fsync(req, datasync, fi);
+}
+
+static void cuse_fll_ioctl(fuse_req_t req, fuse_ino_t ino, int cmd, void *arg,
+		       struct fuse_file_info *fi, unsigned int flags,
+		       const void *in_buf, size_t in_bufsz, size_t out_bufsz)
+{
+	(void)ino;
+	req_clop(req)->ioctl(req, cmd, arg, fi, flags, in_buf, in_bufsz,
+			     out_bufsz);
+}
+
+static void cuse_fll_poll(fuse_req_t req, fuse_ino_t ino,
+			  struct fuse_file_info *fi, struct fuse_pollhandle *ph)
+{
+	(void)ino;
+	req_clop(req)->poll(req, fi, ph);
+}
+
+static size_t cuse_pack_info(int argc, const char **argv, char *buf)
+{
+	size_t size = 0;
+	int i;
+
+	for (i = 0; i < argc; i++) {
+		size_t len;
+
+		len = strlen(argv[i]) + 1;
+		size += len;
+		if (buf) {
+			memcpy(buf, argv[i], len);
+			buf += len;
+		}
+	}
+
+	return size;
+}
+
+static struct cuse_data *cuse_prep_data(const struct cuse_info *ci,
+					const struct cuse_lowlevel_ops *clop)
+{
+	struct cuse_data *cd;
+	size_t dev_info_len;
+
+	dev_info_len = cuse_pack_info(ci->dev_info_argc, ci->dev_info_argv,
+				      NULL);
+
+	if (dev_info_len > CUSE_INIT_INFO_MAX) {
+		fprintf(stderr, "cuse: dev_info (%zu) too large, limit=%u\n",
+			dev_info_len, CUSE_INIT_INFO_MAX);
+		return NULL;
+	}
+
+	cd = calloc(1, sizeof(*cd) + dev_info_len);
+	if (!cd) {
+		fprintf(stderr, "cuse: failed to allocate cuse_data\n");
+		return NULL;
+	}
+
+	memcpy(&cd->clop, clop, sizeof(cd->clop));
+	cd->max_read = 131072;
+	cd->dev_major = ci->dev_major;
+	cd->dev_minor = ci->dev_minor;
+	cd->dev_info_len = dev_info_len;
+	cd->flags = ci->flags;
+	cuse_pack_info(ci->dev_info_argc, ci->dev_info_argv, cd->dev_info);
+
+	return cd;
+}
+
+struct fuse_session *cuse_lowlevel_new(struct fuse_args *args,
+				       const struct cuse_info *ci,
+				       const struct cuse_lowlevel_ops *clop,
+				       void *userdata)
+{
+	struct fuse_lowlevel_ops lop;
+	struct cuse_data *cd;
+	struct fuse_session *se;
+	struct fuse_ll *ll;
+
+	cd = cuse_prep_data(ci, clop);
+	if (!cd)
+		return NULL;
+
+	memset(&lop, 0, sizeof(lop));
+	lop.init	= clop->init;
+	lop.destroy	= clop->destroy;
+	lop.open	= clop->open		? cuse_fll_open		: NULL;
+	lop.read	= clop->read		? cuse_fll_read		: NULL;
+	lop.write	= clop->write		? cuse_fll_write	: NULL;
+	lop.flush	= clop->flush		? cuse_fll_flush	: NULL;
+	lop.release	= clop->release		? cuse_fll_release	: NULL;
+	lop.fsync	= clop->fsync		? cuse_fll_fsync	: NULL;
+	lop.ioctl	= clop->ioctl		? cuse_fll_ioctl	: NULL;
+	lop.poll	= clop->poll		? cuse_fll_poll		: NULL;
+
+	se = fuse_lowlevel_new_common(args, &lop, sizeof(lop), userdata);
+	if (!se) {
+		free(cd);
+		return NULL;
+	}
+	ll = se->data;
+	ll->cuse_data = cd;
+
+	return se;
+}
+
+static int cuse_reply_init(fuse_req_t req, struct cuse_init_out *arg,
+			   char *dev_info, unsigned dev_info_len)
+{
+	struct iovec iov[3];
+
+	iov[1].iov_base = arg;
+	iov[1].iov_len = sizeof(struct cuse_init_out);
+	iov[2].iov_base = dev_info;
+	iov[2].iov_len = dev_info_len;
+
+	return fuse_send_reply_iov_nofree(req, 0, iov, 3);
+}
+
+void cuse_lowlevel_init(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_init_in *arg = (struct fuse_init_in *) inarg;
+	struct cuse_init_out outarg;
+	struct fuse_ll *f = req->f;
+	struct cuse_data *cd = f->cuse_data;
+	size_t bufsize = fuse_chan_bufsize(req->ch);
+	struct cuse_lowlevel_ops *clop = req_clop(req);
+
+	(void) nodeid;
+	if (f->debug) {
+		fprintf(stderr, "CUSE_INIT: %u.%u\n", arg->major, arg->minor);
+		fprintf(stderr, "flags=0x%08x\n", arg->flags);
+	}
+	f->conn.proto_major = arg->major;
+	f->conn.proto_minor = arg->minor;
+	f->conn.capable = 0;
+	f->conn.want = 0;
+
+	if (arg->major < 7) {
+		fprintf(stderr, "cuse: unsupported protocol version: %u.%u\n",
+			arg->major, arg->minor);
+		fuse_reply_err(req, EPROTO);
+		return;
+	}
+
+	if (bufsize < FUSE_MIN_READ_BUFFER) {
+		fprintf(stderr, "cuse: warning: buffer size too small: %zu\n",
+			bufsize);
+		bufsize = FUSE_MIN_READ_BUFFER;
+	}
+
+	bufsize -= 4096;
+	if (bufsize < f->conn.max_write)
+		f->conn.max_write = bufsize;
+
+	f->got_init = 1;
+	if (f->op.init)
+		f->op.init(f->userdata, &f->conn);
+
+	memset(&outarg, 0, sizeof(outarg));
+	outarg.major = FUSE_KERNEL_VERSION;
+	outarg.minor = FUSE_KERNEL_MINOR_VERSION;
+	outarg.flags = cd->flags;
+	outarg.max_read = cd->max_read;
+	outarg.max_write = f->conn.max_write;
+	outarg.dev_major = cd->dev_major;
+	outarg.dev_minor = cd->dev_minor;
+
+	if (f->debug) {
+		fprintf(stderr, "   CUSE_INIT: %u.%u\n",
+			outarg.major, outarg.minor);
+		fprintf(stderr, "   flags=0x%08x\n", outarg.flags);
+		fprintf(stderr, "   max_read=0x%08x\n", outarg.max_read);
+		fprintf(stderr, "   max_write=0x%08x\n", outarg.max_write);
+		fprintf(stderr, "   dev_major=%u\n", outarg.dev_major);
+		fprintf(stderr, "   dev_minor=%u\n", outarg.dev_minor);
+		fprintf(stderr, "   dev_info: %.*s\n", cd->dev_info_len,
+			cd->dev_info);
+	}
+
+	cuse_reply_init(req, &outarg, cd->dev_info, cd->dev_info_len);
+
+	if (clop->init_done)
+		clop->init_done(f->userdata);
+
+	fuse_free_req(req);
+}
+
+struct fuse_session *cuse_lowlevel_setup(int argc, char *argv[],
+					 const struct cuse_info *ci,
+					 const struct cuse_lowlevel_ops *clop,
+					 int *multithreaded, void *userdata)
+{
+	const char *devname = "/dev/cuse";
+	static const struct fuse_opt kill_subtype_opts[] = {
+		FUSE_OPT_KEY("subtype=",  FUSE_OPT_KEY_DISCARD),
+		FUSE_OPT_END
+	};
+	struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
+	struct fuse_session *se;
+	struct fuse_chan *ch;
+	int fd;
+	int foreground;
+	int res;
+
+	res = fuse_parse_cmdline(&args, NULL, multithreaded, &foreground);
+	if (res == -1)
+		goto err_args;
+
+	res = fuse_opt_parse(&args, NULL, kill_subtype_opts, NULL);
+	if (res == -1)
+		goto err_args;
+
+	/*
+	 * Make sure file descriptors 0, 1 and 2 are open, otherwise chaos
+	 * would ensue.
+	 */
+	do {
+		fd = open("/dev/null", O_RDWR);
+		if (fd > 2)
+			close(fd);
+	} while (fd >= 0 && fd <= 2);
+
+	se = cuse_lowlevel_new(&args, ci, clop, userdata);
+	fuse_opt_free_args(&args);
+	if (se == NULL)
+		goto err_args;
+
+	fd = open(devname, O_RDWR);
+	if (fd == -1) {
+		if (errno == ENODEV || errno == ENOENT)
+			fprintf(stderr, "cuse: device not found, try 'modprobe cuse' first\n");
+		else
+			fprintf(stderr, "cuse: failed to open %s: %s\n",
+				devname, strerror(errno));
+		goto err_se;
+	}
+
+	ch = fuse_kern_chan_new(fd);
+	if (!ch) {
+		close(fd);
+		goto err_se;
+	}
+
+	fuse_session_add_chan(se, ch);
+
+	res = fuse_set_signal_handlers(se);
+	if (res == -1)
+		goto err_se;
+
+	res = fuse_daemonize(foreground);
+	if (res == -1)
+		goto err_sig;
+
+	return se;
+
+err_sig:
+	fuse_remove_signal_handlers(se);
+err_se:
+	fuse_session_destroy(se);
+err_args:
+	fuse_opt_free_args(&args);
+	return NULL;
+}
+
+void cuse_lowlevel_teardown(struct fuse_session *se)
+{
+	fuse_remove_signal_handlers(se);
+	fuse_session_destroy(se);
+}
+
+int cuse_lowlevel_main(int argc, char *argv[], const struct cuse_info *ci,
+		       const struct cuse_lowlevel_ops *clop, void *userdata)
+{
+	struct fuse_session *se;
+	int multithreaded;
+	int res;
+
+	se = cuse_lowlevel_setup(argc, argv, ci, clop, &multithreaded,
+				 userdata);
+	if (se == NULL)
+		return 1;
+
+	if (multithreaded)
+		res = fuse_session_loop_mt(se);
+	else
+		res = fuse_session_loop(se);
+
+	cuse_lowlevel_teardown(se);
+	if (res == -1)
+		return 1;
+
+	return 0;
+}
diff --git a/external/fuse/fuse.c b/external/fuse/fuse.c
new file mode 100755
index 0000000000..753773a886
--- /dev/null
+++ b/external/fuse/fuse.c
@@ -0,0 +1,4890 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB
+*/
+
+
+/* For pthread_rwlock_t */
+#define _GNU_SOURCE
+
+#include "config.h"
+#include "fuse_i.h"
+#include "fuse_lowlevel.h"
+#include "fuse_opt.h"
+#include "fuse_misc.h"
+#include "fuse_common_compat.h"
+#include "fuse_compat.h"
+#include "fuse_kernel.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <stdbool.h>
+#include <unistd.h>
+#include <time.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <errno.h>
+#include <signal.h>
+#include <dlfcn.h>
+#include <assert.h>
+#include <poll.h>
+#include <sys/param.h>
+#include <sys/uio.h>
+#include <sys/time.h>
+#include <sys/mman.h>
+#if defined(__ANDROID__)
+extern int pthread_cancel(pthread_t thread);
+extern int pthread_setcancelstate(int state, int *oldstate);
+#endif
+
+#define FUSE_NODE_SLAB 1
+
+#ifndef MAP_ANONYMOUS
+#undef FUSE_NODE_SLAB
+#endif
+
+#define FUSE_DEFAULT_INTR_SIGNAL SIGUSR1
+
+#define FUSE_UNKNOWN_INO 0xffffffff
+#define OFFSET_MAX 0x7fffffffffffffffLL
+
+#define NODE_TABLE_MIN_SIZE 8192
+
+struct fuse_config {
+	unsigned int uid;
+	unsigned int gid;
+	unsigned int  umask;
+	double entry_timeout;
+	double negative_timeout;
+	double attr_timeout;
+	double ac_attr_timeout;
+	int ac_attr_timeout_set;
+	int remember;
+	int nopath;
+	int debug;
+	int hard_remove;
+	int use_ino;
+	int readdir_ino;
+	int set_mode;
+	int set_uid;
+	int set_gid;
+	int direct_io;
+	int kernel_cache;
+	int auto_cache;
+	int intr;
+	int intr_signal;
+	int help;
+	char *modules;
+};
+
+struct fuse_fs {
+	struct fuse_operations op;
+	struct fuse_module *m;
+	void *user_data;
+	int compat;
+	int debug;
+};
+
+struct fusemod_so {
+	void *handle;
+	int ctr;
+};
+
+struct lock_queue_element {
+	struct lock_queue_element *next;
+	pthread_cond_t cond;
+	fuse_ino_t nodeid1;
+	const char *name1;
+	char **path1;
+	struct node **wnode1;
+	fuse_ino_t nodeid2;
+	const char *name2;
+	char **path2;
+	struct node **wnode2;
+	int err;
+	bool first_locked : 1;
+	bool second_locked : 1;
+	bool done : 1;
+};
+
+struct node_table {
+	struct node **array;
+	size_t use;
+	size_t size;
+	size_t split;
+};
+
+#define container_of(ptr, type, member) ({                              \
+                        const typeof( ((type *)0)->member ) *__mptr = (ptr); \
+                        (type *)( (char *)__mptr - offsetof(type,member) );})
+
+#define list_entry(ptr, type, member)           \
+        container_of(ptr, type, member)
+
+struct list_head {
+	struct list_head *next;
+	struct list_head *prev;
+};
+
+struct node_slab {
+	struct list_head list;  /* must be the first member */
+	struct list_head freelist;
+	int used;
+};
+
+struct fuse {
+	struct fuse_session *se;
+	struct node_table name_table;
+	struct node_table id_table;
+	struct list_head lru_table;
+	fuse_ino_t ctr;
+	unsigned int generation;
+	unsigned int hidectr;
+	pthread_mutex_t lock;
+	struct fuse_config conf;
+	int intr_installed;
+	struct fuse_fs *fs;
+	int nullpath_ok;
+	int utime_omit_ok;
+	struct lock_queue_element *lockq;
+	int pagesize;
+	struct list_head partial_slabs;
+	struct list_head full_slabs;
+	pthread_t prune_thread;
+};
+
+struct lock {
+	int type;
+	off64_t start;
+	off64_t end;
+	pid_t pid;
+	uint64_t owner;
+	struct lock *next;
+};
+
+struct node {
+	struct node *name_next;
+	struct node *id_next;
+	fuse_ino_t nodeid;
+	unsigned int generation;
+	int refctr;
+	struct node *parent;
+	char *name;
+	uint64_t nlookup;
+	int open_count;
+	struct timespec stat_updated;
+	struct timespec mtime;
+	off64_t size;
+	struct lock *locks;
+	unsigned int is_hidden : 1;
+	unsigned int cache_valid : 1;
+	int treelock;
+	char inline_name[32];
+};
+
+#define TREELOCK_WRITE -1
+#define TREELOCK_WAIT_OFFSET INT_MIN
+
+struct node_lru {
+	struct node node;
+	struct list_head lru;
+	struct timespec forget_time;
+};
+
+struct fuse_dh {
+	pthread_mutex_t lock;
+	struct fuse *fuse;
+	fuse_req_t req;
+	char *contents;
+	int allocated;
+	unsigned len;
+	unsigned size;
+	unsigned needlen;
+	int filled;
+	uint64_t fh;
+	int error;
+	fuse_ino_t nodeid;
+};
+
+/* old dir handle */
+struct fuse_dirhandle {
+	fuse_fill_dir_t filler;
+	void *buf;
+};
+
+struct fuse_context_i {
+	struct fuse_context ctx;
+	fuse_req_t req;
+};
+
+static pthread_key_t fuse_context_key;
+static pthread_mutex_t fuse_context_lock = PTHREAD_MUTEX_INITIALIZER;
+static int fuse_context_ref;
+static struct fusemod_so *fuse_current_so;
+static struct fuse_module *fuse_modules;
+
+static int fuse_load_so_name(const char *soname)
+{
+	struct fusemod_so *so;
+
+	so = calloc(1, sizeof(struct fusemod_so));
+	if (!so) {
+		fprintf(stderr, "fuse: memory allocation failed\n");
+		return -1;
+	}
+
+	fuse_current_so = so;
+	so->handle = dlopen(soname, RTLD_NOW);
+	fuse_current_so = NULL;
+	if (!so->handle) {
+		fprintf(stderr, "fuse: %s\n", dlerror());
+		goto err;
+	}
+	if (!so->ctr) {
+		fprintf(stderr, "fuse: %s did not register any modules\n",
+			soname);
+		goto err;
+	}
+	return 0;
+
+err:
+	if (so->handle)
+		dlclose(so->handle);
+	free(so);
+	return -1;
+}
+
+static int fuse_load_so_module(const char *module)
+{
+	int res;
+	char *soname = malloc(strlen(module) + 64);
+	if (!soname) {
+		fprintf(stderr, "fuse: memory allocation failed\n");
+		return -1;
+	}
+	sprintf(soname, "libfusemod_%s.so", module);
+	res = fuse_load_so_name(soname);
+	free(soname);
+	return res;
+}
+
+static struct fuse_module *fuse_find_module(const char *module)
+{
+	struct fuse_module *m;
+	for (m = fuse_modules; m; m = m->next) {
+		if (strcmp(module, m->name) == 0) {
+			m->ctr++;
+			break;
+		}
+	}
+	return m;
+}
+
+static struct fuse_module *fuse_get_module(const char *module)
+{
+	struct fuse_module *m;
+
+	pthread_mutex_lock(&fuse_context_lock);
+	m = fuse_find_module(module);
+	if (!m) {
+		int err = fuse_load_so_module(module);
+		if (!err)
+			m = fuse_find_module(module);
+	}
+	pthread_mutex_unlock(&fuse_context_lock);
+	return m;
+}
+
+static void fuse_put_module(struct fuse_module *m)
+{
+	pthread_mutex_lock(&fuse_context_lock);
+	assert(m->ctr > 0);
+	m->ctr--;
+	if (!m->ctr && m->so) {
+		struct fusemod_so *so = m->so;
+		assert(so->ctr > 0);
+		so->ctr--;
+		if (!so->ctr) {
+			struct fuse_module **mp;
+			for (mp = &fuse_modules; *mp;) {
+				if ((*mp)->so == so)
+					*mp = (*mp)->next;
+				else
+					mp = &(*mp)->next;
+			}
+			dlclose(so->handle);
+			free(so);
+		}
+	}
+	pthread_mutex_unlock(&fuse_context_lock);
+}
+
+static void init_list_head(struct list_head *list)
+{
+	list->next = list;
+	list->prev = list;
+}
+
+static int list_empty(const struct list_head *head)
+{
+	return head->next == head;
+}
+
+static void list_add(struct list_head *new, struct list_head *prev,
+		     struct list_head *next)
+{
+	next->prev = new;
+	new->next = next;
+	new->prev = prev;
+	prev->next = new;
+}
+
+static inline void list_add_head(struct list_head *new, struct list_head *head)
+{
+	list_add(new, head, head->next);
+}
+
+static inline void list_add_tail(struct list_head *new, struct list_head *head)
+{
+	list_add(new, head->prev, head);
+}
+
+static inline void list_del(struct list_head *entry)
+{
+	struct list_head *prev = entry->prev;
+	struct list_head *next = entry->next;
+
+	next->prev = prev;
+	prev->next = next;
+}
+
+static inline int lru_enabled(struct fuse *f)
+{
+	return f->conf.remember > 0;
+}
+
+static struct node_lru *node_lru(struct node *node)
+{
+	return (struct node_lru *) node;
+}
+
+static size_t get_node_size(struct fuse *f)
+{
+	if (lru_enabled(f))
+		return sizeof(struct node_lru);
+	else
+		return sizeof(struct node);
+}
+
+#ifdef FUSE_NODE_SLAB
+static struct node_slab *list_to_slab(struct list_head *head)
+{
+	return (struct node_slab *) head;
+}
+
+static struct node_slab *node_to_slab(struct fuse *f, struct node *node)
+{
+	return (struct node_slab *) (((uintptr_t) node) & ~((uintptr_t) f->pagesize - 1));
+}
+
+static int alloc_slab(struct fuse *f)
+{
+	void *mem;
+	struct node_slab *slab;
+	char *start;
+	size_t num;
+	size_t i;
+	size_t node_size = get_node_size(f);
+
+	mem = mmap(NULL, f->pagesize, PROT_READ | PROT_WRITE,
+		   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+
+	if (mem == MAP_FAILED)
+		return -1;
+
+	slab = mem;
+	init_list_head(&slab->freelist);
+	slab->used = 0;
+	num = (f->pagesize - sizeof(struct node_slab)) / node_size;
+
+	start = (char *) mem + f->pagesize - num * node_size;
+	for (i = 0; i < num; i++) {
+		struct list_head *n;
+
+		n = (struct list_head *) (start + i * node_size);
+		list_add_tail(n, &slab->freelist);
+	}
+	list_add_tail(&slab->list, &f->partial_slabs);
+
+	return 0;
+}
+
+static struct node *alloc_node(struct fuse *f)
+{
+	struct node_slab *slab;
+	struct list_head *node;
+
+	if (list_empty(&f->partial_slabs)) {
+		int res = alloc_slab(f);
+		if (res != 0)
+			return NULL;
+	}
+	slab = list_to_slab(f->partial_slabs.next);
+	slab->used++;
+	node = slab->freelist.next;
+	list_del(node);
+	if (list_empty(&slab->freelist)) {
+		list_del(&slab->list);
+		list_add_tail(&slab->list, &f->full_slabs);
+	}
+	memset(node, 0, sizeof(struct node));
+
+	return (struct node *) node;
+}
+
+static void free_slab(struct fuse *f, struct node_slab *slab)
+{
+	int res;
+
+	list_del(&slab->list);
+	res = munmap(slab, f->pagesize);
+	if (res == -1)
+		fprintf(stderr, "fuse warning: munmap(%p) failed\n", slab);
+}
+
+static void free_node_mem(struct fuse *f, struct node *node)
+{
+	struct node_slab *slab = node_to_slab(f, node);
+	struct list_head *n = (struct list_head *) node;
+
+	slab->used--;
+	if (slab->used) {
+		if (list_empty(&slab->freelist)) {
+			list_del(&slab->list);
+			list_add_tail(&slab->list, &f->partial_slabs);
+		}
+		list_add_head(n, &slab->freelist);
+	} else {
+		free_slab(f, slab);
+	}
+}
+#else
+static struct node *alloc_node(struct fuse *f)
+{
+	return (struct node *) calloc(1, get_node_size(f));
+}
+
+static void free_node_mem(struct fuse *f, struct node *node)
+{
+	(void) f;
+	free(node);
+}
+#endif
+
+static size_t id_hash(struct fuse *f, fuse_ino_t ino)
+{
+	uint64_t hash = ((uint32_t) ino * 2654435761U) % f->id_table.size;
+	uint64_t oldhash = hash % (f->id_table.size / 2);
+
+	if (oldhash >= f->id_table.split)
+		return oldhash;
+	else
+		return hash;
+}
+
+static struct node *get_node_nocheck(struct fuse *f, fuse_ino_t nodeid)
+{
+	size_t hash = id_hash(f, nodeid);
+	struct node *node;
+
+	for (node = f->id_table.array[hash]; node != NULL; node = node->id_next)
+		if (node->nodeid == nodeid)
+			return node;
+
+	return NULL;
+}
+
+static struct node *get_node(struct fuse *f, fuse_ino_t nodeid)
+{
+	struct node *node = get_node_nocheck(f, nodeid);
+	if (!node) {
+		fprintf(stderr, "fuse internal error: node %llu not found\n",
+			(unsigned long long) nodeid);
+		abort();
+	}
+	return node;
+}
+
+static void curr_time(struct timespec *now);
+static double diff_timespec(const struct timespec *t1,
+			   const struct timespec *t2);
+
+static void remove_node_lru(struct node *node)
+{
+	struct node_lru *lnode = node_lru(node);
+	list_del(&lnode->lru);
+	init_list_head(&lnode->lru);
+}
+
+static void set_forget_time(struct fuse *f, struct node *node)
+{
+	struct node_lru *lnode = node_lru(node);
+
+	list_del(&lnode->lru);
+	list_add_tail(&lnode->lru, &f->lru_table);
+	curr_time(&lnode->forget_time);
+}
+
+static void free_node(struct fuse *f, struct node *node)
+{
+	if (node->name != node->inline_name)
+		free(node->name);
+	free_node_mem(f, node);
+}
+
+static void node_table_reduce(struct node_table *t)
+{
+	size_t newsize = t->size / 2;
+	void *newarray;
+
+	if (newsize < NODE_TABLE_MIN_SIZE)
+		return;
+
+	newarray = realloc(t->array, sizeof(struct node *) * newsize);
+	if (newarray != NULL)
+		t->array = newarray;
+
+	t->size = newsize;
+	t->split = t->size / 2;
+}
+
+static void remerge_id(struct fuse *f)
+{
+	struct node_table *t = &f->id_table;
+	int iter;
+
+	if (t->split == 0)
+		node_table_reduce(t);
+
+	for (iter = 8; t->split > 0 && iter; iter--) {
+		struct node **upper;
+
+		t->split--;
+		upper = &t->array[t->split + t->size / 2];
+		if (*upper) {
+			struct node **nodep;
+
+			for (nodep = &t->array[t->split]; *nodep;
+			     nodep = &(*nodep)->id_next);
+
+			*nodep = *upper;
+			*upper = NULL;
+			break;
+		}
+	}
+}
+
+static void unhash_id(struct fuse *f, struct node *node)
+{
+	struct node **nodep = &f->id_table.array[id_hash(f, node->nodeid)];
+
+	for (; *nodep != NULL; nodep = &(*nodep)->id_next)
+		if (*nodep == node) {
+			*nodep = node->id_next;
+			f->id_table.use--;
+
+			if(f->id_table.use < f->id_table.size / 4)
+				remerge_id(f);
+			return;
+		}
+}
+
+static int node_table_resize(struct node_table *t)
+{
+	size_t newsize = t->size * 2;
+	void *newarray;
+
+	newarray = realloc(t->array, sizeof(struct node *) * newsize);
+	if (newarray == NULL)
+		return -1;
+
+	t->array = newarray;
+	memset(t->array + t->size, 0, t->size * sizeof(struct node *));
+	t->size = newsize;
+	t->split = 0;
+
+	return 0;
+}
+
+static void rehash_id(struct fuse *f)
+{
+	struct node_table *t = &f->id_table;
+	struct node **nodep;
+	struct node **next;
+	size_t hash;
+
+	if (t->split == t->size / 2)
+		return;
+
+	hash = t->split;
+	t->split++;
+	for (nodep = &t->array[hash]; *nodep != NULL; nodep = next) {
+		struct node *node = *nodep;
+		size_t newhash = id_hash(f, node->nodeid);
+
+		if (newhash != hash) {
+			next = nodep;
+			*nodep = node->id_next;
+			node->id_next = t->array[newhash];
+			t->array[newhash] = node;
+		} else {
+			next = &node->id_next;
+		}
+	}
+	if (t->split == t->size / 2)
+		node_table_resize(t);
+}
+
+static void hash_id(struct fuse *f, struct node *node)
+{
+	size_t hash = id_hash(f, node->nodeid);
+	node->id_next = f->id_table.array[hash];
+	f->id_table.array[hash] = node;
+	f->id_table.use++;
+
+	if (f->id_table.use >= f->id_table.size / 2)
+		rehash_id(f);
+}
+
+static size_t name_hash(struct fuse *f, fuse_ino_t parent,
+			const char *name)
+{
+	uint64_t hash = parent;
+	uint64_t oldhash;
+
+	for (; *name; name++)
+		hash = hash * 31 + (unsigned char) *name;
+
+	hash %= f->name_table.size;
+	oldhash = hash % (f->name_table.size / 2);
+	if (oldhash >= f->name_table.split)
+		return oldhash;
+	else
+		return hash;
+}
+
+static void unref_node(struct fuse *f, struct node *node);
+
+static void remerge_name(struct fuse *f)
+{
+	struct node_table *t = &f->name_table;
+	int iter;
+
+	if (t->split == 0)
+		node_table_reduce(t);
+
+	for (iter = 8; t->split > 0 && iter; iter--) {
+		struct node **upper;
+
+		t->split--;
+		upper = &t->array[t->split + t->size / 2];
+		if (*upper) {
+			struct node **nodep;
+
+			for (nodep = &t->array[t->split]; *nodep;
+			     nodep = &(*nodep)->name_next);
+
+			*nodep = *upper;
+			*upper = NULL;
+			break;
+		}
+	}
+}
+
+static void unhash_name(struct fuse *f, struct node *node)
+{
+	if (node->name) {
+		size_t hash = name_hash(f, node->parent->nodeid, node->name);
+		struct node **nodep = &f->name_table.array[hash];
+
+		for (; *nodep != NULL; nodep = &(*nodep)->name_next)
+			if (*nodep == node) {
+				*nodep = node->name_next;
+				node->name_next = NULL;
+				unref_node(f, node->parent);
+				if (node->name != node->inline_name)
+					free(node->name);
+				node->name = NULL;
+				node->parent = NULL;
+				f->name_table.use--;
+
+				if (f->name_table.use < f->name_table.size / 4)
+					remerge_name(f);
+				return;
+			}
+		fprintf(stderr,
+			"fuse internal error: unable to unhash node: %llu\n",
+			(unsigned long long) node->nodeid);
+		abort();
+	}
+}
+
+static void rehash_name(struct fuse *f)
+{
+	struct node_table *t = &f->name_table;
+	struct node **nodep;
+	struct node **next;
+	size_t hash;
+
+	if (t->split == t->size / 2)
+		return;
+
+	hash = t->split;
+	t->split++;
+	for (nodep = &t->array[hash]; *nodep != NULL; nodep = next) {
+		struct node *node = *nodep;
+		size_t newhash = name_hash(f, node->parent->nodeid, node->name);
+
+		if (newhash != hash) {
+			next = nodep;
+			*nodep = node->name_next;
+			node->name_next = t->array[newhash];
+			t->array[newhash] = node;
+		} else {
+			next = &node->name_next;
+		}
+	}
+	if (t->split == t->size / 2)
+		node_table_resize(t);
+}
+
+static int hash_name(struct fuse *f, struct node *node, fuse_ino_t parentid,
+		     const char *name)
+{
+	size_t hash = name_hash(f, parentid, name);
+	struct node *parent = get_node(f, parentid);
+	if (strlen(name) < sizeof(node->inline_name)) {
+		strcpy(node->inline_name, name);
+		node->name = node->inline_name;
+	} else {
+		node->name = strdup(name);
+		if (node->name == NULL)
+			return -1;
+	}
+
+	parent->refctr ++;
+	node->parent = parent;
+	node->name_next = f->name_table.array[hash];
+	f->name_table.array[hash] = node;
+	f->name_table.use++;
+
+	if (f->name_table.use >= f->name_table.size / 2)
+		rehash_name(f);
+
+	return 0;
+}
+
+static void delete_node(struct fuse *f, struct node *node)
+{
+	if (f->conf.debug)
+		fprintf(stderr, "DELETE: %llu\n",
+			(unsigned long long) node->nodeid);
+
+	assert(node->treelock == 0);
+	unhash_name(f, node);
+	if (lru_enabled(f))
+		remove_node_lru(node);
+	unhash_id(f, node);
+	free_node(f, node);
+}
+
+static void unref_node(struct fuse *f, struct node *node)
+{
+	assert(node->refctr > 0);
+	node->refctr --;
+	if (!node->refctr)
+		delete_node(f, node);
+}
+
+static fuse_ino_t next_id(struct fuse *f)
+{
+	do {
+		f->ctr = (f->ctr + 1) & 0xffffffff;
+		if (!f->ctr)
+			f->generation ++;
+	} while (f->ctr == 0 || f->ctr == FUSE_UNKNOWN_INO ||
+		 get_node_nocheck(f, f->ctr) != NULL);
+	return f->ctr;
+}
+
+static struct node *lookup_node(struct fuse *f, fuse_ino_t parent,
+				const char *name)
+{
+	size_t hash = name_hash(f, parent, name);
+	struct node *node;
+
+	for (node = f->name_table.array[hash]; node != NULL; node = node->name_next)
+		if (node->parent->nodeid == parent &&
+		    strcmp(node->name, name) == 0)
+			return node;
+
+	return NULL;
+}
+
+static void inc_nlookup(struct node *node)
+{
+	if (!node->nlookup)
+		node->refctr++;
+	node->nlookup++;
+}
+
+static struct node *find_node(struct fuse *f, fuse_ino_t parent,
+			      const char *name)
+{
+	struct node *node;
+
+	pthread_mutex_lock(&f->lock);
+	if (!name)
+		node = get_node(f, parent);
+	else
+		node = lookup_node(f, parent, name);
+	if (node == NULL) {
+		node = alloc_node(f);
+		if (node == NULL)
+			goto out_err;
+
+		node->nodeid = next_id(f);
+		node->generation = f->generation;
+		if (f->conf.remember)
+			inc_nlookup(node);
+
+		if (hash_name(f, node, parent, name) == -1) {
+			free_node(f, node);
+			node = NULL;
+			goto out_err;
+		}
+		hash_id(f, node);
+		if (lru_enabled(f)) {
+			struct node_lru *lnode = node_lru(node);
+			init_list_head(&lnode->lru);
+		}
+	} else if (lru_enabled(f) && node->nlookup == 1) {
+		remove_node_lru(node);
+	}
+	inc_nlookup(node);
+out_err:
+	pthread_mutex_unlock(&f->lock);
+	return node;
+}
+
+static char *add_name(char **buf, unsigned *bufsize, char *s, const char *name)
+{
+	size_t len = strlen(name);
+
+	if (s - len <= *buf) {
+		unsigned pathlen = *bufsize - (s - *buf);
+		unsigned newbufsize = *bufsize;
+		char *newbuf;
+
+		while (newbufsize < pathlen + len + 1) {
+			if (newbufsize >= 0x80000000)
+				newbufsize = 0xffffffff;
+			else
+				newbufsize *= 2;
+		}
+
+		newbuf = realloc(*buf, newbufsize);
+		if (newbuf == NULL)
+			return NULL;
+
+		*buf = newbuf;
+		s = newbuf + newbufsize - pathlen;
+		memmove(s, newbuf + *bufsize - pathlen, pathlen);
+		*bufsize = newbufsize;
+	}
+	s -= len;
+	strncpy(s, name, len);
+	s--;
+	*s = '/';
+
+	return s;
+}
+
+static void unlock_path(struct fuse *f, fuse_ino_t nodeid, struct node *wnode,
+			struct node *end)
+{
+	struct node *node;
+
+	if (wnode) {
+		assert(wnode->treelock == TREELOCK_WRITE);
+		wnode->treelock = 0;
+	}
+
+	for (node = get_node(f, nodeid);
+	     node != end && node->nodeid != FUSE_ROOT_ID; node = node->parent) {
+		assert(node->treelock != 0);
+		assert(node->treelock != TREELOCK_WAIT_OFFSET);
+		assert(node->treelock != TREELOCK_WRITE);
+		node->treelock--;
+		if (node->treelock == TREELOCK_WAIT_OFFSET)
+			node->treelock = 0;
+	}
+}
+
+static int try_get_path(struct fuse *f, fuse_ino_t nodeid, const char *name,
+			char **path, struct node **wnodep, bool need_lock)
+{
+	unsigned bufsize = 256;
+	char *buf;
+	char *s;
+	struct node *node;
+	struct node *wnode = NULL;
+	int err;
+
+	*path = NULL;
+
+	err = -ENOMEM;
+	buf = malloc(bufsize);
+	if (buf == NULL)
+		goto out_err;
+
+	s = buf + bufsize - 1;
+	*s = '\0';
+
+	if (name != NULL) {
+		s = add_name(&buf, &bufsize, s, name);
+		err = -ENOMEM;
+		if (s == NULL)
+			goto out_free;
+	}
+
+	if (wnodep) {
+		assert(need_lock);
+		wnode = lookup_node(f, nodeid, name);
+		if (wnode) {
+			if (wnode->treelock != 0) {
+				if (wnode->treelock > 0)
+					wnode->treelock += TREELOCK_WAIT_OFFSET;
+				err = -EAGAIN;
+				goto out_free;
+			}
+			wnode->treelock = TREELOCK_WRITE;
+		}
+	}
+
+	for (node = get_node(f, nodeid); node->nodeid != FUSE_ROOT_ID;
+	     node = node->parent) {
+		err = -ENOENT;
+		if (node->name == NULL || node->parent == NULL)
+			goto out_unlock;
+
+		err = -ENOMEM;
+		s = add_name(&buf, &bufsize, s, node->name);
+		if (s == NULL)
+			goto out_unlock;
+
+		if (need_lock) {
+			err = -EAGAIN;
+			if (node->treelock < 0)
+				goto out_unlock;
+
+			node->treelock++;
+		}
+	}
+
+	if (s[0])
+		memmove(buf, s, bufsize - (s - buf));
+	else
+		strcpy(buf, "/");
+
+	*path = buf;
+	if (wnodep)
+		*wnodep = wnode;
+
+	return 0;
+
+ out_unlock:
+	if (need_lock)
+		unlock_path(f, nodeid, wnode, node);
+ out_free:
+	free(buf);
+
+ out_err:
+	return err;
+}
+
+static void queue_element_unlock(struct fuse *f, struct lock_queue_element *qe)
+{
+	struct node *wnode;
+
+	if (qe->first_locked) {
+		wnode = qe->wnode1 ? *qe->wnode1 : NULL;
+		unlock_path(f, qe->nodeid1, wnode, NULL);
+	}
+	if (qe->second_locked) {
+		wnode = qe->wnode2 ? *qe->wnode2 : NULL;
+		unlock_path(f, qe->nodeid2, wnode, NULL);
+	}
+}
+
+static void queue_element_wakeup(struct fuse *f, struct lock_queue_element *qe)
+{
+	int err;
+	bool first = (qe == f->lockq);
+
+	if (!qe->path1) {
+		/* Just waiting for it to be unlocked */
+		if (get_node(f, qe->nodeid1)->treelock == 0)
+			pthread_cond_signal(&qe->cond);
+
+		return;
+	}
+
+	if (!qe->first_locked) {
+		err = try_get_path(f, qe->nodeid1, qe->name1, qe->path1,
+				   qe->wnode1, true);
+		if (!err)
+			qe->first_locked = true;
+		else if (err != -EAGAIN)
+			goto err_unlock;
+	}
+	if (!qe->second_locked && qe->path2) {
+		err = try_get_path(f, qe->nodeid2, qe->name2, qe->path2,
+				   qe->wnode2, true);
+		if (!err)
+			qe->second_locked = true;
+		else if (err != -EAGAIN)
+			goto err_unlock;
+	}
+
+	if (qe->first_locked && (qe->second_locked || !qe->path2)) {
+		err = 0;
+		goto done;
+	}
+
+	/*
+	 * Only let the first element be partially locked otherwise there could
+	 * be a deadlock.
+	 *
+	 * But do allow the first element to be partially locked to prevent
+	 * starvation.
+	 */
+	if (!first)
+		queue_element_unlock(f, qe);
+
+	/* keep trying */
+	return;
+
+err_unlock:
+	queue_element_unlock(f, qe);
+done:
+	qe->err = err;
+	qe->done = true;
+	pthread_cond_signal(&qe->cond);
+}
+
+static void wake_up_queued(struct fuse *f)
+{
+	struct lock_queue_element *qe;
+
+	for (qe = f->lockq; qe != NULL; qe = qe->next)
+		queue_element_wakeup(f, qe);
+}
+
+static void debug_path(struct fuse *f, const char *msg, fuse_ino_t nodeid,
+		       const char *name, bool wr)
+{
+	if (f->conf.debug) {
+		struct node *wnode = NULL;
+
+		if (wr)
+			wnode = lookup_node(f, nodeid, name);
+
+		if (wnode)
+			fprintf(stderr, "%s %li (w)\n",	msg, wnode->nodeid);
+		else
+			fprintf(stderr, "%s %li\n", msg, nodeid);
+	}
+}
+
+static void queue_path(struct fuse *f, struct lock_queue_element *qe)
+{
+	struct lock_queue_element **qp;
+
+	qe->done = false;
+	qe->first_locked = false;
+	qe->second_locked = false;
+	pthread_cond_init(&qe->cond, NULL);
+	qe->next = NULL;
+	for (qp = &f->lockq; *qp != NULL; qp = &(*qp)->next);
+	*qp = qe;
+}
+
+static void dequeue_path(struct fuse *f, struct lock_queue_element *qe)
+{
+	struct lock_queue_element **qp;
+
+	pthread_cond_destroy(&qe->cond);
+	for (qp = &f->lockq; *qp != qe; qp = &(*qp)->next);
+	*qp = qe->next;
+}
+
+static int wait_path(struct fuse *f, struct lock_queue_element *qe)
+{
+	queue_path(f, qe);
+
+	do {
+		pthread_cond_wait(&qe->cond, &f->lock);
+	} while (!qe->done);
+
+	dequeue_path(f, qe);
+
+	return qe->err;
+}
+
+static int get_path_common(struct fuse *f, fuse_ino_t nodeid, const char *name,
+			   char **path, struct node **wnode)
+{
+	int err;
+
+	pthread_mutex_lock(&f->lock);
+	err = try_get_path(f, nodeid, name, path, wnode, true);
+	if (err == -EAGAIN) {
+		struct lock_queue_element qe = {
+			.nodeid1 = nodeid,
+			.name1 = name,
+			.path1 = path,
+			.wnode1 = wnode,
+		};
+		debug_path(f, "QUEUE PATH", nodeid, name, !!wnode);
+		err = wait_path(f, &qe);
+		debug_path(f, "DEQUEUE PATH", nodeid, name, !!wnode);
+	}
+	pthread_mutex_unlock(&f->lock);
+
+	return err;
+}
+
+static int get_path(struct fuse *f, fuse_ino_t nodeid, char **path)
+{
+	return get_path_common(f, nodeid, NULL, path, NULL);
+}
+
+static int get_path_nullok(struct fuse *f, fuse_ino_t nodeid, char **path)
+{
+	int err = 0;
+
+	if (f->conf.nopath) {
+		*path = NULL;
+	} else {
+		err = get_path_common(f, nodeid, NULL, path, NULL);
+		if (err == -ENOENT && f->nullpath_ok)
+			err = 0;
+	}
+
+	return err;
+}
+
+static int get_path_name(struct fuse *f, fuse_ino_t nodeid, const char *name,
+			 char **path)
+{
+	return get_path_common(f, nodeid, name, path, NULL);
+}
+
+static int get_path_wrlock(struct fuse *f, fuse_ino_t nodeid, const char *name,
+			   char **path, struct node **wnode)
+{
+	return get_path_common(f, nodeid, name, path, wnode);
+}
+
+static int try_get_path2(struct fuse *f, fuse_ino_t nodeid1, const char *name1,
+			 fuse_ino_t nodeid2, const char *name2,
+			 char **path1, char **path2,
+			 struct node **wnode1, struct node **wnode2)
+{
+	int err;
+
+	/* FIXME: locking two paths needs deadlock checking */
+	err = try_get_path(f, nodeid1, name1, path1, wnode1, true);
+	if (!err) {
+		err = try_get_path(f, nodeid2, name2, path2, wnode2, true);
+		if (err) {
+			struct node *wn1 = wnode1 ? *wnode1 : NULL;
+
+			unlock_path(f, nodeid1, wn1, NULL);
+			free(*path1);
+		}
+	}
+	return err;
+}
+
+static int get_path2(struct fuse *f, fuse_ino_t nodeid1, const char *name1,
+		     fuse_ino_t nodeid2, const char *name2,
+		     char **path1, char **path2,
+		     struct node **wnode1, struct node **wnode2)
+{
+	int err;
+
+	pthread_mutex_lock(&f->lock);
+	err = try_get_path2(f, nodeid1, name1, nodeid2, name2,
+			    path1, path2, wnode1, wnode2);
+	if (err == -EAGAIN) {
+		struct lock_queue_element qe = {
+			.nodeid1 = nodeid1,
+			.name1 = name1,
+			.path1 = path1,
+			.wnode1 = wnode1,
+			.nodeid2 = nodeid2,
+			.name2 = name2,
+			.path2 = path2,
+			.wnode2 = wnode2,
+		};
+
+		debug_path(f, "QUEUE PATH1", nodeid1, name1, !!wnode1);
+		debug_path(f, "      PATH2", nodeid2, name2, !!wnode2);
+		err = wait_path(f, &qe);
+		debug_path(f, "DEQUEUE PATH1", nodeid1, name1, !!wnode1);
+		debug_path(f, "        PATH2", nodeid2, name2, !!wnode2);
+	}
+	pthread_mutex_unlock(&f->lock);
+
+	return err;
+}
+
+static void free_path_wrlock(struct fuse *f, fuse_ino_t nodeid,
+			     struct node *wnode, char *path)
+{
+	pthread_mutex_lock(&f->lock);
+	unlock_path(f, nodeid, wnode, NULL);
+	if (f->lockq)
+		wake_up_queued(f);
+	pthread_mutex_unlock(&f->lock);
+	free(path);
+}
+
+static void free_path(struct fuse *f, fuse_ino_t nodeid, char *path)
+{
+	if (path)
+		free_path_wrlock(f, nodeid, NULL, path);
+}
+
+static void free_path2(struct fuse *f, fuse_ino_t nodeid1, fuse_ino_t nodeid2,
+		       struct node *wnode1, struct node *wnode2,
+		       char *path1, char *path2)
+{
+	pthread_mutex_lock(&f->lock);
+	unlock_path(f, nodeid1, wnode1, NULL);
+	unlock_path(f, nodeid2, wnode2, NULL);
+	wake_up_queued(f);
+	pthread_mutex_unlock(&f->lock);
+	free(path1);
+	free(path2);
+}
+
+static void forget_node(struct fuse *f, fuse_ino_t nodeid, uint64_t nlookup)
+{
+	struct node *node;
+	if (nodeid == FUSE_ROOT_ID)
+		return;
+	pthread_mutex_lock(&f->lock);
+	node = get_node(f, nodeid);
+
+	/*
+	 * Node may still be locked due to interrupt idiocy in open,
+	 * create and opendir
+	 */
+	while (node->nlookup == nlookup && node->treelock) {
+		struct lock_queue_element qe = {
+			.nodeid1 = nodeid,
+		};
+
+		debug_path(f, "QUEUE PATH (forget)", nodeid, NULL, false);
+		queue_path(f, &qe);
+
+		do {
+			pthread_cond_wait(&qe.cond, &f->lock);
+		} while (node->nlookup == nlookup && node->treelock);
+
+		dequeue_path(f, &qe);
+		debug_path(f, "DEQUEUE_PATH (forget)", nodeid, NULL, false);
+	}
+
+	assert(node->nlookup >= nlookup);
+	node->nlookup -= nlookup;
+	if (!node->nlookup) {
+		unref_node(f, node);
+	} else if (lru_enabled(f) && node->nlookup == 1) {
+		set_forget_time(f, node);
+	}
+	pthread_mutex_unlock(&f->lock);
+}
+
+static void unlink_node(struct fuse *f, struct node *node)
+{
+	if (f->conf.remember) {
+		assert(node->nlookup > 1);
+		node->nlookup--;
+	}
+	unhash_name(f, node);
+}
+
+static void remove_node(struct fuse *f, fuse_ino_t dir, const char *name)
+{
+	struct node *node;
+
+	pthread_mutex_lock(&f->lock);
+	node = lookup_node(f, dir, name);
+	if (node != NULL)
+		unlink_node(f, node);
+	pthread_mutex_unlock(&f->lock);
+}
+
+static int rename_node(struct fuse *f, fuse_ino_t olddir, const char *oldname,
+		       fuse_ino_t newdir, const char *newname, int hide)
+{
+	struct node *node;
+	struct node *newnode;
+	int err = 0;
+
+	pthread_mutex_lock(&f->lock);
+	node  = lookup_node(f, olddir, oldname);
+	newnode	 = lookup_node(f, newdir, newname);
+	if (node == NULL)
+		goto out;
+
+	if (newnode != NULL) {
+		if (hide) {
+			fprintf(stderr, "fuse: hidden file got created during hiding\n");
+			err = -EBUSY;
+			goto out;
+		}
+		unlink_node(f, newnode);
+	}
+
+	unhash_name(f, node);
+	if (hash_name(f, node, newdir, newname) == -1) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	if (hide)
+		node->is_hidden = 1;
+
+out:
+	pthread_mutex_unlock(&f->lock);
+	return err;
+}
+
+static void set_stat(struct fuse *f, fuse_ino_t nodeid, struct stat *stbuf)
+{
+	if (!f->conf.use_ino)
+		stbuf->st_ino = nodeid;
+	if (f->conf.set_mode)
+		stbuf->st_mode = (stbuf->st_mode & S_IFMT) |
+				 (0777 & ~f->conf.umask);
+	if (f->conf.set_uid)
+		stbuf->st_uid = f->conf.uid;
+	if (f->conf.set_gid)
+		stbuf->st_gid = f->conf.gid;
+}
+
+static struct fuse *req_fuse(fuse_req_t req)
+{
+	return (struct fuse *) fuse_req_userdata(req);
+}
+
+static void fuse_intr_sighandler(int sig)
+{
+	(void) sig;
+	/* Nothing to do */
+}
+
+struct fuse_intr_data {
+	pthread_t id;
+	pthread_cond_t cond;
+	int finished;
+};
+
+static void fuse_interrupt(fuse_req_t req, void *d_)
+{
+	struct fuse_intr_data *d = d_;
+	struct fuse *f = req_fuse(req);
+
+	if (d->id == pthread_self())
+		return;
+
+	pthread_mutex_lock(&f->lock);
+	while (!d->finished) {
+		struct timeval now;
+		struct timespec timeout;
+
+		pthread_kill(d->id, f->conf.intr_signal);
+		gettimeofday(&now, NULL);
+		timeout.tv_sec = now.tv_sec + 1;
+		timeout.tv_nsec = now.tv_usec * 1000;
+		pthread_cond_timedwait(&d->cond, &f->lock, &timeout);
+	}
+	pthread_mutex_unlock(&f->lock);
+}
+
+static void fuse_do_finish_interrupt(struct fuse *f, fuse_req_t req,
+				     struct fuse_intr_data *d)
+{
+	pthread_mutex_lock(&f->lock);
+	d->finished = 1;
+	pthread_cond_broadcast(&d->cond);
+	pthread_mutex_unlock(&f->lock);
+	fuse_req_interrupt_func(req, NULL, NULL);
+	pthread_cond_destroy(&d->cond);
+}
+
+static void fuse_do_prepare_interrupt(fuse_req_t req, struct fuse_intr_data *d)
+{
+	d->id = pthread_self();
+	pthread_cond_init(&d->cond, NULL);
+	d->finished = 0;
+	fuse_req_interrupt_func(req, fuse_interrupt, d);
+}
+
+static inline void fuse_finish_interrupt(struct fuse *f, fuse_req_t req,
+					 struct fuse_intr_data *d)
+{
+	if (f->conf.intr)
+		fuse_do_finish_interrupt(f, req, d);
+}
+
+static inline void fuse_prepare_interrupt(struct fuse *f, fuse_req_t req,
+					  struct fuse_intr_data *d)
+{
+	if (f->conf.intr)
+		fuse_do_prepare_interrupt(req, d);
+}
+
+#if !defined(__FreeBSD__) && !defined(__NetBSD__)
+
+static int fuse_compat_open(struct fuse_fs *fs, const char *path,
+			    struct fuse_file_info *fi)
+{
+	int err;
+	if (!fs->compat || fs->compat >= 25)
+		err = fs->op.open(path, fi);
+	else if (fs->compat == 22) {
+		struct fuse_file_info_compat tmp;
+		memcpy(&tmp, fi, sizeof(tmp));
+		err = ((struct fuse_operations_compat22 *) &fs->op)->open(path,
+									  &tmp);
+		memcpy(fi, &tmp, sizeof(tmp));
+		fi->fh = tmp.fh;
+	} else
+		err = ((struct fuse_operations_compat2 *) &fs->op)
+			->open(path, fi->flags);
+	return err;
+}
+
+static int fuse_compat_release(struct fuse_fs *fs, const char *path,
+			       struct fuse_file_info *fi)
+{
+	if (!fs->compat || fs->compat >= 22)
+		return fs->op.release(path, fi);
+	else
+		return ((struct fuse_operations_compat2 *) &fs->op)
+			->release(path, fi->flags);
+}
+
+static int fuse_compat_opendir(struct fuse_fs *fs, const char *path,
+			       struct fuse_file_info *fi)
+{
+	if (!fs->compat || fs->compat >= 25)
+		return fs->op.opendir(path, fi);
+	else {
+		int err;
+		struct fuse_file_info_compat tmp;
+		memcpy(&tmp, fi, sizeof(tmp));
+		err = ((struct fuse_operations_compat22 *) &fs->op)
+			->opendir(path, &tmp);
+		memcpy(fi, &tmp, sizeof(tmp));
+		fi->fh = tmp.fh;
+		return err;
+	}
+}
+
+static void convert_statfs_compat(struct fuse_statfs_compat1 *compatbuf,
+				  struct statvfs *stbuf)
+{
+	stbuf->f_bsize	 = compatbuf->block_size;
+	stbuf->f_blocks	 = compatbuf->blocks;
+	stbuf->f_bfree	 = compatbuf->blocks_free;
+	stbuf->f_bavail	 = compatbuf->blocks_free;
+	stbuf->f_files	 = compatbuf->files;
+	stbuf->f_ffree	 = compatbuf->files_free;
+	stbuf->f_namemax = compatbuf->namelen;
+}
+
+static void convert_statfs_old(struct statfs *oldbuf, struct statvfs *stbuf)
+{
+	stbuf->f_bsize	 = oldbuf->f_bsize;
+	stbuf->f_blocks	 = oldbuf->f_blocks;
+	stbuf->f_bfree	 = oldbuf->f_bfree;
+	stbuf->f_bavail	 = oldbuf->f_bavail;
+	stbuf->f_files	 = oldbuf->f_files;
+	stbuf->f_ffree	 = oldbuf->f_ffree;
+	stbuf->f_namemax = oldbuf->f_namelen;
+}
+
+static int fuse_compat_statfs(struct fuse_fs *fs, const char *path,
+			      struct statvfs *buf)
+{
+	int err;
+
+	if (!fs->compat || fs->compat >= 25) {
+		err = fs->op.statfs(fs->compat == 25 ? "/" : path, buf);
+	} else if (fs->compat > 11) {
+		struct statfs oldbuf;
+		err = ((struct fuse_operations_compat22 *) &fs->op)
+			->statfs("/", &oldbuf);
+		if (!err)
+			convert_statfs_old(&oldbuf, buf);
+	} else {
+		struct fuse_statfs_compat1 compatbuf;
+		memset(&compatbuf, 0, sizeof(struct fuse_statfs_compat1));
+		err = ((struct fuse_operations_compat1 *) &fs->op)
+			->statfs(&compatbuf);
+		if (!err)
+			convert_statfs_compat(&compatbuf, buf);
+	}
+	return err;
+}
+
+#else /* __FreeBSD__ || __NetBSD__ */
+
+static inline int fuse_compat_open(struct fuse_fs *fs, char *path,
+				   struct fuse_file_info *fi)
+{
+	return fs->op.open(path, fi);
+}
+
+static inline int fuse_compat_release(struct fuse_fs *fs, const char *path,
+				      struct fuse_file_info *fi)
+{
+	return fs->op.release(path, fi);
+}
+
+static inline int fuse_compat_opendir(struct fuse_fs *fs, const char *path,
+				      struct fuse_file_info *fi)
+{
+	return fs->op.opendir(path, fi);
+}
+
+static inline int fuse_compat_statfs(struct fuse_fs *fs, const char *path,
+				     struct statvfs *buf)
+{
+	return fs->op.statfs(fs->compat == 25 ? "/" : path, buf);
+}
+
+#endif /* __FreeBSD__ || __NetBSD__ */
+
+int fuse_fs_getattr(struct fuse_fs *fs, const char *path, struct stat *buf)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.getattr) {
+		if (fs->debug)
+			fprintf(stderr, "getattr %s\n", path);
+
+		return fs->op.getattr(path, buf);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_fgetattr(struct fuse_fs *fs, const char *path, struct stat *buf,
+		     struct fuse_file_info *fi)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.fgetattr) {
+		if (fs->debug)
+			fprintf(stderr, "fgetattr[%llu] %s\n",
+				(unsigned long long) fi->fh, path);
+
+		return fs->op.fgetattr(path, buf, fi);
+	} else if (path && fs->op.getattr) {
+		if (fs->debug)
+			fprintf(stderr, "getattr %s\n", path);
+
+		return fs->op.getattr(path, buf);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_rename(struct fuse_fs *fs, const char *oldpath,
+		   const char *newpath)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.rename) {
+		if (fs->debug)
+			fprintf(stderr, "rename %s %s\n", oldpath, newpath);
+
+		return fs->op.rename(oldpath, newpath);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_unlink(struct fuse_fs *fs, const char *path)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.unlink) {
+		if (fs->debug)
+			fprintf(stderr, "unlink %s\n", path);
+
+		return fs->op.unlink(path);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_rmdir(struct fuse_fs *fs, const char *path)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.rmdir) {
+		if (fs->debug)
+			fprintf(stderr, "rmdir %s\n", path);
+
+		return fs->op.rmdir(path);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_symlink(struct fuse_fs *fs, const char *linkname, const char *path)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.symlink) {
+		if (fs->debug)
+			fprintf(stderr, "symlink %s %s\n", linkname, path);
+
+		return fs->op.symlink(linkname, path);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_link(struct fuse_fs *fs, const char *oldpath, const char *newpath)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.link) {
+		if (fs->debug)
+			fprintf(stderr, "link %s %s\n", oldpath, newpath);
+
+		return fs->op.link(oldpath, newpath);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_release(struct fuse_fs *fs,	 const char *path,
+		    struct fuse_file_info *fi)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.release) {
+		if (fs->debug)
+			fprintf(stderr, "release%s[%llu] flags: 0x%x\n",
+				fi->flush ? "+flush" : "",
+				(unsigned long long) fi->fh, fi->flags);
+
+		return fuse_compat_release(fs, path, fi);
+	} else {
+		return 0;
+	}
+}
+
+int fuse_fs_opendir(struct fuse_fs *fs, const char *path,
+		    struct fuse_file_info *fi)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.opendir) {
+		int err;
+
+		if (fs->debug)
+			fprintf(stderr, "opendir flags: 0x%x %s\n", fi->flags,
+				path);
+
+		err = fuse_compat_opendir(fs, path, fi);
+
+		if (fs->debug && !err)
+			fprintf(stderr, "   opendir[%lli] flags: 0x%x %s\n",
+				(unsigned long long) fi->fh, fi->flags, path);
+
+		return err;
+	} else {
+		return 0;
+	}
+}
+
+int fuse_fs_open(struct fuse_fs *fs, const char *path,
+		 struct fuse_file_info *fi)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.open) {
+		int err;
+
+		if (fs->debug)
+			fprintf(stderr, "open flags: 0x%x %s\n", fi->flags,
+				path);
+
+		err = fuse_compat_open(fs, path, fi);
+
+		if (fs->debug && !err)
+			fprintf(stderr, "   open[%lli] flags: 0x%x %s\n",
+				(unsigned long long) fi->fh, fi->flags, path);
+
+		return err;
+	} else {
+		return 0;
+	}
+}
+
+static void fuse_free_buf(struct fuse_bufvec *buf)
+{
+	if (buf != NULL) {
+		size_t i;
+
+		for (i = 0; i < buf->count; i++)
+			free(buf->buf[i].mem);
+		free(buf);
+	}
+}
+
+int fuse_fs_read_buf(struct fuse_fs *fs, const char *path,
+		     struct fuse_bufvec **bufp, size_t size, off64_t off,
+		     struct fuse_file_info *fi)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.read || fs->op.read_buf) {
+		int res;
+
+		if (fs->debug)
+			fprintf(stderr,
+				"read[%llu] %zu bytes from %llu flags: 0x%x\n",
+				(unsigned long long) fi->fh,
+				size, (unsigned long long) off, fi->flags);
+
+		if (fs->op.read_buf) {
+			res = fs->op.read_buf(path, bufp, size, off, fi);
+		} else {
+			struct fuse_bufvec *buf;
+			void *mem;
+
+			buf = malloc(sizeof(struct fuse_bufvec));
+			if (buf == NULL)
+				return -ENOMEM;
+
+			mem = malloc(size);
+			if (mem == NULL) {
+				free(buf);
+				return -ENOMEM;
+			}
+			*buf = FUSE_BUFVEC_INIT(size);
+			buf->buf[0].mem = mem;
+			*bufp = buf;
+
+			res = fs->op.read(path, mem, size, off, fi);
+			if (res >= 0)
+				buf->buf[0].size = res;
+		}
+
+		if (fs->debug && res >= 0)
+			fprintf(stderr, "   read[%llu] %zu bytes from %llu\n",
+				(unsigned long long) fi->fh,
+				fuse_buf_size(*bufp),
+				(unsigned long long) off);
+		if (res >= 0 && fuse_buf_size(*bufp) > (int) size)
+			fprintf(stderr, "fuse: read too many bytes\n");
+
+		if (res < 0)
+			return res;
+
+		return 0;
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_read(struct fuse_fs *fs, const char *path, char *mem, size_t size,
+		 off64_t off, struct fuse_file_info *fi)
+{
+	int res;
+	struct fuse_bufvec *buf = NULL;
+
+	res = fuse_fs_read_buf(fs, path, &buf, size, off, fi);
+	if (res == 0) {
+		struct fuse_bufvec dst = FUSE_BUFVEC_INIT(size);
+
+		dst.buf[0].mem = mem;
+		res = fuse_buf_copy(&dst, buf, 0);
+	}
+	fuse_free_buf(buf);
+
+	return res;
+}
+
+int fuse_fs_write_buf(struct fuse_fs *fs, const char *path,
+		      struct fuse_bufvec *buf, off64_t off,
+		      struct fuse_file_info *fi)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.write_buf || fs->op.write) {
+		int res;
+		size_t size = fuse_buf_size(buf);
+
+		assert(buf->idx == 0 && buf->off == 0);
+		if (fs->debug)
+			fprintf(stderr,
+				"write%s[%llu] %zu bytes to %llu flags: 0x%x\n",
+				fi->writepage ? "page" : "",
+				(unsigned long long) fi->fh,
+				size,
+				(unsigned long long) off,
+				fi->flags);
+
+		if (fs->op.write_buf) {
+			res = fs->op.write_buf(path, buf, off, fi);
+		} else {
+			void *mem = NULL;
+			struct fuse_buf *flatbuf;
+			struct fuse_bufvec tmp = FUSE_BUFVEC_INIT(size);
+
+			if (buf->count == 1 &&
+			    !(buf->buf[0].flags & FUSE_BUF_IS_FD)) {
+				flatbuf = &buf->buf[0];
+			} else {
+				res = -ENOMEM;
+				mem = malloc(size);
+				if (mem == NULL)
+					goto out;
+
+				tmp.buf[0].mem = mem;
+				res = fuse_buf_copy(&tmp, buf, 0);
+				if (res <= 0)
+					goto out_free;
+
+				tmp.buf[0].size = res;
+				flatbuf = &tmp.buf[0];
+			}
+
+			res = fs->op.write(path, flatbuf->mem, flatbuf->size,
+					   off, fi);
+out_free:
+			free(mem);
+		}
+out:
+		if (fs->debug && res >= 0)
+			fprintf(stderr, "   write%s[%llu] %u bytes to %llu\n",
+				fi->writepage ? "page" : "",
+				(unsigned long long) fi->fh, res,
+				(unsigned long long) off);
+		if (res > (int) size)
+			fprintf(stderr, "fuse: wrote too many bytes\n");
+
+		return res;
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_write(struct fuse_fs *fs, const char *path, const char *mem,
+		  size_t size, off64_t off, struct fuse_file_info *fi)
+{
+	struct fuse_bufvec bufv = FUSE_BUFVEC_INIT(size);
+
+	bufv.buf[0].mem = (void *) mem;
+
+	return fuse_fs_write_buf(fs, path, &bufv, off, fi);
+}
+
+int fuse_fs_fsync(struct fuse_fs *fs, const char *path, int datasync,
+		  struct fuse_file_info *fi)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.fsync) {
+		if (fs->debug)
+			fprintf(stderr, "fsync[%llu] datasync: %i\n",
+				(unsigned long long) fi->fh, datasync);
+
+		return fs->op.fsync(path, datasync, fi);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_fsyncdir(struct fuse_fs *fs, const char *path, int datasync,
+		     struct fuse_file_info *fi)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.fsyncdir) {
+		if (fs->debug)
+			fprintf(stderr, "fsyncdir[%llu] datasync: %i\n",
+				(unsigned long long) fi->fh, datasync);
+
+		return fs->op.fsyncdir(path, datasync, fi);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_flush(struct fuse_fs *fs, const char *path,
+		  struct fuse_file_info *fi)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.flush) {
+		if (fs->debug)
+			fprintf(stderr, "flush[%llu]\n",
+				(unsigned long long) fi->fh);
+
+		return fs->op.flush(path, fi);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_statfs(struct fuse_fs *fs, const char *path, struct statvfs *buf)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.statfs) {
+		if (fs->debug)
+			fprintf(stderr, "statfs %s\n", path);
+
+		return fuse_compat_statfs(fs, path, buf);
+	} else {
+		buf->f_namemax = 255;
+		buf->f_bsize = 512;
+		return 0;
+	}
+}
+
+int fuse_fs_releasedir(struct fuse_fs *fs, const char *path,
+		       struct fuse_file_info *fi)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.releasedir) {
+		if (fs->debug)
+			fprintf(stderr, "releasedir[%llu] flags: 0x%x\n",
+				(unsigned long long) fi->fh, fi->flags);
+
+		return fs->op.releasedir(path, fi);
+	} else {
+		return 0;
+	}
+}
+
+static int fill_dir_old(struct fuse_dirhandle *dh, const char *name, int type,
+			ino_t ino)
+{
+	int res;
+	struct stat stbuf;
+
+	memset(&stbuf, 0, sizeof(stbuf));
+	stbuf.st_mode = type << 12;
+	stbuf.st_ino = ino;
+
+	res = dh->filler(dh->buf, name, &stbuf, 0);
+	return res ? -ENOMEM : 0;
+}
+
+int fuse_fs_readdir(struct fuse_fs *fs, const char *path, void *buf,
+		    fuse_fill_dir_t filler, off64_t off,
+		    struct fuse_file_info *fi)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.readdir) {
+		if (fs->debug)
+			fprintf(stderr, "readdir[%llu] from %llu\n",
+				(unsigned long long) fi->fh,
+				(unsigned long long) off);
+
+		return fs->op.readdir(path, buf, filler, off, fi);
+	} else if (fs->op.getdir) {
+		struct fuse_dirhandle dh;
+
+		if (fs->debug)
+			fprintf(stderr, "getdir[%llu]\n",
+				(unsigned long long) fi->fh);
+
+		dh.filler = filler;
+		dh.buf = buf;
+		return fs->op.getdir(path, &dh, fill_dir_old);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_create(struct fuse_fs *fs, const char *path, mode_t mode,
+		   struct fuse_file_info *fi)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.create) {
+		int err;
+
+		if (fs->debug)
+			fprintf(stderr,
+				"create flags: 0x%x %s 0%o umask=0%03o\n",
+				fi->flags, path, mode,
+				fuse_get_context()->umask);
+
+		err = fs->op.create(path, mode, fi);
+
+		if (fs->debug && !err)
+			fprintf(stderr, "   create[%llu] flags: 0x%x %s\n",
+				(unsigned long long) fi->fh, fi->flags, path);
+
+		return err;
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_lock(struct fuse_fs *fs, const char *path,
+		 struct fuse_file_info *fi, int cmd, struct flock *lock)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.lock) {
+		if (fs->debug)
+			fprintf(stderr, "lock[%llu] %s %s start: %llu len: %llu pid: %llu\n",
+				(unsigned long long) fi->fh,
+				(cmd == F_GETLK ? "F_GETLK" :
+				 (cmd == F_SETLK ? "F_SETLK" :
+				  (cmd == F_SETLKW ? "F_SETLKW" : "???"))),
+				(lock->l_type == F_RDLCK ? "F_RDLCK" :
+				 (lock->l_type == F_WRLCK ? "F_WRLCK" :
+				  (lock->l_type == F_UNLCK ? "F_UNLCK" :
+				   "???"))),
+				(unsigned long long) lock->l_start,
+				(unsigned long long) lock->l_len,
+				(unsigned long long) lock->l_pid);
+
+		return fs->op.lock(path, fi, cmd, lock);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_flock(struct fuse_fs *fs, const char *path,
+		  struct fuse_file_info *fi, int op)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.flock) {
+		if (fs->debug) {
+			int xop = op & ~LOCK_NB;
+
+			fprintf(stderr, "lock[%llu] %s%s\n",
+				(unsigned long long) fi->fh,
+				xop == LOCK_SH ? "LOCK_SH" :
+				(xop == LOCK_EX ? "LOCK_EX" :
+				 (xop == LOCK_UN ? "LOCK_UN" : "???")),
+				(op & LOCK_NB) ? "|LOCK_NB" : "");
+		}
+		return fs->op.flock(path, fi, op);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_chown(struct fuse_fs *fs, const char *path, uid_t uid, gid_t gid)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.chown) {
+		if (fs->debug)
+			fprintf(stderr, "chown %s %lu %lu\n", path,
+				(unsigned long) uid, (unsigned long) gid);
+
+		return fs->op.chown(path, uid, gid);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_truncate(struct fuse_fs *fs, const char *path, off64_t size)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.truncate) {
+		if (fs->debug)
+			fprintf(stderr, "truncate %s %llu\n", path,
+				(unsigned long long) size);
+
+		return fs->op.truncate(path, size);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_ftruncate(struct fuse_fs *fs, const char *path, off64_t size,
+		      struct fuse_file_info *fi)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.ftruncate) {
+		if (fs->debug)
+			fprintf(stderr, "ftruncate[%llu] %llu\n",
+				(unsigned long long) fi->fh,
+				(unsigned long long) size);
+
+		return fs->op.ftruncate(path, size, fi);
+	} else if (path && fs->op.truncate) {
+		if (fs->debug)
+			fprintf(stderr, "truncate %s %llu\n", path,
+				(unsigned long long) size);
+
+		return fs->op.truncate(path, size);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_utimens(struct fuse_fs *fs, const char *path,
+		    const struct timespec tv[2])
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.utimens) {
+		if (fs->debug)
+			fprintf(stderr, "utimens %s %li.%09lu %li.%09lu\n",
+				path, tv[0].tv_sec, tv[0].tv_nsec,
+				tv[1].tv_sec, tv[1].tv_nsec);
+
+		return fs->op.utimens(path, tv);
+	} else if(fs->op.utime) {
+		struct utimbuf buf;
+
+		if (fs->debug)
+			fprintf(stderr, "utime %s %li %li\n", path,
+				tv[0].tv_sec, tv[1].tv_sec);
+
+		buf.actime = tv[0].tv_sec;
+		buf.modtime = tv[1].tv_sec;
+		return fs->op.utime(path, &buf);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_access(struct fuse_fs *fs, const char *path, int mask)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.access) {
+		if (fs->debug)
+			fprintf(stderr, "access %s 0%o\n", path, mask);
+
+		return fs->op.access(path, mask);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_readlink(struct fuse_fs *fs, const char *path, char *buf,
+		     size_t len)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.readlink) {
+		if (fs->debug)
+			fprintf(stderr, "readlink %s %lu\n", path,
+				(unsigned long) len);
+
+		return fs->op.readlink(path, buf, len);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_mknod(struct fuse_fs *fs, const char *path, mode_t mode,
+		  dev_t rdev)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.mknod) {
+		if (fs->debug)
+			fprintf(stderr, "mknod %s 0%o 0x%llx umask=0%03o\n",
+				path, mode, (unsigned long long) rdev,
+				fuse_get_context()->umask);
+
+		return fs->op.mknod(path, mode, rdev);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_mkdir(struct fuse_fs *fs, const char *path, mode_t mode)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.mkdir) {
+		if (fs->debug)
+			fprintf(stderr, "mkdir %s 0%o umask=0%03o\n",
+				path, mode, fuse_get_context()->umask);
+
+		return fs->op.mkdir(path, mode);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_setxattr(struct fuse_fs *fs, const char *path, const char *name,
+		     const char *value, size_t size, int flags)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.setxattr) {
+		if (fs->debug)
+			fprintf(stderr, "setxattr %s %s %lu 0x%x\n",
+				path, name, (unsigned long) size, flags);
+
+		return fs->op.setxattr(path, name, value, size, flags);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_getxattr(struct fuse_fs *fs, const char *path, const char *name,
+		     char *value, size_t size)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.getxattr) {
+		if (fs->debug)
+			fprintf(stderr, "getxattr %s %s %lu\n",
+				path, name, (unsigned long) size);
+
+		return fs->op.getxattr(path, name, value, size);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_listxattr(struct fuse_fs *fs, const char *path, char *list,
+		      size_t size)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.listxattr) {
+		if (fs->debug)
+			fprintf(stderr, "listxattr %s %lu\n",
+				path, (unsigned long) size);
+
+		return fs->op.listxattr(path, list, size);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_bmap(struct fuse_fs *fs, const char *path, size_t blocksize,
+		 uint64_t *idx)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.bmap) {
+		if (fs->debug)
+			fprintf(stderr, "bmap %s blocksize: %lu index: %llu\n",
+				path, (unsigned long) blocksize,
+				(unsigned long long) *idx);
+
+		return fs->op.bmap(path, blocksize, idx);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_removexattr(struct fuse_fs *fs, const char *path, const char *name)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.removexattr) {
+		if (fs->debug)
+			fprintf(stderr, "removexattr %s %s\n", path, name);
+
+		return fs->op.removexattr(path, name);
+	} else {
+		return -ENOSYS;
+	}
+}
+
+int fuse_fs_ioctl(struct fuse_fs *fs, const char *path, int cmd, void *arg,
+		  struct fuse_file_info *fi, unsigned int flags, void *data)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.ioctl) {
+		if (fs->debug)
+			fprintf(stderr, "ioctl[%llu] 0x%x flags: 0x%x\n",
+				(unsigned long long) fi->fh, cmd, flags);
+
+		return fs->op.ioctl(path, cmd, arg, fi, flags, data);
+	} else
+		return -ENOSYS;
+}
+
+int fuse_fs_poll(struct fuse_fs *fs, const char *path,
+		 struct fuse_file_info *fi, struct fuse_pollhandle *ph,
+		 unsigned *reventsp)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.poll) {
+		int res;
+
+		if (fs->debug)
+			fprintf(stderr, "poll[%llu] ph: %p\n",
+				(unsigned long long) fi->fh, ph);
+
+		res = fs->op.poll(path, fi, ph, reventsp);
+
+		if (fs->debug && !res)
+			fprintf(stderr, "   poll[%llu] revents: 0x%x\n",
+				(unsigned long long) fi->fh, *reventsp);
+
+		return res;
+	} else
+		return -ENOSYS;
+}
+
+int fuse_fs_fallocate(struct fuse_fs *fs, const char *path, int mode,
+		off64_t offset, off64_t length, struct fuse_file_info *fi)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.fallocate) {
+		if (fs->debug)
+			fprintf(stderr, "fallocate %s mode %x, offset: %llu, length: %llu\n",
+				path,
+				mode,
+				(unsigned long long) offset,
+				(unsigned long long) length);
+
+		return fs->op.fallocate(path, mode, offset, length, fi);
+	} else
+		return -ENOSYS;
+}
+
+static int is_open(struct fuse *f, fuse_ino_t dir, const char *name)
+{
+	struct node *node;
+	int isopen = 0;
+	pthread_mutex_lock(&f->lock);
+	node = lookup_node(f, dir, name);
+	if (node && node->open_count > 0)
+		isopen = 1;
+	pthread_mutex_unlock(&f->lock);
+	return isopen;
+}
+
+static char *hidden_name(struct fuse *f, fuse_ino_t dir, const char *oldname,
+			 char *newname, size_t bufsize)
+{
+	struct stat buf;
+	struct node *node;
+	struct node *newnode;
+	char *newpath;
+	int res;
+	int failctr = 10;
+
+	do {
+		pthread_mutex_lock(&f->lock);
+		node = lookup_node(f, dir, oldname);
+		if (node == NULL) {
+			pthread_mutex_unlock(&f->lock);
+			return NULL;
+		}
+		do {
+			f->hidectr ++;
+			snprintf(newname, bufsize, ".fuse_hidden%08x%08x",
+				 (unsigned int) node->nodeid, f->hidectr);
+			newnode = lookup_node(f, dir, newname);
+		} while(newnode);
+
+		res = try_get_path(f, dir, newname, &newpath, NULL, false);
+		pthread_mutex_unlock(&f->lock);
+		if (res)
+			break;
+
+		res = fuse_fs_getattr(f->fs, newpath, &buf);
+		if (res == -ENOENT)
+			break;
+		free(newpath);
+		newpath = NULL;
+	} while(res == 0 && --failctr);
+
+	return newpath;
+}
+
+static int hide_node(struct fuse *f, const char *oldpath,
+		     fuse_ino_t dir, const char *oldname)
+{
+	char newname[64];
+	char *newpath;
+	int err = -EBUSY;
+
+	newpath = hidden_name(f, dir, oldname, newname, sizeof(newname));
+	if (newpath) {
+		err = fuse_fs_rename(f->fs, oldpath, newpath);
+		if (!err)
+			err = rename_node(f, dir, oldname, dir, newname, 1);
+		free(newpath);
+	}
+	return err;
+}
+
+static int mtime_eq(const struct stat *stbuf, const struct timespec *ts)
+{
+	return stbuf->st_mtime == ts->tv_sec &&
+		ST_MTIM_NSEC(stbuf) == ts->tv_nsec;
+}
+
+#ifndef CLOCK_MONOTONIC
+#define CLOCK_MONOTONIC CLOCK_REALTIME
+#endif
+
+static void curr_time(struct timespec *now)
+{
+	static clockid_t clockid = CLOCK_MONOTONIC;
+	int res = clock_gettime(clockid, now);
+	if (res == -1 && errno == EINVAL) {
+		clockid = CLOCK_REALTIME;
+		res = clock_gettime(clockid, now);
+	}
+	if (res == -1) {
+		perror("fuse: clock_gettime");
+		abort();
+	}
+}
+
+static void update_stat(struct node *node, const struct stat *stbuf)
+{
+	if (node->cache_valid && (!mtime_eq(stbuf, &node->mtime) ||
+				  stbuf->st_size != node->size))
+		node->cache_valid = 0;
+	node->mtime.tv_sec = stbuf->st_mtime;
+	node->mtime.tv_nsec = ST_MTIM_NSEC(stbuf);
+	node->size = stbuf->st_size;
+	curr_time(&node->stat_updated);
+}
+
+static int lookup_path(struct fuse *f, fuse_ino_t nodeid,
+		       const char *name, const char *path,
+		       struct fuse_entry_param *e, struct fuse_file_info *fi)
+{
+	int res;
+
+	memset(e, 0, sizeof(struct fuse_entry_param));
+	if (fi)
+		res = fuse_fs_fgetattr(f->fs, path, &e->attr, fi);
+	else
+		res = fuse_fs_getattr(f->fs, path, &e->attr);
+	if (res == 0) {
+		struct node *node;
+
+		node = find_node(f, nodeid, name);
+		if (node == NULL)
+			res = -ENOMEM;
+		else {
+			e->ino = node->nodeid;
+			e->generation = node->generation;
+			e->entry_timeout = f->conf.entry_timeout;
+			e->attr_timeout = f->conf.attr_timeout;
+			if (f->conf.auto_cache) {
+				pthread_mutex_lock(&f->lock);
+				update_stat(node, &e->attr);
+				pthread_mutex_unlock(&f->lock);
+			}
+			set_stat(f, e->ino, &e->attr);
+			if (f->conf.debug)
+				fprintf(stderr, "   NODEID: %lu\n",
+					(unsigned long) e->ino);
+		}
+	}
+	return res;
+}
+
+static struct fuse_context_i *fuse_get_context_internal(void)
+{
+	struct fuse_context_i *c;
+
+	c = (struct fuse_context_i *) pthread_getspecific(fuse_context_key);
+	if (c == NULL) {
+		c = (struct fuse_context_i *)
+			calloc(1, sizeof(struct fuse_context_i));
+		if (c == NULL) {
+			/* This is hard to deal with properly, so just
+			   abort.  If memory is so low that the
+			   context cannot be allocated, there's not
+			   much hope for the filesystem anyway */
+			fprintf(stderr, "fuse: failed to allocate thread specific data\n");
+			abort();
+		}
+		pthread_setspecific(fuse_context_key, c);
+	}
+	return c;
+}
+
+static void fuse_freecontext(void *data)
+{
+	free(data);
+}
+
+static int fuse_create_context_key(void)
+{
+	int err = 0;
+	pthread_mutex_lock(&fuse_context_lock);
+	if (!fuse_context_ref) {
+		err = pthread_key_create(&fuse_context_key, fuse_freecontext);
+		if (err) {
+			fprintf(stderr, "fuse: failed to create thread specific key: %s\n",
+				strerror(err));
+			pthread_mutex_unlock(&fuse_context_lock);
+			return -1;
+		}
+	}
+	fuse_context_ref++;
+	pthread_mutex_unlock(&fuse_context_lock);
+	return 0;
+}
+
+static void fuse_delete_context_key(void)
+{
+	pthread_mutex_lock(&fuse_context_lock);
+	fuse_context_ref--;
+	if (!fuse_context_ref) {
+		free(pthread_getspecific(fuse_context_key));
+		pthread_key_delete(fuse_context_key);
+	}
+	pthread_mutex_unlock(&fuse_context_lock);
+}
+
+static struct fuse *req_fuse_prepare(fuse_req_t req)
+{
+	struct fuse_context_i *c = fuse_get_context_internal();
+	const struct fuse_ctx *ctx = fuse_req_ctx(req);
+	c->req = req;
+	c->ctx.fuse = req_fuse(req);
+	c->ctx.uid = ctx->uid;
+	c->ctx.gid = ctx->gid;
+	c->ctx.pid = ctx->pid;
+	c->ctx.umask = ctx->umask;
+	return c->ctx.fuse;
+}
+
+static inline void reply_err(fuse_req_t req, int err)
+{
+	/* fuse_reply_err() uses non-negated errno values */
+	fuse_reply_err(req, -err);
+}
+
+static void reply_entry(fuse_req_t req, const struct fuse_entry_param *e,
+			int err)
+{
+	if (!err) {
+		struct fuse *f = req_fuse(req);
+		if (fuse_reply_entry(req, e) == -ENOENT) {
+			/* Skip forget for negative result */
+			if  (e->ino != 0)
+				forget_node(f, e->ino, 1);
+		}
+	} else
+		reply_err(req, err);
+}
+
+void fuse_fs_init(struct fuse_fs *fs, struct fuse_conn_info *conn)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (!fs->op.write_buf)
+		conn->want &= ~FUSE_CAP_SPLICE_READ;
+	if (!fs->op.lock)
+		conn->want &= ~FUSE_CAP_POSIX_LOCKS;
+	if (!fs->op.flock)
+		conn->want &= ~FUSE_CAP_FLOCK_LOCKS;
+	if (fs->op.init)
+		fs->user_data = fs->op.init(conn);
+}
+
+static void fuse_lib_init(void *data, struct fuse_conn_info *conn)
+{
+	struct fuse *f = (struct fuse *) data;
+	struct fuse_context_i *c = fuse_get_context_internal();
+
+	memset(c, 0, sizeof(*c));
+	c->ctx.fuse = f;
+	conn->want |= FUSE_CAP_EXPORT_SUPPORT;
+	fuse_fs_init(f->fs, conn);
+}
+
+void fuse_fs_destroy(struct fuse_fs *fs)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.destroy)
+		fs->op.destroy(fs->user_data);
+	if (fs->m)
+		fuse_put_module(fs->m);
+	free(fs);
+}
+
+static void fuse_lib_destroy(void *data)
+{
+	struct fuse *f = (struct fuse *) data;
+	struct fuse_context_i *c = fuse_get_context_internal();
+
+	memset(c, 0, sizeof(*c));
+	c->ctx.fuse = f;
+	fuse_fs_destroy(f->fs);
+	f->fs = NULL;
+}
+
+static void fuse_lib_lookup(fuse_req_t req, fuse_ino_t parent,
+			    const char *name)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct fuse_entry_param e;
+	char *path;
+	int err;
+	struct node *dot = NULL;
+
+	if (name[0] == '.') {
+		int len = strlen(name);
+
+		if (len == 1 || (name[1] == '.' && len == 2)) {
+			pthread_mutex_lock(&f->lock);
+			if (len == 1) {
+				if (f->conf.debug)
+					fprintf(stderr, "LOOKUP-DOT\n");
+				dot = get_node_nocheck(f, parent);
+				if (dot == NULL) {
+					pthread_mutex_unlock(&f->lock);
+					reply_entry(req, &e, -ESTALE);
+					return;
+				}
+				dot->refctr++;
+			} else {
+				if (f->conf.debug)
+					fprintf(stderr, "LOOKUP-DOTDOT\n");
+				parent = get_node(f, parent)->parent->nodeid;
+			}
+			pthread_mutex_unlock(&f->lock);
+			name = NULL;
+		}
+	}
+
+	err = get_path_name(f, parent, name, &path);
+	if (!err) {
+		struct fuse_intr_data d;
+		if (f->conf.debug)
+			fprintf(stderr, "LOOKUP %s\n", path);
+		fuse_prepare_interrupt(f, req, &d);
+		err = lookup_path(f, parent, name, path, &e, NULL);
+		if (err == -ENOENT && f->conf.negative_timeout != 0.0) {
+			e.ino = 0;
+			e.entry_timeout = f->conf.negative_timeout;
+			err = 0;
+		}
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, parent, path);
+	}
+	if (dot) {
+		pthread_mutex_lock(&f->lock);
+		unref_node(f, dot);
+		pthread_mutex_unlock(&f->lock);
+	}
+	reply_entry(req, &e, err);
+}
+
+static void do_forget(struct fuse *f, fuse_ino_t ino, uint64_t nlookup)
+{
+	if (f->conf.debug)
+		fprintf(stderr, "FORGET %llu/%llu\n", (unsigned long long)ino,
+			(unsigned long long) nlookup);
+	forget_node(f, ino, nlookup);
+}
+
+static void fuse_lib_forget(fuse_req_t req, fuse_ino_t ino,
+			    unsigned long nlookup)
+{
+	do_forget(req_fuse(req), ino, nlookup);
+	fuse_reply_none(req);
+}
+
+static void fuse_lib_forget_multi(fuse_req_t req, size_t count,
+				  struct fuse_forget_data *forgets)
+{
+	struct fuse *f = req_fuse(req);
+	size_t i;
+
+	for (i = 0; i < count; i++)
+		do_forget(f, forgets[i].ino, forgets[i].nlookup);
+
+	fuse_reply_none(req);
+}
+
+
+static void fuse_lib_getattr(fuse_req_t req, fuse_ino_t ino,
+			     struct fuse_file_info *fi)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct stat buf;
+	char *path;
+	int err;
+
+	memset(&buf, 0, sizeof(buf));
+
+	if (fi != NULL && f->fs->op.fgetattr)
+		err = get_path_nullok(f, ino, &path);
+	else
+		err = get_path(f, ino, &path);
+	if (!err) {
+		struct fuse_intr_data d;
+		fuse_prepare_interrupt(f, req, &d);
+		if (fi)
+			err = fuse_fs_fgetattr(f->fs, path, &buf, fi);
+		else
+			err = fuse_fs_getattr(f->fs, path, &buf);
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, ino, path);
+	}
+	if (!err) {
+		struct node *node;
+
+		pthread_mutex_lock(&f->lock);
+		node = get_node(f, ino);
+		if (node->is_hidden && buf.st_nlink > 0)
+			buf.st_nlink--;
+		if (f->conf.auto_cache)
+			update_stat(node, &buf);
+		pthread_mutex_unlock(&f->lock);
+		set_stat(f, ino, &buf);
+		fuse_reply_attr(req, &buf, f->conf.attr_timeout);
+	} else
+		reply_err(req, err);
+}
+
+int fuse_fs_chmod(struct fuse_fs *fs, const char *path, mode_t mode)
+{
+	fuse_get_context()->private_data = fs->user_data;
+	if (fs->op.chmod)
+		return fs->op.chmod(path, mode);
+	else
+		return -ENOSYS;
+}
+
+static void fuse_lib_setattr(fuse_req_t req, fuse_ino_t ino, struct stat *attr,
+			     int valid, struct fuse_file_info *fi)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct stat buf;
+	char *path;
+	int err;
+
+	if (valid == FUSE_SET_ATTR_SIZE && fi != NULL &&
+	    f->fs->op.ftruncate && f->fs->op.fgetattr)
+		err = get_path_nullok(f, ino, &path);
+	else
+		err = get_path(f, ino, &path);
+	if (!err) {
+		struct fuse_intr_data d;
+		fuse_prepare_interrupt(f, req, &d);
+		err = 0;
+		if (!err && (valid & FUSE_SET_ATTR_MODE))
+			err = fuse_fs_chmod(f->fs, path, attr->st_mode);
+		if (!err && (valid & (FUSE_SET_ATTR_UID | FUSE_SET_ATTR_GID))) {
+			uid_t uid = (valid & FUSE_SET_ATTR_UID) ?
+				attr->st_uid : (uid_t) -1;
+			gid_t gid = (valid & FUSE_SET_ATTR_GID) ?
+				attr->st_gid : (gid_t) -1;
+			err = fuse_fs_chown(f->fs, path, uid, gid);
+		}
+		if (!err && (valid & FUSE_SET_ATTR_SIZE)) {
+			if (fi)
+				err = fuse_fs_ftruncate(f->fs, path,
+							attr->st_size, fi);
+			else
+				err = fuse_fs_truncate(f->fs, path,
+						       attr->st_size);
+		}
+#ifdef HAVE_UTIMENSAT
+		if (!err && f->utime_omit_ok &&
+		    (valid & (FUSE_SET_ATTR_ATIME | FUSE_SET_ATTR_MTIME))) {
+			struct timespec tv[2];
+
+			tv[0].tv_sec = 0;
+			tv[1].tv_sec = 0;
+			tv[0].tv_nsec = UTIME_OMIT;
+			tv[1].tv_nsec = UTIME_OMIT;
+
+			if (valid & FUSE_SET_ATTR_ATIME_NOW)
+				tv[0].tv_nsec = UTIME_NOW;
+			else if (valid & FUSE_SET_ATTR_ATIME)
+				tv[0] = attr->st_atim;
+
+			if (valid & FUSE_SET_ATTR_MTIME_NOW)
+				tv[1].tv_nsec = UTIME_NOW;
+			else if (valid & FUSE_SET_ATTR_MTIME)
+				tv[1] = attr->st_mtim;
+
+			err = fuse_fs_utimens(f->fs, path, tv);
+		} else
+#endif
+		if (!err &&
+		    (valid & (FUSE_SET_ATTR_ATIME | FUSE_SET_ATTR_MTIME)) ==
+		    (FUSE_SET_ATTR_ATIME | FUSE_SET_ATTR_MTIME)) {
+			struct timespec tv[2];
+			tv[0].tv_sec = attr->st_atime;
+			tv[0].tv_nsec = ST_ATIM_NSEC(attr);
+			tv[1].tv_sec = attr->st_mtime;
+			tv[1].tv_nsec = ST_MTIM_NSEC(attr);
+			err = fuse_fs_utimens(f->fs, path, tv);
+		}
+		if (!err) {
+			if (fi)
+				err = fuse_fs_fgetattr(f->fs, path, &buf, fi);
+			else
+				err = fuse_fs_getattr(f->fs, path, &buf);
+		}
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, ino, path);
+	}
+	if (!err) {
+		if (f->conf.auto_cache) {
+			pthread_mutex_lock(&f->lock);
+			update_stat(get_node(f, ino), &buf);
+			pthread_mutex_unlock(&f->lock);
+		}
+		set_stat(f, ino, &buf);
+		fuse_reply_attr(req, &buf, f->conf.attr_timeout);
+	} else
+		reply_err(req, err);
+}
+
+static void fuse_lib_access(fuse_req_t req, fuse_ino_t ino, int mask)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	char *path;
+	int err;
+
+	err = get_path(f, ino, &path);
+	if (!err) {
+		struct fuse_intr_data d;
+
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_access(f->fs, path, mask);
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, ino, path);
+	}
+	reply_err(req, err);
+}
+
+static void fuse_lib_readlink(fuse_req_t req, fuse_ino_t ino)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	char linkname[PATH_MAX + 1];
+	char *path;
+	int err;
+
+	err = get_path(f, ino, &path);
+	if (!err) {
+		struct fuse_intr_data d;
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_readlink(f->fs, path, linkname, sizeof(linkname));
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, ino, path);
+	}
+	if (!err) {
+		linkname[PATH_MAX] = '\0';
+		fuse_reply_readlink(req, linkname);
+	} else
+		reply_err(req, err);
+}
+
+static void fuse_lib_mknod(fuse_req_t req, fuse_ino_t parent, const char *name,
+			   mode_t mode, dev_t rdev)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct fuse_entry_param e;
+	char *path;
+	int err;
+
+	err = get_path_name(f, parent, name, &path);
+	if (!err) {
+		struct fuse_intr_data d;
+
+		fuse_prepare_interrupt(f, req, &d);
+		err = -ENOSYS;
+		if (S_ISREG(mode)) {
+			struct fuse_file_info fi;
+
+			memset(&fi, 0, sizeof(fi));
+			fi.flags = O_CREAT | O_EXCL | O_WRONLY;
+			err = fuse_fs_create(f->fs, path, mode, &fi);
+			if (!err) {
+				err = lookup_path(f, parent, name, path, &e,
+						  &fi);
+				fuse_fs_release(f->fs, path, &fi);
+			}
+		}
+		if (err == -ENOSYS) {
+			err = fuse_fs_mknod(f->fs, path, mode, rdev);
+			if (!err)
+				err = lookup_path(f, parent, name, path, &e,
+						  NULL);
+		}
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, parent, path);
+	}
+	reply_entry(req, &e, err);
+}
+
+static void fuse_lib_mkdir(fuse_req_t req, fuse_ino_t parent, const char *name,
+			   mode_t mode)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct fuse_entry_param e;
+	char *path;
+	int err;
+
+	err = get_path_name(f, parent, name, &path);
+	if (!err) {
+		struct fuse_intr_data d;
+
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_mkdir(f->fs, path, mode);
+		if (!err)
+			err = lookup_path(f, parent, name, path, &e, NULL);
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, parent, path);
+	}
+	reply_entry(req, &e, err);
+}
+
+static void fuse_lib_unlink(fuse_req_t req, fuse_ino_t parent,
+			    const char *name)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct node *wnode;
+	char *path;
+	int err;
+
+	err = get_path_wrlock(f, parent, name, &path, &wnode);
+	if (!err) {
+		struct fuse_intr_data d;
+
+		fuse_prepare_interrupt(f, req, &d);
+		if (!f->conf.hard_remove && is_open(f, parent, name)) {
+			err = hide_node(f, path, parent, name);
+		} else {
+			err = fuse_fs_unlink(f->fs, path);
+			if (!err)
+				remove_node(f, parent, name);
+		}
+		fuse_finish_interrupt(f, req, &d);
+		free_path_wrlock(f, parent, wnode, path);
+	}
+	reply_err(req, err);
+}
+
+static void fuse_lib_rmdir(fuse_req_t req, fuse_ino_t parent, const char *name)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct node *wnode;
+	char *path;
+	int err;
+
+	err = get_path_wrlock(f, parent, name, &path, &wnode);
+	if (!err) {
+		struct fuse_intr_data d;
+
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_rmdir(f->fs, path);
+		fuse_finish_interrupt(f, req, &d);
+		if (!err)
+			remove_node(f, parent, name);
+		free_path_wrlock(f, parent, wnode, path);
+	}
+	reply_err(req, err);
+}
+
+static void fuse_lib_symlink(fuse_req_t req, const char *linkname,
+			     fuse_ino_t parent, const char *name)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct fuse_entry_param e;
+	char *path;
+	int err;
+
+	err = get_path_name(f, parent, name, &path);
+	if (!err) {
+		struct fuse_intr_data d;
+
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_symlink(f->fs, linkname, path);
+		if (!err)
+			err = lookup_path(f, parent, name, path, &e, NULL);
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, parent, path);
+	}
+	reply_entry(req, &e, err);
+}
+
+static void fuse_lib_rename(fuse_req_t req, fuse_ino_t olddir,
+			    const char *oldname, fuse_ino_t newdir,
+			    const char *newname)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	char *oldpath;
+	char *newpath;
+	struct node *wnode1;
+	struct node *wnode2;
+	int err;
+
+	err = get_path2(f, olddir, oldname, newdir, newname,
+			&oldpath, &newpath, &wnode1, &wnode2);
+	if (!err) {
+		struct fuse_intr_data d;
+		err = 0;
+		fuse_prepare_interrupt(f, req, &d);
+		if (!f->conf.hard_remove && is_open(f, newdir, newname))
+			err = hide_node(f, newpath, newdir, newname);
+		if (!err) {
+			err = fuse_fs_rename(f->fs, oldpath, newpath);
+			if (!err)
+				err = rename_node(f, olddir, oldname, newdir,
+						  newname, 0);
+		}
+		fuse_finish_interrupt(f, req, &d);
+		free_path2(f, olddir, newdir, wnode1, wnode2, oldpath, newpath);
+	}
+	reply_err(req, err);
+}
+
+static void fuse_lib_link(fuse_req_t req, fuse_ino_t ino, fuse_ino_t newparent,
+			  const char *newname)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct fuse_entry_param e;
+	char *oldpath;
+	char *newpath;
+	int err;
+
+	err = get_path2(f, ino, NULL, newparent, newname,
+			&oldpath, &newpath, NULL, NULL);
+	if (!err) {
+		struct fuse_intr_data d;
+
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_link(f->fs, oldpath, newpath);
+		if (!err)
+			err = lookup_path(f, newparent, newname, newpath,
+					  &e, NULL);
+		fuse_finish_interrupt(f, req, &d);
+		free_path2(f, ino, newparent, NULL, NULL, oldpath, newpath);
+	}
+	reply_entry(req, &e, err);
+}
+
+static void fuse_do_release(struct fuse *f, fuse_ino_t ino, const char *path,
+			    struct fuse_file_info *fi)
+{
+	struct node *node;
+	int unlink_hidden = 0;
+	const char *compatpath;
+
+	if (path != NULL || f->nullpath_ok || f->conf.nopath)
+		compatpath = path;
+	else
+		compatpath = "-";
+
+	fuse_fs_release(f->fs, compatpath, fi);
+
+	pthread_mutex_lock(&f->lock);
+	node = get_node(f, ino);
+	assert(node->open_count > 0);
+	--node->open_count;
+	if (node->is_hidden && !node->open_count) {
+		unlink_hidden = 1;
+		node->is_hidden = 0;
+	}
+	pthread_mutex_unlock(&f->lock);
+
+	if(unlink_hidden) {
+		if (path) {
+			fuse_fs_unlink(f->fs, path);
+		} else if (f->conf.nopath) {
+			char *unlinkpath;
+
+			if (get_path(f, ino, &unlinkpath) == 0)
+				fuse_fs_unlink(f->fs, unlinkpath);
+
+			free_path(f, ino, unlinkpath);
+		}
+	}
+}
+
+static void fuse_lib_create(fuse_req_t req, fuse_ino_t parent,
+			    const char *name, mode_t mode,
+			    struct fuse_file_info *fi)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct fuse_intr_data d;
+	struct fuse_entry_param e;
+	char *path;
+	int err;
+
+	err = get_path_name(f, parent, name, &path);
+	if (!err) {
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_create(f->fs, path, mode, fi);
+		if (!err) {
+			err = lookup_path(f, parent, name, path, &e, fi);
+			if (err)
+				fuse_fs_release(f->fs, path, fi);
+			else if (!S_ISREG(e.attr.st_mode)) {
+				err = -EIO;
+				fuse_fs_release(f->fs, path, fi);
+				forget_node(f, e.ino, 1);
+			} else {
+				if (f->conf.direct_io)
+					fi->direct_io = 1;
+				if (f->conf.kernel_cache)
+					fi->keep_cache = 1;
+
+			}
+		}
+		fuse_finish_interrupt(f, req, &d);
+	}
+	if (!err) {
+		pthread_mutex_lock(&f->lock);
+		get_node(f, e.ino)->open_count++;
+		pthread_mutex_unlock(&f->lock);
+		if (fuse_reply_create(req, &e, fi) == -ENOENT) {
+			/* The open syscall was interrupted, so it
+			   must be cancelled */
+			fuse_do_release(f, e.ino, path, fi);
+			forget_node(f, e.ino, 1);
+		}
+	} else {
+		reply_err(req, err);
+	}
+
+	free_path(f, parent, path);
+}
+
+static double diff_timespec(const struct timespec *t1,
+			    const struct timespec *t2)
+{
+	return (t1->tv_sec - t2->tv_sec) +
+		((double) t1->tv_nsec - (double) t2->tv_nsec) / 1000000000.0;
+}
+
+static void open_auto_cache(struct fuse *f, fuse_ino_t ino, const char *path,
+			    struct fuse_file_info *fi)
+{
+	struct node *node;
+
+	pthread_mutex_lock(&f->lock);
+	node = get_node(f, ino);
+	if (node->cache_valid) {
+		struct timespec now;
+
+		curr_time(&now);
+		if (diff_timespec(&now, &node->stat_updated) >
+		    f->conf.ac_attr_timeout) {
+			struct stat stbuf;
+			int err;
+			pthread_mutex_unlock(&f->lock);
+			err = fuse_fs_fgetattr(f->fs, path, &stbuf, fi);
+			pthread_mutex_lock(&f->lock);
+			if (!err)
+				update_stat(node, &stbuf);
+			else
+				node->cache_valid = 0;
+		}
+	}
+	if (node->cache_valid)
+		fi->keep_cache = 1;
+
+	node->cache_valid = 1;
+	pthread_mutex_unlock(&f->lock);
+}
+
+static void fuse_lib_open(fuse_req_t req, fuse_ino_t ino,
+			  struct fuse_file_info *fi)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct fuse_intr_data d;
+	char *path;
+	int err;
+
+	err = get_path(f, ino, &path);
+	if (!err) {
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_open(f->fs, path, fi);
+		if (!err) {
+			if (f->conf.direct_io)
+				fi->direct_io = 1;
+			if (f->conf.kernel_cache)
+				fi->keep_cache = 1;
+
+			if (f->conf.auto_cache)
+				open_auto_cache(f, ino, path, fi);
+		}
+		fuse_finish_interrupt(f, req, &d);
+	}
+	if (!err) {
+		pthread_mutex_lock(&f->lock);
+		get_node(f, ino)->open_count++;
+		pthread_mutex_unlock(&f->lock);
+		if (fuse_reply_open(req, fi) == -ENOENT) {
+			/* The open syscall was interrupted, so it
+			   must be cancelled */
+			fuse_do_release(f, ino, path, fi);
+		}
+	} else
+		reply_err(req, err);
+
+	free_path(f, ino, path);
+}
+
+static void fuse_lib_read(fuse_req_t req, fuse_ino_t ino, size_t size,
+			  off64_t off, struct fuse_file_info *fi)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct fuse_bufvec *buf = NULL;
+	char *path;
+	int res;
+
+	res = get_path_nullok(f, ino, &path);
+	if (res == 0) {
+		struct fuse_intr_data d;
+
+		fuse_prepare_interrupt(f, req, &d);
+		res = fuse_fs_read_buf(f->fs, path, &buf, size, off, fi);
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, ino, path);
+	}
+
+	if (res == 0)
+		fuse_reply_data(req, buf, FUSE_BUF_SPLICE_MOVE);
+	else
+		reply_err(req, res);
+
+	fuse_free_buf(buf);
+}
+
+static void fuse_lib_write_buf(fuse_req_t req, fuse_ino_t ino,
+			       struct fuse_bufvec *buf, off64_t off,
+			       struct fuse_file_info *fi)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	char *path;
+	int res;
+
+	res = get_path_nullok(f, ino, &path);
+	if (res == 0) {
+		struct fuse_intr_data d;
+
+		fuse_prepare_interrupt(f, req, &d);
+		res = fuse_fs_write_buf(f->fs, path, buf, off, fi);
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, ino, path);
+	}
+
+	if (res >= 0)
+		fuse_reply_write(req, res);
+	else
+		reply_err(req, res);
+}
+
+static void fuse_lib_fsync(fuse_req_t req, fuse_ino_t ino, int datasync,
+			   struct fuse_file_info *fi)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	char *path;
+	int err;
+
+	err = get_path_nullok(f, ino, &path);
+	if (!err) {
+		struct fuse_intr_data d;
+
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_fsync(f->fs, path, datasync, fi);
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, ino, path);
+	}
+	reply_err(req, err);
+}
+
+static struct fuse_dh *get_dirhandle(const struct fuse_file_info *llfi,
+				     struct fuse_file_info *fi)
+{
+	struct fuse_dh *dh = (struct fuse_dh *) (uintptr_t) llfi->fh;
+	memset(fi, 0, sizeof(struct fuse_file_info));
+	fi->fh = dh->fh;
+	fi->fh_old = dh->fh;
+	return dh;
+}
+
+static void fuse_lib_opendir(fuse_req_t req, fuse_ino_t ino,
+			     struct fuse_file_info *llfi)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct fuse_intr_data d;
+	struct fuse_dh *dh;
+	struct fuse_file_info fi;
+	char *path;
+	int err;
+
+	dh = (struct fuse_dh *) malloc(sizeof(struct fuse_dh));
+	if (dh == NULL) {
+		reply_err(req, -ENOMEM);
+		return;
+	}
+	memset(dh, 0, sizeof(struct fuse_dh));
+	dh->fuse = f;
+	dh->contents = NULL;
+	dh->len = 0;
+	dh->filled = 0;
+	dh->nodeid = ino;
+	fuse_mutex_init(&dh->lock);
+
+	llfi->fh = (uintptr_t) dh;
+
+	memset(&fi, 0, sizeof(fi));
+	fi.flags = llfi->flags;
+
+	err = get_path(f, ino, &path);
+	if (!err) {
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_opendir(f->fs, path, &fi);
+		fuse_finish_interrupt(f, req, &d);
+		dh->fh = fi.fh;
+	}
+	if (!err) {
+		if (fuse_reply_open(req, llfi) == -ENOENT) {
+			/* The opendir syscall was interrupted, so it
+			   must be cancelled */
+			fuse_fs_releasedir(f->fs, path, &fi);
+			pthread_mutex_destroy(&dh->lock);
+			free(dh);
+		}
+	} else {
+		reply_err(req, err);
+		pthread_mutex_destroy(&dh->lock);
+		free(dh);
+	}
+	free_path(f, ino, path);
+}
+
+static int extend_contents(struct fuse_dh *dh, unsigned minsize)
+{
+	if (minsize > dh->size) {
+		char *newptr;
+		unsigned newsize = dh->size;
+		if (!newsize)
+			newsize = 1024;
+		while (newsize < minsize) {
+			if (newsize >= 0x80000000)
+				newsize = 0xffffffff;
+			else
+				newsize *= 2;
+		}
+
+		newptr = (char *) realloc(dh->contents, newsize);
+		if (!newptr) {
+			dh->error = -ENOMEM;
+			return -1;
+		}
+		dh->contents = newptr;
+		dh->size = newsize;
+	}
+	return 0;
+}
+
+static int fill_dir(void *dh_, const char *name, const struct stat *statp,
+		    off64_t off)
+{
+	struct fuse_dh *dh = (struct fuse_dh *) dh_;
+	struct stat stbuf;
+	size_t newlen;
+
+	if (statp)
+		stbuf = *statp;
+	else {
+		memset(&stbuf, 0, sizeof(stbuf));
+		stbuf.st_ino = FUSE_UNKNOWN_INO;
+	}
+
+	if (!dh->fuse->conf.use_ino) {
+		stbuf.st_ino = FUSE_UNKNOWN_INO;
+		if (dh->fuse->conf.readdir_ino) {
+			struct node *node;
+			pthread_mutex_lock(&dh->fuse->lock);
+			node = lookup_node(dh->fuse, dh->nodeid, name);
+			if (node)
+				stbuf.st_ino  = (ino_t) node->nodeid;
+			pthread_mutex_unlock(&dh->fuse->lock);
+		}
+	}
+
+	if (off) {
+		if (extend_contents(dh, dh->needlen) == -1)
+			return 1;
+
+		dh->filled = 0;
+		newlen = dh->len +
+			fuse_add_direntry(dh->req, dh->contents + dh->len,
+					  dh->needlen - dh->len, name,
+					  &stbuf, off);
+		if (newlen > dh->needlen)
+			return 1;
+	} else {
+		newlen = dh->len +
+			fuse_add_direntry(dh->req, NULL, 0, name, NULL, 0);
+		if (extend_contents(dh, newlen) == -1)
+			return 1;
+
+		fuse_add_direntry(dh->req, dh->contents + dh->len,
+				  dh->size - dh->len, name, &stbuf, newlen);
+	}
+	dh->len = newlen;
+	return 0;
+}
+
+static int readdir_fill(struct fuse *f, fuse_req_t req, fuse_ino_t ino,
+			size_t size, off64_t off, struct fuse_dh *dh,
+			struct fuse_file_info *fi)
+{
+	char *path;
+	int err;
+
+	if (f->fs->op.readdir)
+		err = get_path_nullok(f, ino, &path);
+	else
+		err = get_path(f, ino, &path);
+	if (!err) {
+		struct fuse_intr_data d;
+
+		dh->len = 0;
+		dh->error = 0;
+		dh->needlen = size;
+		dh->filled = 1;
+		dh->req = req;
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_readdir(f->fs, path, dh, fill_dir, off, fi);
+		fuse_finish_interrupt(f, req, &d);
+		dh->req = NULL;
+		if (!err)
+			err = dh->error;
+		if (err)
+			dh->filled = 0;
+		free_path(f, ino, path);
+	}
+	return err;
+}
+
+static void fuse_lib_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,
+			     off64_t off, struct fuse_file_info *llfi)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct fuse_file_info fi;
+	struct fuse_dh *dh = get_dirhandle(llfi, &fi);
+
+	pthread_mutex_lock(&dh->lock);
+	/* According to SUS, directory contents need to be refreshed on
+	   rewinddir() */
+	if (!off)
+		dh->filled = 0;
+
+	if (!dh->filled) {
+		int err = readdir_fill(f, req, ino, size, off, dh, &fi);
+		if (err) {
+			reply_err(req, err);
+			goto out;
+		}
+	}
+	if (dh->filled) {
+		if (off < dh->len) {
+			if (off + size > dh->len)
+				size = dh->len - off;
+		} else
+			size = 0;
+	} else {
+		size = dh->len;
+		off = 0;
+	}
+	fuse_reply_buf(req, dh->contents + off, size);
+out:
+	pthread_mutex_unlock(&dh->lock);
+}
+
+static void fuse_lib_releasedir(fuse_req_t req, fuse_ino_t ino,
+				struct fuse_file_info *llfi)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct fuse_intr_data d;
+	struct fuse_file_info fi;
+	struct fuse_dh *dh = get_dirhandle(llfi, &fi);
+	char *path;
+	const char *compatpath;
+
+	get_path_nullok(f, ino, &path);
+	if (path != NULL || f->nullpath_ok || f->conf.nopath)
+		compatpath = path;
+	else
+		compatpath = "-";
+
+	fuse_prepare_interrupt(f, req, &d);
+	fuse_fs_releasedir(f->fs, compatpath, &fi);
+	fuse_finish_interrupt(f, req, &d);
+	free_path(f, ino, path);
+
+	pthread_mutex_lock(&dh->lock);
+	pthread_mutex_unlock(&dh->lock);
+	pthread_mutex_destroy(&dh->lock);
+	free(dh->contents);
+	free(dh);
+	reply_err(req, 0);
+}
+
+static void fuse_lib_fsyncdir(fuse_req_t req, fuse_ino_t ino, int datasync,
+			      struct fuse_file_info *llfi)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct fuse_file_info fi;
+	char *path;
+	int err;
+
+	get_dirhandle(llfi, &fi);
+
+	err = get_path_nullok(f, ino, &path);
+	if (!err) {
+		struct fuse_intr_data d;
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_fsyncdir(f->fs, path, datasync, &fi);
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, ino, path);
+	}
+	reply_err(req, err);
+}
+
+static void fuse_lib_statfs(fuse_req_t req, fuse_ino_t ino)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct statvfs buf;
+	char *path = NULL;
+	int err = 0;
+
+	memset(&buf, 0, sizeof(buf));
+	if (ino)
+		err = get_path(f, ino, &path);
+
+	if (!err) {
+		struct fuse_intr_data d;
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_statfs(f->fs, path ? path : "/", &buf);
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, ino, path);
+	}
+
+	if (!err)
+		fuse_reply_statfs(req, &buf);
+	else
+		reply_err(req, err);
+}
+
+static void fuse_lib_setxattr(fuse_req_t req, fuse_ino_t ino, const char *name,
+			      const char *value, size_t size, int flags)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	char *path;
+	int err;
+
+	err = get_path(f, ino, &path);
+	if (!err) {
+		struct fuse_intr_data d;
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_setxattr(f->fs, path, name, value, size, flags);
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, ino, path);
+	}
+	reply_err(req, err);
+}
+
+static int common_getxattr(struct fuse *f, fuse_req_t req, fuse_ino_t ino,
+			   const char *name, char *value, size_t size)
+{
+	int err;
+	char *path;
+
+	err = get_path(f, ino, &path);
+	if (!err) {
+		struct fuse_intr_data d;
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_getxattr(f->fs, path, name, value, size);
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, ino, path);
+	}
+	return err;
+}
+
+static void fuse_lib_getxattr(fuse_req_t req, fuse_ino_t ino, const char *name,
+			      size_t size)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	int res;
+
+	if (size) {
+		char *value = (char *) malloc(size);
+		if (value == NULL) {
+			reply_err(req, -ENOMEM);
+			return;
+		}
+		res = common_getxattr(f, req, ino, name, value, size);
+		if (res > 0)
+			fuse_reply_buf(req, value, res);
+		else
+			reply_err(req, res);
+		free(value);
+	} else {
+		res = common_getxattr(f, req, ino, name, NULL, 0);
+		if (res >= 0)
+			fuse_reply_xattr(req, res);
+		else
+			reply_err(req, res);
+	}
+}
+
+static int common_listxattr(struct fuse *f, fuse_req_t req, fuse_ino_t ino,
+			    char *list, size_t size)
+{
+	char *path;
+	int err;
+
+	err = get_path(f, ino, &path);
+	if (!err) {
+		struct fuse_intr_data d;
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_listxattr(f->fs, path, list, size);
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, ino, path);
+	}
+	return err;
+}
+
+static void fuse_lib_listxattr(fuse_req_t req, fuse_ino_t ino, size_t size)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	int res;
+
+	if (size) {
+		char *list = (char *) malloc(size);
+		if (list == NULL) {
+			reply_err(req, -ENOMEM);
+			return;
+		}
+		res = common_listxattr(f, req, ino, list, size);
+		if (res > 0)
+			fuse_reply_buf(req, list, res);
+		else
+			reply_err(req, res);
+		free(list);
+	} else {
+		res = common_listxattr(f, req, ino, NULL, 0);
+		if (res >= 0)
+			fuse_reply_xattr(req, res);
+		else
+			reply_err(req, res);
+	}
+}
+
+static void fuse_lib_removexattr(fuse_req_t req, fuse_ino_t ino,
+				 const char *name)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	char *path;
+	int err;
+
+	err = get_path(f, ino, &path);
+	if (!err) {
+		struct fuse_intr_data d;
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_removexattr(f->fs, path, name);
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, ino, path);
+	}
+	reply_err(req, err);
+}
+
+static struct lock *locks_conflict(struct node *node, const struct lock *lock)
+{
+	struct lock *l;
+
+	for (l = node->locks; l; l = l->next)
+		if (l->owner != lock->owner &&
+		    lock->start <= l->end && l->start <= lock->end &&
+		    (l->type == F_WRLCK || lock->type == F_WRLCK))
+			break;
+
+	return l;
+}
+
+static void delete_lock(struct lock **lockp)
+{
+	struct lock *l = *lockp;
+	*lockp = l->next;
+	free(l);
+}
+
+static void insert_lock(struct lock **pos, struct lock *lock)
+{
+	lock->next = *pos;
+	*pos = lock;
+}
+
+static int locks_insert(struct node *node, struct lock *lock)
+{
+	struct lock **lp;
+	struct lock *newl1 = NULL;
+	struct lock *newl2 = NULL;
+
+	if (lock->type != F_UNLCK || lock->start != 0 ||
+	    lock->end != OFFSET_MAX) {
+		newl1 = malloc(sizeof(struct lock));
+		newl2 = malloc(sizeof(struct lock));
+
+		if (!newl1 || !newl2) {
+			free(newl1);
+			free(newl2);
+			return -ENOLCK;
+		}
+	}
+
+	for (lp = &node->locks; *lp;) {
+		struct lock *l = *lp;
+		if (l->owner != lock->owner)
+			goto skip;
+
+		if (lock->type == l->type) {
+			if (l->end < lock->start - 1)
+				goto skip;
+			if (lock->end < l->start - 1)
+				break;
+			if (l->start <= lock->start && lock->end <= l->end)
+				goto out;
+			if (l->start < lock->start)
+				lock->start = l->start;
+			if (lock->end < l->end)
+				lock->end = l->end;
+			goto delete;
+		} else {
+			if (l->end < lock->start)
+				goto skip;
+			if (lock->end < l->start)
+				break;
+			if (lock->start <= l->start && l->end <= lock->end)
+				goto delete;
+			if (l->end <= lock->end) {
+				l->end = lock->start - 1;
+				goto skip;
+			}
+			if (lock->start <= l->start) {
+				l->start = lock->end + 1;
+				break;
+			}
+			*newl2 = *l;
+			newl2->start = lock->end + 1;
+			l->end = lock->start - 1;
+			insert_lock(&l->next, newl2);
+			newl2 = NULL;
+		}
+	skip:
+		lp = &l->next;
+		continue;
+
+	delete:
+		delete_lock(lp);
+	}
+	if (lock->type != F_UNLCK) {
+		*newl1 = *lock;
+		insert_lock(lp, newl1);
+		newl1 = NULL;
+	}
+out:
+	free(newl1);
+	free(newl2);
+	return 0;
+}
+
+static void flock_to_lock(struct flock *flock, struct lock *lock)
+{
+	memset(lock, 0, sizeof(struct lock));
+	lock->type = flock->l_type;
+	lock->start = flock->l_start;
+	lock->end =
+		flock->l_len ? flock->l_start + flock->l_len - 1 : OFFSET_MAX;
+	lock->pid = flock->l_pid;
+}
+
+static void lock_to_flock(struct lock *lock, struct flock *flock)
+{
+	flock->l_type = lock->type;
+	flock->l_start = lock->start;
+	flock->l_len =
+		(lock->end == OFFSET_MAX) ? 0 : lock->end - lock->start + 1;
+	flock->l_pid = lock->pid;
+}
+
+static int fuse_flush_common(struct fuse *f, fuse_req_t req, fuse_ino_t ino,
+			     const char *path, struct fuse_file_info *fi)
+{
+	struct fuse_intr_data d;
+	struct flock lock;
+	struct lock l;
+	int err;
+	int errlock;
+
+	fuse_prepare_interrupt(f, req, &d);
+	memset(&lock, 0, sizeof(lock));
+	lock.l_type = F_UNLCK;
+	lock.l_whence = SEEK_SET;
+	err = fuse_fs_flush(f->fs, path, fi);
+	errlock = fuse_fs_lock(f->fs, path, fi, F_SETLK, &lock);
+	fuse_finish_interrupt(f, req, &d);
+
+	if (errlock != -ENOSYS) {
+		flock_to_lock(&lock, &l);
+		l.owner = fi->lock_owner;
+		pthread_mutex_lock(&f->lock);
+		locks_insert(get_node(f, ino), &l);
+		pthread_mutex_unlock(&f->lock);
+
+		/* if op.lock() is defined FLUSH is needed regardless
+		   of op.flush() */
+		if (err == -ENOSYS)
+			err = 0;
+	}
+	return err;
+}
+
+static void fuse_lib_release(fuse_req_t req, fuse_ino_t ino,
+			     struct fuse_file_info *fi)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct fuse_intr_data d;
+	char *path;
+	int err = 0;
+
+	get_path_nullok(f, ino, &path);
+	if (fi->flush) {
+		err = fuse_flush_common(f, req, ino, path, fi);
+		if (err == -ENOSYS)
+			err = 0;
+	}
+
+	fuse_prepare_interrupt(f, req, &d);
+	fuse_do_release(f, ino, path, fi);
+	fuse_finish_interrupt(f, req, &d);
+	free_path(f, ino, path);
+
+	reply_err(req, err);
+}
+
+static void fuse_lib_flush(fuse_req_t req, fuse_ino_t ino,
+			   struct fuse_file_info *fi)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	char *path;
+	int err;
+
+	get_path_nullok(f, ino, &path);
+	err = fuse_flush_common(f, req, ino, path, fi);
+	free_path(f, ino, path);
+
+	reply_err(req, err);
+}
+
+static int fuse_lock_common(fuse_req_t req, fuse_ino_t ino,
+			    struct fuse_file_info *fi, struct flock *lock,
+			    int cmd)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	char *path;
+	int err;
+
+	err = get_path_nullok(f, ino, &path);
+	if (!err) {
+		struct fuse_intr_data d;
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_lock(f->fs, path, fi, cmd, lock);
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, ino, path);
+	}
+	return err;
+}
+
+static void fuse_lib_getlk(fuse_req_t req, fuse_ino_t ino,
+			   struct fuse_file_info *fi, struct flock *lock)
+{
+	int err;
+	struct lock l;
+	struct lock *conflict;
+	struct fuse *f = req_fuse(req);
+
+	flock_to_lock(lock, &l);
+	l.owner = fi->lock_owner;
+	pthread_mutex_lock(&f->lock);
+	conflict = locks_conflict(get_node(f, ino), &l);
+	if (conflict)
+		lock_to_flock(conflict, lock);
+	pthread_mutex_unlock(&f->lock);
+	if (!conflict)
+		err = fuse_lock_common(req, ino, fi, lock, F_GETLK);
+	else
+		err = 0;
+
+	if (!err)
+		fuse_reply_lock(req, lock);
+	else
+		reply_err(req, err);
+}
+
+static void fuse_lib_setlk(fuse_req_t req, fuse_ino_t ino,
+			   struct fuse_file_info *fi, struct flock *lock,
+			   int sleep)
+{
+	int err = fuse_lock_common(req, ino, fi, lock,
+				   sleep ? F_SETLKW : F_SETLK);
+	if (!err) {
+		struct fuse *f = req_fuse(req);
+		struct lock l;
+		flock_to_lock(lock, &l);
+		l.owner = fi->lock_owner;
+		pthread_mutex_lock(&f->lock);
+		locks_insert(get_node(f, ino), &l);
+		pthread_mutex_unlock(&f->lock);
+	}
+	reply_err(req, err);
+}
+
+static void fuse_lib_flock(fuse_req_t req, fuse_ino_t ino,
+			   struct fuse_file_info *fi, int op)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	char *path;
+	int err;
+
+	err = get_path_nullok(f, ino, &path);
+	if (err == 0) {
+		struct fuse_intr_data d;
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_flock(f->fs, path, fi, op);
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, ino, path);
+	}
+	reply_err(req, err);
+}
+
+static void fuse_lib_bmap(fuse_req_t req, fuse_ino_t ino, size_t blocksize,
+			  uint64_t idx)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct fuse_intr_data d;
+	char *path;
+	int err;
+
+	err = get_path(f, ino, &path);
+	if (!err) {
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_bmap(f->fs, path, blocksize, &idx);
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, ino, path);
+	}
+	if (!err)
+		fuse_reply_bmap(req, idx);
+	else
+		reply_err(req, err);
+}
+
+static void fuse_lib_ioctl(fuse_req_t req, fuse_ino_t ino, int cmd, void *arg,
+			   struct fuse_file_info *fi, unsigned int flags,
+			   const void *in_buf, size_t in_bufsz,
+			   size_t out_bufsz)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct fuse_intr_data d;
+	char *path, *out_buf = NULL;
+	int err;
+
+	err = -EPERM;
+	if (flags & FUSE_IOCTL_UNRESTRICTED)
+		goto err;
+
+	if (out_bufsz) {
+		err = -ENOMEM;
+		out_buf = malloc(out_bufsz);
+		if (!out_buf)
+			goto err;
+	}
+
+	assert(!in_bufsz || !out_bufsz || in_bufsz == out_bufsz);
+	if (out_buf)
+		memcpy(out_buf, in_buf, in_bufsz);
+
+	err = get_path_nullok(f, ino, &path);
+	if (err)
+		goto err;
+
+	fuse_prepare_interrupt(f, req, &d);
+
+	err = fuse_fs_ioctl(f->fs, path, cmd, arg, fi, flags,
+			    out_buf ?: (void *)in_buf);
+
+	fuse_finish_interrupt(f, req, &d);
+	free_path(f, ino, path);
+
+	fuse_reply_ioctl(req, err, out_buf, out_bufsz);
+	goto out;
+err:
+	reply_err(req, err);
+out:
+	free(out_buf);
+}
+
+static void fuse_lib_poll(fuse_req_t req, fuse_ino_t ino,
+			  struct fuse_file_info *fi, struct fuse_pollhandle *ph)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct fuse_intr_data d;
+	char *path;
+	int err;
+	unsigned revents = 0;
+
+	err = get_path_nullok(f, ino, &path);
+	if (!err) {
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_poll(f->fs, path, fi, ph, &revents);
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, ino, path);
+	}
+	if (!err)
+		fuse_reply_poll(req, revents);
+	else
+		reply_err(req, err);
+}
+
+static void fuse_lib_fallocate(fuse_req_t req, fuse_ino_t ino, int mode,
+		off64_t offset, off64_t length, struct fuse_file_info *fi)
+{
+	struct fuse *f = req_fuse_prepare(req);
+	struct fuse_intr_data d;
+	char *path;
+	int err;
+
+	err = get_path_nullok(f, ino, &path);
+	if (!err) {
+		fuse_prepare_interrupt(f, req, &d);
+		err = fuse_fs_fallocate(f->fs, path, mode, offset, length, fi);
+		fuse_finish_interrupt(f, req, &d);
+		free_path(f, ino, path);
+	}
+	reply_err(req, err);
+}
+
+static int clean_delay(struct fuse *f)
+{
+	/*
+	 * This is calculating the delay between clean runs.  To
+	 * reduce the number of cleans we are doing them 10 times
+	 * within the remember window.
+	 */
+	int min_sleep = 60;
+	int max_sleep = 3600;
+	int sleep_time = f->conf.remember / 10;
+
+	if (sleep_time > max_sleep)
+		return max_sleep;
+	if (sleep_time < min_sleep)
+		return min_sleep;
+	return sleep_time;
+}
+
+int fuse_clean_cache(struct fuse *f)
+{
+	struct node_lru *lnode;
+	struct list_head *curr, *next;
+	struct node *node;
+	struct timespec now;
+
+	pthread_mutex_lock(&f->lock);
+
+	curr_time(&now);
+
+	for (curr = f->lru_table.next; curr != &f->lru_table; curr = next) {
+		double age;
+
+		next = curr->next;
+		lnode = list_entry(curr, struct node_lru, lru);
+		node = &lnode->node;
+
+		age = diff_timespec(&now, &lnode->forget_time);
+		if (age <= f->conf.remember)
+			break;
+
+		assert(node->nlookup == 1);
+
+		/* Don't forget active directories */
+		if (node->refctr > 1)
+			continue;
+
+		node->nlookup = 0;
+		unhash_name(f, node);
+		unref_node(f, node);
+	}
+	pthread_mutex_unlock(&f->lock);
+
+	return clean_delay(f);
+}
+
+static struct fuse_lowlevel_ops fuse_path_ops = {
+	.init = fuse_lib_init,
+	.destroy = fuse_lib_destroy,
+	.lookup = fuse_lib_lookup,
+	.forget = fuse_lib_forget,
+	.forget_multi = fuse_lib_forget_multi,
+	.getattr = fuse_lib_getattr,
+	.setattr = fuse_lib_setattr,
+	.access = fuse_lib_access,
+	.readlink = fuse_lib_readlink,
+	.mknod = fuse_lib_mknod,
+	.mkdir = fuse_lib_mkdir,
+	.unlink = fuse_lib_unlink,
+	.rmdir = fuse_lib_rmdir,
+	.symlink = fuse_lib_symlink,
+	.rename = fuse_lib_rename,
+	.link = fuse_lib_link,
+	.create = fuse_lib_create,
+	.open = fuse_lib_open,
+	.read = fuse_lib_read,
+	.write_buf = fuse_lib_write_buf,
+	.flush = fuse_lib_flush,
+	.release = fuse_lib_release,
+	.fsync = fuse_lib_fsync,
+	.opendir = fuse_lib_opendir,
+	.readdir = fuse_lib_readdir,
+	.releasedir = fuse_lib_releasedir,
+	.fsyncdir = fuse_lib_fsyncdir,
+	.statfs = fuse_lib_statfs,
+	.setxattr = fuse_lib_setxattr,
+	.getxattr = fuse_lib_getxattr,
+	.listxattr = fuse_lib_listxattr,
+	.removexattr = fuse_lib_removexattr,
+	.getlk = fuse_lib_getlk,
+	.setlk = fuse_lib_setlk,
+	.flock = fuse_lib_flock,
+	.bmap = fuse_lib_bmap,
+	.ioctl = fuse_lib_ioctl,
+	.poll = fuse_lib_poll,
+	.fallocate = fuse_lib_fallocate,
+};
+
+int fuse_notify_poll(struct fuse_pollhandle *ph)
+{
+	return fuse_lowlevel_notify_poll(ph);
+}
+
+static void free_cmd(struct fuse_cmd *cmd)
+{
+	free(cmd->buf);
+	free(cmd);
+}
+
+void fuse_process_cmd(struct fuse *f, struct fuse_cmd *cmd)
+{
+	fuse_session_process(f->se, cmd->buf, cmd->buflen, cmd->ch);
+	free_cmd(cmd);
+}
+
+int fuse_exited(struct fuse *f)
+{
+	return fuse_session_exited(f->se);
+}
+
+struct fuse_session *fuse_get_session(struct fuse *f)
+{
+	return f->se;
+}
+
+static struct fuse_cmd *fuse_alloc_cmd(size_t bufsize)
+{
+	struct fuse_cmd *cmd = (struct fuse_cmd *) malloc(sizeof(*cmd));
+	if (cmd == NULL) {
+		fprintf(stderr, "fuse: failed to allocate cmd\n");
+		return NULL;
+	}
+	cmd->buf = (char *) malloc(bufsize);
+	if (cmd->buf == NULL) {
+		fprintf(stderr, "fuse: failed to allocate read buffer\n");
+		free(cmd);
+		return NULL;
+	}
+	return cmd;
+}
+
+struct fuse_cmd *fuse_read_cmd(struct fuse *f)
+{
+	struct fuse_chan *ch = fuse_session_next_chan(f->se, NULL);
+	size_t bufsize = fuse_chan_bufsize(ch);
+	struct fuse_cmd *cmd = fuse_alloc_cmd(bufsize);
+	if (cmd != NULL) {
+		int res = fuse_chan_recv(&ch, cmd->buf, bufsize);
+		if (res <= 0) {
+			free_cmd(cmd);
+			if (res < 0 && res != -EINTR && res != -EAGAIN)
+				fuse_exit(f);
+			return NULL;
+		}
+		cmd->buflen = res;
+		cmd->ch = ch;
+	}
+	return cmd;
+}
+
+static int fuse_session_loop_remember(struct fuse *f)
+{
+	struct fuse_session *se = f->se;
+	int res = 0;
+	struct timespec now;
+	time_t next_clean;
+	struct fuse_chan *ch = fuse_session_next_chan(se, NULL);
+	size_t bufsize = fuse_chan_bufsize(ch);
+	char *buf = (char *) malloc(bufsize);
+	struct pollfd fds = {
+		.fd = fuse_chan_fd(ch),
+		.events = POLLIN
+	};
+
+	if (!buf) {
+		fprintf(stderr, "fuse: failed to allocate read buffer\n");
+		return -1;
+	}
+
+	curr_time(&now);
+	next_clean = now.tv_sec;
+	while (!fuse_session_exited(se)) {
+		struct fuse_chan *tmpch = ch;
+		struct fuse_buf fbuf = {
+			.mem = buf,
+			.size = bufsize,
+		};
+		unsigned timeout;
+
+		curr_time(&now);
+		if (now.tv_sec < next_clean)
+			timeout = next_clean - now.tv_sec;
+		else
+			timeout = 0;
+
+		res = poll(&fds, 1, timeout * 1000);
+		if (res == -1) {
+			if (errno == -EINTR)
+				continue;
+			else
+				break;
+		} else if (res > 0) {
+			res = fuse_session_receive_buf(se, &fbuf, &tmpch);
+
+			if (res == -EINTR)
+				continue;
+			if (res <= 0)
+				break;
+
+			fuse_session_process_buf(se, &fbuf, tmpch);
+		} else {
+			timeout = fuse_clean_cache(f);
+			curr_time(&now);
+			next_clean = now.tv_sec + timeout;
+		}
+	}
+
+	free(buf);
+	fuse_session_reset(se);
+	return res < 0 ? -1 : 0;
+}
+
+int fuse_loop(struct fuse *f)
+{
+	if (!f)
+		return -1;
+
+	if (lru_enabled(f))
+		return fuse_session_loop_remember(f);
+
+	return fuse_session_loop(f->se);
+}
+
+int fuse_invalidate(struct fuse *f, const char *path)
+{
+	(void) f;
+	(void) path;
+	return -EINVAL;
+}
+
+void fuse_exit(struct fuse *f)
+{
+	fuse_session_exit(f->se);
+}
+
+struct fuse_context *fuse_get_context(void)
+{
+	return &fuse_get_context_internal()->ctx;
+}
+
+/*
+ * The size of fuse_context got extended, so need to be careful about
+ * incompatibility (i.e. a new binary cannot work with an old
+ * library).
+ */
+struct fuse_context *fuse_get_context_compat22(void);
+struct fuse_context *fuse_get_context_compat22(void)
+{
+	return &fuse_get_context_internal()->ctx;
+}
+FUSE_SYMVER(".symver fuse_get_context_compat22,fuse_get_context@FUSE_2.2");
+
+int fuse_getgroups(int size, gid_t list[])
+{
+	fuse_req_t req = fuse_get_context_internal()->req;
+	return fuse_req_getgroups(req, size, list);
+}
+
+int fuse_interrupted(void)
+{
+	return fuse_req_interrupted(fuse_get_context_internal()->req);
+}
+
+void fuse_set_getcontext_func(struct fuse_context *(*func)(void))
+{
+	(void) func;
+	/* no-op */
+}
+
+enum {
+	KEY_HELP,
+};
+
+#define FUSE_LIB_OPT(t, p, v) { t, offsetof(struct fuse_config, p), v }
+
+static const struct fuse_opt fuse_lib_opts[] = {
+	FUSE_OPT_KEY("-h",		      KEY_HELP),
+	FUSE_OPT_KEY("--help",		      KEY_HELP),
+	FUSE_OPT_KEY("debug",		      FUSE_OPT_KEY_KEEP),
+	FUSE_OPT_KEY("-d",		      FUSE_OPT_KEY_KEEP),
+	FUSE_LIB_OPT("debug",		      debug, 1),
+	FUSE_LIB_OPT("-d",		      debug, 1),
+	FUSE_LIB_OPT("hard_remove",	      hard_remove, 1),
+	FUSE_LIB_OPT("use_ino",		      use_ino, 1),
+	FUSE_LIB_OPT("readdir_ino",	      readdir_ino, 1),
+	FUSE_LIB_OPT("direct_io",	      direct_io, 1),
+	FUSE_LIB_OPT("kernel_cache",	      kernel_cache, 1),
+	FUSE_LIB_OPT("auto_cache",	      auto_cache, 1),
+	FUSE_LIB_OPT("noauto_cache",	      auto_cache, 0),
+	FUSE_LIB_OPT("umask=",		      set_mode, 1),
+	FUSE_LIB_OPT("umask=%o",	      umask, 0),
+	FUSE_LIB_OPT("uid=",		      set_uid, 1),
+	FUSE_LIB_OPT("uid=%d",		      uid, 0),
+	FUSE_LIB_OPT("gid=",		      set_gid, 1),
+	FUSE_LIB_OPT("gid=%d",		      gid, 0),
+	FUSE_LIB_OPT("entry_timeout=%lf",     entry_timeout, 0),
+	FUSE_LIB_OPT("attr_timeout=%lf",      attr_timeout, 0),
+	FUSE_LIB_OPT("ac_attr_timeout=%lf",   ac_attr_timeout, 0),
+	FUSE_LIB_OPT("ac_attr_timeout=",      ac_attr_timeout_set, 1),
+	FUSE_LIB_OPT("negative_timeout=%lf",  negative_timeout, 0),
+	FUSE_LIB_OPT("noforget",              remember, -1),
+	FUSE_LIB_OPT("remember=%u",           remember, 0),
+	FUSE_LIB_OPT("nopath",                nopath, 1),
+	FUSE_LIB_OPT("intr",		      intr, 1),
+	FUSE_LIB_OPT("intr_signal=%d",	      intr_signal, 0),
+	FUSE_LIB_OPT("modules=%s",	      modules, 0),
+	FUSE_OPT_END
+};
+
+static void fuse_lib_help(void)
+{
+	fprintf(stderr,
+"    -o hard_remove         immediate removal (don't hide files)\n"
+"    -o use_ino             let filesystem set inode numbers\n"
+"    -o readdir_ino         try to fill in d_ino in readdir\n"
+"    -o direct_io           use direct I/O\n"
+"    -o kernel_cache        cache files in kernel\n"
+"    -o [no]auto_cache      enable caching based on modification times (off)\n"
+"    -o umask=M             set file permissions (octal)\n"
+"    -o uid=N               set file owner\n"
+"    -o gid=N               set file group\n"
+"    -o entry_timeout=T     cache timeout for names (1.0s)\n"
+"    -o negative_timeout=T  cache timeout for deleted names (0.0s)\n"
+"    -o attr_timeout=T      cache timeout for attributes (1.0s)\n"
+"    -o ac_attr_timeout=T   auto cache timeout for attributes (attr_timeout)\n"
+"    -o noforget            never forget cached inodes\n"
+"    -o remember=T          remember cached inodes for T seconds (0s)\n"
+"    -o intr                allow requests to be interrupted\n"
+"    -o intr_signal=NUM     signal to send on interrupt (%i)\n"
+"    -o modules=M1[:M2...]  names of modules to push onto filesystem stack\n"
+"\n", FUSE_DEFAULT_INTR_SIGNAL);
+}
+
+static void fuse_lib_help_modules(void)
+{
+	struct fuse_module *m;
+	fprintf(stderr, "\nModule options:\n");
+	pthread_mutex_lock(&fuse_context_lock);
+	for (m = fuse_modules; m; m = m->next) {
+		struct fuse_fs *fs = NULL;
+		struct fuse_fs *newfs;
+		struct fuse_args args = FUSE_ARGS_INIT(0, NULL);
+		if (fuse_opt_add_arg(&args, "") != -1 &&
+		    fuse_opt_add_arg(&args, "-h") != -1) {
+			fprintf(stderr, "\n[%s]\n", m->name);
+			newfs = m->factory(&args, &fs);
+			assert(newfs == NULL);
+		}
+		fuse_opt_free_args(&args);
+	}
+	pthread_mutex_unlock(&fuse_context_lock);
+}
+
+static int fuse_lib_opt_proc(void *data, const char *arg, int key,
+			     struct fuse_args *outargs)
+{
+	(void) arg; (void) outargs;
+
+	if (key == KEY_HELP) {
+		struct fuse_config *conf = (struct fuse_config *) data;
+		fuse_lib_help();
+		conf->help = 1;
+	}
+
+	return 1;
+}
+
+int fuse_is_lib_option(const char *opt)
+{
+	return fuse_lowlevel_is_lib_option(opt) ||
+		fuse_opt_match(fuse_lib_opts, opt);
+}
+
+static int fuse_init_intr_signal(int signum, int *installed)
+{
+	struct sigaction old_sa;
+
+	if (sigaction(signum, NULL, &old_sa) == -1) {
+		perror("fuse: cannot get old signal handler");
+		return -1;
+	}
+
+	if (old_sa.sa_handler == SIG_DFL) {
+		struct sigaction sa;
+
+		memset(&sa, 0, sizeof(struct sigaction));
+		sa.sa_handler = fuse_intr_sighandler;
+		sigemptyset(&sa.sa_mask);
+
+		if (sigaction(signum, &sa, NULL) == -1) {
+			perror("fuse: cannot set interrupt signal handler");
+			return -1;
+		}
+		*installed = 1;
+	}
+	return 0;
+}
+
+static void fuse_restore_intr_signal(int signum)
+{
+	struct sigaction sa;
+
+	memset(&sa, 0, sizeof(struct sigaction));
+	sa.sa_handler = SIG_DFL;
+	sigaction(signum, &sa, NULL);
+}
+
+
+static int fuse_push_module(struct fuse *f, const char *module,
+			    struct fuse_args *args)
+{
+	struct fuse_fs *fs[2] = { f->fs, NULL };
+	struct fuse_fs *newfs;
+	struct fuse_module *m = fuse_get_module(module);
+
+	if (!m)
+		return -1;
+
+	newfs = m->factory(args, fs);
+	if (!newfs) {
+		fuse_put_module(m);
+		return -1;
+	}
+	newfs->m = m;
+	f->fs = newfs;
+	f->nullpath_ok = newfs->op.flag_nullpath_ok && f->nullpath_ok;
+	f->conf.nopath = newfs->op.flag_nopath && f->conf.nopath;
+	f->utime_omit_ok = newfs->op.flag_utime_omit_ok && f->utime_omit_ok;
+	return 0;
+}
+
+struct fuse_fs *fuse_fs_new(const struct fuse_operations *op, size_t op_size,
+			    void *user_data)
+{
+	struct fuse_fs *fs;
+
+	if (sizeof(struct fuse_operations) < op_size) {
+		fprintf(stderr, "fuse: warning: library too old, some operations may not not work\n");
+		op_size = sizeof(struct fuse_operations);
+	}
+
+	fs = (struct fuse_fs *) calloc(1, sizeof(struct fuse_fs));
+	if (!fs) {
+		fprintf(stderr, "fuse: failed to allocate fuse_fs object\n");
+		return NULL;
+	}
+
+	fs->user_data = user_data;
+	if (op)
+		memcpy(&fs->op, op, op_size);
+	return fs;
+}
+
+static int node_table_init(struct node_table *t)
+{
+	t->size = NODE_TABLE_MIN_SIZE;
+	t->array = (struct node **) calloc(1, sizeof(struct node *) * t->size);
+	if (t->array == NULL) {
+		fprintf(stderr, "fuse: memory allocation failed\n");
+		return -1;
+	}
+	t->use = 0;
+	t->split = 0;
+
+	return 0;
+}
+
+static void *fuse_prune_nodes(void *fuse)
+{
+	struct fuse *f = fuse;
+	int sleep_time;
+
+	while(1) {
+		sleep_time = fuse_clean_cache(f);
+		sleep(sleep_time);
+	}
+	return NULL;
+}
+
+int fuse_start_cleanup_thread(struct fuse *f)
+{
+	if (lru_enabled(f))
+		return fuse_start_thread(&f->prune_thread, fuse_prune_nodes, f);
+
+	return 0;
+}
+
+void fuse_stop_cleanup_thread(struct fuse *f)
+{
+	if (lru_enabled(f)) {
+		pthread_mutex_lock(&f->lock);
+		pthread_cancel(f->prune_thread);
+		pthread_mutex_unlock(&f->lock);
+		pthread_join(f->prune_thread, NULL);
+	}
+}
+
+struct fuse *fuse_new_common(struct fuse_chan *ch, struct fuse_args *args,
+			     const struct fuse_operations *op,
+			     size_t op_size, void *user_data, int compat)
+{
+	struct fuse *f;
+	struct node *root;
+	struct fuse_fs *fs;
+	struct fuse_lowlevel_ops llop = fuse_path_ops;
+
+	if (fuse_create_context_key() == -1)
+		goto out;
+
+	f = (struct fuse *) calloc(1, sizeof(struct fuse));
+	if (f == NULL) {
+		fprintf(stderr, "fuse: failed to allocate fuse object\n");
+		goto out_delete_context_key;
+	}
+
+	fs = fuse_fs_new(op, op_size, user_data);
+	if (!fs)
+		goto out_free;
+
+	fs->compat = compat;
+	f->fs = fs;
+	f->nullpath_ok = fs->op.flag_nullpath_ok;
+	f->conf.nopath = fs->op.flag_nopath;
+	f->utime_omit_ok = fs->op.flag_utime_omit_ok;
+
+	/* Oh f**k, this is ugly! */
+	if (!fs->op.lock) {
+		llop.getlk = NULL;
+		llop.setlk = NULL;
+	}
+
+	f->conf.entry_timeout = 1.0;
+	f->conf.attr_timeout = 1.0;
+	f->conf.negative_timeout = 0.0;
+	f->conf.intr_signal = FUSE_DEFAULT_INTR_SIGNAL;
+
+	f->pagesize = getpagesize();
+	init_list_head(&f->partial_slabs);
+	init_list_head(&f->full_slabs);
+	init_list_head(&f->lru_table);
+
+	if (fuse_opt_parse(args, &f->conf, fuse_lib_opts,
+			   fuse_lib_opt_proc) == -1)
+		goto out_free_fs;
+
+	if (f->conf.modules) {
+		char *module;
+		char *next;
+
+		for (module = f->conf.modules; module; module = next) {
+			char *p;
+			for (p = module; *p && *p != ':'; p++);
+			next = *p ? p + 1 : NULL;
+			*p = '\0';
+			if (module[0] &&
+			    fuse_push_module(f, module, args) == -1)
+				goto out_free_fs;
+		}
+	}
+
+	if (!f->conf.ac_attr_timeout_set)
+		f->conf.ac_attr_timeout = f->conf.attr_timeout;
+
+#if defined(__FreeBSD__) || defined(__NetBSD__)
+	/*
+	 * In FreeBSD, we always use these settings as inode numbers
+	 * are needed to make getcwd(3) work.
+	 */
+	f->conf.readdir_ino = 1;
+#endif
+
+	if (compat && compat <= 25) {
+		if (fuse_sync_compat_args(args) == -1)
+			goto out_free_fs;
+	}
+
+	f->se = fuse_lowlevel_new_common(args, &llop, sizeof(llop), f);
+	if (f->se == NULL) {
+		if (f->conf.help)
+			fuse_lib_help_modules();
+		goto out_free_fs;
+	}
+
+	fuse_session_add_chan(f->se, ch);
+
+	if (f->conf.debug) {
+		fprintf(stderr, "nullpath_ok: %i\n", f->nullpath_ok);
+		fprintf(stderr, "nopath: %i\n", f->conf.nopath);
+		fprintf(stderr, "utime_omit_ok: %i\n", f->utime_omit_ok);
+	}
+
+	/* Trace topmost layer by default */
+	f->fs->debug = f->conf.debug;
+	f->ctr = 0;
+	f->generation = 0;
+	if (node_table_init(&f->name_table) == -1)
+		goto out_free_session;
+
+	if (node_table_init(&f->id_table) == -1)
+		goto out_free_name_table;
+
+	fuse_mutex_init(&f->lock);
+
+	root = alloc_node(f);
+	if (root == NULL) {
+		fprintf(stderr, "fuse: memory allocation failed\n");
+		goto out_free_id_table;
+	}
+
+	strcpy(root->inline_name, "/");
+	root->name = root->inline_name;
+
+	if (f->conf.intr &&
+	    fuse_init_intr_signal(f->conf.intr_signal,
+				  &f->intr_installed) == -1)
+		goto out_free_root;
+
+	root->parent = NULL;
+	root->nodeid = FUSE_ROOT_ID;
+	inc_nlookup(root);
+	hash_id(f, root);
+
+	return f;
+
+out_free_root:
+	free(root);
+out_free_id_table:
+	free(f->id_table.array);
+out_free_name_table:
+	free(f->name_table.array);
+out_free_session:
+	fuse_session_destroy(f->se);
+out_free_fs:
+	/* Horrible compatibility hack to stop the destructor from being
+	   called on the filesystem without init being called first */
+	fs->op.destroy = NULL;
+	fuse_fs_destroy(f->fs);
+	free(f->conf.modules);
+out_free:
+	free(f);
+out_delete_context_key:
+	fuse_delete_context_key();
+out:
+	return NULL;
+}
+
+struct fuse *fuse_new(struct fuse_chan *ch, struct fuse_args *args,
+		      const struct fuse_operations *op, size_t op_size,
+		      void *user_data)
+{
+	return fuse_new_common(ch, args, op, op_size, user_data, 0);
+}
+
+void fuse_destroy(struct fuse *f)
+{
+	size_t i;
+
+	if (f->conf.intr && f->intr_installed)
+		fuse_restore_intr_signal(f->conf.intr_signal);
+
+	if (f->fs) {
+		struct fuse_context_i *c = fuse_get_context_internal();
+
+		memset(c, 0, sizeof(*c));
+		c->ctx.fuse = f;
+
+		for (i = 0; i < f->id_table.size; i++) {
+			struct node *node;
+
+			for (node = f->id_table.array[i]; node != NULL;
+			     node = node->id_next) {
+				if (node->is_hidden) {
+					char *path;
+					if (try_get_path(f, node->nodeid, NULL, &path, NULL, false) == 0) {
+						fuse_fs_unlink(f->fs, path);
+						free(path);
+					}
+				}
+			}
+		}
+	}
+	for (i = 0; i < f->id_table.size; i++) {
+		struct node *node;
+		struct node *next;
+
+		for (node = f->id_table.array[i]; node != NULL; node = next) {
+			next = node->id_next;
+			free_node(f, node);
+			f->id_table.use--;
+		}
+	}
+	assert(list_empty(&f->partial_slabs));
+	assert(list_empty(&f->full_slabs));
+
+	free(f->id_table.array);
+	free(f->name_table.array);
+	pthread_mutex_destroy(&f->lock);
+	fuse_session_destroy(f->se);
+	free(f->conf.modules);
+	free(f);
+	fuse_delete_context_key();
+}
+
+static struct fuse *fuse_new_common_compat25(int fd, struct fuse_args *args,
+					     const struct fuse_operations *op,
+					     size_t op_size, int compat)
+{
+	struct fuse *f = NULL;
+	struct fuse_chan *ch = fuse_kern_chan_new(fd);
+
+	if (ch)
+		f = fuse_new_common(ch, args, op, op_size, NULL, compat);
+
+	return f;
+}
+
+/* called with fuse_context_lock held or during initialization (before
+   main() has been called) */
+void fuse_register_module(struct fuse_module *mod)
+{
+	mod->ctr = 0;
+	mod->so = fuse_current_so;
+	if (mod->so)
+		mod->so->ctr++;
+	mod->next = fuse_modules;
+	fuse_modules = mod;
+}
+
+#if !defined(__FreeBSD__) && !defined(__NetBSD__)
+
+static struct fuse *fuse_new_common_compat(int fd, const char *opts,
+					   const struct fuse_operations *op,
+					   size_t op_size, int compat)
+{
+	struct fuse *f;
+	struct fuse_args args = FUSE_ARGS_INIT(0, NULL);
+
+	if (fuse_opt_add_arg(&args, "") == -1)
+		return NULL;
+	if (opts &&
+	    (fuse_opt_add_arg(&args, "-o") == -1 ||
+	     fuse_opt_add_arg(&args, opts) == -1)) {
+		fuse_opt_free_args(&args);
+		return NULL;
+	}
+	f = fuse_new_common_compat25(fd, &args, op, op_size, compat);
+	fuse_opt_free_args(&args);
+
+	return f;
+}
+
+struct fuse *fuse_new_compat22(int fd, const char *opts,
+			       const struct fuse_operations_compat22 *op,
+			       size_t op_size)
+{
+	return fuse_new_common_compat(fd, opts, (struct fuse_operations *) op,
+				      op_size, 22);
+}
+
+struct fuse *fuse_new_compat2(int fd, const char *opts,
+			      const struct fuse_operations_compat2 *op)
+{
+	return fuse_new_common_compat(fd, opts, (struct fuse_operations *) op,
+				      sizeof(struct fuse_operations_compat2),
+				      21);
+}
+
+struct fuse *fuse_new_compat1(int fd, int flags,
+			      const struct fuse_operations_compat1 *op)
+{
+	const char *opts = NULL;
+	if (flags & FUSE_DEBUG_COMPAT1)
+		opts = "debug";
+	return fuse_new_common_compat(fd, opts, (struct fuse_operations *) op,
+				      sizeof(struct fuse_operations_compat1),
+				      11);
+}
+
+FUSE_SYMVER(".symver fuse_exited,__fuse_exited@");
+FUSE_SYMVER(".symver fuse_process_cmd,__fuse_process_cmd@");
+FUSE_SYMVER(".symver fuse_read_cmd,__fuse_read_cmd@");
+FUSE_SYMVER(".symver fuse_set_getcontext_func,__fuse_set_getcontext_func@");
+FUSE_SYMVER(".symver fuse_new_compat2,fuse_new@");
+FUSE_SYMVER(".symver fuse_new_compat22,fuse_new@FUSE_2.2");
+
+#endif /* __FreeBSD__ || __NetBSD__  */
+
+struct fuse *fuse_new_compat25(int fd, struct fuse_args *args,
+			       const struct fuse_operations_compat25 *op,
+			       size_t op_size)
+{
+	return fuse_new_common_compat25(fd, args, (struct fuse_operations *) op,
+					op_size, 25);
+}
+
+FUSE_SYMVER(".symver fuse_new_compat25,fuse_new@FUSE_2.5");
diff --git a/external/fuse/fuse_i.h b/external/fuse/fuse_i.h
new file mode 100755
index 0000000000..78f14677aa
--- /dev/null
+++ b/external/fuse/fuse_i.h
@@ -0,0 +1,128 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB
+*/
+
+#include "fuse.h"
+#include "fuse_lowlevel.h"
+
+struct fuse_chan;
+struct fuse_ll;
+
+struct fuse_session {
+	struct fuse_session_ops op;
+
+	int (*receive_buf)(struct fuse_session *se, struct fuse_buf *buf,
+			   struct fuse_chan **chp);
+
+	void (*process_buf)(void *data, const struct fuse_buf *buf,
+			    struct fuse_chan *ch);
+
+	void *data;
+
+	volatile int exited;
+
+	struct fuse_chan *ch;
+};
+
+struct fuse_req {
+	struct fuse_ll *f;
+	uint64_t unique;
+	int ctr;
+	pthread_mutex_t lock;
+	struct fuse_ctx ctx;
+	struct fuse_chan *ch;
+	int interrupted;
+	unsigned int ioctl_64bit : 1;
+	union {
+		struct {
+			uint64_t unique;
+		} i;
+		struct {
+			fuse_interrupt_func_t func;
+			void *data;
+		} ni;
+	} u;
+	struct fuse_req *next;
+	struct fuse_req *prev;
+};
+
+struct fuse_notify_req {
+	uint64_t unique;
+	void (*reply)(struct fuse_notify_req *, fuse_req_t, fuse_ino_t,
+		      const void *, const struct fuse_buf *);
+	struct fuse_notify_req *next;
+	struct fuse_notify_req *prev;
+};
+
+struct fuse_ll {
+	int debug;
+	int allow_root;
+	int atomic_o_trunc;
+	int no_remote_posix_lock;
+	int no_remote_flock;
+	int big_writes;
+	int splice_write;
+	int splice_move;
+	int splice_read;
+	int no_splice_write;
+	int no_splice_move;
+	int no_splice_read;
+	struct fuse_lowlevel_ops op;
+	int got_init;
+	struct cuse_data *cuse_data;
+	void *userdata;
+	uid_t owner;
+	struct fuse_conn_info conn;
+	struct fuse_req list;
+	struct fuse_req interrupts;
+	pthread_mutex_t lock;
+	int got_destroy;
+	pthread_key_t pipe_key;
+	int broken_splice_nonblock;
+	uint64_t notify_ctr;
+	struct fuse_notify_req notify_list;
+};
+
+struct fuse_cmd {
+	char *buf;
+	size_t buflen;
+	struct fuse_chan *ch;
+};
+
+struct fuse *fuse_new_common(struct fuse_chan *ch, struct fuse_args *args,
+			     const struct fuse_operations *op,
+			     size_t op_size, void *user_data, int compat);
+
+int fuse_sync_compat_args(struct fuse_args *args);
+
+struct fuse_chan *fuse_kern_chan_new(int fd);
+
+struct fuse_session *fuse_lowlevel_new_common(struct fuse_args *args,
+					const struct fuse_lowlevel_ops *op,
+					size_t op_size, void *userdata);
+
+void fuse_kern_unmount_compat22(const char *mountpoint);
+void fuse_kern_unmount(const char *mountpoint, int fd);
+int fuse_kern_mount(const char *mountpoint, struct fuse_args *args);
+
+int fuse_send_reply_iov_nofree(fuse_req_t req, int error, struct iovec *iov,
+			       int count);
+void fuse_free_req(fuse_req_t req);
+
+
+struct fuse *fuse_setup_common(int argc, char *argv[],
+			       const struct fuse_operations *op,
+			       size_t op_size,
+			       char **mountpoint,
+			       int *multithreaded,
+			       int *fd,
+			       void *user_data,
+			       int compat);
+
+void cuse_lowlevel_init(fuse_req_t req, fuse_ino_t nodeide, const void *inarg);
+
+int fuse_start_thread(pthread_t *thread_id, void *(*func)(void *), void *arg);
diff --git a/external/fuse/fuse_kern_chan.c b/external/fuse/fuse_kern_chan.c
new file mode 100755
index 0000000000..5f77bbf562
--- /dev/null
+++ b/external/fuse/fuse_kern_chan.c
@@ -0,0 +1,95 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB
+*/
+
+#include "fuse_lowlevel.h"
+#include "fuse_kernel.h"
+#include "fuse_i.h"
+
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <assert.h>
+
+static int fuse_kern_chan_receive(struct fuse_chan **chp, char *buf,
+				  size_t size)
+{
+	struct fuse_chan *ch = *chp;
+	int err;
+	ssize_t res;
+	struct fuse_session *se = fuse_chan_session(ch);
+	assert(se != NULL);
+
+restart:
+	res = read(fuse_chan_fd(ch), buf, size);
+	err = errno;
+
+	if (fuse_session_exited(se))
+		return 0;
+	if (res == -1) {
+		/* ENOENT means the operation was interrupted, it's safe
+		   to restart */
+		if (err == ENOENT)
+			goto restart;
+
+		if (err == ENODEV) {
+			fuse_session_exit(se);
+			return 0;
+		}
+		/* Errors occurring during normal operation: EINTR (read
+		   interrupted), EAGAIN (nonblocking I/O), ENODEV (filesystem
+		   umounted) */
+		if (err != EINTR && err != EAGAIN)
+			perror("fuse: reading device");
+		return -err;
+	}
+	if ((size_t) res < sizeof(struct fuse_in_header)) {
+		fprintf(stderr, "short read on fuse device\n");
+		return -EIO;
+	}
+	return res;
+}
+
+static int fuse_kern_chan_send(struct fuse_chan *ch, const struct iovec iov[],
+			       size_t count)
+{
+	if (iov) {
+		ssize_t res = writev(fuse_chan_fd(ch), iov, count);
+		int err = errno;
+
+		if (res == -1) {
+			struct fuse_session *se = fuse_chan_session(ch);
+
+			assert(se != NULL);
+
+			/* ENOENT means the operation was interrupted */
+			if (!fuse_session_exited(se) && err != ENOENT)
+				perror("fuse: writing device");
+			return -err;
+		}
+	}
+	return 0;
+}
+
+static void fuse_kern_chan_destroy(struct fuse_chan *ch)
+{
+	close(fuse_chan_fd(ch));
+}
+
+#define MIN_BUFSIZE 0x21000
+
+struct fuse_chan *fuse_kern_chan_new(int fd)
+{
+	struct fuse_chan_ops op = {
+		.receive = fuse_kern_chan_receive,
+		.send = fuse_kern_chan_send,
+		.destroy = fuse_kern_chan_destroy,
+	};
+	size_t bufsize = getpagesize() + 0x1000;
+	bufsize = bufsize < MIN_BUFSIZE ? MIN_BUFSIZE : bufsize;
+	return fuse_chan_new(&op, fd, bufsize, NULL);
+}
diff --git a/external/fuse/fuse_loop.c b/external/fuse/fuse_loop.c
new file mode 100755
index 0000000000..b7b4ca4eee
--- /dev/null
+++ b/external/fuse/fuse_loop.c
@@ -0,0 +1,46 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB
+*/
+
+#include "fuse_lowlevel.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+
+int fuse_session_loop(struct fuse_session *se)
+{
+	int res = 0;
+	struct fuse_chan *ch = fuse_session_next_chan(se, NULL);
+	size_t bufsize = fuse_chan_bufsize(ch);
+	char *buf = (char *) malloc(bufsize);
+	if (!buf) {
+		fprintf(stderr, "fuse: failed to allocate read buffer\n");
+		return -1;
+	}
+
+	while (!fuse_session_exited(se)) {
+		struct fuse_chan *tmpch = ch;
+		struct fuse_buf fbuf = {
+			.mem = buf,
+			.size = bufsize,
+		};
+
+		res = fuse_session_receive_buf(se, &fbuf, &tmpch);
+
+		if (res == -EINTR)
+			continue;
+		if (res <= 0)
+			break;
+
+		fuse_session_process_buf(se, &fbuf, tmpch);
+	}
+
+	free(buf);
+	fuse_session_reset(se);
+	return res < 0 ? -1 : 0;
+}
diff --git a/external/fuse/fuse_loop_mt.c b/external/fuse/fuse_loop_mt.c
new file mode 100755
index 0000000000..1bae244385
--- /dev/null
+++ b/external/fuse/fuse_loop_mt.c
@@ -0,0 +1,266 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB.
+*/
+
+#include "fuse_lowlevel.h"
+#include "fuse_misc.h"
+#include "fuse_kernel.h"
+#include "fuse_i.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <signal.h>
+#include <semaphore.h>
+#include <errno.h>
+#include <sys/time.h>
+#include <pthread.h>
+#if defined(__ANDROID__)
+extern int pthread_cancel(pthread_t thread);
+extern int pthread_setcancelstate(int state, int *oldstate);
+#endif
+
+/* Environment var controlling the thread stack size */
+#define ENVNAME_THREAD_STACK "FUSE_THREAD_STACK"
+
+struct fuse_worker {
+	struct fuse_worker *prev;
+	struct fuse_worker *next;
+	pthread_t thread_id;
+	size_t bufsize;
+	char *buf;
+	struct fuse_mt *mt;
+};
+
+struct fuse_mt {
+	pthread_mutex_t lock;
+	int numworker;
+	int numavail;
+	struct fuse_session *se;
+	struct fuse_chan *prevch;
+	struct fuse_worker main;
+	sem_t finish;
+	int exit;
+	int error;
+};
+
+static void list_add_worker(struct fuse_worker *w, struct fuse_worker *next)
+{
+	struct fuse_worker *prev = next->prev;
+	w->next = next;
+	w->prev = prev;
+	prev->next = w;
+	next->prev = w;
+}
+
+static void list_del_worker(struct fuse_worker *w)
+{
+	struct fuse_worker *prev = w->prev;
+	struct fuse_worker *next = w->next;
+	prev->next = next;
+	next->prev = prev;
+}
+
+#define PTHREAD_CANCEL_ENABLE 0
+#define PTHREAD_CANCEL_DISABLE 1
+
+static int fuse_loop_start_thread(struct fuse_mt *mt);
+
+static void *fuse_do_work(void *data)
+{
+	struct fuse_worker *w = (struct fuse_worker *) data;
+	struct fuse_mt *mt = w->mt;
+
+	while (!fuse_session_exited(mt->se)) {
+		int isforget = 0;
+		struct fuse_chan *ch = mt->prevch;
+		struct fuse_buf fbuf = {
+			.mem = w->buf,
+			.size = w->bufsize,
+		};
+		int res;
+
+		pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
+		res = fuse_session_receive_buf(mt->se, &fbuf, &ch);
+		pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
+		if (res == -EINTR)
+			continue;
+		if (res <= 0) {
+			if (res < 0) {
+				fuse_session_exit(mt->se);
+				mt->error = -1;
+			}
+			break;
+		}
+
+		pthread_mutex_lock(&mt->lock);
+		if (mt->exit) {
+			pthread_mutex_unlock(&mt->lock);
+			return NULL;
+		}
+
+		/*
+		 * This disgusting hack is needed so that zillions of threads
+		 * are not created on a burst of FORGET messages
+		 */
+		if (!(fbuf.flags & FUSE_BUF_IS_FD)) {
+			struct fuse_in_header *in = fbuf.mem;
+
+			if (in->opcode == FUSE_FORGET ||
+			    in->opcode == FUSE_BATCH_FORGET)
+				isforget = 1;
+		}
+
+		if (!isforget)
+			mt->numavail--;
+		if (mt->numavail == 0)
+			fuse_loop_start_thread(mt);
+		pthread_mutex_unlock(&mt->lock);
+
+		fuse_session_process_buf(mt->se, &fbuf, ch);
+
+		pthread_mutex_lock(&mt->lock);
+		if (!isforget)
+			mt->numavail++;
+		if (mt->numavail > 10) {
+			if (mt->exit) {
+				pthread_mutex_unlock(&mt->lock);
+				return NULL;
+			}
+			list_del_worker(w);
+			mt->numavail--;
+			mt->numworker--;
+			pthread_mutex_unlock(&mt->lock);
+
+			pthread_detach(w->thread_id);
+			free(w->buf);
+			free(w);
+			return NULL;
+		}
+		pthread_mutex_unlock(&mt->lock);
+	}
+
+	sem_post(&mt->finish);
+
+	return NULL;
+}
+
+int fuse_start_thread(pthread_t *thread_id, void *(*func)(void *), void *arg)
+{
+	sigset_t oldset;
+	sigset_t newset;
+	int res;
+	pthread_attr_t attr;
+	char *stack_size;
+
+	/* Override default stack size */
+	pthread_attr_init(&attr);
+	stack_size = getenv(ENVNAME_THREAD_STACK);
+	if (stack_size && pthread_attr_setstacksize(&attr, atoi(stack_size)))
+		fprintf(stderr, "fuse: invalid stack size: %s\n", stack_size);
+
+	/* Disallow signal reception in worker threads */
+	sigemptyset(&newset);
+	sigaddset(&newset, SIGTERM);
+	sigaddset(&newset, SIGINT);
+	sigaddset(&newset, SIGHUP);
+	sigaddset(&newset, SIGQUIT);
+	pthread_sigmask(SIG_BLOCK, &newset, &oldset);
+	res = pthread_create(thread_id, &attr, func, arg);
+	pthread_sigmask(SIG_SETMASK, &oldset, NULL);
+	pthread_attr_destroy(&attr);
+	if (res != 0) {
+		fprintf(stderr, "fuse: error creating thread: %s\n",
+			strerror(res));
+		return -1;
+	}
+
+	return 0;
+}
+
+static int fuse_loop_start_thread(struct fuse_mt *mt)
+{
+	int res;
+	struct fuse_worker *w = malloc(sizeof(struct fuse_worker));
+	if (!w) {
+		fprintf(stderr, "fuse: failed to allocate worker structure\n");
+		return -1;
+	}
+	memset(w, 0, sizeof(struct fuse_worker));
+	w->bufsize = fuse_chan_bufsize(mt->prevch);
+	w->buf = malloc(w->bufsize);
+	w->mt = mt;
+	if (!w->buf) {
+		fprintf(stderr, "fuse: failed to allocate read buffer\n");
+		free(w);
+		return -1;
+	}
+
+	res = fuse_start_thread(&w->thread_id, fuse_do_work, w);
+	if (res == -1) {
+		free(w->buf);
+		free(w);
+		return -1;
+	}
+	list_add_worker(w, &mt->main);
+	mt->numavail ++;
+	mt->numworker ++;
+
+	return 0;
+}
+
+static void fuse_join_worker(struct fuse_mt *mt, struct fuse_worker *w)
+{
+	pthread_join(w->thread_id, NULL);
+	pthread_mutex_lock(&mt->lock);
+	list_del_worker(w);
+	pthread_mutex_unlock(&mt->lock);
+	free(w->buf);
+	free(w);
+}
+
+int fuse_session_loop_mt(struct fuse_session *se)
+{
+	int err;
+	struct fuse_mt mt;
+	struct fuse_worker *w;
+
+	memset(&mt, 0, sizeof(struct fuse_mt));
+	mt.se = se;
+	mt.prevch = fuse_session_next_chan(se, NULL);
+	mt.error = 0;
+	mt.numworker = 0;
+	mt.numavail = 0;
+	mt.main.thread_id = pthread_self();
+	mt.main.prev = mt.main.next = &mt.main;
+	sem_init(&mt.finish, 0, 0);
+	fuse_mutex_init(&mt.lock);
+
+	pthread_mutex_lock(&mt.lock);
+	err = fuse_loop_start_thread(&mt);
+	pthread_mutex_unlock(&mt.lock);
+	if (!err) {
+		/* sem_wait() is interruptible */
+		while (!fuse_session_exited(se))
+			sem_wait(&mt.finish);
+
+		for (w = mt.main.next; w != &mt.main; w = w->next)
+			pthread_cancel(w->thread_id);
+		mt.exit = 1;
+
+		while (mt.main.next != &mt.main)
+			fuse_join_worker(&mt, mt.main.next);
+
+		err = mt.error;
+	}
+
+	pthread_mutex_destroy(&mt.lock);
+	sem_destroy(&mt.finish);
+	fuse_session_reset(se);
+	return err;
+}
diff --git a/external/fuse/fuse_lowlevel.c b/external/fuse/fuse_lowlevel.c
new file mode 100755
index 0000000000..103f831548
--- /dev/null
+++ b/external/fuse/fuse_lowlevel.c
@@ -0,0 +1,2967 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB
+*/
+
+#define _GNU_SOURCE
+
+#include "config.h"
+#include "fuse_i.h"
+#include "fuse_kernel.h"
+#include "fuse_opt.h"
+#include "fuse_misc.h"
+#include "fuse_common_compat.h"
+#include "fuse_lowlevel_compat.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <string.h>
+#include <unistd.h>
+#include <limits.h>
+#include <errno.h>
+#include <assert.h>
+
+#ifndef F_LINUX_SPECIFIC_BASE
+#define F_LINUX_SPECIFIC_BASE       1024
+#endif
+#ifndef F_SETPIPE_SZ
+#define F_SETPIPE_SZ	(F_LINUX_SPECIFIC_BASE + 7)
+#endif
+
+
+#define PARAM(inarg) (((char *)(inarg)) + sizeof(*(inarg)))
+#define OFFSET_MAX 0x7fffffffffffffffLL
+
+#define container_of(ptr, type, member) ({				\
+			const typeof( ((type *)0)->member ) *__mptr = (ptr); \
+			(type *)( (char *)__mptr - offsetof(type,member) );})
+
+struct fuse_pollhandle {
+	uint64_t kh;
+	struct fuse_chan *ch;
+	struct fuse_ll *f;
+};
+
+static size_t pagesize;
+
+static __attribute__((constructor)) void fuse_ll_init_pagesize(void)
+{
+	pagesize = getpagesize();
+}
+
+static void convert_stat(const struct stat *stbuf, struct fuse_attr *attr)
+{
+	attr->ino	= stbuf->st_ino;
+	attr->mode	= stbuf->st_mode;
+	attr->nlink	= stbuf->st_nlink;
+	attr->uid	= stbuf->st_uid;
+	attr->gid	= stbuf->st_gid;
+	attr->rdev	= stbuf->st_rdev;
+	attr->size	= stbuf->st_size;
+	attr->blksize	= stbuf->st_blksize;
+	attr->blocks	= stbuf->st_blocks;
+	attr->atime	= stbuf->st_atime;
+	attr->mtime	= stbuf->st_mtime;
+	attr->ctime	= stbuf->st_ctime;
+	attr->atimensec = ST_ATIM_NSEC(stbuf);
+	attr->mtimensec = ST_MTIM_NSEC(stbuf);
+	attr->ctimensec = ST_CTIM_NSEC(stbuf);
+}
+
+static void convert_attr(const struct fuse_setattr_in *attr, struct stat *stbuf)
+{
+	stbuf->st_mode	       = attr->mode;
+	stbuf->st_uid	       = attr->uid;
+	stbuf->st_gid	       = attr->gid;
+	stbuf->st_size	       = attr->size;
+	stbuf->st_atime	       = attr->atime;
+	stbuf->st_mtime	       = attr->mtime;
+	ST_ATIM_NSEC_SET(stbuf, attr->atimensec);
+	ST_MTIM_NSEC_SET(stbuf, attr->mtimensec);
+}
+
+static	size_t iov_length(const struct iovec *iov, size_t count)
+{
+	size_t seg;
+	size_t ret = 0;
+
+	for (seg = 0; seg < count; seg++)
+		ret += iov[seg].iov_len;
+	return ret;
+}
+
+static void list_init_req(struct fuse_req *req)
+{
+	req->next = req;
+	req->prev = req;
+}
+
+static void list_del_req(struct fuse_req *req)
+{
+	struct fuse_req *prev = req->prev;
+	struct fuse_req *next = req->next;
+	prev->next = next;
+	next->prev = prev;
+}
+
+static void list_add_req(struct fuse_req *req, struct fuse_req *next)
+{
+	struct fuse_req *prev = next->prev;
+	req->next = next;
+	req->prev = prev;
+	prev->next = req;
+	next->prev = req;
+}
+
+static void destroy_req(fuse_req_t req)
+{
+	pthread_mutex_destroy(&req->lock);
+	free(req);
+}
+
+void fuse_free_req(fuse_req_t req)
+{
+	int ctr;
+	struct fuse_ll *f = req->f;
+
+	pthread_mutex_lock(&f->lock);
+	req->u.ni.func = NULL;
+	req->u.ni.data = NULL;
+	list_del_req(req);
+	ctr = --req->ctr;
+	pthread_mutex_unlock(&f->lock);
+	if (!ctr)
+		destroy_req(req);
+}
+
+static struct fuse_req *fuse_ll_alloc_req(struct fuse_ll *f)
+{
+	struct fuse_req *req;
+
+	req = (struct fuse_req *) calloc(1, sizeof(struct fuse_req));
+	if (req == NULL) {
+		fprintf(stderr, "fuse: failed to allocate request\n");
+	} else {
+		req->f = f;
+		req->ctr = 1;
+		list_init_req(req);
+		fuse_mutex_init(&req->lock);
+	}
+
+	return req;
+}
+
+
+static int fuse_send_msg(struct fuse_ll *f, struct fuse_chan *ch,
+			 struct iovec *iov, int count)
+{
+	struct fuse_out_header *out = iov[0].iov_base;
+
+	out->len = iov_length(iov, count);
+	if (f->debug) {
+		if (out->unique == 0) {
+			fprintf(stderr, "NOTIFY: code=%d length=%u\n",
+				out->error, out->len);
+		} else if (out->error) {
+			fprintf(stderr,
+				"   unique: %llu, error: %i (%s), outsize: %i\n",
+				(unsigned long long) out->unique, out->error,
+				strerror(-out->error), out->len);
+		} else {
+			fprintf(stderr,
+				"   unique: %llu, success, outsize: %i\n",
+				(unsigned long long) out->unique, out->len);
+		}
+	}
+
+	return fuse_chan_send(ch, iov, count);
+}
+
+int fuse_send_reply_iov_nofree(fuse_req_t req, int error, struct iovec *iov,
+			       int count)
+{
+	struct fuse_out_header out;
+
+	if (error <= -1000 || error > 0) {
+		fprintf(stderr, "fuse: bad error value: %i\n",	error);
+		error = -ERANGE;
+	}
+
+	out.unique = req->unique;
+	out.error = error;
+
+	iov[0].iov_base = &out;
+	iov[0].iov_len = sizeof(struct fuse_out_header);
+
+	return fuse_send_msg(req->f, req->ch, iov, count);
+}
+
+static int send_reply_iov(fuse_req_t req, int error, struct iovec *iov,
+			  int count)
+{
+	int res;
+
+	res = fuse_send_reply_iov_nofree(req, error, iov, count);
+	fuse_free_req(req);
+	return res;
+}
+
+static int send_reply(fuse_req_t req, int error, const void *arg,
+		      size_t argsize)
+{
+	struct iovec iov[2];
+	int count = 1;
+	if (argsize) {
+		iov[1].iov_base = (void *) arg;
+		iov[1].iov_len = argsize;
+		count++;
+	}
+	return send_reply_iov(req, error, iov, count);
+}
+
+int fuse_reply_iov(fuse_req_t req, const struct iovec *iov, int count)
+{
+	int res;
+	struct iovec *padded_iov;
+
+	padded_iov = malloc((count + 1) * sizeof(struct iovec));
+	if (padded_iov == NULL)
+		return fuse_reply_err(req, ENOMEM);
+
+	memcpy(padded_iov + 1, iov, count * sizeof(struct iovec));
+	count++;
+
+	res = send_reply_iov(req, 0, padded_iov, count);
+	free(padded_iov);
+
+	return res;
+}
+
+size_t fuse_dirent_size(size_t namelen)
+{
+	return FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + namelen);
+}
+
+char *fuse_add_dirent(char *buf, const char *name, const struct stat *stbuf,
+		      off64_t off)
+{
+	unsigned namelen = strlen(name);
+	unsigned entlen = FUSE_NAME_OFFSET + namelen;
+	unsigned entsize = fuse_dirent_size(namelen);
+	unsigned padlen = entsize - entlen;
+	struct fuse_dirent *dirent = (struct fuse_dirent *) buf;
+
+	dirent->ino = stbuf->st_ino;
+	dirent->off = off;
+	dirent->namelen = namelen;
+	dirent->type = (stbuf->st_mode & 0170000) >> 12;
+	strncpy(dirent->name, name, namelen);
+	if (padlen)
+		memset(buf + entlen, 0, padlen);
+
+	return buf + entsize;
+}
+
+size_t fuse_add_direntry(fuse_req_t req, char *buf, size_t bufsize,
+			 const char *name, const struct stat *stbuf, off64_t off)
+{
+	size_t entsize;
+
+	(void) req;
+	entsize = fuse_dirent_size(strlen(name));
+	if (entsize <= bufsize && buf)
+		fuse_add_dirent(buf, name, stbuf, off);
+	return entsize;
+}
+
+static void convert_statfs(const struct statvfs *stbuf,
+			   struct fuse_kstatfs *kstatfs)
+{
+	kstatfs->bsize	 = stbuf->f_bsize;
+	kstatfs->frsize	 = stbuf->f_frsize;
+	kstatfs->blocks	 = stbuf->f_blocks;
+	kstatfs->bfree	 = stbuf->f_bfree;
+	kstatfs->bavail	 = stbuf->f_bavail;
+	kstatfs->files	 = stbuf->f_files;
+	kstatfs->ffree	 = stbuf->f_ffree;
+	kstatfs->namelen = stbuf->f_namemax;
+}
+
+static int send_reply_ok(fuse_req_t req, const void *arg, size_t argsize)
+{
+	return send_reply(req, 0, arg, argsize);
+}
+
+int fuse_reply_err(fuse_req_t req, int err)
+{
+	return send_reply(req, -err, NULL, 0);
+}
+
+void fuse_reply_none(fuse_req_t req)
+{
+	if (req->ch)
+		fuse_chan_send(req->ch, NULL, 0);
+	fuse_free_req(req);
+}
+
+static unsigned long calc_timeout_sec(double t)
+{
+	if (t > (double) ULONG_MAX)
+		return ULONG_MAX;
+	else if (t < 0.0)
+		return 0;
+	else
+		return (unsigned long) t;
+}
+
+static unsigned int calc_timeout_nsec(double t)
+{
+	double f = t - (double) calc_timeout_sec(t);
+	if (f < 0.0)
+		return 0;
+	else if (f >= 0.999999999)
+		return 999999999;
+	else
+		return (unsigned int) (f * 1.0e9);
+}
+
+static void fill_entry(struct fuse_entry_out *arg,
+		       const struct fuse_entry_param *e)
+{
+	arg->nodeid = e->ino;
+	arg->generation = e->generation;
+	arg->entry_valid = calc_timeout_sec(e->entry_timeout);
+	arg->entry_valid_nsec = calc_timeout_nsec(e->entry_timeout);
+	arg->attr_valid = calc_timeout_sec(e->attr_timeout);
+	arg->attr_valid_nsec = calc_timeout_nsec(e->attr_timeout);
+	convert_stat(&e->attr, &arg->attr);
+}
+
+static void fill_open(struct fuse_open_out *arg,
+		      const struct fuse_file_info *f)
+{
+	arg->fh = f->fh;
+	if (f->direct_io)
+		arg->open_flags |= FOPEN_DIRECT_IO;
+	if (f->keep_cache)
+		arg->open_flags |= FOPEN_KEEP_CACHE;
+	if (f->nonseekable)
+		arg->open_flags |= FOPEN_NONSEEKABLE;
+}
+
+int fuse_reply_entry(fuse_req_t req, const struct fuse_entry_param *e)
+{
+	struct fuse_entry_out arg;
+	size_t size = req->f->conn.proto_minor < 9 ?
+		FUSE_COMPAT_ENTRY_OUT_SIZE : sizeof(arg);
+
+	/* before ABI 7.4 e->ino == 0 was invalid, only ENOENT meant
+	   negative entry */
+	if (!e->ino && req->f->conn.proto_minor < 4)
+		return fuse_reply_err(req, ENOENT);
+
+	memset(&arg, 0, sizeof(arg));
+	fill_entry(&arg, e);
+	return send_reply_ok(req, &arg, size);
+}
+
+int fuse_reply_create(fuse_req_t req, const struct fuse_entry_param *e,
+		      const struct fuse_file_info *f)
+{
+	char buf[sizeof(struct fuse_entry_out) + sizeof(struct fuse_open_out)];
+	size_t entrysize = req->f->conn.proto_minor < 9 ?
+		FUSE_COMPAT_ENTRY_OUT_SIZE : sizeof(struct fuse_entry_out);
+	struct fuse_entry_out *earg = (struct fuse_entry_out *) buf;
+	struct fuse_open_out *oarg = (struct fuse_open_out *) (buf + entrysize);
+
+	memset(buf, 0, sizeof(buf));
+	fill_entry(earg, e);
+	fill_open(oarg, f);
+	return send_reply_ok(req, buf,
+			     entrysize + sizeof(struct fuse_open_out));
+}
+
+int fuse_reply_attr(fuse_req_t req, const struct stat *attr,
+		    double attr_timeout)
+{
+	struct fuse_attr_out arg;
+	size_t size = req->f->conn.proto_minor < 9 ?
+		FUSE_COMPAT_ATTR_OUT_SIZE : sizeof(arg);
+
+	memset(&arg, 0, sizeof(arg));
+	arg.attr_valid = calc_timeout_sec(attr_timeout);
+	arg.attr_valid_nsec = calc_timeout_nsec(attr_timeout);
+	convert_stat(attr, &arg.attr);
+
+	return send_reply_ok(req, &arg, size);
+}
+
+int fuse_reply_readlink(fuse_req_t req, const char *linkname)
+{
+	return send_reply_ok(req, linkname, strlen(linkname));
+}
+
+int fuse_reply_open(fuse_req_t req, const struct fuse_file_info *f)
+{
+	struct fuse_open_out arg;
+
+	memset(&arg, 0, sizeof(arg));
+	fill_open(&arg, f);
+	return send_reply_ok(req, &arg, sizeof(arg));
+}
+
+int fuse_reply_write(fuse_req_t req, size_t count)
+{
+	struct fuse_write_out arg;
+
+	memset(&arg, 0, sizeof(arg));
+	arg.size = count;
+
+	return send_reply_ok(req, &arg, sizeof(arg));
+}
+
+int fuse_reply_buf(fuse_req_t req, const char *buf, size_t size)
+{
+	return send_reply_ok(req, buf, size);
+}
+
+static int fuse_send_data_iov_fallback(struct fuse_ll *f, struct fuse_chan *ch,
+				       struct iovec *iov, int iov_count,
+				       struct fuse_bufvec *buf,
+				       size_t len)
+{
+	struct fuse_bufvec mem_buf = FUSE_BUFVEC_INIT(len);
+	void *mbuf;
+	int res;
+
+	/* Optimize common case */
+	if (buf->count == 1 && buf->idx == 0 && buf->off == 0 &&
+	    !(buf->buf[0].flags & FUSE_BUF_IS_FD)) {
+		/* FIXME: also avoid memory copy if there are multiple buffers
+		   but none of them contain an fd */
+
+		iov[iov_count].iov_base = buf->buf[0].mem;
+		iov[iov_count].iov_len = len;
+		iov_count++;
+		return fuse_send_msg(f, ch, iov, iov_count);
+	}
+
+	res = posix_memalign(&mbuf, pagesize, len);
+	if (res != 0)
+		return res;
+
+	mem_buf.buf[0].mem = mbuf;
+	res = fuse_buf_copy(&mem_buf, buf, 0);
+	if (res < 0) {
+		free(mbuf);
+		return -res;
+	}
+	len = res;
+
+	iov[iov_count].iov_base = mbuf;
+	iov[iov_count].iov_len = len;
+	iov_count++;
+	res = fuse_send_msg(f, ch, iov, iov_count);
+	free(mbuf);
+
+	return res;
+}
+
+struct fuse_ll_pipe {
+	size_t size;
+	int can_grow;
+	int pipe[2];
+};
+
+static void fuse_ll_pipe_free(struct fuse_ll_pipe *llp)
+{
+	close(llp->pipe[0]);
+	close(llp->pipe[1]);
+	free(llp);
+}
+
+#ifdef HAVE_SPLICE
+static struct fuse_ll_pipe *fuse_ll_get_pipe(struct fuse_ll *f)
+{
+	struct fuse_ll_pipe *llp = pthread_getspecific(f->pipe_key);
+	if (llp == NULL) {
+		int res;
+
+		llp = malloc(sizeof(struct fuse_ll_pipe));
+		if (llp == NULL)
+			return NULL;
+
+		res = pipe(llp->pipe);
+		if (res == -1) {
+			free(llp);
+			return NULL;
+		}
+
+		if (fcntl(llp->pipe[0], F_SETFL, O_NONBLOCK) == -1 ||
+		    fcntl(llp->pipe[1], F_SETFL, O_NONBLOCK) == -1) {
+			close(llp->pipe[0]);
+			close(llp->pipe[1]);
+			free(llp);
+			return NULL;
+		}
+
+		/*
+		 *the default size is 16 pages on linux
+		 */
+		llp->size = pagesize * 16;
+		llp->can_grow = 1;
+
+		pthread_setspecific(f->pipe_key, llp);
+	}
+
+	return llp;
+}
+#endif
+
+static void fuse_ll_clear_pipe(struct fuse_ll *f)
+{
+	struct fuse_ll_pipe *llp = pthread_getspecific(f->pipe_key);
+	if (llp) {
+		pthread_setspecific(f->pipe_key, NULL);
+		fuse_ll_pipe_free(llp);
+	}
+}
+
+#if defined(HAVE_SPLICE) && defined(HAVE_VMSPLICE)
+static int read_back(int fd, char *buf, size_t len)
+{
+	int res;
+
+	res = read(fd, buf, len);
+	if (res == -1) {
+		fprintf(stderr, "fuse: internal error: failed to read back from pipe: %s\n", strerror(errno));
+		return -EIO;
+	}
+	if (res != len) {
+		fprintf(stderr, "fuse: internal error: short read back from pipe: %i from %zi\n", res, len);
+		return -EIO;
+	}
+	return 0;
+}
+
+static int fuse_send_data_iov(struct fuse_ll *f, struct fuse_chan *ch,
+			       struct iovec *iov, int iov_count,
+			       struct fuse_bufvec *buf, unsigned int flags)
+{
+	int res;
+	size_t len = fuse_buf_size(buf);
+	struct fuse_out_header *out = iov[0].iov_base;
+	struct fuse_ll_pipe *llp;
+	int splice_flags;
+	size_t pipesize;
+	size_t total_fd_size;
+	size_t idx;
+	size_t headerlen;
+	struct fuse_bufvec pipe_buf = FUSE_BUFVEC_INIT(len);
+
+	if (f->broken_splice_nonblock)
+		goto fallback;
+
+	if (flags & FUSE_BUF_NO_SPLICE)
+		goto fallback;
+
+	total_fd_size = 0;
+	for (idx = buf->idx; idx < buf->count; idx++) {
+		if (buf->buf[idx].flags & FUSE_BUF_IS_FD) {
+			total_fd_size = buf->buf[idx].size;
+			if (idx == buf->idx)
+				total_fd_size -= buf->off;
+		}
+	}
+	if (total_fd_size < 2 * pagesize)
+		goto fallback;
+
+	if (f->conn.proto_minor < 14 ||
+	    !(f->conn.want & FUSE_CAP_SPLICE_WRITE))
+		goto fallback;
+
+	llp = fuse_ll_get_pipe(f);
+	if (llp == NULL)
+		goto fallback;
+
+
+	headerlen = iov_length(iov, iov_count);
+
+	out->len = headerlen + len;
+
+	/*
+	 * Heuristic for the required pipe size, does not work if the
+	 * source contains less than page size fragments
+	 */
+	pipesize = pagesize * (iov_count + buf->count + 1) + out->len;
+
+	if (llp->size < pipesize) {
+		if (llp->can_grow) {
+			res = fcntl(llp->pipe[0], F_SETPIPE_SZ, pipesize);
+			if (res == -1) {
+				llp->can_grow = 0;
+				goto fallback;
+			}
+			llp->size = res;
+		}
+		if (llp->size < pipesize)
+			goto fallback;
+	}
+
+
+	res = vmsplice(llp->pipe[1], iov, iov_count, SPLICE_F_NONBLOCK);
+	if (res == -1)
+		goto fallback;
+
+	if (res != headerlen) {
+		res = -EIO;
+		fprintf(stderr, "fuse: short vmsplice to pipe: %u/%zu\n", res,
+			headerlen);
+		goto clear_pipe;
+	}
+
+	pipe_buf.buf[0].flags = FUSE_BUF_IS_FD;
+	pipe_buf.buf[0].fd = llp->pipe[1];
+
+	res = fuse_buf_copy(&pipe_buf, buf,
+			    FUSE_BUF_FORCE_SPLICE | FUSE_BUF_SPLICE_NONBLOCK);
+	if (res < 0) {
+		if (res == -EAGAIN || res == -EINVAL) {
+			/*
+			 * Should only get EAGAIN on kernels with
+			 * broken SPLICE_F_NONBLOCK support (<=
+			 * 2.6.35) where this error or a short read is
+			 * returned even if the pipe itself is not
+			 * full
+			 *
+			 * EINVAL might mean that splice can't handle
+			 * this combination of input and output.
+			 */
+			if (res == -EAGAIN)
+				f->broken_splice_nonblock = 1;
+
+			pthread_setspecific(f->pipe_key, NULL);
+			fuse_ll_pipe_free(llp);
+			goto fallback;
+		}
+		res = -res;
+		goto clear_pipe;
+	}
+
+	if (res != 0 && res < len) {
+		struct fuse_bufvec mem_buf = FUSE_BUFVEC_INIT(len);
+		void *mbuf;
+		size_t now_len = res;
+		/*
+		 * For regular files a short count is either
+		 *  1) due to EOF, or
+		 *  2) because of broken SPLICE_F_NONBLOCK (see above)
+		 *
+		 * For other inputs it's possible that we overflowed
+		 * the pipe because of small buffer fragments.
+		 */
+
+		res = posix_memalign(&mbuf, pagesize, len);
+		if (res != 0)
+			goto clear_pipe;
+
+		mem_buf.buf[0].mem = mbuf;
+		mem_buf.off = now_len;
+		res = fuse_buf_copy(&mem_buf, buf, 0);
+		if (res > 0) {
+			char *tmpbuf;
+			size_t extra_len = res;
+			/*
+			 * Trickiest case: got more data.  Need to get
+			 * back the data from the pipe and then fall
+			 * back to regular write.
+			 */
+			tmpbuf = malloc(headerlen);
+			if (tmpbuf == NULL) {
+				free(mbuf);
+				res = ENOMEM;
+				goto clear_pipe;
+			}
+			res = read_back(llp->pipe[0], tmpbuf, headerlen);
+			if (res != 0) {
+				free(mbuf);
+				goto clear_pipe;
+			}
+			free(tmpbuf);
+			res = read_back(llp->pipe[0], mbuf, now_len);
+			if (res != 0) {
+				free(mbuf);
+				goto clear_pipe;
+			}
+			len = now_len + extra_len;
+			iov[iov_count].iov_base = mbuf;
+			iov[iov_count].iov_len = len;
+			iov_count++;
+			res = fuse_send_msg(f, ch, iov, iov_count);
+			free(mbuf);
+			return res;
+		}
+		free(mbuf);
+		res = now_len;
+	}
+	len = res;
+	out->len = headerlen + len;
+
+	if (f->debug) {
+		fprintf(stderr,
+			"   unique: %llu, success, outsize: %i (splice)\n",
+			(unsigned long long) out->unique, out->len);
+	}
+
+	splice_flags = 0;
+	if ((flags & FUSE_BUF_SPLICE_MOVE) &&
+	    (f->conn.want & FUSE_CAP_SPLICE_MOVE))
+		splice_flags |= SPLICE_F_MOVE;
+
+	res = splice(llp->pipe[0], NULL,
+		     fuse_chan_fd(ch), NULL, out->len, splice_flags);
+	if (res == -1) {
+		res = -errno;
+		perror("fuse: splice from pipe");
+		goto clear_pipe;
+	}
+	if (res != out->len) {
+		res = -EIO;
+		fprintf(stderr, "fuse: short splice from pipe: %u/%u\n",
+			res, out->len);
+		goto clear_pipe;
+	}
+	return 0;
+
+clear_pipe:
+	fuse_ll_clear_pipe(f);
+	return res;
+
+fallback:
+	return fuse_send_data_iov_fallback(f, ch, iov, iov_count, buf, len);
+}
+#else
+static int fuse_send_data_iov(struct fuse_ll *f, struct fuse_chan *ch,
+			       struct iovec *iov, int iov_count,
+			       struct fuse_bufvec *buf, unsigned int flags)
+{
+	size_t len = fuse_buf_size(buf);
+	(void) flags;
+
+	return fuse_send_data_iov_fallback(f, ch, iov, iov_count, buf, len);
+}
+#endif
+
+int fuse_reply_data(fuse_req_t req, struct fuse_bufvec *bufv,
+		    enum fuse_buf_copy_flags flags)
+{
+	struct iovec iov[2];
+	struct fuse_out_header out;
+	int res;
+
+	iov[0].iov_base = &out;
+	iov[0].iov_len = sizeof(struct fuse_out_header);
+
+	out.unique = req->unique;
+	out.error = 0;
+
+	res = fuse_send_data_iov(req->f, req->ch, iov, 1, bufv, flags);
+	if (res <= 0) {
+		fuse_free_req(req);
+		return res;
+	} else {
+		return fuse_reply_err(req, res);
+	}
+}
+
+int fuse_reply_statfs(fuse_req_t req, const struct statvfs *stbuf)
+{
+	struct fuse_statfs_out arg;
+	size_t size = req->f->conn.proto_minor < 4 ?
+		FUSE_COMPAT_STATFS_SIZE : sizeof(arg);
+
+	memset(&arg, 0, sizeof(arg));
+	convert_statfs(stbuf, &arg.st);
+
+	return send_reply_ok(req, &arg, size);
+}
+
+int fuse_reply_xattr(fuse_req_t req, size_t count)
+{
+	struct fuse_getxattr_out arg;
+
+	memset(&arg, 0, sizeof(arg));
+	arg.size = count;
+
+	return send_reply_ok(req, &arg, sizeof(arg));
+}
+
+int fuse_reply_lock(fuse_req_t req, const struct flock *lock)
+{
+	struct fuse_lk_out arg;
+
+	memset(&arg, 0, sizeof(arg));
+	arg.lk.type = lock->l_type;
+	if (lock->l_type != F_UNLCK) {
+		arg.lk.start = lock->l_start;
+		if (lock->l_len == 0)
+			arg.lk.end = OFFSET_MAX;
+		else
+			arg.lk.end = lock->l_start + lock->l_len - 1;
+	}
+	arg.lk.pid = lock->l_pid;
+	return send_reply_ok(req, &arg, sizeof(arg));
+}
+
+int fuse_reply_bmap(fuse_req_t req, uint64_t idx)
+{
+	struct fuse_bmap_out arg;
+
+	memset(&arg, 0, sizeof(arg));
+	arg.block = idx;
+
+	return send_reply_ok(req, &arg, sizeof(arg));
+}
+
+static struct fuse_ioctl_iovec *fuse_ioctl_iovec_copy(const struct iovec *iov,
+						      size_t count)
+{
+	struct fuse_ioctl_iovec *fiov;
+	size_t i;
+
+	fiov = malloc(sizeof(fiov[0]) * count);
+	if (!fiov)
+		return NULL;
+
+	for (i = 0; i < count; i++) {
+		fiov[i].base = (uintptr_t) iov[i].iov_base;
+		fiov[i].len = iov[i].iov_len;
+	}
+
+	return fiov;
+}
+
+int fuse_reply_ioctl_retry(fuse_req_t req,
+			   const struct iovec *in_iov, size_t in_count,
+			   const struct iovec *out_iov, size_t out_count)
+{
+	struct fuse_ioctl_out arg;
+	struct fuse_ioctl_iovec *in_fiov = NULL;
+	struct fuse_ioctl_iovec *out_fiov = NULL;
+	struct iovec iov[4];
+	size_t count = 1;
+	int res;
+
+	memset(&arg, 0, sizeof(arg));
+	arg.flags |= FUSE_IOCTL_RETRY;
+	arg.in_iovs = in_count;
+	arg.out_iovs = out_count;
+	iov[count].iov_base = &arg;
+	iov[count].iov_len = sizeof(arg);
+	count++;
+
+	if (req->f->conn.proto_minor < 16) {
+		if (in_count) {
+			iov[count].iov_base = (void *)in_iov;
+			iov[count].iov_len = sizeof(in_iov[0]) * in_count;
+			count++;
+		}
+
+		if (out_count) {
+			iov[count].iov_base = (void *)out_iov;
+			iov[count].iov_len = sizeof(out_iov[0]) * out_count;
+			count++;
+		}
+	} else {
+		/* Can't handle non-compat 64bit ioctls on 32bit */
+		if (sizeof(void *) == 4 && req->ioctl_64bit) {
+			res = fuse_reply_err(req, EINVAL);
+			goto out;
+		}
+
+		if (in_count) {
+			in_fiov = fuse_ioctl_iovec_copy(in_iov, in_count);
+			if (!in_fiov)
+				goto enomem;
+
+			iov[count].iov_base = (void *)in_fiov;
+			iov[count].iov_len = sizeof(in_fiov[0]) * in_count;
+			count++;
+		}
+		if (out_count) {
+			out_fiov = fuse_ioctl_iovec_copy(out_iov, out_count);
+			if (!out_fiov)
+				goto enomem;
+
+			iov[count].iov_base = (void *)out_fiov;
+			iov[count].iov_len = sizeof(out_fiov[0]) * out_count;
+			count++;
+		}
+	}
+
+	res = send_reply_iov(req, 0, iov, count);
+out:
+	free(in_fiov);
+	free(out_fiov);
+
+	return res;
+
+enomem:
+	res = fuse_reply_err(req, ENOMEM);
+	goto out;
+}
+
+int fuse_reply_ioctl(fuse_req_t req, int result, const void *buf, size_t size)
+{
+	struct fuse_ioctl_out arg;
+	struct iovec iov[3];
+	size_t count = 1;
+
+	memset(&arg, 0, sizeof(arg));
+	arg.result = result;
+	iov[count].iov_base = &arg;
+	iov[count].iov_len = sizeof(arg);
+	count++;
+
+	if (size) {
+		iov[count].iov_base = (char *) buf;
+		iov[count].iov_len = size;
+		count++;
+	}
+
+	return send_reply_iov(req, 0, iov, count);
+}
+
+int fuse_reply_ioctl_iov(fuse_req_t req, int result, const struct iovec *iov,
+			 int count)
+{
+	struct iovec *padded_iov;
+	struct fuse_ioctl_out arg;
+	int res;
+
+	padded_iov = malloc((count + 2) * sizeof(struct iovec));
+	if (padded_iov == NULL)
+		return fuse_reply_err(req, ENOMEM);
+
+	memset(&arg, 0, sizeof(arg));
+	arg.result = result;
+	padded_iov[1].iov_base = &arg;
+	padded_iov[1].iov_len = sizeof(arg);
+
+	memcpy(&padded_iov[2], iov, count * sizeof(struct iovec));
+
+	res = send_reply_iov(req, 0, padded_iov, count + 2);
+	free(padded_iov);
+
+	return res;
+}
+
+int fuse_reply_poll(fuse_req_t req, unsigned revents)
+{
+	struct fuse_poll_out arg;
+
+	memset(&arg, 0, sizeof(arg));
+	arg.revents = revents;
+
+	return send_reply_ok(req, &arg, sizeof(arg));
+}
+
+static void do_lookup(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	char *name = (char *) inarg;
+
+	if (req->f->op.lookup)
+		req->f->op.lookup(req, nodeid, name);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_forget(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_forget_in *arg = (struct fuse_forget_in *) inarg;
+
+	if (req->f->op.forget)
+		req->f->op.forget(req, nodeid, arg->nlookup);
+	else
+		fuse_reply_none(req);
+}
+
+static void do_batch_forget(fuse_req_t req, fuse_ino_t nodeid,
+			    const void *inarg)
+{
+	struct fuse_batch_forget_in *arg = (void *) inarg;
+	struct fuse_forget_one *param = (void *) PARAM(arg);
+	unsigned int i;
+
+	(void) nodeid;
+
+	if (req->f->op.forget_multi) {
+		req->f->op.forget_multi(req, arg->count,
+				     (struct fuse_forget_data *) param);
+	} else if (req->f->op.forget) {
+		for (i = 0; i < arg->count; i++) {
+			struct fuse_forget_one *forget = &param[i];
+			struct fuse_req *dummy_req;
+
+			dummy_req = fuse_ll_alloc_req(req->f);
+			if (dummy_req == NULL)
+				break;
+
+			dummy_req->unique = req->unique;
+			dummy_req->ctx = req->ctx;
+			dummy_req->ch = NULL;
+
+			req->f->op.forget(dummy_req, forget->nodeid,
+					  forget->nlookup);
+		}
+		fuse_reply_none(req);
+	} else {
+		fuse_reply_none(req);
+	}
+}
+
+static void do_getattr(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_file_info *fip = NULL;
+	struct fuse_file_info fi;
+
+	if (req->f->conn.proto_minor >= 9) {
+		struct fuse_getattr_in *arg = (struct fuse_getattr_in *) inarg;
+
+		if (arg->getattr_flags & FUSE_GETATTR_FH) {
+			memset(&fi, 0, sizeof(fi));
+			fi.fh = arg->fh;
+			fi.fh_old = fi.fh;
+			fip = &fi;
+		}
+	}
+
+	if (req->f->op.getattr)
+		req->f->op.getattr(req, nodeid, fip);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_setattr(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_setattr_in *arg = (struct fuse_setattr_in *) inarg;
+
+	if (req->f->op.setattr) {
+		struct fuse_file_info *fi = NULL;
+		struct fuse_file_info fi_store;
+		struct stat stbuf;
+		memset(&stbuf, 0, sizeof(stbuf));
+		convert_attr(arg, &stbuf);
+		if (arg->valid & FATTR_FH) {
+			arg->valid &= ~FATTR_FH;
+			memset(&fi_store, 0, sizeof(fi_store));
+			fi = &fi_store;
+			fi->fh = arg->fh;
+			fi->fh_old = fi->fh;
+		}
+		arg->valid &=
+			FUSE_SET_ATTR_MODE	|
+			FUSE_SET_ATTR_UID	|
+			FUSE_SET_ATTR_GID	|
+			FUSE_SET_ATTR_SIZE	|
+			FUSE_SET_ATTR_ATIME	|
+			FUSE_SET_ATTR_MTIME	|
+			FUSE_SET_ATTR_ATIME_NOW	|
+			FUSE_SET_ATTR_MTIME_NOW;
+
+		req->f->op.setattr(req, nodeid, &stbuf, arg->valid, fi);
+	} else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_access(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_access_in *arg = (struct fuse_access_in *) inarg;
+
+	if (req->f->op.access)
+		req->f->op.access(req, nodeid, arg->mask);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_readlink(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	(void) inarg;
+
+	if (req->f->op.readlink)
+		req->f->op.readlink(req, nodeid);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_mknod(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_mknod_in *arg = (struct fuse_mknod_in *) inarg;
+	char *name = PARAM(arg);
+
+	if (req->f->conn.proto_minor >= 12)
+		req->ctx.umask = arg->umask;
+	else
+		name = (char *) inarg + FUSE_COMPAT_MKNOD_IN_SIZE;
+
+	if (req->f->op.mknod)
+		req->f->op.mknod(req, nodeid, name, arg->mode, arg->rdev);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_mkdir(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_mkdir_in *arg = (struct fuse_mkdir_in *) inarg;
+
+	if (req->f->conn.proto_minor >= 12)
+		req->ctx.umask = arg->umask;
+
+	if (req->f->op.mkdir)
+		req->f->op.mkdir(req, nodeid, PARAM(arg), arg->mode);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_unlink(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	char *name = (char *) inarg;
+
+	if (req->f->op.unlink)
+		req->f->op.unlink(req, nodeid, name);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_rmdir(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	char *name = (char *) inarg;
+
+	if (req->f->op.rmdir)
+		req->f->op.rmdir(req, nodeid, name);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_symlink(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	char *name = (char *) inarg;
+	char *linkname = ((char *) inarg) + strlen((char *) inarg) + 1;
+
+	if (req->f->op.symlink)
+		req->f->op.symlink(req, linkname, nodeid, name);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_rename(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_rename_in *arg = (struct fuse_rename_in *) inarg;
+	char *oldname = PARAM(arg);
+	char *newname = oldname + strlen(oldname) + 1;
+
+	if (req->f->op.rename)
+		req->f->op.rename(req, nodeid, oldname, arg->newdir, newname);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_link(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_link_in *arg = (struct fuse_link_in *) inarg;
+
+	if (req->f->op.link)
+		req->f->op.link(req, arg->oldnodeid, nodeid, PARAM(arg));
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_create(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_create_in *arg = (struct fuse_create_in *) inarg;
+
+	if (req->f->op.create) {
+		struct fuse_file_info fi;
+		char *name = PARAM(arg);
+
+		memset(&fi, 0, sizeof(fi));
+		fi.flags = arg->flags;
+
+		if (req->f->conn.proto_minor >= 12)
+			req->ctx.umask = arg->umask;
+		else
+			name = (char *) inarg + sizeof(struct fuse_open_in);
+
+		req->f->op.create(req, nodeid, name, arg->mode, &fi);
+	} else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_open(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_open_in *arg = (struct fuse_open_in *) inarg;
+	struct fuse_file_info fi;
+
+	memset(&fi, 0, sizeof(fi));
+	fi.flags = arg->flags;
+
+	if (req->f->op.open)
+		req->f->op.open(req, nodeid, &fi);
+	else
+		fuse_reply_open(req, &fi);
+}
+
+static void do_read(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_read_in *arg = (struct fuse_read_in *) inarg;
+
+	if (req->f->op.read) {
+		struct fuse_file_info fi;
+
+		memset(&fi, 0, sizeof(fi));
+		fi.fh = arg->fh;
+		fi.fh_old = fi.fh;
+		if (req->f->conn.proto_minor >= 9) {
+			fi.lock_owner = arg->lock_owner;
+			fi.flags = arg->flags;
+		}
+		req->f->op.read(req, nodeid, arg->size, arg->offset, &fi);
+	} else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_write(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_write_in *arg = (struct fuse_write_in *) inarg;
+	struct fuse_file_info fi;
+	char *param;
+
+	memset(&fi, 0, sizeof(fi));
+	fi.fh = arg->fh;
+	fi.fh_old = fi.fh;
+	fi.writepage = arg->write_flags & 1;
+
+	if (req->f->conn.proto_minor < 9) {
+		param = ((char *) arg) + FUSE_COMPAT_WRITE_IN_SIZE;
+	} else {
+		fi.lock_owner = arg->lock_owner;
+		fi.flags = arg->flags;
+		param = PARAM(arg);
+	}
+
+	if (req->f->op.write)
+		req->f->op.write(req, nodeid, param, arg->size,
+				 arg->offset, &fi);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_write_buf(fuse_req_t req, fuse_ino_t nodeid, const void *inarg,
+			 const struct fuse_buf *ibuf)
+{
+	struct fuse_ll *f = req->f;
+	struct fuse_bufvec bufv = {
+		.buf[0] = *ibuf,
+		.count = 1,
+	};
+	struct fuse_write_in *arg = (struct fuse_write_in *) inarg;
+	struct fuse_file_info fi;
+
+	memset(&fi, 0, sizeof(fi));
+	fi.fh = arg->fh;
+	fi.fh_old = fi.fh;
+	fi.writepage = arg->write_flags & 1;
+
+	if (req->f->conn.proto_minor < 9) {
+		bufv.buf[0].mem = ((char *) arg) + FUSE_COMPAT_WRITE_IN_SIZE;
+		bufv.buf[0].size -= sizeof(struct fuse_in_header) +
+			FUSE_COMPAT_WRITE_IN_SIZE;
+		assert(!(bufv.buf[0].flags & FUSE_BUF_IS_FD));
+	} else {
+		fi.lock_owner = arg->lock_owner;
+		fi.flags = arg->flags;
+		if (!(bufv.buf[0].flags & FUSE_BUF_IS_FD))
+			bufv.buf[0].mem = PARAM(arg);
+
+		bufv.buf[0].size -= sizeof(struct fuse_in_header) +
+			sizeof(struct fuse_write_in);
+	}
+	if (bufv.buf[0].size < arg->size) {
+		fprintf(stderr, "fuse: do_write_buf: buffer size too small\n");
+		fuse_reply_err(req, EIO);
+		goto out;
+	}
+	bufv.buf[0].size = arg->size;
+
+	req->f->op.write_buf(req, nodeid, &bufv, arg->offset, &fi);
+
+out:
+	/* Need to reset the pipe if ->write_buf() didn't consume all data */
+	if ((ibuf->flags & FUSE_BUF_IS_FD) && bufv.idx < bufv.count)
+		fuse_ll_clear_pipe(f);
+}
+
+static void do_flush(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_flush_in *arg = (struct fuse_flush_in *) inarg;
+	struct fuse_file_info fi;
+
+	memset(&fi, 0, sizeof(fi));
+	fi.fh = arg->fh;
+	fi.fh_old = fi.fh;
+	fi.flush = 1;
+	if (req->f->conn.proto_minor >= 7)
+		fi.lock_owner = arg->lock_owner;
+
+	if (req->f->op.flush)
+		req->f->op.flush(req, nodeid, &fi);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_release(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_release_in *arg = (struct fuse_release_in *) inarg;
+	struct fuse_file_info fi;
+
+	memset(&fi, 0, sizeof(fi));
+	fi.flags = arg->flags;
+	fi.fh = arg->fh;
+	fi.fh_old = fi.fh;
+	if (req->f->conn.proto_minor >= 8) {
+		fi.flush = (arg->release_flags & FUSE_RELEASE_FLUSH) ? 1 : 0;
+		fi.lock_owner = arg->lock_owner;
+	}
+	if (arg->release_flags & FUSE_RELEASE_FLOCK_UNLOCK) {
+		fi.flock_release = 1;
+		fi.lock_owner = arg->lock_owner;
+	}
+
+	if (req->f->op.release)
+		req->f->op.release(req, nodeid, &fi);
+	else
+		fuse_reply_err(req, 0);
+}
+
+static void do_fsync(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_fsync_in *arg = (struct fuse_fsync_in *) inarg;
+	struct fuse_file_info fi;
+
+	memset(&fi, 0, sizeof(fi));
+	fi.fh = arg->fh;
+	fi.fh_old = fi.fh;
+
+	if (req->f->op.fsync)
+		req->f->op.fsync(req, nodeid, arg->fsync_flags & 1, &fi);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_opendir(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_open_in *arg = (struct fuse_open_in *) inarg;
+	struct fuse_file_info fi;
+
+	memset(&fi, 0, sizeof(fi));
+	fi.flags = arg->flags;
+
+	if (req->f->op.opendir)
+		req->f->op.opendir(req, nodeid, &fi);
+	else
+		fuse_reply_open(req, &fi);
+}
+
+static void do_readdir(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_read_in *arg = (struct fuse_read_in *) inarg;
+	struct fuse_file_info fi;
+
+	memset(&fi, 0, sizeof(fi));
+	fi.fh = arg->fh;
+	fi.fh_old = fi.fh;
+
+	if (req->f->op.readdir)
+		req->f->op.readdir(req, nodeid, arg->size, arg->offset, &fi);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_releasedir(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_release_in *arg = (struct fuse_release_in *) inarg;
+	struct fuse_file_info fi;
+
+	memset(&fi, 0, sizeof(fi));
+	fi.flags = arg->flags;
+	fi.fh = arg->fh;
+	fi.fh_old = fi.fh;
+
+	if (req->f->op.releasedir)
+		req->f->op.releasedir(req, nodeid, &fi);
+	else
+		fuse_reply_err(req, 0);
+}
+
+static void do_fsyncdir(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_fsync_in *arg = (struct fuse_fsync_in *) inarg;
+	struct fuse_file_info fi;
+
+	memset(&fi, 0, sizeof(fi));
+	fi.fh = arg->fh;
+	fi.fh_old = fi.fh;
+
+	if (req->f->op.fsyncdir)
+		req->f->op.fsyncdir(req, nodeid, arg->fsync_flags & 1, &fi);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_statfs(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	(void) nodeid;
+	(void) inarg;
+
+	if (req->f->op.statfs)
+		req->f->op.statfs(req, nodeid);
+	else {
+		struct statvfs buf = {
+			.f_namemax = 255,
+			.f_bsize = 512,
+		};
+		fuse_reply_statfs(req, &buf);
+	}
+}
+
+static void do_setxattr(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_setxattr_in *arg = (struct fuse_setxattr_in *) inarg;
+	char *name = PARAM(arg);
+	char *value = name + strlen(name) + 1;
+
+	if (req->f->op.setxattr)
+		req->f->op.setxattr(req, nodeid, name, value, arg->size,
+				    arg->flags);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_getxattr(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_getxattr_in *arg = (struct fuse_getxattr_in *) inarg;
+
+	if (req->f->op.getxattr)
+		req->f->op.getxattr(req, nodeid, PARAM(arg), arg->size);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_listxattr(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_getxattr_in *arg = (struct fuse_getxattr_in *) inarg;
+
+	if (req->f->op.listxattr)
+		req->f->op.listxattr(req, nodeid, arg->size);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_removexattr(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	char *name = (char *) inarg;
+
+	if (req->f->op.removexattr)
+		req->f->op.removexattr(req, nodeid, name);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void convert_fuse_file_lock(struct fuse_file_lock *fl,
+				   struct flock *flock)
+{
+	memset(flock, 0, sizeof(struct flock));
+	flock->l_type = fl->type;
+	flock->l_whence = SEEK_SET;
+	flock->l_start = fl->start;
+	if (fl->end == OFFSET_MAX)
+		flock->l_len = 0;
+	else
+		flock->l_len = fl->end - fl->start + 1;
+	flock->l_pid = fl->pid;
+}
+
+static void do_getlk(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_lk_in *arg = (struct fuse_lk_in *) inarg;
+	struct fuse_file_info fi;
+	struct flock flock;
+
+	memset(&fi, 0, sizeof(fi));
+	fi.fh = arg->fh;
+	fi.lock_owner = arg->owner;
+
+	convert_fuse_file_lock(&arg->lk, &flock);
+	if (req->f->op.getlk)
+		req->f->op.getlk(req, nodeid, &fi, &flock);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_setlk_common(fuse_req_t req, fuse_ino_t nodeid,
+			    const void *inarg, int sleep)
+{
+	struct fuse_lk_in *arg = (struct fuse_lk_in *) inarg;
+	struct fuse_file_info fi;
+	struct flock flock;
+
+	memset(&fi, 0, sizeof(fi));
+	fi.fh = arg->fh;
+	fi.lock_owner = arg->owner;
+
+	if (arg->lk_flags & FUSE_LK_FLOCK) {
+		int op = 0;
+
+		switch (arg->lk.type) {
+		case F_RDLCK:
+			op = LOCK_SH;
+			break;
+		case F_WRLCK:
+			op = LOCK_EX;
+			break;
+		case F_UNLCK:
+			op = LOCK_UN;
+			break;
+		}
+		if (!sleep)
+			op |= LOCK_NB;
+
+		if (req->f->op.flock)
+			req->f->op.flock(req, nodeid, &fi, op);
+		else
+			fuse_reply_err(req, ENOSYS);
+	} else {
+		convert_fuse_file_lock(&arg->lk, &flock);
+		if (req->f->op.setlk)
+			req->f->op.setlk(req, nodeid, &fi, &flock, sleep);
+		else
+			fuse_reply_err(req, ENOSYS);
+	}
+}
+
+static void do_setlk(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	do_setlk_common(req, nodeid, inarg, 0);
+}
+
+static void do_setlkw(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	do_setlk_common(req, nodeid, inarg, 1);
+}
+
+static int find_interrupted(struct fuse_ll *f, struct fuse_req *req)
+{
+	struct fuse_req *curr;
+
+	for (curr = f->list.next; curr != &f->list; curr = curr->next) {
+		if (curr->unique == req->u.i.unique) {
+			fuse_interrupt_func_t func;
+			void *data;
+
+			curr->ctr++;
+			pthread_mutex_unlock(&f->lock);
+
+			/* Ugh, ugly locking */
+			pthread_mutex_lock(&curr->lock);
+			pthread_mutex_lock(&f->lock);
+			curr->interrupted = 1;
+			func = curr->u.ni.func;
+			data = curr->u.ni.data;
+			pthread_mutex_unlock(&f->lock);
+			if (func)
+				func(curr, data);
+			pthread_mutex_unlock(&curr->lock);
+
+			pthread_mutex_lock(&f->lock);
+			curr->ctr--;
+			if (!curr->ctr)
+				destroy_req(curr);
+
+			return 1;
+		}
+	}
+	for (curr = f->interrupts.next; curr != &f->interrupts;
+	     curr = curr->next) {
+		if (curr->u.i.unique == req->u.i.unique)
+			return 1;
+	}
+	return 0;
+}
+
+static void do_interrupt(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_interrupt_in *arg = (struct fuse_interrupt_in *) inarg;
+	struct fuse_ll *f = req->f;
+
+	(void) nodeid;
+	if (f->debug)
+		fprintf(stderr, "INTERRUPT: %llu\n",
+			(unsigned long long) arg->unique);
+
+	req->u.i.unique = arg->unique;
+
+	pthread_mutex_lock(&f->lock);
+	if (find_interrupted(f, req))
+		destroy_req(req);
+	else
+		list_add_req(req, &f->interrupts);
+	pthread_mutex_unlock(&f->lock);
+}
+
+static struct fuse_req *check_interrupt(struct fuse_ll *f, struct fuse_req *req)
+{
+	struct fuse_req *curr;
+
+	for (curr = f->interrupts.next; curr != &f->interrupts;
+	     curr = curr->next) {
+		if (curr->u.i.unique == req->unique) {
+			req->interrupted = 1;
+			list_del_req(curr);
+			free(curr);
+			return NULL;
+		}
+	}
+	curr = f->interrupts.next;
+	if (curr != &f->interrupts) {
+		list_del_req(curr);
+		list_init_req(curr);
+		return curr;
+	} else
+		return NULL;
+}
+
+static void do_bmap(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_bmap_in *arg = (struct fuse_bmap_in *) inarg;
+
+	if (req->f->op.bmap)
+		req->f->op.bmap(req, nodeid, arg->blocksize, arg->block);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_ioctl(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_ioctl_in *arg = (struct fuse_ioctl_in *) inarg;
+	unsigned int flags = arg->flags;
+	void *in_buf = arg->in_size ? PARAM(arg) : NULL;
+	struct fuse_file_info fi;
+
+	if (flags & FUSE_IOCTL_DIR &&
+	    !(req->f->conn.want & FUSE_CAP_IOCTL_DIR)) {
+		fuse_reply_err(req, ENOTTY);
+		return;
+	}
+
+	memset(&fi, 0, sizeof(fi));
+	fi.fh = arg->fh;
+	fi.fh_old = fi.fh;
+
+	if (sizeof(void *) == 4 && req->f->conn.proto_minor >= 16 &&
+	    !(flags & FUSE_IOCTL_32BIT)) {
+		req->ioctl_64bit = 1;
+	}
+
+	if (req->f->op.ioctl)
+		req->f->op.ioctl(req, nodeid, arg->cmd,
+				 (void *)(uintptr_t)arg->arg, &fi, flags,
+				 in_buf, arg->in_size, arg->out_size);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+void fuse_pollhandle_destroy(struct fuse_pollhandle *ph)
+{
+	free(ph);
+}
+
+static void do_poll(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_poll_in *arg = (struct fuse_poll_in *) inarg;
+	struct fuse_file_info fi;
+
+	memset(&fi, 0, sizeof(fi));
+	fi.fh = arg->fh;
+	fi.fh_old = fi.fh;
+
+	if (req->f->op.poll) {
+		struct fuse_pollhandle *ph = NULL;
+
+		if (arg->flags & FUSE_POLL_SCHEDULE_NOTIFY) {
+			ph = malloc(sizeof(struct fuse_pollhandle));
+			if (ph == NULL) {
+				fuse_reply_err(req, ENOMEM);
+				return;
+			}
+			ph->kh = arg->kh;
+			ph->ch = req->ch;
+			ph->f = req->f;
+		}
+
+		req->f->op.poll(req, nodeid, &fi, ph);
+	} else {
+		fuse_reply_err(req, ENOSYS);
+	}
+}
+
+static void do_fallocate(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_fallocate_in *arg = (struct fuse_fallocate_in *) inarg;
+	struct fuse_file_info fi;
+
+	memset(&fi, 0, sizeof(fi));
+	fi.fh = arg->fh;
+
+	if (req->f->op.fallocate)
+		req->f->op.fallocate(req, nodeid, arg->mode, arg->offset, arg->length, &fi);
+	else
+		fuse_reply_err(req, ENOSYS);
+}
+
+static void do_init(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_init_in *arg = (struct fuse_init_in *) inarg;
+	struct fuse_init_out outarg;
+	struct fuse_ll *f = req->f;
+	size_t bufsize = fuse_chan_bufsize(req->ch);
+
+	(void) nodeid;
+	if (f->debug) {
+		fprintf(stderr, "INIT: %u.%u\n", arg->major, arg->minor);
+		if (arg->major == 7 && arg->minor >= 6) {
+			fprintf(stderr, "flags=0x%08x\n", arg->flags);
+			fprintf(stderr, "max_readahead=0x%08x\n",
+				arg->max_readahead);
+		}
+	}
+	f->conn.proto_major = arg->major;
+	f->conn.proto_minor = arg->minor;
+	f->conn.capable = 0;
+	f->conn.want = 0;
+
+	memset(&outarg, 0, sizeof(outarg));
+	outarg.major = FUSE_KERNEL_VERSION;
+	outarg.minor = FUSE_KERNEL_MINOR_VERSION;
+
+	if (arg->major < 7) {
+		fprintf(stderr, "fuse: unsupported protocol version: %u.%u\n",
+			arg->major, arg->minor);
+		fuse_reply_err(req, EPROTO);
+		return;
+	}
+
+	if (arg->major > 7) {
+		/* Wait for a second INIT request with a 7.X version */
+		send_reply_ok(req, &outarg, sizeof(outarg));
+		return;
+	}
+
+	if (arg->minor >= 6) {
+		if (f->conn.async_read)
+			f->conn.async_read = arg->flags & FUSE_ASYNC_READ;
+		if (arg->max_readahead < f->conn.max_readahead)
+			f->conn.max_readahead = arg->max_readahead;
+		if (arg->flags & FUSE_ASYNC_READ)
+			f->conn.capable |= FUSE_CAP_ASYNC_READ;
+		if (arg->flags & FUSE_POSIX_LOCKS)
+			f->conn.capable |= FUSE_CAP_POSIX_LOCKS;
+		if (arg->flags & FUSE_ATOMIC_O_TRUNC)
+			f->conn.capable |= FUSE_CAP_ATOMIC_O_TRUNC;
+		if (arg->flags & FUSE_EXPORT_SUPPORT)
+			f->conn.capable |= FUSE_CAP_EXPORT_SUPPORT;
+		if (arg->flags & FUSE_BIG_WRITES)
+			f->conn.capable |= FUSE_CAP_BIG_WRITES;
+		if (arg->flags & FUSE_DONT_MASK)
+			f->conn.capable |= FUSE_CAP_DONT_MASK;
+		if (arg->flags & FUSE_FLOCK_LOCKS)
+			f->conn.capable |= FUSE_CAP_FLOCK_LOCKS;
+	} else {
+		f->conn.async_read = 0;
+		f->conn.max_readahead = 0;
+	}
+
+	if (req->f->conn.proto_minor >= 14) {
+#ifdef HAVE_SPLICE
+#ifdef HAVE_VMSPLICE
+		f->conn.capable |= FUSE_CAP_SPLICE_WRITE | FUSE_CAP_SPLICE_MOVE;
+		if (f->splice_write)
+			f->conn.want |= FUSE_CAP_SPLICE_WRITE;
+		if (f->splice_move)
+			f->conn.want |= FUSE_CAP_SPLICE_MOVE;
+#endif
+		f->conn.capable |= FUSE_CAP_SPLICE_READ;
+		if (f->splice_read)
+			f->conn.want |= FUSE_CAP_SPLICE_READ;
+#endif
+	}
+	if (req->f->conn.proto_minor >= 18)
+		f->conn.capable |= FUSE_CAP_IOCTL_DIR;
+
+	if (f->atomic_o_trunc)
+		f->conn.want |= FUSE_CAP_ATOMIC_O_TRUNC;
+	if (f->op.getlk && f->op.setlk && !f->no_remote_posix_lock)
+		f->conn.want |= FUSE_CAP_POSIX_LOCKS;
+	if (f->op.flock && !f->no_remote_flock)
+		f->conn.want |= FUSE_CAP_FLOCK_LOCKS;
+	if (f->big_writes)
+		f->conn.want |= FUSE_CAP_BIG_WRITES;
+
+	if (bufsize < FUSE_MIN_READ_BUFFER) {
+		fprintf(stderr, "fuse: warning: buffer size too small: %zu\n",
+			bufsize);
+		bufsize = FUSE_MIN_READ_BUFFER;
+	}
+
+	bufsize -= 4096;
+	if (bufsize < f->conn.max_write)
+		f->conn.max_write = bufsize;
+
+	f->got_init = 1;
+	if (f->op.init)
+		f->op.init(f->userdata, &f->conn);
+
+	if (f->no_splice_read)
+		f->conn.want &= ~FUSE_CAP_SPLICE_READ;
+	if (f->no_splice_write)
+		f->conn.want &= ~FUSE_CAP_SPLICE_WRITE;
+	if (f->no_splice_move)
+		f->conn.want &= ~FUSE_CAP_SPLICE_MOVE;
+
+	if (f->conn.async_read || (f->conn.want & FUSE_CAP_ASYNC_READ))
+		outarg.flags |= FUSE_ASYNC_READ;
+	if (f->conn.want & FUSE_CAP_POSIX_LOCKS)
+		outarg.flags |= FUSE_POSIX_LOCKS;
+	if (f->conn.want & FUSE_CAP_ATOMIC_O_TRUNC)
+		outarg.flags |= FUSE_ATOMIC_O_TRUNC;
+	if (f->conn.want & FUSE_CAP_EXPORT_SUPPORT)
+		outarg.flags |= FUSE_EXPORT_SUPPORT;
+	if (f->conn.want & FUSE_CAP_BIG_WRITES)
+		outarg.flags |= FUSE_BIG_WRITES;
+	if (f->conn.want & FUSE_CAP_DONT_MASK)
+		outarg.flags |= FUSE_DONT_MASK;
+	if (f->conn.want & FUSE_CAP_FLOCK_LOCKS)
+		outarg.flags |= FUSE_FLOCK_LOCKS;
+	outarg.max_readahead = f->conn.max_readahead;
+	outarg.max_write = f->conn.max_write;
+	if (f->conn.proto_minor >= 13) {
+		if (f->conn.max_background >= (1 << 16))
+			f->conn.max_background = (1 << 16) - 1;
+		if (f->conn.congestion_threshold > f->conn.max_background)
+			f->conn.congestion_threshold = f->conn.max_background;
+		if (!f->conn.congestion_threshold) {
+			f->conn.congestion_threshold =
+				f->conn.max_background * 3 / 4;
+		}
+
+		outarg.max_background = f->conn.max_background;
+		outarg.congestion_threshold = f->conn.congestion_threshold;
+	}
+
+	if (f->debug) {
+		fprintf(stderr, "   INIT: %u.%u\n", outarg.major, outarg.minor);
+		fprintf(stderr, "   flags=0x%08x\n", outarg.flags);
+		fprintf(stderr, "   max_readahead=0x%08x\n",
+			outarg.max_readahead);
+		fprintf(stderr, "   max_write=0x%08x\n", outarg.max_write);
+		fprintf(stderr, "   max_background=%i\n",
+			outarg.max_background);
+		fprintf(stderr, "   congestion_threshold=%i\n",
+		        outarg.congestion_threshold);
+	}
+
+	send_reply_ok(req, &outarg, arg->minor < 5 ? 8 : sizeof(outarg));
+}
+
+static void do_destroy(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
+{
+	struct fuse_ll *f = req->f;
+
+	(void) nodeid;
+	(void) inarg;
+
+	f->got_destroy = 1;
+	if (f->op.destroy)
+		f->op.destroy(f->userdata);
+
+	send_reply_ok(req, NULL, 0);
+}
+
+static void list_del_nreq(struct fuse_notify_req *nreq)
+{
+	struct fuse_notify_req *prev = nreq->prev;
+	struct fuse_notify_req *next = nreq->next;
+	prev->next = next;
+	next->prev = prev;
+}
+
+static void list_add_nreq(struct fuse_notify_req *nreq,
+			  struct fuse_notify_req *next)
+{
+	struct fuse_notify_req *prev = next->prev;
+	nreq->next = next;
+	nreq->prev = prev;
+	prev->next = nreq;
+	next->prev = nreq;
+}
+
+static void list_init_nreq(struct fuse_notify_req *nreq)
+{
+	nreq->next = nreq;
+	nreq->prev = nreq;
+}
+
+static void do_notify_reply(fuse_req_t req, fuse_ino_t nodeid,
+			    const void *inarg, const struct fuse_buf *buf)
+{
+	struct fuse_ll *f = req->f;
+	struct fuse_notify_req *nreq;
+	struct fuse_notify_req *head;
+
+	pthread_mutex_lock(&f->lock);
+	head = &f->notify_list;
+	for (nreq = head->next; nreq != head; nreq = nreq->next) {
+		if (nreq->unique == req->unique) {
+			list_del_nreq(nreq);
+			break;
+		}
+	}
+	pthread_mutex_unlock(&f->lock);
+
+	if (nreq != head)
+		nreq->reply(nreq, req, nodeid, inarg, buf);
+}
+
+static int send_notify_iov(struct fuse_ll *f, struct fuse_chan *ch,
+			   int notify_code, struct iovec *iov, int count)
+{
+	struct fuse_out_header out;
+
+	if (!f->got_init)
+		return -ENOTCONN;
+
+	out.unique = 0;
+	out.error = notify_code;
+	iov[0].iov_base = &out;
+	iov[0].iov_len = sizeof(struct fuse_out_header);
+
+	return fuse_send_msg(f, ch, iov, count);
+}
+
+int fuse_lowlevel_notify_poll(struct fuse_pollhandle *ph)
+{
+	if (ph != NULL) {
+		struct fuse_notify_poll_wakeup_out outarg;
+		struct iovec iov[2];
+
+		outarg.kh = ph->kh;
+
+		iov[1].iov_base = &outarg;
+		iov[1].iov_len = sizeof(outarg);
+
+		return send_notify_iov(ph->f, ph->ch, FUSE_NOTIFY_POLL, iov, 2);
+	} else {
+		return 0;
+	}
+}
+
+int fuse_lowlevel_notify_inval_inode(struct fuse_chan *ch, fuse_ino_t ino,
+                                     off64_t off, off64_t len)
+{
+	struct fuse_notify_inval_inode_out outarg;
+	struct fuse_ll *f;
+	struct iovec iov[2];
+
+	if (!ch)
+		return -EINVAL;
+
+	f = (struct fuse_ll *)fuse_session_data(fuse_chan_session(ch));
+	if (!f)
+		return -ENODEV;
+
+	outarg.ino = ino;
+	outarg.off = off;
+	outarg.len = len;
+
+	iov[1].iov_base = &outarg;
+	iov[1].iov_len = sizeof(outarg);
+
+	return send_notify_iov(f, ch, FUSE_NOTIFY_INVAL_INODE, iov, 2);
+}
+
+int fuse_lowlevel_notify_inval_entry(struct fuse_chan *ch, fuse_ino_t parent,
+                                     const char *name, size_t namelen)
+{
+	struct fuse_notify_inval_entry_out outarg;
+	struct fuse_ll *f;
+	struct iovec iov[3];
+
+	if (!ch)
+		return -EINVAL;
+
+	f = (struct fuse_ll *)fuse_session_data(fuse_chan_session(ch));
+	if (!f)
+		return -ENODEV;
+
+	outarg.parent = parent;
+	outarg.namelen = namelen;
+	outarg.padding = 0;
+
+	iov[1].iov_base = &outarg;
+	iov[1].iov_len = sizeof(outarg);
+	iov[2].iov_base = (void *)name;
+	iov[2].iov_len = namelen + 1;
+
+	return send_notify_iov(f, ch, FUSE_NOTIFY_INVAL_ENTRY, iov, 3);
+}
+
+int fuse_lowlevel_notify_delete(struct fuse_chan *ch,
+				fuse_ino_t parent, fuse_ino_t child,
+				const char *name, size_t namelen)
+{
+	struct fuse_notify_delete_out outarg;
+	struct fuse_ll *f;
+	struct iovec iov[3];
+
+	if (!ch)
+		return -EINVAL;
+
+	f = (struct fuse_ll *)fuse_session_data(fuse_chan_session(ch));
+	if (!f)
+		return -ENODEV;
+
+	if (f->conn.proto_minor < 18)
+		return -ENOSYS;
+
+	outarg.parent = parent;
+	outarg.child = child;
+	outarg.namelen = namelen;
+	outarg.padding = 0;
+
+	iov[1].iov_base = &outarg;
+	iov[1].iov_len = sizeof(outarg);
+	iov[2].iov_base = (void *)name;
+	iov[2].iov_len = namelen + 1;
+
+	return send_notify_iov(f, ch, FUSE_NOTIFY_DELETE, iov, 3);
+}
+
+int fuse_lowlevel_notify_store(struct fuse_chan *ch, fuse_ino_t ino,
+			       off64_t offset, struct fuse_bufvec *bufv,
+			       enum fuse_buf_copy_flags flags)
+{
+	struct fuse_out_header out;
+	struct fuse_notify_store_out outarg;
+	struct fuse_ll *f;
+	struct iovec iov[3];
+	size_t size = fuse_buf_size(bufv);
+	int res;
+
+	if (!ch)
+		return -EINVAL;
+
+	f = (struct fuse_ll *)fuse_session_data(fuse_chan_session(ch));
+	if (!f)
+		return -ENODEV;
+
+	if (f->conn.proto_minor < 15)
+		return -ENOSYS;
+
+	out.unique = 0;
+	out.error = FUSE_NOTIFY_STORE;
+
+	outarg.nodeid = ino;
+	outarg.offset = offset;
+	outarg.size = size;
+
+	iov[0].iov_base = &out;
+	iov[0].iov_len = sizeof(out);
+	iov[1].iov_base = &outarg;
+	iov[1].iov_len = sizeof(outarg);
+
+	res = fuse_send_data_iov(f, ch, iov, 2, bufv, flags);
+	if (res > 0)
+		res = -res;
+
+	return res;
+}
+
+struct fuse_retrieve_req {
+	struct fuse_notify_req nreq;
+	void *cookie;
+};
+
+static void fuse_ll_retrieve_reply(struct fuse_notify_req *nreq,
+				   fuse_req_t req, fuse_ino_t ino,
+				   const void *inarg,
+				   const struct fuse_buf *ibuf)
+{
+	struct fuse_ll *f = req->f;
+	struct fuse_retrieve_req *rreq =
+		container_of(nreq, struct fuse_retrieve_req, nreq);
+	const struct fuse_notify_retrieve_in *arg = inarg;
+	struct fuse_bufvec bufv = {
+		.buf[0] = *ibuf,
+		.count = 1,
+	};
+
+	if (!(bufv.buf[0].flags & FUSE_BUF_IS_FD))
+		bufv.buf[0].mem = PARAM(arg);
+
+	bufv.buf[0].size -= sizeof(struct fuse_in_header) +
+		sizeof(struct fuse_notify_retrieve_in);
+
+	if (bufv.buf[0].size < arg->size) {
+		fprintf(stderr, "fuse: retrieve reply: buffer size too small\n");
+		fuse_reply_none(req);
+		goto out;
+	}
+	bufv.buf[0].size = arg->size;
+
+	if (req->f->op.retrieve_reply) {
+		req->f->op.retrieve_reply(req, rreq->cookie, ino,
+					  arg->offset, &bufv);
+	} else {
+		fuse_reply_none(req);
+	}
+out:
+	free(rreq);
+	if ((ibuf->flags & FUSE_BUF_IS_FD) && bufv.idx < bufv.count)
+		fuse_ll_clear_pipe(f);
+}
+
+int fuse_lowlevel_notify_retrieve(struct fuse_chan *ch, fuse_ino_t ino,
+				  size_t size, off64_t offset, void *cookie)
+{
+	struct fuse_notify_retrieve_out outarg;
+	struct fuse_ll *f;
+	struct iovec iov[2];
+	struct fuse_retrieve_req *rreq;
+	int err;
+
+	if (!ch)
+		return -EINVAL;
+
+	f = (struct fuse_ll *)fuse_session_data(fuse_chan_session(ch));
+	if (!f)
+		return -ENODEV;
+
+	if (f->conn.proto_minor < 15)
+		return -ENOSYS;
+
+	rreq = malloc(sizeof(*rreq));
+	if (rreq == NULL)
+		return -ENOMEM;
+
+	pthread_mutex_lock(&f->lock);
+	rreq->cookie = cookie;
+	rreq->nreq.unique = f->notify_ctr++;
+	rreq->nreq.reply = fuse_ll_retrieve_reply;
+	list_add_nreq(&rreq->nreq, &f->notify_list);
+	pthread_mutex_unlock(&f->lock);
+
+	outarg.notify_unique = rreq->nreq.unique;
+	outarg.nodeid = ino;
+	outarg.offset = offset;
+	outarg.size = size;
+
+	iov[1].iov_base = &outarg;
+	iov[1].iov_len = sizeof(outarg);
+
+	err = send_notify_iov(f, ch, FUSE_NOTIFY_RETRIEVE, iov, 2);
+	if (err) {
+		pthread_mutex_lock(&f->lock);
+		list_del_nreq(&rreq->nreq);
+		pthread_mutex_unlock(&f->lock);
+		free(rreq);
+	}
+
+	return err;
+}
+
+void *fuse_req_userdata(fuse_req_t req)
+{
+	return req->f->userdata;
+}
+
+const struct fuse_ctx *fuse_req_ctx(fuse_req_t req)
+{
+	return &req->ctx;
+}
+
+/*
+ * The size of fuse_ctx got extended, so need to be careful about
+ * incompatibility (i.e. a new binary cannot work with an old
+ * library).
+ */
+const struct fuse_ctx *fuse_req_ctx_compat24(fuse_req_t req);
+const struct fuse_ctx *fuse_req_ctx_compat24(fuse_req_t req)
+{
+	return fuse_req_ctx(req);
+}
+#ifndef __NetBSD__
+FUSE_SYMVER(".symver fuse_req_ctx_compat24,fuse_req_ctx@FUSE_2.4");
+#endif
+
+
+void fuse_req_interrupt_func(fuse_req_t req, fuse_interrupt_func_t func,
+			     void *data)
+{
+	pthread_mutex_lock(&req->lock);
+	pthread_mutex_lock(&req->f->lock);
+	req->u.ni.func = func;
+	req->u.ni.data = data;
+	pthread_mutex_unlock(&req->f->lock);
+	if (req->interrupted && func)
+		func(req, data);
+	pthread_mutex_unlock(&req->lock);
+}
+
+int fuse_req_interrupted(fuse_req_t req)
+{
+	int interrupted;
+
+	pthread_mutex_lock(&req->f->lock);
+	interrupted = req->interrupted;
+	pthread_mutex_unlock(&req->f->lock);
+
+	return interrupted;
+}
+
+static struct {
+	void (*func)(fuse_req_t, fuse_ino_t, const void *);
+	const char *name;
+} fuse_ll_ops[] = {
+	[FUSE_LOOKUP]	   = { do_lookup,      "LOOKUP"	     },
+	[FUSE_FORGET]	   = { do_forget,      "FORGET"	     },
+	[FUSE_GETATTR]	   = { do_getattr,     "GETATTR"     },
+	[FUSE_SETATTR]	   = { do_setattr,     "SETATTR"     },
+	[FUSE_READLINK]	   = { do_readlink,    "READLINK"    },
+	[FUSE_SYMLINK]	   = { do_symlink,     "SYMLINK"     },
+	[FUSE_MKNOD]	   = { do_mknod,       "MKNOD"	     },
+	[FUSE_MKDIR]	   = { do_mkdir,       "MKDIR"	     },
+	[FUSE_UNLINK]	   = { do_unlink,      "UNLINK"	     },
+	[FUSE_RMDIR]	   = { do_rmdir,       "RMDIR"	     },
+	[FUSE_RENAME]	   = { do_rename,      "RENAME"	     },
+	[FUSE_LINK]	   = { do_link,	       "LINK"	     },
+	[FUSE_OPEN]	   = { do_open,	       "OPEN"	     },
+	[FUSE_READ]	   = { do_read,	       "READ"	     },
+	[FUSE_WRITE]	   = { do_write,       "WRITE"	     },
+	[FUSE_STATFS]	   = { do_statfs,      "STATFS"	     },
+	[FUSE_RELEASE]	   = { do_release,     "RELEASE"     },
+	[FUSE_FSYNC]	   = { do_fsync,       "FSYNC"	     },
+	[FUSE_SETXATTR]	   = { do_setxattr,    "SETXATTR"    },
+	[FUSE_GETXATTR]	   = { do_getxattr,    "GETXATTR"    },
+	[FUSE_LISTXATTR]   = { do_listxattr,   "LISTXATTR"   },
+	[FUSE_REMOVEXATTR] = { do_removexattr, "REMOVEXATTR" },
+	[FUSE_FLUSH]	   = { do_flush,       "FLUSH"	     },
+	[FUSE_INIT]	   = { do_init,	       "INIT"	     },
+	[FUSE_OPENDIR]	   = { do_opendir,     "OPENDIR"     },
+	[FUSE_READDIR]	   = { do_readdir,     "READDIR"     },
+	[FUSE_RELEASEDIR]  = { do_releasedir,  "RELEASEDIR"  },
+	[FUSE_FSYNCDIR]	   = { do_fsyncdir,    "FSYNCDIR"    },
+	[FUSE_GETLK]	   = { do_getlk,       "GETLK"	     },
+	[FUSE_SETLK]	   = { do_setlk,       "SETLK"	     },
+	[FUSE_SETLKW]	   = { do_setlkw,      "SETLKW"	     },
+	[FUSE_ACCESS]	   = { do_access,      "ACCESS"	     },
+	[FUSE_CREATE]	   = { do_create,      "CREATE"	     },
+	[FUSE_INTERRUPT]   = { do_interrupt,   "INTERRUPT"   },
+	[FUSE_BMAP]	   = { do_bmap,	       "BMAP"	     },
+	[FUSE_IOCTL]	   = { do_ioctl,       "IOCTL"	     },
+	[FUSE_POLL]	   = { do_poll,        "POLL"	     },
+	[FUSE_FALLOCATE]   = { do_fallocate,   "FALLOCATE"   },
+	[FUSE_DESTROY]	   = { do_destroy,     "DESTROY"     },
+	[FUSE_NOTIFY_REPLY] = { (void *) 1,    "NOTIFY_REPLY" },
+	[FUSE_BATCH_FORGET] = { do_batch_forget, "BATCH_FORGET" },
+	[CUSE_INIT]	   = { cuse_lowlevel_init, "CUSE_INIT"   },
+};
+
+#define FUSE_MAXOP (sizeof(fuse_ll_ops) / sizeof(fuse_ll_ops[0]))
+
+static const char *opname(enum fuse_opcode opcode)
+{
+	if (opcode >= FUSE_MAXOP || !fuse_ll_ops[opcode].name)
+		return "???";
+	else
+		return fuse_ll_ops[opcode].name;
+}
+
+static int fuse_ll_copy_from_pipe(struct fuse_bufvec *dst,
+				  struct fuse_bufvec *src)
+{
+	int res = fuse_buf_copy(dst, src, 0);
+	if (res < 0) {
+		fprintf(stderr, "fuse: copy from pipe: %s\n", strerror(-res));
+		return res;
+	}
+	if (res < fuse_buf_size(dst)) {
+		fprintf(stderr, "fuse: copy from pipe: short read\n");
+		return -1;
+	}
+	return 0;
+}
+
+static void fuse_ll_process_buf(void *data, const struct fuse_buf *buf,
+				struct fuse_chan *ch)
+{
+	struct fuse_ll *f = (struct fuse_ll *) data;
+	const size_t write_header_size = sizeof(struct fuse_in_header) +
+		sizeof(struct fuse_write_in);
+	struct fuse_bufvec bufv = { .buf[0] = *buf, .count = 1 };
+	struct fuse_bufvec tmpbuf = FUSE_BUFVEC_INIT(write_header_size);
+	struct fuse_in_header *in;
+	const void *inarg;
+	struct fuse_req *req;
+	void *mbuf = NULL;
+	int err;
+	int res;
+
+	if (buf->flags & FUSE_BUF_IS_FD) {
+		if (buf->size < tmpbuf.buf[0].size)
+			tmpbuf.buf[0].size = buf->size;
+
+		mbuf = malloc(tmpbuf.buf[0].size);
+		if (mbuf == NULL) {
+			fprintf(stderr, "fuse: failed to allocate header\n");
+			goto clear_pipe;
+		}
+		tmpbuf.buf[0].mem = mbuf;
+
+		res = fuse_ll_copy_from_pipe(&tmpbuf, &bufv);
+		if (res < 0)
+			goto clear_pipe;
+
+		in = mbuf;
+	} else {
+		in = buf->mem;
+	}
+
+	if (f->debug) {
+		fprintf(stderr,
+			"unique: %llu, opcode: %s (%i), nodeid: %lu, insize: %zu, pid: %u\n",
+			(unsigned long long) in->unique,
+			opname((enum fuse_opcode) in->opcode), in->opcode,
+			(unsigned long) in->nodeid, buf->size, in->pid);
+	}
+
+	req = fuse_ll_alloc_req(f);
+	if (req == NULL) {
+		struct fuse_out_header out = {
+			.unique = in->unique,
+			.error = -ENOMEM,
+		};
+		struct iovec iov = {
+			.iov_base = &out,
+			.iov_len = sizeof(struct fuse_out_header),
+		};
+
+		fuse_send_msg(f, ch, &iov, 1);
+		goto clear_pipe;
+	}
+
+	req->unique = in->unique;
+	req->ctx.uid = in->uid;
+	req->ctx.gid = in->gid;
+	req->ctx.pid = in->pid;
+	req->ch = ch;
+
+	err = EIO;
+	if (!f->got_init) {
+		enum fuse_opcode expected;
+
+		expected = f->cuse_data ? CUSE_INIT : FUSE_INIT;
+		if (in->opcode != expected)
+			goto reply_err;
+	} else if (in->opcode == FUSE_INIT || in->opcode == CUSE_INIT)
+		goto reply_err;
+
+	err = EACCES;
+	if (f->allow_root && in->uid != f->owner && in->uid != 0 &&
+		 in->opcode != FUSE_INIT && in->opcode != FUSE_READ &&
+		 in->opcode != FUSE_WRITE && in->opcode != FUSE_FSYNC &&
+		 in->opcode != FUSE_RELEASE && in->opcode != FUSE_READDIR &&
+		 in->opcode != FUSE_FSYNCDIR && in->opcode != FUSE_RELEASEDIR &&
+		 in->opcode != FUSE_NOTIFY_REPLY)
+		goto reply_err;
+
+	err = ENOSYS;
+	if (in->opcode >= FUSE_MAXOP || !fuse_ll_ops[in->opcode].func)
+		goto reply_err;
+	if (in->opcode != FUSE_INTERRUPT) {
+		struct fuse_req *intr;
+		pthread_mutex_lock(&f->lock);
+		intr = check_interrupt(f, req);
+		list_add_req(req, &f->list);
+		pthread_mutex_unlock(&f->lock);
+		if (intr)
+			fuse_reply_err(intr, EAGAIN);
+	}
+
+	if ((buf->flags & FUSE_BUF_IS_FD) && write_header_size < buf->size &&
+	    (in->opcode != FUSE_WRITE || !f->op.write_buf) &&
+	    in->opcode != FUSE_NOTIFY_REPLY) {
+		void *newmbuf;
+
+		err = ENOMEM;
+		newmbuf = realloc(mbuf, buf->size);
+		if (newmbuf == NULL)
+			goto reply_err;
+		mbuf = newmbuf;
+
+		tmpbuf = FUSE_BUFVEC_INIT(buf->size - write_header_size);
+		tmpbuf.buf[0].mem = mbuf + write_header_size;
+
+		res = fuse_ll_copy_from_pipe(&tmpbuf, &bufv);
+		err = -res;
+		if (res < 0)
+			goto reply_err;
+
+		in = mbuf;
+	}
+
+	inarg = (void *) &in[1];
+	if (in->opcode == FUSE_WRITE && f->op.write_buf)
+		do_write_buf(req, in->nodeid, inarg, buf);
+	else if (in->opcode == FUSE_NOTIFY_REPLY)
+		do_notify_reply(req, in->nodeid, inarg, buf);
+	else
+		fuse_ll_ops[in->opcode].func(req, in->nodeid, inarg);
+
+out_free:
+	free(mbuf);
+	return;
+
+reply_err:
+	fuse_reply_err(req, err);
+clear_pipe:
+	if (buf->flags & FUSE_BUF_IS_FD)
+		fuse_ll_clear_pipe(f);
+	goto out_free;
+}
+
+static void fuse_ll_process(void *data, const char *buf, size_t len,
+			    struct fuse_chan *ch)
+{
+	struct fuse_buf fbuf = {
+		.mem = (void *) buf,
+		.size = len,
+	};
+
+	fuse_ll_process_buf(data, &fbuf, ch);
+}
+
+enum {
+	KEY_HELP,
+	KEY_VERSION,
+};
+
+static const struct fuse_opt fuse_ll_opts[] = {
+	{ "debug", offsetof(struct fuse_ll, debug), 1 },
+	{ "-d", offsetof(struct fuse_ll, debug), 1 },
+	{ "allow_root", offsetof(struct fuse_ll, allow_root), 1 },
+	{ "max_write=%u", offsetof(struct fuse_ll, conn.max_write), 0 },
+	{ "max_readahead=%u", offsetof(struct fuse_ll, conn.max_readahead), 0 },
+	{ "max_background=%u", offsetof(struct fuse_ll, conn.max_background), 0 },
+	{ "congestion_threshold=%u",
+	  offsetof(struct fuse_ll, conn.congestion_threshold), 0 },
+	{ "async_read", offsetof(struct fuse_ll, conn.async_read), 1 },
+	{ "sync_read", offsetof(struct fuse_ll, conn.async_read), 0 },
+	{ "atomic_o_trunc", offsetof(struct fuse_ll, atomic_o_trunc), 1},
+	{ "no_remote_lock", offsetof(struct fuse_ll, no_remote_posix_lock), 1},
+	{ "no_remote_lock", offsetof(struct fuse_ll, no_remote_flock), 1},
+	{ "no_remote_flock", offsetof(struct fuse_ll, no_remote_flock), 1},
+	{ "no_remote_posix_lock", offsetof(struct fuse_ll, no_remote_posix_lock), 1},
+	{ "big_writes", offsetof(struct fuse_ll, big_writes), 1},
+	{ "splice_write", offsetof(struct fuse_ll, splice_write), 1},
+	{ "no_splice_write", offsetof(struct fuse_ll, no_splice_write), 1},
+	{ "splice_move", offsetof(struct fuse_ll, splice_move), 1},
+	{ "no_splice_move", offsetof(struct fuse_ll, no_splice_move), 1},
+	{ "splice_read", offsetof(struct fuse_ll, splice_read), 1},
+	{ "no_splice_read", offsetof(struct fuse_ll, no_splice_read), 1},
+	FUSE_OPT_KEY("max_read=", FUSE_OPT_KEY_DISCARD),
+	FUSE_OPT_KEY("-h", KEY_HELP),
+	FUSE_OPT_KEY("--help", KEY_HELP),
+	FUSE_OPT_KEY("-V", KEY_VERSION),
+	FUSE_OPT_KEY("--version", KEY_VERSION),
+	FUSE_OPT_END
+};
+
+static void fuse_ll_version(void)
+{
+	fprintf(stderr, "using FUSE kernel interface version %i.%i\n",
+		FUSE_KERNEL_VERSION, FUSE_KERNEL_MINOR_VERSION);
+}
+
+static void fuse_ll_help(void)
+{
+	fprintf(stderr,
+"    -o max_write=N         set maximum size of write requests\n"
+"    -o max_readahead=N     set maximum readahead\n"
+"    -o max_background=N    set number of maximum background requests\n"
+"    -o congestion_threshold=N  set kernel's congestion threshold\n"
+"    -o async_read          perform reads asynchronously (default)\n"
+"    -o sync_read           perform reads synchronously\n"
+"    -o atomic_o_trunc      enable atomic open+truncate support\n"
+"    -o big_writes          enable larger than 4kB writes\n"
+"    -o no_remote_lock      disable remote file locking\n"
+"    -o no_remote_flock     disable remote file locking (BSD)\n"
+"    -o no_remote_posix_lock disable remove file locking (POSIX)\n"
+"    -o [no_]splice_write   use splice to write to the fuse device\n"
+"    -o [no_]splice_move    move data while splicing to the fuse device\n"
+"    -o [no_]splice_read    use splice to read from the fuse device\n"
+);
+}
+
+static int fuse_ll_opt_proc(void *data, const char *arg, int key,
+			    struct fuse_args *outargs)
+{
+	(void) data; (void) outargs;
+
+	switch (key) {
+	case KEY_HELP:
+		fuse_ll_help();
+		break;
+
+	case KEY_VERSION:
+		fuse_ll_version();
+		break;
+
+	default:
+		fprintf(stderr, "fuse: unknown option `%s'\n", arg);
+	}
+
+	return -1;
+}
+
+int fuse_lowlevel_is_lib_option(const char *opt)
+{
+	return fuse_opt_match(fuse_ll_opts, opt);
+}
+
+static void fuse_ll_destroy(void *data)
+{
+	struct fuse_ll *f = (struct fuse_ll *) data;
+	struct fuse_ll_pipe *llp;
+
+	if (f->got_init && !f->got_destroy) {
+		if (f->op.destroy)
+			f->op.destroy(f->userdata);
+	}
+	llp = pthread_getspecific(f->pipe_key);
+	if (llp != NULL)
+		fuse_ll_pipe_free(llp);
+	pthread_key_delete(f->pipe_key);
+	pthread_mutex_destroy(&f->lock);
+	free(f->cuse_data);
+	free(f);
+}
+
+static void fuse_ll_pipe_destructor(void *data)
+{
+	struct fuse_ll_pipe *llp = data;
+	fuse_ll_pipe_free(llp);
+}
+
+#ifdef HAVE_SPLICE
+static int fuse_ll_receive_buf(struct fuse_session *se, struct fuse_buf *buf,
+			       struct fuse_chan **chp)
+{
+	struct fuse_chan *ch = *chp;
+	struct fuse_ll *f = fuse_session_data(se);
+	size_t bufsize = buf->size;
+	struct fuse_ll_pipe *llp;
+	struct fuse_buf tmpbuf;
+	int err;
+	int res;
+
+	if (f->conn.proto_minor < 14 || !(f->conn.want & FUSE_CAP_SPLICE_READ))
+		goto fallback;
+
+	llp = fuse_ll_get_pipe(f);
+	if (llp == NULL)
+		goto fallback;
+
+	if (llp->size < bufsize) {
+		if (llp->can_grow) {
+			res = fcntl(llp->pipe[0], F_SETPIPE_SZ, bufsize);
+			if (res == -1) {
+				llp->can_grow = 0;
+				goto fallback;
+			}
+			llp->size = res;
+		}
+		if (llp->size < bufsize)
+			goto fallback;
+	}
+
+	res = splice(fuse_chan_fd(ch), NULL, llp->pipe[1], NULL, bufsize, 0);
+	err = errno;
+
+	if (fuse_session_exited(se))
+		return 0;
+
+	if (res == -1) {
+		if (err == ENODEV) {
+			fuse_session_exit(se);
+			return 0;
+		}
+		if (err != EINTR && err != EAGAIN)
+			perror("fuse: splice from device");
+		return -err;
+	}
+
+	if (res < sizeof(struct fuse_in_header)) {
+		fprintf(stderr, "short splice from fuse device\n");
+		return -EIO;
+	}
+
+	tmpbuf = (struct fuse_buf) {
+		.size = res,
+		.flags = FUSE_BUF_IS_FD,
+		.fd = llp->pipe[0],
+	};
+
+	/*
+	 * Don't bother with zero copy for small requests.
+	 * fuse_loop_mt() needs to check for FORGET so this more than
+	 * just an optimization.
+	 */
+	if (res < sizeof(struct fuse_in_header) +
+	    sizeof(struct fuse_write_in) + pagesize) {
+		struct fuse_bufvec src = { .buf[0] = tmpbuf, .count = 1 };
+		struct fuse_bufvec dst = { .buf[0] = *buf, .count = 1 };
+
+		res = fuse_buf_copy(&dst, &src, 0);
+		if (res < 0) {
+			fprintf(stderr, "fuse: copy from pipe: %s\n",
+				strerror(-res));
+			fuse_ll_clear_pipe(f);
+			return res;
+		}
+		if (res < tmpbuf.size) {
+			fprintf(stderr, "fuse: copy from pipe: short read\n");
+			fuse_ll_clear_pipe(f);
+			return -EIO;
+		}
+		buf->size = tmpbuf.size;
+		return buf->size;
+	}
+
+	*buf = tmpbuf;
+
+	return res;
+
+fallback:
+	res = fuse_chan_recv(chp, buf->mem, bufsize);
+	if (res <= 0)
+		return res;
+
+	buf->size = res;
+
+	return res;
+}
+#else
+static int fuse_ll_receive_buf(struct fuse_session *se, struct fuse_buf *buf,
+			       struct fuse_chan **chp)
+{
+	(void) se;
+
+	int res = fuse_chan_recv(chp, buf->mem, buf->size);
+	if (res <= 0)
+		return res;
+
+	buf->size = res;
+
+	return res;
+}
+#endif
+
+
+/*
+ * always call fuse_lowlevel_new_common() internally, to work around a
+ * misfeature in the FreeBSD runtime linker, which links the old
+ * version of a symbol to internal references.
+ */
+struct fuse_session *fuse_lowlevel_new_common(struct fuse_args *args,
+					      const struct fuse_lowlevel_ops *op,
+					      size_t op_size, void *userdata)
+{
+	int err;
+	struct fuse_ll *f;
+	struct fuse_session *se;
+	struct fuse_session_ops sop = {
+		.process = fuse_ll_process,
+		.destroy = fuse_ll_destroy,
+	};
+
+	if (sizeof(struct fuse_lowlevel_ops) < op_size) {
+		fprintf(stderr, "fuse: warning: library too old, some operations may not work\n");
+		op_size = sizeof(struct fuse_lowlevel_ops);
+	}
+
+	f = (struct fuse_ll *) calloc(1, sizeof(struct fuse_ll));
+	if (f == NULL) {
+		fprintf(stderr, "fuse: failed to allocate fuse object\n");
+		goto out;
+	}
+
+	f->conn.async_read = 1;
+	f->conn.max_write = UINT_MAX;
+	f->conn.max_readahead = UINT_MAX;
+	f->atomic_o_trunc = 0;
+	list_init_req(&f->list);
+	list_init_req(&f->interrupts);
+	list_init_nreq(&f->notify_list);
+	f->notify_ctr = 1;
+	fuse_mutex_init(&f->lock);
+
+	err = pthread_key_create(&f->pipe_key, fuse_ll_pipe_destructor);
+	if (err) {
+		fprintf(stderr, "fuse: failed to create thread specific key: %s\n",
+			strerror(err));
+		goto out_free;
+	}
+
+	if (fuse_opt_parse(args, f, fuse_ll_opts, fuse_ll_opt_proc) == -1)
+		goto out_key_destroy;
+
+	if (f->debug)
+		fprintf(stderr, "FUSE library version: %s\n", PACKAGE_VERSION);
+
+	memcpy(&f->op, op, op_size);
+	f->owner = getuid();
+	f->userdata = userdata;
+
+	se = fuse_session_new(&sop, f);
+	if (!se)
+		goto out_key_destroy;
+
+	se->receive_buf = fuse_ll_receive_buf;
+	se->process_buf = fuse_ll_process_buf;
+
+	return se;
+
+out_key_destroy:
+	pthread_key_delete(f->pipe_key);
+out_free:
+	pthread_mutex_destroy(&f->lock);
+	free(f);
+out:
+	return NULL;
+}
+
+
+struct fuse_session *fuse_lowlevel_new(struct fuse_args *args,
+				       const struct fuse_lowlevel_ops *op,
+				       size_t op_size, void *userdata)
+{
+	return fuse_lowlevel_new_common(args, op, op_size, userdata);
+}
+
+#ifdef linux
+int fuse_req_getgroups(fuse_req_t req, int size, gid_t list[])
+{
+	char *buf;
+	size_t bufsize = 1024;
+	char path[128];
+	int ret;
+	int fd;
+	unsigned long pid = req->ctx.pid;
+	char *s;
+
+	sprintf(path, "/proc/%lu/task/%lu/status", pid, pid);
+
+retry:
+	buf = malloc(bufsize);
+	if (buf == NULL)
+		return -ENOMEM;
+
+	ret = -EIO;
+	fd = open(path, O_RDONLY);
+	if (fd == -1)
+		goto out_free;
+
+	ret = read(fd, buf, bufsize);
+	close(fd);
+	if (ret == -1) {
+		ret = -EIO;
+		goto out_free;
+	}
+
+	if (ret == bufsize) {
+		free(buf);
+		bufsize *= 4;
+		goto retry;
+	}
+
+	ret = -EIO;
+	s = strstr(buf, "\nGroups:");
+	if (s == NULL)
+		goto out_free;
+
+	s += 8;
+	ret = 0;
+	while (1) {
+		char *end;
+		unsigned long val = strtoul(s, &end, 0);
+		if (end == s)
+			break;
+
+		s = end;
+		if (ret < size)
+			list[ret] = val;
+		ret++;
+	}
+
+out_free:
+	free(buf);
+	return ret;
+}
+#else /* linux */
+/*
+ * This is currently not implemented on other than Linux...
+ */
+int fuse_req_getgroups(fuse_req_t req, int size, gid_t list[])
+{
+	return -ENOSYS;
+}
+#endif
+
+#if !defined(__FreeBSD__) && !defined(__NetBSD__)
+
+static void fill_open_compat(struct fuse_open_out *arg,
+			     const struct fuse_file_info_compat *f)
+{
+	arg->fh = f->fh;
+	if (f->direct_io)
+		arg->open_flags |= FOPEN_DIRECT_IO;
+	if (f->keep_cache)
+		arg->open_flags |= FOPEN_KEEP_CACHE;
+}
+
+static void convert_statfs_compat(const struct statfs *compatbuf,
+				  struct statvfs *buf)
+{
+	buf->f_bsize	= compatbuf->f_bsize;
+	buf->f_blocks	= compatbuf->f_blocks;
+	buf->f_bfree	= compatbuf->f_bfree;
+	buf->f_bavail	= compatbuf->f_bavail;
+	buf->f_files	= compatbuf->f_files;
+	buf->f_ffree	= compatbuf->f_ffree;
+	buf->f_namemax	= compatbuf->f_namelen;
+}
+
+int fuse_reply_open_compat(fuse_req_t req,
+			   const struct fuse_file_info_compat *f)
+{
+	struct fuse_open_out arg;
+
+	memset(&arg, 0, sizeof(arg));
+	fill_open_compat(&arg, f);
+	return send_reply_ok(req, &arg, sizeof(arg));
+}
+
+int fuse_reply_statfs_compat(fuse_req_t req, const struct statfs *stbuf)
+{
+	struct statvfs newbuf;
+
+	memset(&newbuf, 0, sizeof(newbuf));
+	convert_statfs_compat(stbuf, &newbuf);
+
+	return fuse_reply_statfs(req, &newbuf);
+}
+
+struct fuse_session *fuse_lowlevel_new_compat(const char *opts,
+				const struct fuse_lowlevel_ops_compat *op,
+				size_t op_size, void *userdata)
+{
+	struct fuse_session *se;
+	struct fuse_args args = FUSE_ARGS_INIT(0, NULL);
+
+	if (opts &&
+	    (fuse_opt_add_arg(&args, "") == -1 ||
+	     fuse_opt_add_arg(&args, "-o") == -1 ||
+	     fuse_opt_add_arg(&args, opts) == -1)) {
+		fuse_opt_free_args(&args);
+		return NULL;
+	}
+	se = fuse_lowlevel_new(&args, (const struct fuse_lowlevel_ops *) op,
+			       op_size, userdata);
+	fuse_opt_free_args(&args);
+
+	return se;
+}
+
+struct fuse_ll_compat_conf {
+	unsigned max_read;
+	int set_max_read;
+};
+
+static const struct fuse_opt fuse_ll_opts_compat[] = {
+	{ "max_read=", offsetof(struct fuse_ll_compat_conf, set_max_read), 1 },
+	{ "max_read=%u", offsetof(struct fuse_ll_compat_conf, max_read), 0 },
+	FUSE_OPT_KEY("max_read=", FUSE_OPT_KEY_KEEP),
+	FUSE_OPT_END
+};
+
+int fuse_sync_compat_args(struct fuse_args *args)
+{
+	struct fuse_ll_compat_conf conf;
+
+	memset(&conf, 0, sizeof(conf));
+	if (fuse_opt_parse(args, &conf, fuse_ll_opts_compat, NULL) == -1)
+		return -1;
+
+	if (fuse_opt_insert_arg(args, 1, "-osync_read"))
+		return -1;
+
+	if (conf.set_max_read) {
+		char tmpbuf[64];
+
+		sprintf(tmpbuf, "-omax_readahead=%u", conf.max_read);
+		if (fuse_opt_insert_arg(args, 1, tmpbuf) == -1)
+			return -1;
+	}
+	return 0;
+}
+
+FUSE_SYMVER(".symver fuse_reply_statfs_compat,fuse_reply_statfs@FUSE_2.4");
+FUSE_SYMVER(".symver fuse_reply_open_compat,fuse_reply_open@FUSE_2.4");
+FUSE_SYMVER(".symver fuse_lowlevel_new_compat,fuse_lowlevel_new@FUSE_2.4");
+
+#else /* __FreeBSD__ || __NetBSD__ */
+
+int fuse_sync_compat_args(struct fuse_args *args)
+{
+	(void) args;
+	return 0;
+}
+
+#endif /* __FreeBSD__ || __NetBSD__ */
+
+struct fuse_session *fuse_lowlevel_new_compat25(struct fuse_args *args,
+				const struct fuse_lowlevel_ops_compat25 *op,
+				size_t op_size, void *userdata)
+{
+	if (fuse_sync_compat_args(args) == -1)
+		return NULL;
+
+	return fuse_lowlevel_new_common(args,
+					(const struct fuse_lowlevel_ops *) op,
+					op_size, userdata);
+}
+
+FUSE_SYMVER(".symver fuse_lowlevel_new_compat25,fuse_lowlevel_new@FUSE_2.5");
diff --git a/external/fuse/fuse_misc.h b/external/fuse/fuse_misc.h
new file mode 100755
index 0000000000..eedf0e0f71
--- /dev/null
+++ b/external/fuse/fuse_misc.h
@@ -0,0 +1,57 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB
+*/
+
+#include "config.h"
+#include <pthread.h>
+
+/*
+  Versioned symbols cannot be used in some cases because it
+    - confuse the dynamic linker in uClibc
+    - not supported on MacOSX (in MachO binary format)
+*/
+#if (!defined(__UCLIBC__) && !defined(__APPLE__))
+#define FUSE_SYMVER(x) __asm__(x)
+#else
+#define FUSE_SYMVER(x)
+#endif
+
+#ifndef USE_UCLIBC
+#define fuse_mutex_init(mut) pthread_mutex_init(mut, NULL)
+#else
+/* Is this hack still needed? */
+static inline void fuse_mutex_init(pthread_mutex_t *mut)
+{
+	pthread_mutexattr_t attr;
+	pthread_mutexattr_init(&attr);
+	pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ADAPTIVE_NP);
+	pthread_mutex_init(mut, &attr);
+	pthread_mutexattr_destroy(&attr);
+}
+#endif
+
+#ifdef HAVE_STRUCT_STAT_ST_ATIM
+/* Linux */
+#define ST_ATIM_NSEC(stbuf) ((stbuf)->st_atim.tv_nsec)
+#define ST_CTIM_NSEC(stbuf) ((stbuf)->st_ctim.tv_nsec)
+#define ST_MTIM_NSEC(stbuf) ((stbuf)->st_mtim.tv_nsec)
+#define ST_ATIM_NSEC_SET(stbuf, val) (stbuf)->st_atim.tv_nsec = (val)
+#define ST_MTIM_NSEC_SET(stbuf, val) (stbuf)->st_mtim.tv_nsec = (val)
+#elif defined(HAVE_STRUCT_STAT_ST_ATIMESPEC)
+/* FreeBSD */
+#define ST_ATIM_NSEC(stbuf) ((stbuf)->st_atimespec.tv_nsec)
+#define ST_CTIM_NSEC(stbuf) ((stbuf)->st_ctimespec.tv_nsec)
+#define ST_MTIM_NSEC(stbuf) ((stbuf)->st_mtimespec.tv_nsec)
+#define ST_ATIM_NSEC_SET(stbuf, val) (stbuf)->st_atimespec.tv_nsec = (val)
+#define ST_MTIM_NSEC_SET(stbuf, val) (stbuf)->st_mtimespec.tv_nsec = (val)
+#else
+#define ST_ATIM_NSEC(stbuf) 0
+#define ST_CTIM_NSEC(stbuf) 0
+#define ST_MTIM_NSEC(stbuf) 0
+#define ST_ATIM_NSEC_SET(stbuf, val) do { } while (0)
+#define ST_MTIM_NSEC_SET(stbuf, val) do { } while (0)
+#endif
diff --git a/external/fuse/fuse_mt.c b/external/fuse/fuse_mt.c
new file mode 100755
index 0000000000..f6dbe71b21
--- /dev/null
+++ b/external/fuse/fuse_mt.c
@@ -0,0 +1,122 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB.
+*/
+
+#include "fuse_i.h"
+#include "fuse_misc.h"
+#include "fuse_lowlevel.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <pthread.h>
+#include <assert.h>
+
+struct procdata {
+	struct fuse *f;
+	struct fuse_chan *prevch;
+	struct fuse_session *prevse;
+	fuse_processor_t proc;
+	void *data;
+};
+
+static void mt_session_proc(void *data, const char *buf, size_t len,
+			    struct fuse_chan *ch)
+{
+	struct procdata *pd = (struct procdata *) data;
+	struct fuse_cmd *cmd = *(struct fuse_cmd **) buf;
+
+	(void) len;
+	(void) ch;
+	pd->proc(pd->f, cmd, pd->data);
+}
+
+static void mt_session_exit(void *data, int val)
+{
+	struct procdata *pd = (struct procdata *) data;
+	if (val)
+		fuse_session_exit(pd->prevse);
+	else
+		fuse_session_reset(pd->prevse);
+}
+
+static int mt_session_exited(void *data)
+{
+	struct procdata *pd = (struct procdata *) data;
+	return fuse_session_exited(pd->prevse);
+}
+
+static int mt_chan_receive(struct fuse_chan **chp, char *buf, size_t size)
+{
+	struct fuse_cmd *cmd;
+	struct procdata *pd = (struct procdata *) fuse_chan_data(*chp);
+
+	assert(size >= sizeof(cmd));
+
+	cmd = fuse_read_cmd(pd->f);
+	if (cmd == NULL)
+		return 0;
+
+	*(struct fuse_cmd **) buf = cmd;
+
+	return sizeof(cmd);
+}
+
+int fuse_loop_mt_proc(struct fuse *f, fuse_processor_t proc, void *data)
+{
+	int res;
+	struct procdata pd;
+	struct fuse_session *prevse = fuse_get_session(f);
+	struct fuse_session *se;
+	struct fuse_chan *prevch = fuse_session_next_chan(prevse, NULL);
+	struct fuse_chan *ch;
+	struct fuse_session_ops sop = {
+		.exit = mt_session_exit,
+		.exited = mt_session_exited,
+		.process = mt_session_proc,
+	};
+	struct fuse_chan_ops cop = {
+		.receive = mt_chan_receive,
+	};
+
+	pd.f = f;
+	pd.prevch = prevch;
+	pd.prevse = prevse;
+	pd.proc = proc;
+	pd.data = data;
+
+	se = fuse_session_new(&sop, &pd);
+	if (se == NULL)
+		return -1;
+
+	ch = fuse_chan_new(&cop, fuse_chan_fd(prevch),
+			   sizeof(struct fuse_cmd *), &pd);
+	if (ch == NULL) {
+		fuse_session_destroy(se);
+		return -1;
+	}
+	fuse_session_add_chan(se, ch);
+	res = fuse_session_loop_mt(se);
+	fuse_session_destroy(se);
+	return res;
+}
+
+int fuse_loop_mt(struct fuse *f)
+{
+	if (f == NULL)
+		return -1;
+
+	int res = fuse_start_cleanup_thread(f);
+	if (res)
+		return -1;
+
+	res = fuse_session_loop_mt(fuse_get_session(f));
+	fuse_stop_cleanup_thread(f);
+	return res;
+}
+
+FUSE_SYMVER(".symver fuse_loop_mt_proc,__fuse_loop_mt@");
diff --git a/external/fuse/fuse_opt.c b/external/fuse/fuse_opt.c
new file mode 100755
index 0000000000..a2118cedc3
--- /dev/null
+++ b/external/fuse/fuse_opt.c
@@ -0,0 +1,426 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB
+*/
+
+#include "fuse_opt.h"
+#include "fuse_misc.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+struct fuse_opt_context {
+	void *data;
+	const struct fuse_opt *opt;
+	fuse_opt_proc_t proc;
+	int argctr;
+	int argc;
+	char **argv;
+	struct fuse_args outargs;
+	char *opts;
+	int nonopt;
+};
+
+void fuse_opt_free_args(struct fuse_args *args)
+{
+	if (args) {
+		if (args->argv && args->allocated) {
+			int i;
+			for (i = 0; i < args->argc; i++)
+				free(args->argv[i]);
+			free(args->argv);
+		}
+		args->argc = 0;
+		args->argv = NULL;
+		args->allocated = 0;
+	}
+}
+
+static int alloc_failed(void)
+{
+	fprintf(stderr, "fuse: memory allocation failed\n");
+	return -1;
+}
+
+int fuse_opt_add_arg(struct fuse_args *args, const char *arg)
+{
+	char **newargv;
+	char *newarg;
+
+	assert(!args->argv || args->allocated);
+
+	newarg = strdup(arg);
+	if (!newarg)
+		return alloc_failed();
+
+	newargv = realloc(args->argv, (args->argc + 2) * sizeof(char *));
+	if (!newargv) {
+		free(newarg);
+		return alloc_failed();
+	}
+
+	args->argv = newargv;
+	args->allocated = 1;
+	args->argv[args->argc++] = newarg;
+	args->argv[args->argc] = NULL;
+	return 0;
+}
+
+static int fuse_opt_insert_arg_common(struct fuse_args *args, int pos,
+				      const char *arg)
+{
+	assert(pos <= args->argc);
+	if (fuse_opt_add_arg(args, arg) == -1)
+		return -1;
+
+	if (pos != args->argc - 1) {
+		char *newarg = args->argv[args->argc - 1];
+		memmove(&args->argv[pos + 1], &args->argv[pos],
+			sizeof(char *) * (args->argc - pos - 1));
+		args->argv[pos] = newarg;
+	}
+	return 0;
+}
+
+int fuse_opt_insert_arg(struct fuse_args *args, int pos, const char *arg)
+{
+	return fuse_opt_insert_arg_common(args, pos, arg);
+}
+
+int fuse_opt_insert_arg_compat(struct fuse_args *args, int pos,
+			       const char *arg);
+int fuse_opt_insert_arg_compat(struct fuse_args *args, int pos, const char *arg)
+{
+	return fuse_opt_insert_arg_common(args, pos, arg);
+}
+
+static int next_arg(struct fuse_opt_context *ctx, const char *opt)
+{
+	if (ctx->argctr + 1 >= ctx->argc) {
+		fprintf(stderr, "fuse: missing argument after `%s'\n", opt);
+		return -1;
+	}
+	ctx->argctr++;
+	return 0;
+}
+
+static int add_arg(struct fuse_opt_context *ctx, const char *arg)
+{
+	return fuse_opt_add_arg(&ctx->outargs, arg);
+}
+
+static int add_opt_common(char **opts, const char *opt, int esc)
+{
+	unsigned oldlen = *opts ? strlen(*opts) : 0;
+	char *d = realloc(*opts, oldlen + 1 + strlen(opt) * 2 + 1);
+
+	if (!d)
+		return alloc_failed();
+
+	*opts = d;
+	if (oldlen) {
+		d += oldlen;
+		*d++ = ',';
+	}
+
+	for (; *opt; opt++) {
+		if (esc && (*opt == ',' || *opt == '\\'))
+			*d++ = '\\';
+		*d++ = *opt;
+	}
+	*d = '\0';
+
+	return 0;
+}
+
+int fuse_opt_add_opt(char **opts, const char *opt)
+{
+	return add_opt_common(opts, opt, 0);
+}
+
+int fuse_opt_add_opt_escaped(char **opts, const char *opt)
+{
+	return add_opt_common(opts, opt, 1);
+}
+
+static int add_opt(struct fuse_opt_context *ctx, const char *opt)
+{
+	return add_opt_common(&ctx->opts, opt, 1);
+}
+
+static int call_proc(struct fuse_opt_context *ctx, const char *arg, int key,
+		     int iso)
+{
+	if (key == FUSE_OPT_KEY_DISCARD)
+		return 0;
+
+	if (key != FUSE_OPT_KEY_KEEP && ctx->proc) {
+		int res = ctx->proc(ctx->data, arg, key, &ctx->outargs);
+		if (res == -1 || !res)
+			return res;
+	}
+	if (iso)
+		return add_opt(ctx, arg);
+	else
+		return add_arg(ctx, arg);
+}
+
+static int match_template(const char *t, const char *arg, unsigned *sepp)
+{
+	int arglen = strlen(arg);
+	const char *sep = strchr(t, '=');
+	sep = sep ? sep : strchr(t, ' ');
+	if (sep && (!sep[1] || sep[1] == '%')) {
+		int tlen = sep - t;
+		if (sep[0] == '=')
+			tlen ++;
+		if (arglen >= tlen && strncmp(arg, t, tlen) == 0) {
+			*sepp = sep - t;
+			return 1;
+		}
+	}
+	if (strcmp(t, arg) == 0) {
+		*sepp = 0;
+		return 1;
+	}
+	return 0;
+}
+
+static const struct fuse_opt *find_opt(const struct fuse_opt *opt,
+				       const char *arg, unsigned *sepp)
+{
+	for (; opt && opt->templ; opt++)
+		if (match_template(opt->templ, arg, sepp))
+			return opt;
+	return NULL;
+}
+
+int fuse_opt_match(const struct fuse_opt *opts, const char *opt)
+{
+	unsigned dummy;
+	return find_opt(opts, opt, &dummy) ? 1 : 0;
+}
+
+static int process_opt_param(void *var, const char *format, const char *param,
+			     const char *arg)
+{
+	assert(format[0] == '%');
+	if (format[1] == 's') {
+		char *copy = strdup(param);
+		if (!copy)
+			return alloc_failed();
+
+		*(char **) var = copy;
+	} else {
+		if (sscanf(param, format, var) != 1) {
+			fprintf(stderr, "fuse: invalid parameter in option `%s'\n", arg);
+			return -1;
+		}
+	}
+	return 0;
+}
+
+static int process_opt(struct fuse_opt_context *ctx,
+		       const struct fuse_opt *opt, unsigned sep,
+		       const char *arg, int iso)
+{
+	if (opt->offset == -1U) {
+		if (call_proc(ctx, arg, opt->value, iso) == -1)
+			return -1;
+	} else {
+		void *var = ctx->data + opt->offset;
+		if (sep && opt->templ[sep + 1]) {
+			const char *param = arg + sep;
+			if (opt->templ[sep] == '=')
+				param ++;
+			if (process_opt_param(var, opt->templ + sep + 1,
+					      param, arg) == -1)
+				return -1;
+		} else
+			*(int *)var = opt->value;
+	}
+	return 0;
+}
+
+static int process_opt_sep_arg(struct fuse_opt_context *ctx,
+			       const struct fuse_opt *opt, unsigned sep,
+			       const char *arg, int iso)
+{
+	int res;
+	char *newarg;
+	char *param;
+
+	if (next_arg(ctx, arg) == -1)
+		return -1;
+
+	param = ctx->argv[ctx->argctr];
+	newarg = malloc(sep + strlen(param) + 1);
+	if (!newarg)
+		return alloc_failed();
+
+	memcpy(newarg, arg, sep);
+	strcpy(newarg + sep, param);
+	res = process_opt(ctx, opt, sep, newarg, iso);
+	free(newarg);
+
+	return res;
+}
+
+static int process_gopt(struct fuse_opt_context *ctx, const char *arg, int iso)
+{
+	unsigned sep;
+	const struct fuse_opt *opt = find_opt(ctx->opt, arg, &sep);
+	if (opt) {
+		for (; opt; opt = find_opt(opt + 1, arg, &sep)) {
+			int res;
+			if (sep && opt->templ[sep] == ' ' && !arg[sep])
+				res = process_opt_sep_arg(ctx, opt, sep, arg,
+							  iso);
+			else
+				res = process_opt(ctx, opt, sep, arg, iso);
+			if (res == -1)
+				return -1;
+		}
+		return 0;
+	} else
+		return call_proc(ctx, arg, FUSE_OPT_KEY_OPT, iso);
+}
+
+static int process_real_option_group(struct fuse_opt_context *ctx, char *opts)
+{
+	char *s = opts;
+	char *d = s;
+	int end = 0;
+
+	while (!end) {
+		if (*s == '\0')
+			end = 1;
+		if (*s == ',' || end) {
+			int res;
+
+			*d = '\0';
+			res = process_gopt(ctx, opts, 1);
+			if (res == -1)
+				return -1;
+			d = opts;
+		} else {
+			if (s[0] == '\\' && s[1] != '\0') {
+				s++;
+				if (s[0] >= '0' && s[0] <= '3' &&
+				    s[1] >= '0' && s[1] <= '7' &&
+				    s[2] >= '0' && s[2] <= '7') {
+					*d++ = (s[0] - '0') * 0100 +
+						(s[1] - '0') * 0010 +
+						(s[2] - '0');
+					s += 2;
+				} else {
+					*d++ = *s;
+				}
+			} else {
+				*d++ = *s;
+			}
+		}
+		s++;
+	}
+
+	return 0;
+}
+
+static int process_option_group(struct fuse_opt_context *ctx, const char *opts)
+{
+	int res;
+	char *copy = strdup(opts);
+
+	if (!copy) {
+		fprintf(stderr, "fuse: memory allocation failed\n");
+		return -1;
+	}
+	res = process_real_option_group(ctx, copy);
+	free(copy);
+	return res;
+}
+
+static int process_one(struct fuse_opt_context *ctx, const char *arg)
+{
+	if (ctx->nonopt || arg[0] != '-')
+		return call_proc(ctx, arg, FUSE_OPT_KEY_NONOPT, 0);
+	else if (arg[1] == 'o') {
+		if (arg[2])
+			return process_option_group(ctx, arg + 2);
+		else {
+			if (next_arg(ctx, arg) == -1)
+				return -1;
+
+			return process_option_group(ctx,
+						    ctx->argv[ctx->argctr]);
+		}
+	} else if (arg[1] == '-' && !arg[2]) {
+		if (add_arg(ctx, arg) == -1)
+			return -1;
+		ctx->nonopt = ctx->outargs.argc;
+		return 0;
+	} else
+		return process_gopt(ctx, arg, 0);
+}
+
+static int opt_parse(struct fuse_opt_context *ctx)
+{
+	if (ctx->argc) {
+		if (add_arg(ctx, ctx->argv[0]) == -1)
+			return -1;
+	}
+
+	for (ctx->argctr = 1; ctx->argctr < ctx->argc; ctx->argctr++)
+		if (process_one(ctx, ctx->argv[ctx->argctr]) == -1)
+			return -1;
+
+	if (ctx->opts) {
+		if (fuse_opt_insert_arg(&ctx->outargs, 1, "-o") == -1 ||
+		    fuse_opt_insert_arg(&ctx->outargs, 2, ctx->opts) == -1)
+			return -1;
+	}
+
+	/* If option separator ("--") is the last argument, remove it */
+	if (ctx->nonopt && ctx->nonopt == ctx->outargs.argc &&
+	    strcmp(ctx->outargs.argv[ctx->outargs.argc - 1], "--") == 0) {
+		free(ctx->outargs.argv[ctx->outargs.argc - 1]);
+		ctx->outargs.argv[--ctx->outargs.argc] = NULL;
+	}
+
+	return 0;
+}
+
+int fuse_opt_parse(struct fuse_args *args, void *data,
+		   const struct fuse_opt opts[], fuse_opt_proc_t proc)
+{
+	int res;
+	struct fuse_opt_context ctx = {
+		.data = data,
+		.opt = opts,
+		.proc = proc,
+	};
+
+	if (!args || !args->argv || !args->argc)
+		return 0;
+
+	ctx.argc = args->argc;
+	ctx.argv = args->argv;
+
+	res = opt_parse(&ctx);
+	if (res != -1) {
+		struct fuse_args tmp = *args;
+		*args = ctx.outargs;
+		ctx.outargs = tmp;
+	}
+	free(ctx.opts);
+	fuse_opt_free_args(&ctx.outargs);
+	return res;
+}
+
+/* This symbol version was mistakenly added to the version script */
+FUSE_SYMVER(".symver fuse_opt_insert_arg_compat,fuse_opt_insert_arg@FUSE_2.5");
diff --git a/external/fuse/fuse_session.c b/external/fuse/fuse_session.c
new file mode 100755
index 0000000000..c55f250747
--- /dev/null
+++ b/external/fuse/fuse_session.c
@@ -0,0 +1,233 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB
+*/
+
+#include "fuse_i.h"
+#include "fuse_misc.h"
+#include "fuse_common_compat.h"
+#include "fuse_lowlevel_compat.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <errno.h>
+
+struct fuse_chan {
+	struct fuse_chan_ops op;
+
+	struct fuse_session *se;
+
+	int fd;
+
+	size_t bufsize;
+
+	void *data;
+
+	int compat;
+};
+
+struct fuse_session *fuse_session_new(struct fuse_session_ops *op, void *data)
+{
+	struct fuse_session *se = (struct fuse_session *) malloc(sizeof(*se));
+	if (se == NULL) {
+		fprintf(stderr, "fuse: failed to allocate session\n");
+		return NULL;
+	}
+
+	memset(se, 0, sizeof(*se));
+	se->op = *op;
+	se->data = data;
+
+	return se;
+}
+
+void fuse_session_add_chan(struct fuse_session *se, struct fuse_chan *ch)
+{
+	assert(se->ch == NULL);
+	assert(ch->se == NULL);
+	se->ch = ch;
+	ch->se = se;
+}
+
+void fuse_session_remove_chan(struct fuse_chan *ch)
+{
+	struct fuse_session *se = ch->se;
+	if (se) {
+		assert(se->ch == ch);
+		se->ch = NULL;
+		ch->se = NULL;
+	}
+}
+
+struct fuse_chan *fuse_session_next_chan(struct fuse_session *se,
+					 struct fuse_chan *ch)
+{
+	assert(ch == NULL || ch == se->ch);
+	if (ch == NULL)
+		return se->ch;
+	else
+		return NULL;
+}
+
+void fuse_session_process(struct fuse_session *se, const char *buf, size_t len,
+			  struct fuse_chan *ch)
+{
+	se->op.process(se->data, buf, len, ch);
+}
+
+void fuse_session_process_buf(struct fuse_session *se,
+			      const struct fuse_buf *buf, struct fuse_chan *ch)
+{
+	if (se->process_buf) {
+		se->process_buf(se->data, buf, ch);
+	} else {
+		assert(!(buf->flags & FUSE_BUF_IS_FD));
+		fuse_session_process(se->data, buf->mem, buf->size, ch);
+	}
+}
+
+int fuse_session_receive_buf(struct fuse_session *se, struct fuse_buf *buf,
+			     struct fuse_chan **chp)
+{
+	int res;
+
+	if (se->receive_buf) {
+		res = se->receive_buf(se, buf, chp);
+	} else {
+		res = fuse_chan_recv(chp, buf->mem, buf->size);
+		if (res > 0)
+			buf->size = res;
+	}
+
+	return res;
+}
+
+
+void fuse_session_destroy(struct fuse_session *se)
+{
+	if (se->op.destroy)
+		se->op.destroy(se->data);
+	if (se->ch != NULL)
+		fuse_chan_destroy(se->ch);
+	free(se);
+}
+
+void fuse_session_exit(struct fuse_session *se)
+{
+	if (se->op.exit)
+		se->op.exit(se->data, 1);
+	se->exited = 1;
+}
+
+void fuse_session_reset(struct fuse_session *se)
+{
+	if (se->op.exit)
+		se->op.exit(se->data, 0);
+	se->exited = 0;
+}
+
+int fuse_session_exited(struct fuse_session *se)
+{
+	if (se->op.exited)
+		return se->op.exited(se->data);
+	else
+		return se->exited;
+}
+
+void *fuse_session_data(struct fuse_session *se)
+{
+	return se->data;
+}
+
+static struct fuse_chan *fuse_chan_new_common(struct fuse_chan_ops *op, int fd,
+					      size_t bufsize, void *data,
+					      int compat)
+{
+	struct fuse_chan *ch = (struct fuse_chan *) malloc(sizeof(*ch));
+	if (ch == NULL) {
+		fprintf(stderr, "fuse: failed to allocate channel\n");
+		return NULL;
+	}
+
+	memset(ch, 0, sizeof(*ch));
+	ch->op = *op;
+	ch->fd = fd;
+	ch->bufsize = bufsize;
+	ch->data = data;
+	ch->compat = compat;
+
+	return ch;
+}
+
+struct fuse_chan *fuse_chan_new(struct fuse_chan_ops *op, int fd,
+				size_t bufsize, void *data)
+{
+	return fuse_chan_new_common(op, fd, bufsize, data, 0);
+}
+
+struct fuse_chan *fuse_chan_new_compat24(struct fuse_chan_ops_compat24 *op,
+					 int fd, size_t bufsize, void *data)
+{
+	return fuse_chan_new_common((struct fuse_chan_ops *) op, fd, bufsize,
+				    data, 24);
+}
+
+int fuse_chan_fd(struct fuse_chan *ch)
+{
+	return ch->fd;
+}
+
+size_t fuse_chan_bufsize(struct fuse_chan *ch)
+{
+	return ch->bufsize;
+}
+
+void *fuse_chan_data(struct fuse_chan *ch)
+{
+	return ch->data;
+}
+
+struct fuse_session *fuse_chan_session(struct fuse_chan *ch)
+{
+	return ch->se;
+}
+
+int fuse_chan_recv(struct fuse_chan **chp, char *buf, size_t size)
+{
+	struct fuse_chan *ch = *chp;
+	if (ch->compat)
+		return ((struct fuse_chan_ops_compat24 *) &ch->op)
+			->receive(ch, buf, size);
+	else
+		return ch->op.receive(chp, buf, size);
+}
+
+int fuse_chan_receive(struct fuse_chan *ch, char *buf, size_t size)
+{
+	int res;
+
+	res = fuse_chan_recv(&ch, buf, size);
+	return res >= 0 ? res : (res != -EINTR && res != -EAGAIN) ? -1 : 0;
+}
+
+int fuse_chan_send(struct fuse_chan *ch, const struct iovec iov[], size_t count)
+{
+	return ch->op.send(ch, iov, count);
+}
+
+void fuse_chan_destroy(struct fuse_chan *ch)
+{
+	fuse_session_remove_chan(ch);
+	if (ch->op.destroy)
+		ch->op.destroy(ch);
+	free(ch);
+}
+
+#ifndef __FreeBSD__
+FUSE_SYMVER(".symver fuse_chan_new_compat24,fuse_chan_new@FUSE_2.4");
+#endif
diff --git a/external/fuse/fuse_signals.c b/external/fuse/fuse_signals.c
new file mode 100755
index 0000000000..88ac39e187
--- /dev/null
+++ b/external/fuse/fuse_signals.c
@@ -0,0 +1,72 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB
+*/
+
+#include "fuse_lowlevel.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <signal.h>
+
+static struct fuse_session *fuse_instance;
+
+static void exit_handler(int sig)
+{
+	(void) sig;
+	if (fuse_instance)
+		fuse_session_exit(fuse_instance);
+}
+
+static int set_one_signal_handler(int sig, void (*handler)(int))
+{
+	struct sigaction sa;
+	struct sigaction old_sa;
+
+	memset(&sa, 0, sizeof(struct sigaction));
+	sa.sa_handler = handler;
+	sigemptyset(&(sa.sa_mask));
+	sa.sa_flags = 0;
+
+	if (sigaction(sig, NULL, &old_sa) == -1) {
+		perror("fuse: cannot get old signal handler");
+		return -1;
+	}
+
+	if (old_sa.sa_handler == SIG_DFL &&
+	    sigaction(sig, &sa, NULL) == -1) {
+		perror("fuse: cannot set signal handler");
+		return -1;
+	}
+	return 0;
+}
+
+int fuse_set_signal_handlers(struct fuse_session *se)
+{
+	if (set_one_signal_handler(SIGHUP, exit_handler) == -1 ||
+	    set_one_signal_handler(SIGINT, exit_handler) == -1 ||
+	    set_one_signal_handler(SIGTERM, exit_handler) == -1 ||
+	    set_one_signal_handler(SIGPIPE, SIG_IGN) == -1)
+		return -1;
+
+	fuse_instance = se;
+	return 0;
+}
+
+void fuse_remove_signal_handlers(struct fuse_session *se)
+{
+	if (fuse_instance != se)
+		fprintf(stderr,
+			"fuse: fuse_remove_signal_handlers: unknown session\n");
+	else
+		fuse_instance = NULL;
+
+	set_one_signal_handler(SIGHUP, SIG_DFL);
+	set_one_signal_handler(SIGINT, SIG_DFL);
+	set_one_signal_handler(SIGTERM, SIG_DFL);
+	set_one_signal_handler(SIGPIPE, SIG_DFL);
+}
+
diff --git a/external/fuse/fusexmp.c b/external/fuse/fusexmp.c
new file mode 100755
index 0000000000..d4edbc9ae4
--- /dev/null
+++ b/external/fuse/fusexmp.c
@@ -0,0 +1,385 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU GPL.
+  See the file COPYING.
+
+  gcc -Wall `pkg-config fuse --cflags --libs` fusexmp.c -o fusexmp
+*/
+
+#define FUSE_USE_VERSION 26
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#ifdef linux
+/* For pread()/pwrite() */
+#define _XOPEN_SOURCE 500
+#endif
+
+#include <fuse.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <errno.h>
+#include <sys/time.h>
+#ifdef HAVE_SETXATTR
+#include <sys/xattr.h>
+#endif
+
+static int xmp_getattr(const char *path, struct stat *stbuf)
+{
+	int res;
+
+	res = lstat(path, stbuf);
+	if (res == -1)
+		return -errno;
+
+	return 0;
+}
+
+static int xmp_access(const char *path, int mask)
+{
+	int res;
+
+	res = access(path, mask);
+	if (res == -1)
+		return -errno;
+
+	return 0;
+}
+
+static int xmp_readlink(const char *path, char *buf, size_t size)
+{
+	int res;
+
+	res = readlink(path, buf, size - 1);
+	if (res == -1)
+		return -errno;
+
+	buf[res] = '\0';
+	return 0;
+}
+
+
+static int xmp_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
+		       off64_t offset, struct fuse_file_info *fi)
+{
+	DIR *dp;
+	struct dirent *de;
+
+	(void) offset;
+	(void) fi;
+
+	dp = opendir(path);
+	if (dp == NULL)
+		return -errno;
+
+	while ((de = readdir(dp)) != NULL) {
+		struct stat st;
+		memset(&st, 0, sizeof(st));
+		st.st_ino = de->d_ino;
+		st.st_mode = de->d_type << 12;
+		if (filler(buf, de->d_name, &st, 0))
+			break;
+	}
+
+	closedir(dp);
+	return 0;
+}
+
+static int xmp_mknod(const char *path, mode_t mode, dev_t rdev)
+{
+	int res;
+
+	/* On Linux this could just be 'mknod(path, mode, rdev)' but this
+	   is more portable */
+	if (S_ISREG(mode)) {
+		res = open(path, O_CREAT | O_EXCL | O_WRONLY, mode);
+		if (res >= 0)
+			res = close(res);
+	} else if (S_ISFIFO(mode))
+		res = mkfifo(path, mode);
+	else
+		res = mknod(path, mode, rdev);
+	if (res == -1)
+		return -errno;
+
+	return 0;
+}
+
+static int xmp_mkdir(const char *path, mode_t mode)
+{
+	int res;
+
+	res = mkdir(path, mode);
+	if (res == -1)
+		return -errno;
+
+	return 0;
+}
+
+static int xmp_unlink(const char *path)
+{
+	int res;
+
+	res = unlink(path);
+	if (res == -1)
+		return -errno;
+
+	return 0;
+}
+
+static int xmp_rmdir(const char *path)
+{
+	int res;
+
+	res = rmdir(path);
+	if (res == -1)
+		return -errno;
+
+	return 0;
+}
+
+static int xmp_symlink(const char *from, const char *to)
+{
+	int res;
+
+	res = symlink(from, to);
+	if (res == -1)
+		return -errno;
+
+	return 0;
+}
+
+static int xmp_rename(const char *from, const char *to)
+{
+	int res;
+
+	res = rename(from, to);
+	if (res == -1)
+		return -errno;
+
+	return 0;
+}
+
+static int xmp_link(const char *from, const char *to)
+{
+	int res;
+
+	res = link(from, to);
+	if (res == -1)
+		return -errno;
+
+	return 0;
+}
+
+static int xmp_chmod(const char *path, mode_t mode)
+{
+	int res;
+
+	res = chmod(path, mode);
+	if (res == -1)
+		return -errno;
+
+	return 0;
+}
+
+static int xmp_chown(const char *path, uid_t uid, gid_t gid)
+{
+	int res;
+
+	res = lchown(path, uid, gid);
+	if (res == -1)
+		return -errno;
+
+	return 0;
+}
+
+static int xmp_truncate(const char *path, off64_t size)
+{
+	int res;
+
+	res = truncate(path, size);
+	if (res == -1)
+		return -errno;
+
+	return 0;
+}
+
+static int xmp_utimens(const char *path, const struct timespec ts[2])
+{
+	int res;
+	struct timeval tv[2];
+
+	tv[0].tv_sec = ts[0].tv_sec;
+	tv[0].tv_usec = ts[0].tv_nsec / 1000;
+	tv[1].tv_sec = ts[1].tv_sec;
+	tv[1].tv_usec = ts[1].tv_nsec / 1000;
+
+	res = utimes(path, tv);
+	if (res == -1)
+		return -errno;
+
+	return 0;
+}
+
+static int xmp_open(const char *path, struct fuse_file_info *fi)
+{
+	int res;
+
+	res = open(path, fi->flags);
+	if (res == -1)
+		return -errno;
+
+	close(res);
+	return 0;
+}
+
+static int xmp_read(const char *path, char *buf, size_t size, off64_t offset,
+		    struct fuse_file_info *fi)
+{
+	int fd;
+	int res;
+
+	(void) fi;
+	fd = open(path, O_RDONLY);
+	if (fd == -1)
+		return -errno;
+
+	res = pread(fd, buf, size, offset);
+	if (res == -1)
+		res = -errno;
+
+	close(fd);
+	return res;
+}
+
+static int xmp_write(const char *path, const char *buf, size_t size,
+		     off64_t offset, struct fuse_file_info *fi)
+{
+	int fd;
+	int res;
+
+	(void) fi;
+	fd = open(path, O_WRONLY);
+	if (fd == -1)
+		return -errno;
+
+	res = pwrite(fd, buf, size, offset);
+	if (res == -1)
+		res = -errno;
+
+	close(fd);
+	return res;
+}
+
+static int xmp_statfs(const char *path, struct statvfs *stbuf)
+{
+	int res;
+
+	//res = statvfs(path, stbuf);
+	if (res == -1)
+		return -errno;
+
+	return 0;
+}
+
+static int xmp_release(const char *path, struct fuse_file_info *fi)
+{
+	/* Just a stub.	 This method is optional and can safely be left
+	   unimplemented */
+
+	(void) path;
+	(void) fi;
+	return 0;
+}
+
+static int xmp_fsync(const char *path, int isdatasync,
+		     struct fuse_file_info *fi)
+{
+	/* Just a stub.	 This method is optional and can safely be left
+	   unimplemented */
+
+	(void) path;
+	(void) isdatasync;
+	(void) fi;
+	return 0;
+}
+
+#ifdef HAVE_SETXATTR
+/* xattr operations are optional and can safely be left unimplemented */
+static int xmp_setxattr(const char *path, const char *name, const char *value,
+			size_t size, int flags)
+{
+	int res = lsetxattr(path, name, value, size, flags);
+	if (res == -1)
+		return -errno;
+	return 0;
+}
+
+static int xmp_getxattr(const char *path, const char *name, char *value,
+			size_t size)
+{
+	int res = lgetxattr(path, name, value, size);
+	if (res == -1)
+		return -errno;
+	return res;
+}
+
+static int xmp_listxattr(const char *path, char *list, size_t size)
+{
+	int res = llistxattr(path, list, size);
+	if (res == -1)
+		return -errno;
+	return res;
+}
+
+static int xmp_removexattr(const char *path, const char *name)
+{
+	int res = lremovexattr(path, name);
+	if (res == -1)
+		return -errno;
+	return 0;
+}
+#endif /* HAVE_SETXATTR */
+
+static struct fuse_operations xmp_oper = {
+	.getattr	= xmp_getattr,
+	.access		= xmp_access,
+	.readlink	= xmp_readlink,
+	.readdir	= xmp_readdir,
+	.mknod		= xmp_mknod,
+	.mkdir		= xmp_mkdir,
+	.symlink	= xmp_symlink,
+	.unlink		= xmp_unlink,
+	.rmdir		= xmp_rmdir,
+	.rename		= xmp_rename,
+	.link		= xmp_link,
+	.chmod		= xmp_chmod,
+	.chown		= xmp_chown,
+	.truncate	= xmp_truncate,
+	.utimens	= xmp_utimens,
+	.open		= xmp_open,
+	.read		= xmp_read,
+	.write		= xmp_write,
+	.statfs		= xmp_statfs,
+	.release	= xmp_release,
+	.fsync		= xmp_fsync,
+#ifdef HAVE_SETXATTR
+	.setxattr	= xmp_setxattr,
+	.getxattr	= xmp_getxattr,
+	.listxattr	= xmp_listxattr,
+	.removexattr	= xmp_removexattr,
+#endif
+};
+
+int main(int argc, char *argv[])
+{
+	umask(0);
+	return fuse_main(argc, argv, &xmp_oper, NULL);
+}
diff --git a/external/fuse/helper.c b/external/fuse/helper.c
new file mode 100755
index 0000000000..ace19dd709
--- /dev/null
+++ b/external/fuse/helper.c
@@ -0,0 +1,478 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB.
+*/
+
+#include "config.h"
+#include "fuse_i.h"
+#include "fuse_misc.h"
+#include "fuse_opt.h"
+#include "fuse_lowlevel.h"
+#include "fuse_common_compat.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <string.h>
+#include <limits.h>
+#include <errno.h>
+#include <sys/param.h>
+
+enum  {
+	KEY_HELP,
+	KEY_HELP_NOHEADER,
+	KEY_VERSION,
+};
+
+struct helper_opts {
+	int singlethread;
+	int foreground;
+	int nodefault_subtype;
+	char *mountpoint;
+};
+
+#define FUSE_HELPER_OPT(t, p) { t, offsetof(struct helper_opts, p), 1 }
+
+static const struct fuse_opt fuse_helper_opts[] = {
+	FUSE_HELPER_OPT("-d",		foreground),
+	FUSE_HELPER_OPT("debug",	foreground),
+	FUSE_HELPER_OPT("-f",		foreground),
+	FUSE_HELPER_OPT("-s",		singlethread),
+	FUSE_HELPER_OPT("fsname=",	nodefault_subtype),
+	FUSE_HELPER_OPT("subtype=",	nodefault_subtype),
+
+	FUSE_OPT_KEY("-h",		KEY_HELP),
+	FUSE_OPT_KEY("--help",		KEY_HELP),
+	FUSE_OPT_KEY("-ho",		KEY_HELP_NOHEADER),
+	FUSE_OPT_KEY("-V",		KEY_VERSION),
+	FUSE_OPT_KEY("--version",	KEY_VERSION),
+	FUSE_OPT_KEY("-d",		FUSE_OPT_KEY_KEEP),
+	FUSE_OPT_KEY("debug",		FUSE_OPT_KEY_KEEP),
+	FUSE_OPT_KEY("fsname=",		FUSE_OPT_KEY_KEEP),
+	FUSE_OPT_KEY("subtype=",	FUSE_OPT_KEY_KEEP),
+	FUSE_OPT_END
+};
+
+static void usage(const char *progname)
+{
+	fprintf(stderr,
+		"usage: %s mountpoint [options]\n\n", progname);
+	fprintf(stderr,
+		"general options:\n"
+		"    -o opt,[opt...]        mount options\n"
+		"    -h   --help            print help\n"
+		"    -V   --version         print version\n"
+		"\n");
+}
+
+static void helper_help(void)
+{
+	fprintf(stderr,
+		"FUSE options:\n"
+		"    -d   -o debug          enable debug output (implies -f)\n"
+		"    -f                     foreground operation\n"
+		"    -s                     disable multi-threaded operation\n"
+		"\n"
+		);
+}
+
+static void helper_version(void)
+{
+	fprintf(stderr, "FUSE library version: %s\n", PACKAGE_VERSION);
+}
+
+static int fuse_helper_opt_proc(void *data, const char *arg, int key,
+				struct fuse_args *outargs)
+{
+	struct helper_opts *hopts = data;
+
+	switch (key) {
+	case KEY_HELP:
+		usage(outargs->argv[0]);
+		/* fall through */
+
+	case KEY_HELP_NOHEADER:
+		helper_help();
+		return fuse_opt_add_arg(outargs, "-h");
+
+	case KEY_VERSION:
+		helper_version();
+		return 1;
+
+	case FUSE_OPT_KEY_NONOPT:
+		if (!hopts->mountpoint) {
+			char mountpoint[PATH_MAX];
+			if (realpath(arg, mountpoint) == NULL) {
+				fprintf(stderr,
+					"fuse: bad mount point `%s': %s\n",
+					arg, strerror(errno));
+				return -1;
+			}
+			return fuse_opt_add_opt(&hopts->mountpoint, mountpoint);
+		} else {
+			fprintf(stderr, "fuse: invalid argument `%s'\n", arg);
+			return -1;
+		}
+
+	default:
+		return 1;
+	}
+}
+
+static int add_default_subtype(const char *progname, struct fuse_args *args)
+{
+	int res;
+	char *subtype_opt;
+	const char *basename = strrchr(progname, '/');
+	if (basename == NULL)
+		basename = progname;
+	else if (basename[1] != '\0')
+		basename++;
+
+	subtype_opt = (char *) malloc(strlen(basename) + 64);
+	if (subtype_opt == NULL) {
+		fprintf(stderr, "fuse: memory allocation failed\n");
+		return -1;
+	}
+	sprintf(subtype_opt, "-osubtype=%s", basename);
+	res = fuse_opt_add_arg(args, subtype_opt);
+	free(subtype_opt);
+	return res;
+}
+
+int fuse_parse_cmdline(struct fuse_args *args, char **mountpoint,
+		       int *multithreaded, int *foreground)
+{
+	int res;
+	struct helper_opts hopts;
+
+	memset(&hopts, 0, sizeof(hopts));
+	res = fuse_opt_parse(args, &hopts, fuse_helper_opts,
+			     fuse_helper_opt_proc);
+	if (res == -1)
+		return -1;
+
+	if (!hopts.nodefault_subtype) {
+		res = add_default_subtype(args->argv[0], args);
+		if (res == -1)
+			goto err;
+	}
+	if (mountpoint)
+		*mountpoint = hopts.mountpoint;
+	else
+		free(hopts.mountpoint);
+
+	if (multithreaded)
+		*multithreaded = !hopts.singlethread;
+	if (foreground)
+		*foreground = hopts.foreground;
+	return 0;
+
+err:
+	free(hopts.mountpoint);
+	return -1;
+}
+
+int fuse_daemonize(int foreground)
+{
+	if (!foreground) {
+		int nullfd;
+
+		/*
+		 * demonize current process by forking it and killing the
+		 * parent.  This makes current process as a child of 'init'.
+		 */
+		switch(fork()) {
+		case -1:
+			perror("fuse_daemonize: fork");
+			return -1;
+		case 0:
+			break;
+		default:
+			_exit(0);
+		}
+
+		if (setsid() == -1) {
+			perror("fuse_daemonize: setsid");
+			return -1;
+		}
+
+		(void) chdir("/");
+
+		nullfd = open("/dev/null", O_RDWR, 0);
+		if (nullfd != -1) {
+			(void) dup2(nullfd, 0);
+			(void) dup2(nullfd, 1);
+			(void) dup2(nullfd, 2);
+			if (nullfd > 2)
+				close(nullfd);
+		}
+	}
+	return 0;
+}
+
+static struct fuse_chan *fuse_mount_common(const char *mountpoint,
+					   struct fuse_args *args)
+{
+	struct fuse_chan *ch;
+	int fd;
+
+	/*
+	 * Make sure file descriptors 0, 1 and 2 are open, otherwise chaos
+	 * would ensue.
+	 */
+	do {
+		fd = open("/dev/null", O_RDWR);
+		if (fd > 2)
+			close(fd);
+	} while (fd >= 0 && fd <= 2);
+
+	fd = fuse_mount_compat25(mountpoint, args);
+	if (fd == -1)
+		return NULL;
+
+	ch = fuse_kern_chan_new(fd);
+	if (!ch)
+		fuse_kern_unmount(mountpoint, fd);
+
+	return ch;
+}
+
+struct fuse_chan *fuse_mount(const char *mountpoint, struct fuse_args *args)
+{
+	return fuse_mount_common(mountpoint, args);
+}
+
+static void fuse_unmount_common(const char *mountpoint, struct fuse_chan *ch)
+{
+	int fd = ch ? fuse_chan_fd(ch) : -1;
+	fuse_kern_unmount(mountpoint, fd);
+	if (ch)
+		fuse_chan_destroy(ch);
+}
+
+void fuse_unmount(const char *mountpoint, struct fuse_chan *ch)
+{
+	fuse_unmount_common(mountpoint, ch);
+}
+
+struct fuse *fuse_setup_common(int argc, char *argv[],
+			       const struct fuse_operations *op,
+			       size_t op_size,
+			       char **mountpoint,
+			       int *multithreaded,
+			       int *fd,
+			       void *user_data,
+			       int compat)
+{
+	struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
+	struct fuse_chan *ch;
+	struct fuse *fuse;
+	int foreground;
+	int res;
+
+	res = fuse_parse_cmdline(&args, mountpoint, multithreaded, &foreground);
+	if (res == -1)
+		return NULL;
+
+	ch = fuse_mount_common(*mountpoint, &args);
+	if (!ch) {
+		fuse_opt_free_args(&args);
+		goto err_free;
+	}
+
+	fuse = fuse_new_common(ch, &args, op, op_size, user_data, compat);
+	fuse_opt_free_args(&args);
+	if (fuse == NULL)
+		goto err_unmount;
+
+	res = fuse_daemonize(foreground);
+	if (res == -1)
+		goto err_unmount;
+
+	res = fuse_set_signal_handlers(fuse_get_session(fuse));
+	if (res == -1)
+		goto err_unmount;
+
+	if (fd)
+		*fd = fuse_chan_fd(ch);
+
+	return fuse;
+
+err_unmount:
+	fuse_unmount_common(*mountpoint, ch);
+	if (fuse)
+		fuse_destroy(fuse);
+err_free:
+	free(*mountpoint);
+	return NULL;
+}
+
+struct fuse *fuse_setup(int argc, char *argv[],
+			const struct fuse_operations *op, size_t op_size,
+			char **mountpoint, int *multithreaded, void *user_data)
+{
+	return fuse_setup_common(argc, argv, op, op_size, mountpoint,
+				 multithreaded, NULL, user_data, 0);
+}
+
+static void fuse_teardown_common(struct fuse *fuse, char *mountpoint)
+{
+	struct fuse_session *se = fuse_get_session(fuse);
+	struct fuse_chan *ch = fuse_session_next_chan(se, NULL);
+	fuse_remove_signal_handlers(se);
+	fuse_unmount_common(mountpoint, ch);
+	fuse_destroy(fuse);
+	free(mountpoint);
+}
+
+void fuse_teardown(struct fuse *fuse, char *mountpoint)
+{
+	fuse_teardown_common(fuse, mountpoint);
+}
+
+static int fuse_main_common(int argc, char *argv[],
+			    const struct fuse_operations *op, size_t op_size,
+			    void *user_data, int compat)
+{
+	struct fuse *fuse;
+	char *mountpoint;
+	int multithreaded;
+	int res;
+
+	fuse = fuse_setup_common(argc, argv, op, op_size, &mountpoint,
+				 &multithreaded, NULL, user_data, compat);
+	if (fuse == NULL)
+		return 1;
+
+	if (multithreaded)
+		res = fuse_loop_mt(fuse);
+	else
+		res = fuse_loop(fuse);
+
+	fuse_teardown_common(fuse, mountpoint);
+	if (res == -1)
+		return 1;
+
+	return 0;
+}
+
+int fuse_main_real(int argc, char *argv[], const struct fuse_operations *op,
+		   size_t op_size, void *user_data)
+{
+	return fuse_main_common(argc, argv, op, op_size, user_data, 0);
+}
+
+#undef fuse_main
+int fuse_main(void);
+int fuse_main(void)
+{
+	fprintf(stderr, "fuse_main(): This function does not exist\n");
+	return -1;
+}
+
+int fuse_version(void)
+{
+	return FUSE_VERSION;
+}
+
+#include "fuse_compat.h"
+
+#if !defined(__FreeBSD__) && !defined(__NetBSD__)
+
+struct fuse *fuse_setup_compat22(int argc, char *argv[],
+				 const struct fuse_operations_compat22 *op,
+				 size_t op_size, char **mountpoint,
+				 int *multithreaded, int *fd)
+{
+	return fuse_setup_common(argc, argv, (struct fuse_operations *) op,
+				 op_size, mountpoint, multithreaded, fd, NULL,
+				 22);
+}
+
+struct fuse *fuse_setup_compat2(int argc, char *argv[],
+				const struct fuse_operations_compat2 *op,
+				char **mountpoint, int *multithreaded,
+				int *fd)
+{
+	return fuse_setup_common(argc, argv, (struct fuse_operations *) op,
+				 sizeof(struct fuse_operations_compat2),
+				 mountpoint, multithreaded, fd, NULL, 21);
+}
+
+int fuse_main_real_compat22(int argc, char *argv[],
+			    const struct fuse_operations_compat22 *op,
+			    size_t op_size)
+{
+	return fuse_main_common(argc, argv, (struct fuse_operations *) op,
+				op_size, NULL, 22);
+}
+
+void fuse_main_compat1(int argc, char *argv[],
+		       const struct fuse_operations_compat1 *op)
+{
+	fuse_main_common(argc, argv, (struct fuse_operations *) op,
+			 sizeof(struct fuse_operations_compat1), NULL, 11);
+}
+
+int fuse_main_compat2(int argc, char *argv[],
+		      const struct fuse_operations_compat2 *op)
+{
+	return fuse_main_common(argc, argv, (struct fuse_operations *) op,
+				sizeof(struct fuse_operations_compat2), NULL,
+				21);
+}
+
+int fuse_mount_compat1(const char *mountpoint, const char *args[])
+{
+	/* just ignore mount args for now */
+	(void) args;
+	return fuse_mount_compat22(mountpoint, NULL);
+}
+
+FUSE_SYMVER(".symver fuse_setup_compat2,__fuse_setup@");
+FUSE_SYMVER(".symver fuse_setup_compat22,fuse_setup@FUSE_2.2");
+FUSE_SYMVER(".symver fuse_teardown,__fuse_teardown@");
+FUSE_SYMVER(".symver fuse_main_compat2,fuse_main@");
+FUSE_SYMVER(".symver fuse_main_real_compat22,fuse_main_real@FUSE_2.2");
+
+#endif /* __FreeBSD__ || __NetBSD__ */
+
+
+struct fuse *fuse_setup_compat25(int argc, char *argv[],
+				 const struct fuse_operations_compat25 *op,
+				 size_t op_size, char **mountpoint,
+				 int *multithreaded, int *fd)
+{
+	return fuse_setup_common(argc, argv, (struct fuse_operations *) op,
+				 op_size, mountpoint, multithreaded, fd, NULL,
+				 25);
+}
+
+int fuse_main_real_compat25(int argc, char *argv[],
+			    const struct fuse_operations_compat25 *op,
+			    size_t op_size)
+{
+	return fuse_main_common(argc, argv, (struct fuse_operations *) op,
+				op_size, NULL, 25);
+}
+
+void fuse_teardown_compat22(struct fuse *fuse, int fd, char *mountpoint)
+{
+	(void) fd;
+	fuse_teardown_common(fuse, mountpoint);
+}
+
+int fuse_mount_compat25(const char *mountpoint, struct fuse_args *args)
+{
+	return fuse_kern_mount(mountpoint, args);
+}
+
+FUSE_SYMVER(".symver fuse_setup_compat25,fuse_setup@FUSE_2.5");
+FUSE_SYMVER(".symver fuse_teardown_compat22,fuse_teardown@FUSE_2.2");
+FUSE_SYMVER(".symver fuse_main_real_compat25,fuse_main_real@FUSE_2.5");
+FUSE_SYMVER(".symver fuse_mount_compat25,fuse_mount@FUSE_2.5");
diff --git a/external/fuse/include/Makefile b/external/fuse/include/Makefile
new file mode 100755
index 0000000000..43fd00aa80
--- /dev/null
+++ b/external/fuse/include/Makefile
@@ -0,0 +1,515 @@
+# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# include/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+
+pkgdatadir = $(datadir)/fuse
+pkgincludedir = $(includedir)/fuse
+pkglibdir = $(libdir)/fuse
+pkglibexecdir = $(libexecdir)/fuse
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = i686-pc-linux-gnu
+host_triplet = i686-pc-linux-gnu
+target_triplet = i686-pc-linux-gnu
+subdir = include
+DIST_COMMON = $(fuseinclude_HEADERS) $(include_HEADERS) \
+	$(noinst_HEADERS) $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+	$(srcdir)/config.h.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
+	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
+	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__installdirs = "$(DESTDIR)$(fuseincludedir)" \
+	"$(DESTDIR)$(includedir)"
+HEADERS = $(fuseinclude_HEADERS) $(include_HEADERS) $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = ${SHELL} /root/fuse-2.8.5/missing --run aclocal-1.11
+AMTAR = ${SHELL} /root/fuse-2.8.5/missing --run tar
+AR = ar
+AUTOCONF = ${SHELL} /root/fuse-2.8.5/missing --run autoconf
+AUTOHEADER = ${SHELL} /root/fuse-2.8.5/missing --run autoheader
+AUTOMAKE = ${SHELL} /root/fuse-2.8.5/missing --run automake-1.11
+AWK = mawk
+CC = gcc
+CCDEPMODE = depmode=gcc3
+CFLAGS = -Wall -W -Wno-sign-compare -Wstrict-prototypes -Wmissing-declarations -Wwrite-strings -g -O2 -fno-strict-aliasing
+CPP = gcc -E
+CPPFLAGS = 
+CYGPATH_W = echo
+DEFS = -DHAVE_CONFIG_H
+DEPDIR = .deps
+DSYMUTIL = 
+DUMPBIN = 
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = /bin/grep -E
+EXEEXT = 
+FGREP = /bin/grep -F
+GREP = /bin/grep
+INIT_D_PATH = /etc/init.d
+INSTALL = /usr/bin/install -c
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
+LD = /usr/bin/ld
+LDFLAGS = 
+LIBICONV = 
+LIBOBJS = 
+LIBS = 
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+LIPO = 
+LN_S = ln -s
+LTLIBICONV = 
+LTLIBOBJS = 
+MAKEINFO = ${SHELL} /root/fuse-2.8.5/missing --run makeinfo
+MKDIR_P = /bin/mkdir -p
+MOUNT_FUSE_PATH = /sbin
+NM = /usr/bin/nm -B
+NMEDIT = 
+OBJDUMP = objdump
+OBJEXT = o
+OTOOL = 
+OTOOL64 = 
+PACKAGE = fuse
+PACKAGE_BUGREPORT = 
+PACKAGE_NAME = fuse
+PACKAGE_STRING = fuse 2.8.5
+PACKAGE_TARNAME = fuse
+PACKAGE_VERSION = 2.8.5
+PATH_SEPARATOR = :
+RANLIB = ranlib
+SED = /bin/sed
+SET_MAKE = 
+SHELL = /bin/bash
+STRIP = strip
+UDEV_RULES_PATH = /etc/udev/rules.d
+VERSION = 2.8.5
+abs_builddir = /root/fuse-2.8.5/include
+abs_srcdir = /root/fuse-2.8.5/include
+abs_top_builddir = /root/fuse-2.8.5
+abs_top_srcdir = /root/fuse-2.8.5
+ac_ct_CC = gcc
+ac_ct_DUMPBIN = 
+am__include = include
+am__leading_dot = .
+am__quote = 
+am__tar = ${AMTAR} chof - "$$tardir"
+am__untar = ${AMTAR} xf -
+bindir = ${exec_prefix}/bin
+build = i686-pc-linux-gnu
+build_alias = 
+build_cpu = i686
+build_os = linux-gnu
+build_vendor = pc
+builddir = .
+datadir = ${datarootdir}
+datarootdir = ${prefix}/share
+docdir = ${datarootdir}/doc/${PACKAGE_TARNAME}
+dvidir = ${docdir}
+exec_prefix = ${prefix}
+host = i686-pc-linux-gnu
+host_alias = 
+host_cpu = i686
+host_os = linux-gnu
+host_vendor = pc
+htmldir = ${docdir}
+includedir = ${prefix}/include
+infodir = ${datarootdir}/info
+install_sh = ${SHELL} /root/fuse-2.8.5/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+libfuse_libs = -pthread -lrt -ldl  
+localedir = ${datarootdir}/locale
+localstatedir = ${prefix}/var
+lt_ECHO = echo
+mandir = ${datarootdir}/man
+mkdir_p = /bin/mkdir -p
+oldincludedir = /usr/include
+pdfdir = ${docdir}
+pkgconfigdir = ${libdir}/pkgconfig
+prefix = /usr/local
+program_transform_name = s,x,x,
+psdir = ${docdir}
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+srcdir = .
+subdirs2 = include lib util example
+sysconfdir = ${prefix}/etc
+target = i686-pc-linux-gnu
+target_alias = 
+target_cpu = i686
+target_os = linux-gnu
+target_vendor = pc
+top_build_prefix = ../
+top_builddir = ..
+top_srcdir = ..
+fuseincludedir = $(includedir)/fuse
+fuseinclude_HEADERS = \
+	fuse.h			\
+	fuse_compat.h		\
+	fuse_common.h		\
+	fuse_common_compat.h    \
+	fuse_lowlevel.h		\
+	fuse_lowlevel_compat.h	\
+	fuse_opt.h		\
+	cuse_lowlevel.h
+
+include_HEADERS = old/fuse.h ulockmgr.h
+noinst_HEADERS = fuse_kernel.h
+all: config.h
+	$(MAKE) $(AM_MAKEFLAGS) all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu include/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu include/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+config.h: stamp-h1
+	@if test ! -f $@; then \
+	  rm -f stamp-h1; \
+	  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \
+	else :; fi
+
+stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
+	@rm -f stamp-h1
+	cd $(top_builddir) && $(SHELL) ./config.status include/config.h
+$(srcdir)/config.h.in:  $(am__configure_deps) 
+	($(am__cd) $(top_srcdir) && $(AUTOHEADER))
+	rm -f stamp-h1
+	touch $@
+
+distclean-hdr:
+	-rm -f config.h stamp-h1
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-fuseincludeHEADERS: $(fuseinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(fuseincludedir)" || $(MKDIR_P) "$(DESTDIR)$(fuseincludedir)"
+	@list='$(fuseinclude_HEADERS)'; test -n "$(fuseincludedir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(fuseincludedir)'"; \
+	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(fuseincludedir)" || exit $$?; \
+	done
+
+uninstall-fuseincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(fuseinclude_HEADERS)'; test -n "$(fuseincludedir)" || list=; \
+	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
+	test -n "$$files" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(fuseincludedir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(fuseincludedir)" && rm -f $$files
+install-includeHEADERS: $(include_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(includedir)" || $(MKDIR_P) "$(DESTDIR)$(includedir)"
+	@list='$(include_HEADERS)'; test -n "$(includedir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(includedir)'"; \
+	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(includedir)" || exit $$?; \
+	done
+
+uninstall-includeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(include_HEADERS)'; test -n "$(includedir)" || list=; \
+	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
+	test -n "$$files" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(includedir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(includedir)" && rm -f $$files
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS) config.h
+installdirs:
+	for dir in "$(DESTDIR)$(fuseincludedir)" "$(DESTDIR)$(includedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-hdr distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-fuseincludeHEADERS install-includeHEADERS
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-fuseincludeHEADERS uninstall-includeHEADERS
+
+.MAKE: all install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic distclean-hdr \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-fuseincludeHEADERS install-html \
+	install-html-am install-includeHEADERS install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-fuseincludeHEADERS \
+	uninstall-includeHEADERS
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/external/fuse/include/Makefile.am b/external/fuse/include/Makefile.am
new file mode 100755
index 0000000000..663e164cc9
--- /dev/null
+++ b/external/fuse/include/Makefile.am
@@ -0,0 +1,17 @@
+## Process this file with automake to produce Makefile.in
+
+fuseincludedir=$(includedir)/fuse
+
+fuseinclude_HEADERS = \
+	fuse.h			\
+	fuse_compat.h		\
+	fuse_common.h		\
+	fuse_common_compat.h    \
+	fuse_lowlevel.h		\
+	fuse_lowlevel_compat.h	\
+	fuse_opt.h		\
+	cuse_lowlevel.h
+
+include_HEADERS = old/fuse.h ulockmgr.h
+
+noinst_HEADERS = fuse_kernel.h
diff --git a/external/fuse/include/Makefile.in b/external/fuse/include/Makefile.in
new file mode 100755
index 0000000000..1ae6d8589e
--- /dev/null
+++ b/external/fuse/include/Makefile.in
@@ -0,0 +1,515 @@
+# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+subdir = include
+DIST_COMMON = $(fuseinclude_HEADERS) $(include_HEADERS) \
+	$(noinst_HEADERS) $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+	$(srcdir)/config.h.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
+	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
+	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__installdirs = "$(DESTDIR)$(fuseincludedir)" \
+	"$(DESTDIR)$(includedir)"
+HEADERS = $(fuseinclude_HEADERS) $(include_HEADERS) $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INIT_D_PATH = @INIT_D_PATH@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBICONV = @LTLIBICONV@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MOUNT_FUSE_PATH = @MOUNT_FUSE_PATH@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+UDEV_RULES_PATH = @UDEV_RULES_PATH@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+libfuse_libs = @libfuse_libs@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+pkgconfigdir = @pkgconfigdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+subdirs2 = @subdirs2@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+fuseincludedir = $(includedir)/fuse
+fuseinclude_HEADERS = \
+	fuse.h			\
+	fuse_compat.h		\
+	fuse_common.h		\
+	fuse_common_compat.h    \
+	fuse_lowlevel.h		\
+	fuse_lowlevel_compat.h	\
+	fuse_opt.h		\
+	cuse_lowlevel.h
+
+include_HEADERS = old/fuse.h ulockmgr.h
+noinst_HEADERS = fuse_kernel.h
+all: config.h
+	$(MAKE) $(AM_MAKEFLAGS) all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu include/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu include/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+config.h: stamp-h1
+	@if test ! -f $@; then \
+	  rm -f stamp-h1; \
+	  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \
+	else :; fi
+
+stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
+	@rm -f stamp-h1
+	cd $(top_builddir) && $(SHELL) ./config.status include/config.h
+$(srcdir)/config.h.in:  $(am__configure_deps) 
+	($(am__cd) $(top_srcdir) && $(AUTOHEADER))
+	rm -f stamp-h1
+	touch $@
+
+distclean-hdr:
+	-rm -f config.h stamp-h1
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-fuseincludeHEADERS: $(fuseinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(fuseincludedir)" || $(MKDIR_P) "$(DESTDIR)$(fuseincludedir)"
+	@list='$(fuseinclude_HEADERS)'; test -n "$(fuseincludedir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(fuseincludedir)'"; \
+	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(fuseincludedir)" || exit $$?; \
+	done
+
+uninstall-fuseincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(fuseinclude_HEADERS)'; test -n "$(fuseincludedir)" || list=; \
+	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
+	test -n "$$files" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(fuseincludedir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(fuseincludedir)" && rm -f $$files
+install-includeHEADERS: $(include_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(includedir)" || $(MKDIR_P) "$(DESTDIR)$(includedir)"
+	@list='$(include_HEADERS)'; test -n "$(includedir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(includedir)'"; \
+	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(includedir)" || exit $$?; \
+	done
+
+uninstall-includeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(include_HEADERS)'; test -n "$(includedir)" || list=; \
+	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
+	test -n "$$files" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(includedir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(includedir)" && rm -f $$files
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS) config.h
+installdirs:
+	for dir in "$(DESTDIR)$(fuseincludedir)" "$(DESTDIR)$(includedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-hdr distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-fuseincludeHEADERS install-includeHEADERS
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-fuseincludeHEADERS uninstall-includeHEADERS
+
+.MAKE: all install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic distclean-hdr \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-fuseincludeHEADERS install-html \
+	install-html-am install-includeHEADERS install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-fuseincludeHEADERS \
+	uninstall-includeHEADERS
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/external/fuse/include/config.h b/external/fuse/include/config.h
new file mode 100755
index 0000000000..a0c603ab60
--- /dev/null
+++ b/external/fuse/include/config.h
@@ -0,0 +1,87 @@
+/* include/config.h.  Generated from config.h.in by configure.  */
+/* include/config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the `fdatasync' function. */
+#define HAVE_FDATASYNC 1
+
+/* Define to 1 if you have the `fork' function. */
+#define HAVE_FORK 1
+
+/* Define if you have the iconv() function and it works. */
+#define HAVE_ICONV 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `setxattr' function. */
+#define HAVE_SETXATTR 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if `st_atim' is member of `struct stat'. */
+//#define HAVE_STRUCT_STAT_ST_ATIM 0
+
+/* Define to 1 if `st_atimespec' is member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_ATIMESPEC */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define as const if the declaration of iconv() needs const. */
+#define ICONV_CONST 
+
+/* Don't update /etc/mtab */
+/* #undef IGNORE_MTAB */
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#define LT_OBJDIR ".libs/"
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together. */
+/* #undef NO_MINUS_C_MINUS_O */
+
+/* Name of package */
+#define PACKAGE "fuse"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "fuse"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "fuse 2.8.5"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "fuse"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "2.8.5"
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Version number of package */
+#define VERSION "2.8.5"
diff --git a/external/fuse/include/config.h.in b/external/fuse/include/config.h.in
new file mode 100755
index 0000000000..3e7c14ccb9
--- /dev/null
+++ b/external/fuse/include/config.h.in
@@ -0,0 +1,86 @@
+/* include/config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the `fdatasync' function. */
+#undef HAVE_FDATASYNC
+
+/* Define to 1 if you have the `fork' function. */
+#undef HAVE_FORK
+
+/* Define if you have the iconv() function and it works. */
+#undef HAVE_ICONV
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the `setxattr' function. */
+#undef HAVE_SETXATTR
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if `st_atim' is member of `struct stat'. */
+#undef HAVE_STRUCT_STAT_ST_ATIM
+
+/* Define to 1 if `st_atimespec' is member of `struct stat'. */
+#undef HAVE_STRUCT_STAT_ST_ATIMESPEC
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define as const if the declaration of iconv() needs const. */
+#undef ICONV_CONST
+
+/* Don't update /etc/mtab */
+#undef IGNORE_MTAB
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together. */
+#undef NO_MINUS_C_MINUS_O
+
+/* Name of package */
+#undef PACKAGE
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Version number of package */
+#undef VERSION
diff --git a/external/fuse/include/cuse_lowlevel.h b/external/fuse/include/cuse_lowlevel.h
new file mode 100755
index 0000000000..d628eac4e7
--- /dev/null
+++ b/external/fuse/include/cuse_lowlevel.h
@@ -0,0 +1,87 @@
+/*
+  CUSE: Character device in Userspace
+  Copyright (C) 2008-2009  SUSE Linux Products GmbH
+  Copyright (C) 2008-2009  Tejun Heo <tj@kernel.org>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB.
+
+  Read example/cusexmp.c for usages.
+*/
+
+#ifndef _CUSE_LOWLEVEL_H_
+#define _CUSE_LOWLEVEL_H_
+
+#ifndef FUSE_USE_VERSION
+#define FUSE_USE_VERSION 29
+#endif
+
+#include "fuse_lowlevel.h"
+
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/uio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CUSE_UNRESTRICTED_IOCTL		(1 << 0) /* use unrestricted ioctl */
+
+struct fuse_session;
+
+struct cuse_info {
+	unsigned	dev_major;
+	unsigned	dev_minor;
+	unsigned	dev_info_argc;
+	const char	**dev_info_argv;
+	unsigned	flags;
+};
+
+/*
+ * Most ops behave almost identically to the matching fuse_lowlevel
+ * ops except that they don't take @ino.
+ *
+ * init_done	: called after initialization is complete
+ * read/write	: always direct IO, simultaneous operations allowed
+ * ioctl	: might be in unrestricted mode depending on ci->flags
+ */
+struct cuse_lowlevel_ops {
+	void (*init) (void *userdata, struct fuse_conn_info *conn);
+	void (*init_done) (void *userdata);
+	void (*destroy) (void *userdata);
+	void (*open) (fuse_req_t req, struct fuse_file_info *fi);
+	void (*read) (fuse_req_t req, size_t size, off64_t off,
+		      struct fuse_file_info *fi);
+	void (*write) (fuse_req_t req, const char *buf, size_t size, off64_t off,
+		       struct fuse_file_info *fi);
+	void (*flush) (fuse_req_t req, struct fuse_file_info *fi);
+	void (*release) (fuse_req_t req, struct fuse_file_info *fi);
+	void (*fsync) (fuse_req_t req, int datasync, struct fuse_file_info *fi);
+	void (*ioctl) (fuse_req_t req, int cmd, void *arg,
+		       struct fuse_file_info *fi, unsigned int flags,
+		       const void *in_buf, size_t in_bufsz, size_t out_bufsz);
+	void (*poll) (fuse_req_t req, struct fuse_file_info *fi,
+		      struct fuse_pollhandle *ph);
+};
+
+struct fuse_session *cuse_lowlevel_new(struct fuse_args *args,
+				       const struct cuse_info *ci,
+				       const struct cuse_lowlevel_ops *clop,
+				       void *userdata);
+
+struct fuse_session *cuse_lowlevel_setup(int argc, char *argv[],
+					 const struct cuse_info *ci,
+					 const struct cuse_lowlevel_ops *clop,
+					 int *multithreaded, void *userdata);
+
+void cuse_lowlevel_teardown(struct fuse_session *se);
+
+int cuse_lowlevel_main(int argc, char *argv[], const struct cuse_info *ci,
+		       const struct cuse_lowlevel_ops *clop, void *userdata);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _CUSE_LOWLEVEL_H_ */
diff --git a/external/fuse/include/fuse.h b/external/fuse/include/fuse.h
new file mode 100755
index 0000000000..cad816cc45
--- /dev/null
+++ b/external/fuse/include/fuse.h
@@ -0,0 +1,1059 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB.
+*/
+
+#ifndef _FUSE_H_
+#define _FUSE_H_
+
+/** @file
+ *
+ * This file defines the library interface of FUSE
+ *
+ * IMPORTANT: you should define FUSE_USE_VERSION before including this
+ * header.  To use the newest API define it to 26 (recommended for any
+ * new application), to use the old API define it to 21 (default) 22
+ * or 25, to use the even older 1.X API define it to 11.
+ */
+
+#ifndef FUSE_USE_VERSION
+#define FUSE_USE_VERSION 21
+#endif
+
+#include "fuse_common.h"
+
+#include <fcntl.h>
+#include <time.h>
+#include <utime.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statvfs.h>
+#include <sys/uio.h>
+#include <pthread.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ----------------------------------------------------------- *
+ * Basic FUSE API					       *
+ * ----------------------------------------------------------- */
+
+/** Handle for a FUSE filesystem */
+struct fuse;
+
+/** Structure containing a raw command */
+struct fuse_cmd;
+
+/** Function to add an entry in a readdir() operation
+ *
+ * @param buf the buffer passed to the readdir() operation
+ * @param name the file name of the directory entry
+ * @param stat file attributes, can be NULL
+ * @param off offset of the next entry or zero
+ * @return 1 if buffer is full, zero otherwise
+ */
+typedef int (*fuse_fill_dir_t) (void *buf, const char *name,
+				const struct stat *stbuf, off64_t off);
+
+/* Used by deprecated getdir() method */
+typedef struct fuse_dirhandle *fuse_dirh_t;
+typedef int (*fuse_dirfil_t) (fuse_dirh_t h, const char *name, int type,
+			      ino_t ino);
+
+/**
+ * The file system operations:
+ *
+ * Most of these should work very similarly to the well known UNIX
+ * file system operations.  A major exception is that instead of
+ * returning an error in 'errno', the operation should return the
+ * negated error value (-errno) directly.
+ *
+ * All methods are optional, but some are essential for a useful
+ * filesystem (e.g. getattr).  Open, flush, release, fsync, opendir,
+ * releasedir, fsyncdir, access, create, ftruncate, fgetattr, lock,
+ * init and destroy are special purpose methods, without which a full
+ * featured filesystem can still be implemented.
+ *
+ * Almost all operations take a path which can be of any length.
+ *
+ * Changed in fuse 2.8.0 (regardless of API version)
+ * Previously, paths were limited to a length of PATH_MAX.
+ *
+ * See http://fuse.sourceforge.net/wiki/ for more information.  There
+ * is also a snapshot of the relevant wiki pages in the doc/ folder.
+ */
+struct fuse_operations {
+	/** Get file attributes.
+	 *
+	 * Similar to stat().  The 'st_dev' and 'st_blksize' fields are
+	 * ignored.	 The 'st_ino' field is ignored except if the 'use_ino'
+	 * mount option is given.
+	 */
+	int (*getattr) (const char *, struct stat *);
+
+	/** Read the target of a symbolic link
+	 *
+	 * The buffer should be filled with a null terminated string.  The
+	 * buffer size argument includes the space for the terminating
+	 * null character.	If the linkname is too long to fit in the
+	 * buffer, it should be truncated.	The return value should be 0
+	 * for success.
+	 */
+	int (*readlink) (const char *, char *, size_t);
+
+	/* Deprecated, use readdir() instead */
+	int (*getdir) (const char *, fuse_dirh_t, fuse_dirfil_t);
+
+	/** Create a file node
+	 *
+	 * This is called for creation of all non-directory, non-symlink
+	 * nodes.  If the filesystem defines a create() method, then for
+	 * regular files that will be called instead.
+	 */
+	int (*mknod) (const char *, mode_t, dev_t);
+
+	/** Create a directory 
+	 *
+	 * Note that the mode argument may not have the type specification
+	 * bits set, i.e. S_ISDIR(mode) can be false.  To obtain the
+	 * correct directory type bits use  mode|S_IFDIR
+	 * */
+	int (*mkdir) (const char *, mode_t);
+
+	/** Remove a file */
+	int (*unlink) (const char *);
+
+	/** Remove a directory */
+	int (*rmdir) (const char *);
+
+	/** Create a symbolic link */
+	int (*symlink) (const char *, const char *);
+
+	/** Rename a file */
+	int (*rename) (const char *, const char *);
+
+	/** Create a hard link to a file */
+	int (*link) (const char *, const char *);
+
+	/** Change the permission bits of a file */
+	int (*chmod) (const char *, mode_t);
+
+	/** Change the owner and group of a file */
+	int (*chown) (const char *, uid_t, gid_t);
+
+	/** Change the size of a file */
+	int (*truncate) (const char *, off64_t);
+
+	/** Change the access and/or modification times of a file
+	 *
+	 * Deprecated, use utimens() instead.
+	 */
+	int (*utime) (const char *, struct utimbuf *);
+
+	/** File open operation
+	 *
+	 * No creation (O_CREAT, O_EXCL) and by default also no
+	 * truncation (O_TRUNC) flags will be passed to open(). If an
+	 * application specifies O_TRUNC, fuse first calls truncate()
+	 * and then open(). Only if 'atomic_o_trunc' has been
+	 * specified and kernel version is 2.6.24 or later, O_TRUNC is
+	 * passed on to open.
+	 *
+	 * Unless the 'default_permissions' mount option is given,
+	 * open should check if the operation is permitted for the
+	 * given flags. Optionally open may also return an arbitrary
+	 * filehandle in the fuse_file_info structure, which will be
+	 * passed to all file operations.
+	 *
+	 * Changed in version 2.2
+	 */
+	int (*open) (const char *, struct fuse_file_info *);
+
+	/** Read data from an open file
+	 *
+	 * Read should return exactly the number of bytes requested except
+	 * on EOF or error, otherwise the rest of the data will be
+	 * substituted with zeroes.	 An exception to this is when the
+	 * 'direct_io' mount option is specified, in which case the return
+	 * value of the read system call will reflect the return value of
+	 * this operation.
+	 *
+	 * Changed in version 2.2
+	 */
+	int (*read) (const char *, char *, size_t, off64_t,
+		     struct fuse_file_info *);
+
+	/** Write data to an open file
+	 *
+	 * Write should return exactly the number of bytes requested
+	 * except on error.	 An exception to this is when the 'direct_io'
+	 * mount option is specified (see read operation).
+	 *
+	 * Changed in version 2.2
+	 */
+	int (*write) (const char *, const char *, size_t, off64_t,
+		      struct fuse_file_info *);
+
+	/** Get file system statistics
+	 *
+	 * The 'f_frsize', 'f_favail', 'f_fsid' and 'f_flag' fields are ignored
+	 *
+	 * Replaced 'struct statfs' parameter with 'struct statvfs' in
+	 * version 2.5
+	 */
+	int (*statfs) (const char *, struct statvfs *);
+
+	/** Possibly flush cached data
+	 *
+	 * BIG NOTE: This is not equivalent to fsync().  It's not a
+	 * request to sync dirty data.
+	 *
+	 * Flush is called on each close() of a file descriptor.  So if a
+	 * filesystem wants to return write errors in close() and the file
+	 * has cached dirty data, this is a good place to write back data
+	 * and return any errors.  Since many applications ignore close()
+	 * errors this is not always useful.
+	 *
+	 * NOTE: The flush() method may be called more than once for each
+	 * open().	This happens if more than one file descriptor refers
+	 * to an opened file due to dup(), dup2() or fork() calls.	It is
+	 * not possible to determine if a flush is final, so each flush
+	 * should be treated equally.  Multiple write-flush sequences are
+	 * relatively rare, so this shouldn't be a problem.
+	 *
+	 * Filesystems shouldn't assume that flush will always be called
+	 * after some writes, or that if will be called at all.
+	 *
+	 * Changed in version 2.2
+	 */
+	int (*flush) (const char *, struct fuse_file_info *);
+
+	/** Release an open file
+	 *
+	 * Release is called when there are no more references to an open
+	 * file: all file descriptors are closed and all memory mappings
+	 * are unmapped.
+	 *
+	 * For every open() call there will be exactly one release() call
+	 * with the same flags and file descriptor.	 It is possible to
+	 * have a file opened more than once, in which case only the last
+	 * release will mean, that no more reads/writes will happen on the
+	 * file.  The return value of release is ignored.
+	 *
+	 * Changed in version 2.2
+	 */
+	int (*release) (const char *, struct fuse_file_info *);
+
+	/** Synchronize file contents
+	 *
+	 * If the datasync parameter is non-zero, then only the user data
+	 * should be flushed, not the meta data.
+	 *
+	 * Changed in version 2.2
+	 */
+	int (*fsync) (const char *, int, struct fuse_file_info *);
+
+	/** Set extended attributes */
+	int (*setxattr) (const char *, const char *, const char *, size_t, int);
+
+	/** Get extended attributes */
+	int (*getxattr) (const char *, const char *, char *, size_t);
+
+	/** List extended attributes */
+	int (*listxattr) (const char *, char *, size_t);
+
+	/** Remove extended attributes */
+	int (*removexattr) (const char *, const char *);
+
+	/** Open directory
+	 *
+	 * Unless the 'default_permissions' mount option is given,
+	 * this method should check if opendir is permitted for this
+	 * directory. Optionally opendir may also return an arbitrary
+	 * filehandle in the fuse_file_info structure, which will be
+	 * passed to readdir, closedir and fsyncdir.
+	 *
+	 * Introduced in version 2.3
+	 */
+	int (*opendir) (const char *, struct fuse_file_info *);
+
+	/** Read directory
+	 *
+	 * This supersedes the old getdir() interface.  New applications
+	 * should use this.
+	 *
+	 * The filesystem may choose between two modes of operation:
+	 *
+	 * 1) The readdir implementation ignores the offset parameter, and
+	 * passes zero to the filler function's offset.  The filler
+	 * function will not return '1' (unless an error happens), so the
+	 * whole directory is read in a single readdir operation.  This
+	 * works just like the old getdir() method.
+	 *
+	 * 2) The readdir implementation keeps track of the offsets of the
+	 * directory entries.  It uses the offset parameter and always
+	 * passes non-zero offset to the filler function.  When the buffer
+	 * is full (or an error happens) the filler function will return
+	 * '1'.
+	 *
+	 * Introduced in version 2.3
+	 */
+	int (*readdir) (const char *, void *, fuse_fill_dir_t, off64_t,
+			struct fuse_file_info *);
+
+	/** Release directory
+	 *
+	 * Introduced in version 2.3
+	 */
+	int (*releasedir) (const char *, struct fuse_file_info *);
+
+	/** Synchronize directory contents
+	 *
+	 * If the datasync parameter is non-zero, then only the user data
+	 * should be flushed, not the meta data
+	 *
+	 * Introduced in version 2.3
+	 */
+	int (*fsyncdir) (const char *, int, struct fuse_file_info *);
+
+	/**
+	 * Initialize filesystem
+	 *
+	 * The return value will passed in the private_data field of
+	 * fuse_context to all file operations and as a parameter to the
+	 * destroy() method.
+	 *
+	 * Introduced in version 2.3
+	 * Changed in version 2.6
+	 */
+	void *(*init) (struct fuse_conn_info *conn);
+
+	/**
+	 * Clean up filesystem
+	 *
+	 * Called on filesystem exit.
+	 *
+	 * Introduced in version 2.3
+	 */
+	void (*destroy) (void *);
+
+	/**
+	 * Check file access permissions
+	 *
+	 * This will be called for the access() system call.  If the
+	 * 'default_permissions' mount option is given, this method is not
+	 * called.
+	 *
+	 * This method is not called under Linux kernel versions 2.4.x
+	 *
+	 * Introduced in version 2.5
+	 */
+	int (*access) (const char *, int);
+
+	/**
+	 * Create and open a file
+	 *
+	 * If the file does not exist, first create it with the specified
+	 * mode, and then open it.
+	 *
+	 * If this method is not implemented or under Linux kernel
+	 * versions earlier than 2.6.15, the mknod() and open() methods
+	 * will be called instead.
+	 *
+	 * Introduced in version 2.5
+	 */
+	int (*create) (const char *, mode_t, struct fuse_file_info *);
+
+	/**
+	 * Change the size of an open file
+	 *
+	 * This method is called instead of the truncate() method if the
+	 * truncation was invoked from an ftruncate() system call.
+	 *
+	 * If this method is not implemented or under Linux kernel
+	 * versions earlier than 2.6.15, the truncate() method will be
+	 * called instead.
+	 *
+	 * Introduced in version 2.5
+	 */
+	int (*ftruncate) (const char *, off64_t, struct fuse_file_info *);
+
+	/**
+	 * Get attributes from an open file
+	 *
+	 * This method is called instead of the getattr() method if the
+	 * file information is available.
+	 *
+	 * Currently this is only called after the create() method if that
+	 * is implemented (see above).  Later it may be called for
+	 * invocations of fstat() too.
+	 *
+	 * Introduced in version 2.5
+	 */
+	int (*fgetattr) (const char *, struct stat *, struct fuse_file_info *);
+
+	/**
+	 * Perform POSIX file locking operation
+	 *
+	 * The cmd argument will be either F_GETLK, F_SETLK or F_SETLKW.
+	 *
+	 * For the meaning of fields in 'struct flock' see the man page
+	 * for fcntl(2).  The l_whence field will always be set to
+	 * SEEK_SET.
+	 *
+	 * For checking lock ownership, the 'fuse_file_info->owner'
+	 * argument must be used.
+	 *
+	 * For F_GETLK operation, the library will first check currently
+	 * held locks, and if a conflicting lock is found it will return
+	 * information without calling this method.	 This ensures, that
+	 * for local locks the l_pid field is correctly filled in.	The
+	 * results may not be accurate in case of race conditions and in
+	 * the presence of hard links, but it's unlikely that an
+	 * application would rely on accurate GETLK results in these
+	 * cases.  If a conflicting lock is not found, this method will be
+	 * called, and the filesystem may fill out l_pid by a meaningful
+	 * value, or it may leave this field zero.
+	 *
+	 * For F_SETLK and F_SETLKW the l_pid field will be set to the pid
+	 * of the process performing the locking operation.
+	 *
+	 * Note: if this method is not implemented, the kernel will still
+	 * allow file locking to work locally.  Hence it is only
+	 * interesting for network filesystems and similar.
+	 *
+	 * Introduced in version 2.6
+	 */
+	int (*lock) (const char *, struct fuse_file_info *, int cmd,
+		     struct flock *);
+
+	/**
+	 * Change the access and modification times of a file with
+	 * nanosecond resolution
+	 *
+	 * This supersedes the old utime() interface.  New applications
+	 * should use this.
+	 *
+	 * See the utimensat(2) man page for details.
+	 *
+	 * Introduced in version 2.6
+	 */
+	int (*utimens) (const char *, const struct timespec tv[2]);
+
+	/**
+	 * Map block index within file to block index within device
+	 *
+	 * Note: This makes sense only for block device backed filesystems
+	 * mounted with the 'blkdev' option
+	 *
+	 * Introduced in version 2.6
+	 */
+	int (*bmap) (const char *, size_t blocksize, uint64_t *idx);
+
+	/**
+	 * Flag indicating that the filesystem can accept a NULL path
+	 * as the first argument for the following operations:
+	 *
+	 * read, write, flush, release, fsync, readdir, releasedir,
+	 * fsyncdir, ftruncate, fgetattr, lock, ioctl and poll
+	 *
+	 * If this flag is set these operations continue to work on
+	 * unlinked files even if "-ohard_remove" option was specified.
+	 */
+	unsigned int flag_nullpath_ok:1;
+
+	/**
+	 * Flag indicating that the path need not be calculated for
+	 * the following operations:
+	 *
+	 * read, write, flush, release, fsync, readdir, releasedir,
+	 * fsyncdir, ftruncate, fgetattr, lock, ioctl and poll
+	 *
+	 * Closely related to flag_nullpath_ok, but if this flag is
+	 * set then the path will not be calculaged even if the file
+	 * wasn't unlinked.  However the path can still be non-NULL if
+	 * it needs to be calculated for some other reason.
+	 */
+	unsigned int flag_nopath:1;
+
+	/**
+	 * Flag indicating that the filesystem accepts special
+	 * UTIME_NOW and UTIME_OMIT values in its utimens operation.
+	 */
+	unsigned int flag_utime_omit_ok:1;
+
+	/**
+	 * Reserved flags, don't set
+	 */
+	unsigned int flag_reserved:29;
+
+	/**
+	 * Ioctl
+	 *
+	 * flags will have FUSE_IOCTL_COMPAT set for 32bit ioctls in
+	 * 64bit environment.  The size and direction of data is
+	 * determined by _IOC_*() decoding of cmd.  For _IOC_NONE,
+	 * data will be NULL, for _IOC_WRITE data is out area, for
+	 * _IOC_READ in area and if both are set in/out area.  In all
+	 * non-NULL cases, the area is of _IOC_SIZE(cmd) bytes.
+	 *
+	 * Introduced in version 2.8
+	 */
+	int (*ioctl) (const char *, int cmd, void *arg,
+		      struct fuse_file_info *, unsigned int flags, void *data);
+
+	/**
+	 * Poll for IO readiness events
+	 *
+	 * Note: If ph is non-NULL, the client should notify
+	 * when IO readiness events occur by calling
+	 * fuse_notify_poll() with the specified ph.
+	 *
+	 * Regardless of the number of times poll with a non-NULL ph
+	 * is received, single notification is enough to clear all.
+	 * Notifying more times incurs overhead but doesn't harm
+	 * correctness.
+	 *
+	 * The callee is responsible for destroying ph with
+	 * fuse_pollhandle_destroy() when no longer in use.
+	 *
+	 * Introduced in version 2.8
+	 */
+	int (*poll) (const char *, struct fuse_file_info *,
+		     struct fuse_pollhandle *ph, unsigned *reventsp);
+
+	/** Write contents of buffer to an open file
+	 *
+	 * Similar to the write() method, but data is supplied in a
+	 * generic buffer.  Use fuse_buf_copy() to transfer data to
+	 * the destination.
+	 *
+	 * Introduced in version 2.9
+	 */
+	int (*write_buf) (const char *, struct fuse_bufvec *buf, off64_t off,
+			  struct fuse_file_info *);
+
+	/** Store data from an open file in a buffer
+	 *
+	 * Similar to the read() method, but data is stored and
+	 * returned in a generic buffer.
+	 *
+	 * No actual copying of data has to take place, the source
+	 * file descriptor may simply be stored in the buffer for
+	 * later data transfer.
+	 *
+	 * The buffer must be allocated dynamically and stored at the
+	 * location pointed to by bufp.  If the buffer contains memory
+	 * regions, they too must be allocated using malloc().  The
+	 * allocated memory will be freed by the caller.
+	 *
+	 * Introduced in version 2.9
+	 */
+	int (*read_buf) (const char *, struct fuse_bufvec **bufp,
+			 size_t size, off64_t off, struct fuse_file_info *);
+	/**
+	 * Perform BSD file locking operation
+	 *
+	 * The op argument will be either LOCK_SH, LOCK_EX or LOCK_UN
+	 *
+	 * Nonblocking requests will be indicated by ORing LOCK_NB to
+	 * the above operations
+	 *
+	 * For more information see the flock(2) manual page.
+	 *
+	 * Additionally fi->owner will be set to a value unique to
+	 * this open file.  This same value will be supplied to
+	 * ->release() when the file is released.
+	 *
+	 * Note: if this method is not implemented, the kernel will still
+	 * allow file locking to work locally.  Hence it is only
+	 * interesting for network filesystems and similar.
+	 *
+	 * Introduced in version 2.9
+	 */
+	int (*flock) (const char *, struct fuse_file_info *, int op);
+
+	/**
+	 * Allocates space for an open file
+	 *
+	 * This function ensures that required space is allocated for specified
+	 * file.  If this function returns success then any subsequent write
+	 * request to specified range is guaranteed not to fail because of lack
+	 * of space on the file system media.
+	 *
+	 * Introduced in version 2.9.1
+	 */
+	int (*fallocate) (const char *, int, off64_t, off64_t,
+			  struct fuse_file_info *);
+};
+
+/** Extra context that may be needed by some filesystems
+ *
+ * The uid, gid and pid fields are not filled in case of a writepage
+ * operation.
+ */
+struct fuse_context {
+	/** Pointer to the fuse object */
+	struct fuse *fuse;
+
+	/** User ID of the calling process */
+	uid_t uid;
+
+	/** Group ID of the calling process */
+	gid_t gid;
+
+	/** Thread ID of the calling process */
+	pid_t pid;
+
+	/** Private filesystem data */
+	void *private_data;
+
+	/** Umask of the calling process (introduced in version 2.8) */
+	mode_t umask;
+};
+
+/**
+ * Main function of FUSE.
+ *
+ * This is for the lazy.  This is all that has to be called from the
+ * main() function.
+ *
+ * This function does the following:
+ *   - parses command line options (-d -s and -h)
+ *   - passes relevant mount options to the fuse_mount()
+ *   - installs signal handlers for INT, HUP, TERM and PIPE
+ *   - registers an exit handler to unmount the filesystem on program exit
+ *   - creates a fuse handle
+ *   - registers the operations
+ *   - calls either the single-threaded or the multi-threaded event loop
+ *
+ * Note: this is currently implemented as a macro.
+ *
+ * @param argc the argument counter passed to the main() function
+ * @param argv the argument vector passed to the main() function
+ * @param op the file system operation
+ * @param user_data user data supplied in the context during the init() method
+ * @return 0 on success, nonzero on failure
+ */
+/*
+  int fuse_main(int argc, char *argv[], const struct fuse_operations *op,
+  void *user_data);
+*/
+#define fuse_main(argc, argv, op, user_data)				\
+	fuse_main_real(argc, argv, op, sizeof(*(op)), user_data)
+
+/* ----------------------------------------------------------- *
+ * More detailed API					       *
+ * ----------------------------------------------------------- */
+
+/**
+ * Create a new FUSE filesystem.
+ *
+ * @param ch the communication channel
+ * @param args argument vector
+ * @param op the filesystem operations
+ * @param op_size the size of the fuse_operations structure
+ * @param user_data user data supplied in the context during the init() method
+ * @return the created FUSE handle
+ */
+struct fuse *fuse_new(struct fuse_chan *ch, struct fuse_args *args,
+		      const struct fuse_operations *op, size_t op_size,
+		      void *user_data);
+
+/**
+ * Destroy the FUSE handle.
+ *
+ * The communication channel attached to the handle is also destroyed.
+ *
+ * NOTE: This function does not unmount the filesystem.	 If this is
+ * needed, call fuse_unmount() before calling this function.
+ *
+ * @param f the FUSE handle
+ */
+void fuse_destroy(struct fuse *f);
+
+/**
+ * FUSE event loop.
+ *
+ * Requests from the kernel are processed, and the appropriate
+ * operations are called.
+ *
+ * @param f the FUSE handle
+ * @return 0 if no error occurred, -1 otherwise
+ */
+int fuse_loop(struct fuse *f);
+
+/**
+ * Exit from event loop
+ *
+ * @param f the FUSE handle
+ */
+void fuse_exit(struct fuse *f);
+
+/**
+ * FUSE event loop with multiple threads
+ *
+ * Requests from the kernel are processed, and the appropriate
+ * operations are called.  Request are processed in parallel by
+ * distributing them between multiple threads.
+ *
+ * Calling this function requires the pthreads library to be linked to
+ * the application.
+ *
+ * @param f the FUSE handle
+ * @return 0 if no error occurred, -1 otherwise
+ */
+int fuse_loop_mt(struct fuse *f);
+
+/**
+ * Get the current context
+ *
+ * The context is only valid for the duration of a filesystem
+ * operation, and thus must not be stored and used later.
+ *
+ * @return the context
+ */
+struct fuse_context *fuse_get_context(void);
+
+/**
+ * Get the current supplementary group IDs for the current request
+ *
+ * Similar to the getgroups(2) system call, except the return value is
+ * always the total number of group IDs, even if it is larger than the
+ * specified size.
+ *
+ * The current fuse kernel module in linux (as of 2.6.30) doesn't pass
+ * the group list to userspace, hence this function needs to parse
+ * "/proc/$TID/task/$TID/status" to get the group IDs.
+ *
+ * This feature may not be supported on all operating systems.  In
+ * such a case this function will return -ENOSYS.
+ *
+ * @param size size of given array
+ * @param list array of group IDs to be filled in
+ * @return the total number of supplementary group IDs or -errno on failure
+ */
+int fuse_getgroups(int size, gid_t list[]);
+
+/**
+ * Check if the current request has already been interrupted
+ *
+ * @return 1 if the request has been interrupted, 0 otherwise
+ */
+int fuse_interrupted(void);
+
+/**
+ * Obsolete, doesn't do anything
+ *
+ * @return -EINVAL
+ */
+int fuse_invalidate(struct fuse *f, const char *path);
+
+/* Deprecated, don't use */
+int fuse_is_lib_option(const char *opt);
+
+/**
+ * The real main function
+ *
+ * Do not call this directly, use fuse_main()
+ */
+int fuse_main_real(int argc, char *argv[], const struct fuse_operations *op,
+		   size_t op_size, void *user_data);
+
+/**
+ * Start the cleanup thread when using option "remember".
+ *
+ * This is done automatically by fuse_loop_mt()
+ * @param fuse struct fuse pointer for fuse instance
+ * @return 0 on success and -1 on error
+ */
+int fuse_start_cleanup_thread(struct fuse *fuse);
+
+/**
+ * Stop the cleanup thread when using option "remember".
+ *
+ * This is done automatically by fuse_loop_mt()
+ * @param fuse struct fuse pointer for fuse instance
+ */
+void fuse_stop_cleanup_thread(struct fuse *fuse);
+
+/**
+ * Iterate over cache removing stale entries
+ * use in conjunction with "-oremember"
+ *
+ * NOTE: This is already done for the standard sessions
+ *
+ * @param fuse struct fuse pointer for fuse instance
+ * @return the number of seconds until the next cleanup
+ */
+int fuse_clean_cache(struct fuse *fuse);
+
+/*
+ * Stacking API
+ */
+
+/**
+ * Fuse filesystem object
+ *
+ * This is opaque object represents a filesystem layer
+ */
+struct fuse_fs;
+
+/*
+ * These functions call the relevant filesystem operation, and return
+ * the result.
+ *
+ * If the operation is not defined, they return -ENOSYS, with the
+ * exception of fuse_fs_open, fuse_fs_release, fuse_fs_opendir,
+ * fuse_fs_releasedir and fuse_fs_statfs, which return 0.
+ */
+
+int fuse_fs_getattr(struct fuse_fs *fs, const char *path, struct stat *buf);
+int fuse_fs_fgetattr(struct fuse_fs *fs, const char *path, struct stat *buf,
+		     struct fuse_file_info *fi);
+int fuse_fs_rename(struct fuse_fs *fs, const char *oldpath,
+		   const char *newpath);
+int fuse_fs_unlink(struct fuse_fs *fs, const char *path);
+int fuse_fs_rmdir(struct fuse_fs *fs, const char *path);
+int fuse_fs_symlink(struct fuse_fs *fs, const char *linkname,
+		    const char *path);
+int fuse_fs_link(struct fuse_fs *fs, const char *oldpath, const char *newpath);
+int fuse_fs_release(struct fuse_fs *fs,	 const char *path,
+		    struct fuse_file_info *fi);
+int fuse_fs_open(struct fuse_fs *fs, const char *path,
+		 struct fuse_file_info *fi);
+int fuse_fs_read(struct fuse_fs *fs, const char *path, char *buf, size_t size,
+		 off64_t off, struct fuse_file_info *fi);
+int fuse_fs_read_buf(struct fuse_fs *fs, const char *path,
+		     struct fuse_bufvec **bufp, size_t size, off64_t off,
+		     struct fuse_file_info *fi);
+int fuse_fs_write(struct fuse_fs *fs, const char *path, const char *buf,
+		  size_t size, off64_t off, struct fuse_file_info *fi);
+int fuse_fs_write_buf(struct fuse_fs *fs, const char *path,
+		      struct fuse_bufvec *buf, off64_t off,
+		      struct fuse_file_info *fi);
+int fuse_fs_fsync(struct fuse_fs *fs, const char *path, int datasync,
+		  struct fuse_file_info *fi);
+int fuse_fs_flush(struct fuse_fs *fs, const char *path,
+		  struct fuse_file_info *fi);
+int fuse_fs_statfs(struct fuse_fs *fs, const char *path, struct statvfs *buf);
+int fuse_fs_opendir(struct fuse_fs *fs, const char *path,
+		    struct fuse_file_info *fi);
+int fuse_fs_readdir(struct fuse_fs *fs, const char *path, void *buf,
+		    fuse_fill_dir_t filler, off64_t off,
+		    struct fuse_file_info *fi);
+int fuse_fs_fsyncdir(struct fuse_fs *fs, const char *path, int datasync,
+		     struct fuse_file_info *fi);
+int fuse_fs_releasedir(struct fuse_fs *fs, const char *path,
+		       struct fuse_file_info *fi);
+int fuse_fs_create(struct fuse_fs *fs, const char *path, mode_t mode,
+		   struct fuse_file_info *fi);
+int fuse_fs_lock(struct fuse_fs *fs, const char *path,
+		 struct fuse_file_info *fi, int cmd, struct flock *lock);
+int fuse_fs_flock(struct fuse_fs *fs, const char *path,
+		  struct fuse_file_info *fi, int op);
+int fuse_fs_chmod(struct fuse_fs *fs, const char *path, mode_t mode);
+int fuse_fs_chown(struct fuse_fs *fs, const char *path, uid_t uid, gid_t gid);
+int fuse_fs_truncate(struct fuse_fs *fs, const char *path, off64_t size);
+int fuse_fs_ftruncate(struct fuse_fs *fs, const char *path, off64_t size,
+		      struct fuse_file_info *fi);
+int fuse_fs_utimens(struct fuse_fs *fs, const char *path,
+		    const struct timespec tv[2]);
+int fuse_fs_access(struct fuse_fs *fs, const char *path, int mask);
+int fuse_fs_readlink(struct fuse_fs *fs, const char *path, char *buf,
+		     size_t len);
+int fuse_fs_mknod(struct fuse_fs *fs, const char *path, mode_t mode,
+		  dev_t rdev);
+int fuse_fs_mkdir(struct fuse_fs *fs, const char *path, mode_t mode);
+int fuse_fs_setxattr(struct fuse_fs *fs, const char *path, const char *name,
+		     const char *value, size_t size, int flags);
+int fuse_fs_getxattr(struct fuse_fs *fs, const char *path, const char *name,
+		     char *value, size_t size);
+int fuse_fs_listxattr(struct fuse_fs *fs, const char *path, char *list,
+		      size_t size);
+int fuse_fs_removexattr(struct fuse_fs *fs, const char *path,
+			const char *name);
+int fuse_fs_bmap(struct fuse_fs *fs, const char *path, size_t blocksize,
+		 uint64_t *idx);
+int fuse_fs_ioctl(struct fuse_fs *fs, const char *path, int cmd, void *arg,
+		  struct fuse_file_info *fi, unsigned int flags, void *data);
+int fuse_fs_poll(struct fuse_fs *fs, const char *path,
+		 struct fuse_file_info *fi, struct fuse_pollhandle *ph,
+		 unsigned *reventsp);
+int fuse_fs_fallocate(struct fuse_fs *fs, const char *path, int mode,
+		 off64_t offset, off64_t length, struct fuse_file_info *fi);
+void fuse_fs_init(struct fuse_fs *fs, struct fuse_conn_info *conn);
+void fuse_fs_destroy(struct fuse_fs *fs);
+
+int fuse_notify_poll(struct fuse_pollhandle *ph);
+
+/**
+ * Create a new fuse filesystem object
+ *
+ * This is usually called from the factory of a fuse module to create
+ * a new instance of a filesystem.
+ *
+ * @param op the filesystem operations
+ * @param op_size the size of the fuse_operations structure
+ * @param user_data user data supplied in the context during the init() method
+ * @return a new filesystem object
+ */
+struct fuse_fs *fuse_fs_new(const struct fuse_operations *op, size_t op_size,
+			    void *user_data);
+
+/**
+ * Filesystem module
+ *
+ * Filesystem modules are registered with the FUSE_REGISTER_MODULE()
+ * macro.
+ *
+ * If the "-omodules=modname:..." option is present, filesystem
+ * objects are created and pushed onto the stack with the 'factory'
+ * function.
+ */
+struct fuse_module {
+	/**
+	 * Name of filesystem
+	 */
+	const char *name;
+
+	/**
+	 * Factory for creating filesystem objects
+	 *
+	 * The function may use and remove options from 'args' that belong
+	 * to this module.
+	 *
+	 * For now the 'fs' vector always contains exactly one filesystem.
+	 * This is the filesystem which will be below the newly created
+	 * filesystem in the stack.
+	 *
+	 * @param args the command line arguments
+	 * @param fs NULL terminated filesystem object vector
+	 * @return the new filesystem object
+	 */
+	struct fuse_fs *(*factory)(struct fuse_args *args,
+				   struct fuse_fs *fs[]);
+
+	struct fuse_module *next;
+	struct fusemod_so *so;
+	int ctr;
+};
+
+/**
+ * Register a filesystem module
+ *
+ * This function is used by FUSE_REGISTER_MODULE and there's usually
+ * no need to call it directly
+ */
+void fuse_register_module(struct fuse_module *mod);
+
+/**
+ * Register filesystem module
+ *
+ * For the parameters, see description of the fields in 'struct
+ * fuse_module'
+ */
+#define FUSE_REGISTER_MODULE(name_, factory_)				  \
+	static __attribute__((constructor)) void name_ ## _register(void) \
+	{								  \
+		static struct fuse_module mod =				  \
+			{ #name_, factory_, NULL, NULL, 0 };		  \
+		fuse_register_module(&mod);				  \
+	}
+
+
+/* ----------------------------------------------------------- *
+ * Advanced API for event handling, don't worry about this...  *
+ * ----------------------------------------------------------- */
+
+/* NOTE: the following functions are deprecated, and will be removed
+   from the 3.0 API.  Use the lowlevel session functions instead */
+
+/** Function type used to process commands */
+typedef void (*fuse_processor_t)(struct fuse *, struct fuse_cmd *, void *);
+
+/** This is the part of fuse_main() before the event loop */
+struct fuse *fuse_setup(int argc, char *argv[],
+			const struct fuse_operations *op, size_t op_size,
+			char **mountpoint, int *multithreaded,
+			void *user_data);
+
+/** This is the part of fuse_main() after the event loop */
+void fuse_teardown(struct fuse *fuse, char *mountpoint);
+
+/** Read a single command.  If none are read, return NULL */
+struct fuse_cmd *fuse_read_cmd(struct fuse *f);
+
+/** Process a single command */
+void fuse_process_cmd(struct fuse *f, struct fuse_cmd *cmd);
+
+/** Multi threaded event loop, which calls the custom command
+    processor function */
+int fuse_loop_mt_proc(struct fuse *f, fuse_processor_t proc, void *data);
+
+/** Return the exited flag, which indicates if fuse_exit() has been
+    called */
+int fuse_exited(struct fuse *f);
+
+/** This function is obsolete and implemented as a no-op */
+void fuse_set_getcontext_func(struct fuse_context *(*func)(void));
+
+/** Get session from fuse object */
+struct fuse_session *fuse_get_session(struct fuse *f);
+
+/* ----------------------------------------------------------- *
+ * Compatibility stuff					       *
+ * ----------------------------------------------------------- */
+
+#if FUSE_USE_VERSION < 26
+#  include "fuse_compat.h"
+#  undef fuse_main
+#  if FUSE_USE_VERSION == 25
+#    define fuse_main(argc, argv, op)				\
+	fuse_main_real_compat25(argc, argv, op, sizeof(*(op)))
+#    define fuse_new fuse_new_compat25
+#    define fuse_setup fuse_setup_compat25
+#    define fuse_teardown fuse_teardown_compat22
+#    define fuse_operations fuse_operations_compat25
+#  elif FUSE_USE_VERSION == 22
+#    define fuse_main(argc, argv, op)				\
+	fuse_main_real_compat22(argc, argv, op, sizeof(*(op)))
+#    define fuse_new fuse_new_compat22
+#    define fuse_setup fuse_setup_compat22
+#    define fuse_teardown fuse_teardown_compat22
+#    define fuse_operations fuse_operations_compat22
+#    define fuse_file_info fuse_file_info_compat
+#  elif FUSE_USE_VERSION == 24
+#    error Compatibility with high-level API version 24 not supported
+#  else
+#    define fuse_dirfil_t fuse_dirfil_t_compat
+#    define __fuse_read_cmd fuse_read_cmd
+#    define __fuse_process_cmd fuse_process_cmd
+#    define __fuse_loop_mt fuse_loop_mt_proc
+#    if FUSE_USE_VERSION == 21
+#      define fuse_operations fuse_operations_compat2
+#      define fuse_main fuse_main_compat2
+#      define fuse_new fuse_new_compat2
+#      define __fuse_setup fuse_setup_compat2
+#      define __fuse_teardown fuse_teardown_compat22
+#      define __fuse_exited fuse_exited
+#      define __fuse_set_getcontext_func fuse_set_getcontext_func
+#    else
+#      define fuse_statfs fuse_statfs_compat1
+#      define fuse_operations fuse_operations_compat1
+#      define fuse_main fuse_main_compat1
+#      define fuse_new fuse_new_compat1
+#      define FUSE_DEBUG FUSE_DEBUG_COMPAT1
+#    endif
+#  endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _FUSE_H_ */
diff --git a/external/fuse/include/fuse_common.h b/external/fuse/include/fuse_common.h
new file mode 100755
index 0000000000..dab3a569a2
--- /dev/null
+++ b/external/fuse/include/fuse_common.h
@@ -0,0 +1,505 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB.
+*/
+
+/** @file */
+
+#if !defined(_FUSE_H_) && !defined(_FUSE_LOWLEVEL_H_)
+#error "Never include <fuse_common.h> directly; use <fuse.h> or <fuse_lowlevel.h> instead."
+#endif
+
+#ifndef _FUSE_COMMON_H_
+#define _FUSE_COMMON_H_
+
+#include "fuse_opt.h"
+#include <stdint.h>
+#include <sys/types.h>
+
+/** Major version of FUSE library interface */
+#define FUSE_MAJOR_VERSION 2
+
+/** Minor version of FUSE library interface */
+#define FUSE_MINOR_VERSION 9
+
+#define FUSE_MAKE_VERSION(maj, min)  ((maj) * 10 + (min))
+#define FUSE_VERSION FUSE_MAKE_VERSION(FUSE_MAJOR_VERSION, FUSE_MINOR_VERSION)
+
+/* This interface uses 64 bit off64_t */
+#if _FILE_OFFSET_BITS != 64
+#error Please add -D_FILE_OFFSET_BITS=64 to your compile flags!
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Information about open files
+ *
+ * Changed in version 2.5
+ */
+struct fuse_file_info {
+	/** Open flags.	 Available in open() and release() */
+	int flags;
+
+	/** Old file handle, don't use */
+	unsigned long fh_old;
+
+	/** In case of a write operation indicates if this was caused by a
+	    writepage */
+	int writepage;
+
+	/** Can be filled in by open, to use direct I/O on this file.
+	    Introduced in version 2.4 */
+	unsigned int direct_io : 1;
+
+	/** Can be filled in by open, to indicate, that cached file data
+	    need not be invalidated.  Introduced in version 2.4 */
+	unsigned int keep_cache : 1;
+
+	/** Indicates a flush operation.  Set in flush operation, also
+	    maybe set in highlevel lock operation and lowlevel release
+	    operation.	Introduced in version 2.6 */
+	unsigned int flush : 1;
+
+	/** Can be filled in by open, to indicate that the file is not
+	    seekable.  Introduced in version 2.8 */
+	unsigned int nonseekable : 1;
+
+	/* Indicates that flock locks for this file should be
+	   released.  If set, lock_owner shall contain a valid value.
+	   May only be set in ->release().  Introduced in version
+	   2.9 */
+	unsigned int flock_release : 1;
+
+	/** Padding.  Do not use*/
+	unsigned int padding : 27;
+
+	/** File handle.  May be filled in by filesystem in open().
+	    Available in all other file operations */
+	uint64_t fh;
+
+	/** Lock owner id.  Available in locking operations and flush */
+	uint64_t lock_owner;
+};
+
+/**
+ * Capability bits for 'fuse_conn_info.capable' and 'fuse_conn_info.want'
+ *
+ * FUSE_CAP_ASYNC_READ: filesystem supports asynchronous read requests
+ * FUSE_CAP_POSIX_LOCKS: filesystem supports "remote" locking
+ * FUSE_CAP_ATOMIC_O_TRUNC: filesystem handles the O_TRUNC open flag
+ * FUSE_CAP_EXPORT_SUPPORT: filesystem handles lookups of "." and ".."
+ * FUSE_CAP_BIG_WRITES: filesystem can handle write size larger than 4kB
+ * FUSE_CAP_DONT_MASK: don't apply umask to file mode on create operations
+ * FUSE_CAP_SPLICE_WRITE: ability to use splice() to write to the fuse device
+ * FUSE_CAP_SPLICE_MOVE: ability to move data to the fuse device with splice()
+ * FUSE_CAP_SPLICE_READ: ability to use splice() to read from the fuse device
+ * FUSE_CAP_IOCTL_DIR: ioctl support on directories
+ */
+#define FUSE_CAP_ASYNC_READ	(1 << 0)
+#define FUSE_CAP_POSIX_LOCKS	(1 << 1)
+#define FUSE_CAP_ATOMIC_O_TRUNC	(1 << 3)
+#define FUSE_CAP_EXPORT_SUPPORT	(1 << 4)
+#define FUSE_CAP_BIG_WRITES	(1 << 5)
+#define FUSE_CAP_DONT_MASK	(1 << 6)
+#define FUSE_CAP_SPLICE_WRITE	(1 << 7)
+#define FUSE_CAP_SPLICE_MOVE	(1 << 8)
+#define FUSE_CAP_SPLICE_READ	(1 << 9)
+#define FUSE_CAP_FLOCK_LOCKS	(1 << 10)
+#define FUSE_CAP_IOCTL_DIR	(1 << 11)
+
+/**
+ * Ioctl flags
+ *
+ * FUSE_IOCTL_COMPAT: 32bit compat ioctl on 64bit machine
+ * FUSE_IOCTL_UNRESTRICTED: not restricted to well-formed ioctls, retry allowed
+ * FUSE_IOCTL_RETRY: retry with new iovecs
+ * FUSE_IOCTL_DIR: is a directory
+ *
+ * FUSE_IOCTL_MAX_IOV: maximum of in_iovecs + out_iovecs
+ */
+#define FUSE_IOCTL_COMPAT	(1 << 0)
+#define FUSE_IOCTL_UNRESTRICTED	(1 << 1)
+#define FUSE_IOCTL_RETRY	(1 << 2)
+#define FUSE_IOCTL_DIR		(1 << 4)
+
+#define FUSE_IOCTL_MAX_IOV	256
+
+/**
+ * Connection information, passed to the ->init() method
+ *
+ * Some of the elements are read-write, these can be changed to
+ * indicate the value requested by the filesystem.  The requested
+ * value must usually be smaller than the indicated value.
+ */
+struct fuse_conn_info {
+	/**
+	 * Major version of the protocol (read-only)
+	 */
+	unsigned proto_major;
+
+	/**
+	 * Minor version of the protocol (read-only)
+	 */
+	unsigned proto_minor;
+
+	/**
+	 * Is asynchronous read supported (read-write)
+	 */
+	unsigned async_read;
+
+	/**
+	 * Maximum size of the write buffer
+	 */
+	unsigned max_write;
+
+	/**
+	 * Maximum readahead
+	 */
+	unsigned max_readahead;
+
+	/**
+	 * Capability flags, that the kernel supports
+	 */
+	unsigned capable;
+
+	/**
+	 * Capability flags, that the filesystem wants to enable
+	 */
+	unsigned want;
+
+	/**
+	 * Maximum number of backgrounded requests
+	 */
+	unsigned max_background;
+
+	/**
+	 * Kernel congestion threshold parameter
+	 */
+	unsigned congestion_threshold;
+
+	/**
+	 * For future use.
+	 */
+	unsigned reserved[23];
+};
+
+struct fuse_session;
+struct fuse_chan;
+struct fuse_pollhandle;
+
+/**
+ * Create a FUSE mountpoint
+ *
+ * Returns a control file descriptor suitable for passing to
+ * fuse_new()
+ *
+ * @param mountpoint the mount point path
+ * @param args argument vector
+ * @return the communication channel on success, NULL on failure
+ */
+struct fuse_chan *fuse_mount(const char *mountpoint, struct fuse_args *args);
+
+/**
+ * Umount a FUSE mountpoint
+ *
+ * @param mountpoint the mount point path
+ * @param ch the communication channel
+ */
+void fuse_unmount(const char *mountpoint, struct fuse_chan *ch);
+
+/**
+ * Parse common options
+ *
+ * The following options are parsed:
+ *
+ *   '-f'	     foreground
+ *   '-d' '-odebug'  foreground, but keep the debug option
+ *   '-s'	     single threaded
+ *   '-h' '--help'   help
+ *   '-ho'	     help without header
+ *   '-ofsname=..'   file system name, if not present, then set to the program
+ *		     name
+ *
+ * All parameters may be NULL
+ *
+ * @param args argument vector
+ * @param mountpoint the returned mountpoint, should be freed after use
+ * @param multithreaded set to 1 unless the '-s' option is present
+ * @param foreground set to 1 if one of the relevant options is present
+ * @return 0 on success, -1 on failure
+ */
+int fuse_parse_cmdline(struct fuse_args *args, char **mountpoint,
+		       int *multithreaded, int *foreground);
+
+/**
+ * Go into the background
+ *
+ * @param foreground if true, stay in the foreground
+ * @return 0 on success, -1 on failure
+ */
+int fuse_daemonize(int foreground);
+
+/**
+ * Get the version of the library
+ *
+ * @return the version
+ */
+int fuse_version(void);
+
+/**
+ * Destroy poll handle
+ *
+ * @param ph the poll handle
+ */
+void fuse_pollhandle_destroy(struct fuse_pollhandle *ph);
+
+/* ----------------------------------------------------------- *
+ * Data buffer						       *
+ * ----------------------------------------------------------- */
+
+/**
+ * Buffer flags
+ */
+enum fuse_buf_flags {
+	/**
+	 * Buffer contains a file descriptor
+	 *
+	 * If this flag is set, the .fd field is valid, otherwise the
+	 * .mem fields is valid.
+	 */
+	FUSE_BUF_IS_FD		= (1 << 1),
+
+	/**
+	 * Seek on the file descriptor
+	 *
+	 * If this flag is set then the .pos field is valid and is
+	 * used to seek to the given offset before performing
+	 * operation on file descriptor.
+	 */
+	FUSE_BUF_FD_SEEK	= (1 << 2),
+
+	/**
+	 * Retry operation on file descriptor
+	 *
+	 * If this flag is set then retry operation on file descriptor
+	 * until .size bytes have been copied or an error or EOF is
+	 * detected.
+	 */
+	FUSE_BUF_FD_RETRY	= (1 << 3),
+};
+
+/**
+ * Buffer copy flags
+ */
+enum fuse_buf_copy_flags {
+	/**
+	 * Don't use splice(2)
+	 *
+	 * Always fall back to using read and write instead of
+	 * splice(2) to copy data from one file descriptor to another.
+	 *
+	 * If this flag is not set, then only fall back if splice is
+	 * unavailable.
+	 */
+	FUSE_BUF_NO_SPLICE	= (1 << 1),
+
+	/**
+	 * Force splice
+	 *
+	 * Always use splice(2) to copy data from one file descriptor
+	 * to another.  If splice is not available, return -EINVAL.
+	 */
+	FUSE_BUF_FORCE_SPLICE	= (1 << 2),
+
+	/**
+	 * Try to move data with splice.
+	 *
+	 * If splice is used, try to move pages from the source to the
+	 * destination instead of copying.  See documentation of
+	 * SPLICE_F_MOVE in splice(2) man page.
+	 */
+	FUSE_BUF_SPLICE_MOVE	= (1 << 3),
+
+	/**
+	 * Don't block on the pipe when copying data with splice
+	 *
+	 * Makes the operations on the pipe non-blocking (if the pipe
+	 * is full or empty).  See SPLICE_F_NONBLOCK in the splice(2)
+	 * man page.
+	 */
+	FUSE_BUF_SPLICE_NONBLOCK= (1 << 4),
+};
+
+/**
+ * Single data buffer
+ *
+ * Generic data buffer for I/O, extended attributes, etc...  Data may
+ * be supplied as a memory pointer or as a file descriptor
+ */
+struct fuse_buf {
+	/**
+	 * Size of data in bytes
+	 */
+	size_t size;
+
+	/**
+	 * Buffer flags
+	 */
+	enum fuse_buf_flags flags;
+
+	/**
+	 * Memory pointer
+	 *
+	 * Used unless FUSE_BUF_IS_FD flag is set.
+	 */
+	void *mem;
+
+	/**
+	 * File descriptor
+	 *
+	 * Used if FUSE_BUF_IS_FD flag is set.
+	 */
+	int fd;
+
+	/**
+	 * File position
+	 *
+	 * Used if FUSE_BUF_FD_SEEK flag is set.
+	 */
+	off64_t pos;
+};
+
+/**
+ * Data buffer vector
+ *
+ * An array of data buffers, each containing a memory pointer or a
+ * file descriptor.
+ *
+ * Allocate dynamically to add more than one buffer.
+ */
+struct fuse_bufvec {
+	/**
+	 * Number of buffers in the array
+	 */
+	size_t count;
+
+	/**
+	 * Index of current buffer within the array
+	 */
+	size_t idx;
+
+	/**
+	 * Current offset within the current buffer
+	 */
+	size_t off;
+
+	/**
+	 * Array of buffers
+	 */
+	struct fuse_buf buf[1];
+};
+
+/* Initialize bufvec with a single buffer of given size */
+#define FUSE_BUFVEC_INIT(size__) 				\
+	((struct fuse_bufvec) {					\
+		/* .count= */ 1,				\
+		/* .idx =  */ 0,				\
+		/* .off =  */ 0,				\
+		/* .buf =  */ { /* [0] = */ {			\
+			/* .size =  */ (size__),		\
+			/* .flags = */ (enum fuse_buf_flags) 0,	\
+			/* .mem =   */ NULL,			\
+			/* .fd =    */ -1,			\
+			/* .pos =   */ 0,			\
+		} }						\
+	} )
+
+/**
+ * Get total size of data in a fuse buffer vector
+ *
+ * @param bufv buffer vector
+ * @return size of data
+ */
+size_t fuse_buf_size(const struct fuse_bufvec *bufv);
+
+/**
+ * Copy data from one buffer vector to another
+ *
+ * @param dst destination buffer vector
+ * @param src source buffer vector
+ * @param flags flags controlling the copy
+ * @return actual number of bytes copied or -errno on error
+ */
+ssize_t fuse_buf_copy(struct fuse_bufvec *dst, struct fuse_bufvec *src,
+		      enum fuse_buf_copy_flags flags);
+
+/* ----------------------------------------------------------- *
+ * Signal handling					       *
+ * ----------------------------------------------------------- */
+
+/**
+ * Exit session on HUP, TERM and INT signals and ignore PIPE signal
+ *
+ * Stores session in a global variable.	 May only be called once per
+ * process until fuse_remove_signal_handlers() is called.
+ *
+ * @param se the session to exit
+ * @return 0 on success, -1 on failure
+ */
+int fuse_set_signal_handlers(struct fuse_session *se);
+
+/**
+ * Restore default signal handlers
+ *
+ * Resets global session.  After this fuse_set_signal_handlers() may
+ * be called again.
+ *
+ * @param se the same session as given in fuse_set_signal_handlers()
+ */
+void fuse_remove_signal_handlers(struct fuse_session *se);
+
+/* ----------------------------------------------------------- *
+ * Compatibility stuff					       *
+ * ----------------------------------------------------------- */
+
+#if FUSE_USE_VERSION < 26
+#    ifdef __FreeBSD__
+#	 if FUSE_USE_VERSION < 25
+#	     error On FreeBSD API version 25 or greater must be used
+#	 endif
+#    endif
+#    include "fuse_common_compat.h"
+#    undef FUSE_MINOR_VERSION
+#    undef fuse_main
+#    define fuse_unmount fuse_unmount_compat22
+#    if FUSE_USE_VERSION == 25
+#	 define FUSE_MINOR_VERSION 5
+#	 define fuse_mount fuse_mount_compat25
+#    elif FUSE_USE_VERSION == 24 || FUSE_USE_VERSION == 22
+#	 define FUSE_MINOR_VERSION 4
+#	 define fuse_mount fuse_mount_compat22
+#    elif FUSE_USE_VERSION == 21
+#	 define FUSE_MINOR_VERSION 1
+#	 define fuse_mount fuse_mount_compat22
+#    elif FUSE_USE_VERSION == 11
+#	 warning Compatibility with API version 11 is deprecated
+#	 undef FUSE_MAJOR_VERSION
+#	 define FUSE_MAJOR_VERSION 1
+#	 define FUSE_MINOR_VERSION 1
+#	 define fuse_mount fuse_mount_compat1
+#    else
+#	 error Compatibility with API version other than 21, 22, 24, 25 and 11 not supported
+#    endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _FUSE_COMMON_H_ */
diff --git a/external/fuse/include/fuse_common_compat.h b/external/fuse/include/fuse_common_compat.h
new file mode 100755
index 0000000000..34440ff716
--- /dev/null
+++ b/external/fuse/include/fuse_common_compat.h
@@ -0,0 +1,26 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB.
+*/
+
+/* these definitions provide source compatibility to prior versions.
+   Do not include this file directly! */
+
+struct fuse_file_info_compat {
+	int flags;
+	unsigned long fh;
+	int writepage;
+	unsigned int direct_io : 1;
+	unsigned int keep_cache : 1;
+};
+
+int fuse_mount_compat25(const char *mountpoint, struct fuse_args *args);
+
+int fuse_mount_compat22(const char *mountpoint, const char *opts);
+
+int fuse_mount_compat1(const char *mountpoint, const char *args[]);
+
+void fuse_unmount_compat22(const char *mountpoint);
diff --git a/external/fuse/include/fuse_compat.h b/external/fuse/include/fuse_compat.h
new file mode 100755
index 0000000000..d09323844d
--- /dev/null
+++ b/external/fuse/include/fuse_compat.h
@@ -0,0 +1,201 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB.
+*/
+
+/* these definitions provide source compatibility to prior versions.
+   Do not include this file directly! */
+
+struct fuse_operations_compat25 {
+	int (*getattr) (const char *, struct stat *);
+	int (*readlink) (const char *, char *, size_t);
+	int (*getdir) (const char *, fuse_dirh_t, fuse_dirfil_t);
+	int (*mknod) (const char *, mode_t, dev_t);
+	int (*mkdir) (const char *, mode_t);
+	int (*unlink) (const char *);
+	int (*rmdir) (const char *);
+	int (*symlink) (const char *, const char *);
+	int (*rename) (const char *, const char *);
+	int (*link) (const char *, const char *);
+	int (*chmod) (const char *, mode_t);
+	int (*chown) (const char *, uid_t, gid_t);
+	int (*truncate) (const char *, off64_t);
+	int (*utime) (const char *, struct utimbuf *);
+	int (*open) (const char *, struct fuse_file_info *);
+	int (*read) (const char *, char *, size_t, off64_t,
+		     struct fuse_file_info *);
+	int (*write) (const char *, const char *, size_t, off64_t,
+		      struct fuse_file_info *);
+	int (*statfs) (const char *, struct statvfs *);
+	int (*flush) (const char *, struct fuse_file_info *);
+	int (*release) (const char *, struct fuse_file_info *);
+	int (*fsync) (const char *, int, struct fuse_file_info *);
+	int (*setxattr) (const char *, const char *, const char *, size_t, int);
+	int (*getxattr) (const char *, const char *, char *, size_t);
+	int (*listxattr) (const char *, char *, size_t);
+	int (*removexattr) (const char *, const char *);
+	int (*opendir) (const char *, struct fuse_file_info *);
+	int (*readdir) (const char *, void *, fuse_fill_dir_t, off64_t,
+			struct fuse_file_info *);
+	int (*releasedir) (const char *, struct fuse_file_info *);
+	int (*fsyncdir) (const char *, int, struct fuse_file_info *);
+	void *(*init) (void);
+	void (*destroy) (void *);
+	int (*access) (const char *, int);
+	int (*create) (const char *, mode_t, struct fuse_file_info *);
+	int (*ftruncate) (const char *, off64_t, struct fuse_file_info *);
+	int (*fgetattr) (const char *, struct stat *, struct fuse_file_info *);
+};
+
+struct fuse *fuse_new_compat25(int fd, struct fuse_args *args,
+			       const struct fuse_operations_compat25 *op,
+			       size_t op_size);
+
+int fuse_main_real_compat25(int argc, char *argv[],
+			    const struct fuse_operations_compat25 *op,
+			    size_t op_size);
+
+struct fuse *fuse_setup_compat25(int argc, char *argv[],
+				 const struct fuse_operations_compat25 *op,
+				 size_t op_size, char **mountpoint,
+				 int *multithreaded, int *fd);
+
+void fuse_teardown_compat22(struct fuse *fuse, int fd, char *mountpoint);
+
+#if !defined(__FreeBSD__) && !defined(__NetBSD__)
+#include <sys/statfs.h>
+
+struct fuse_operations_compat22 {
+	int (*getattr) (const char *, struct stat *);
+	int (*readlink) (const char *, char *, size_t);
+	int (*getdir) (const char *, fuse_dirh_t, fuse_dirfil_t);
+	int (*mknod) (const char *, mode_t, dev_t);
+	int (*mkdir) (const char *, mode_t);
+	int (*unlink) (const char *);
+	int (*rmdir) (const char *);
+	int (*symlink) (const char *, const char *);
+	int (*rename) (const char *, const char *);
+	int (*link) (const char *, const char *);
+	int (*chmod) (const char *, mode_t);
+	int (*chown) (const char *, uid_t, gid_t);
+	int (*truncate) (const char *, off64_t);
+	int (*utime) (const char *, struct utimbuf *);
+	int (*open) (const char *, struct fuse_file_info_compat *);
+	int (*read) (const char *, char *, size_t, off64_t,
+		     struct fuse_file_info_compat *);
+	int (*write) (const char *, const char *, size_t, off64_t,
+		      struct fuse_file_info_compat *);
+	int (*statfs) (const char *, struct statfs *);
+	int (*flush) (const char *, struct fuse_file_info_compat *);
+	int (*release) (const char *, struct fuse_file_info_compat *);
+	int (*fsync) (const char *, int, struct fuse_file_info_compat *);
+	int (*setxattr) (const char *, const char *, const char *, size_t, int);
+	int (*getxattr) (const char *, const char *, char *, size_t);
+	int (*listxattr) (const char *, char *, size_t);
+	int (*removexattr) (const char *, const char *);
+	int (*opendir) (const char *, struct fuse_file_info_compat *);
+	int (*readdir) (const char *, void *, fuse_fill_dir_t, off64_t,
+			struct fuse_file_info_compat *);
+	int (*releasedir) (const char *, struct fuse_file_info_compat *);
+	int (*fsyncdir) (const char *, int, struct fuse_file_info_compat *);
+	void *(*init) (void);
+	void (*destroy) (void *);
+};
+
+struct fuse *fuse_new_compat22(int fd, const char *opts,
+			       const struct fuse_operations_compat22 *op,
+			       size_t op_size);
+
+struct fuse *fuse_setup_compat22(int argc, char *argv[],
+				 const struct fuse_operations_compat22 *op,
+				 size_t op_size, char **mountpoint,
+				 int *multithreaded, int *fd);
+
+int fuse_main_real_compat22(int argc, char *argv[],
+			    const struct fuse_operations_compat22 *op,
+			    size_t op_size);
+
+typedef int (*fuse_dirfil_t_compat) (fuse_dirh_t h, const char *name, int type);
+struct fuse_operations_compat2 {
+	int (*getattr)	   (const char *, struct stat *);
+	int (*readlink)	   (const char *, char *, size_t);
+	int (*getdir)	   (const char *, fuse_dirh_t, fuse_dirfil_t_compat);
+	int (*mknod)	   (const char *, mode_t, dev_t);
+	int (*mkdir)	   (const char *, mode_t);
+	int (*unlink)	   (const char *);
+	int (*rmdir)	   (const char *);
+	int (*symlink)	   (const char *, const char *);
+	int (*rename)	   (const char *, const char *);
+	int (*link)	   (const char *, const char *);
+	int (*chmod)	   (const char *, mode_t);
+	int (*chown)	   (const char *, uid_t, gid_t);
+	int (*truncate)	   (const char *, off64_t);
+	int (*utime)	   (const char *, struct utimbuf *);
+	int (*open)	   (const char *, int);
+	int (*read)	   (const char *, char *, size_t, off64_t);
+	int (*write)	   (const char *, const char *, size_t, off64_t);
+	int (*statfs)	   (const char *, struct statfs *);
+	int (*flush)	   (const char *);
+	int (*release)	   (const char *, int);
+	int (*fsync)	   (const char *, int);
+	int (*setxattr)	   (const char *, const char *, const char *,
+			    size_t, int);
+	int (*getxattr)	   (const char *, const char *, char *, size_t);
+	int (*listxattr)   (const char *, char *, size_t);
+	int (*removexattr) (const char *, const char *);
+};
+
+int fuse_main_compat2(int argc, char *argv[],
+		      const struct fuse_operations_compat2 *op);
+
+struct fuse *fuse_new_compat2(int fd, const char *opts,
+			      const struct fuse_operations_compat2 *op);
+
+struct fuse *fuse_setup_compat2(int argc, char *argv[],
+				const struct fuse_operations_compat2 *op,
+				char **mountpoint, int *multithreaded, int *fd);
+
+struct fuse_statfs_compat1 {
+	long block_size;
+	long blocks;
+	long blocks_free;
+	long files;
+	long files_free;
+	long namelen;
+};
+
+struct fuse_operations_compat1 {
+	int (*getattr)	(const char *, struct stat *);
+	int (*readlink) (const char *, char *, size_t);
+	int (*getdir)	(const char *, fuse_dirh_t, fuse_dirfil_t_compat);
+	int (*mknod)	(const char *, mode_t, dev_t);
+	int (*mkdir)	(const char *, mode_t);
+	int (*unlink)	(const char *);
+	int (*rmdir)	(const char *);
+	int (*symlink)	(const char *, const char *);
+	int (*rename)	(const char *, const char *);
+	int (*link)	(const char *, const char *);
+	int (*chmod)	(const char *, mode_t);
+	int (*chown)	(const char *, uid_t, gid_t);
+	int (*truncate) (const char *, off64_t);
+	int (*utime)	(const char *, struct utimbuf *);
+	int (*open)	(const char *, int);
+	int (*read)	(const char *, char *, size_t, off64_t);
+	int (*write)	(const char *, const char *, size_t, off64_t);
+	int (*statfs)	(struct fuse_statfs_compat1 *);
+	int (*release)	(const char *, int);
+	int (*fsync)	(const char *, int);
+};
+
+#define FUSE_DEBUG_COMPAT1	 (1 << 1)
+
+struct fuse *fuse_new_compat1(int fd, int flags,
+			      const struct fuse_operations_compat1 *op);
+
+void fuse_main_compat1(int argc, char *argv[],
+		       const struct fuse_operations_compat1 *op);
+
+#endif /* __FreeBSD__ || __NetBSD__ */
diff --git a/external/fuse/include/fuse_kernel.h b/external/fuse/include/fuse_kernel.h
new file mode 100755
index 0000000000..c632b58fbc
--- /dev/null
+++ b/external/fuse/include/fuse_kernel.h
@@ -0,0 +1,691 @@
+/*
+    This file defines the kernel interface of FUSE
+    Copyright (C) 2001-2008  Miklos Szeredi <miklos@szeredi.hu>
+
+    This program can be distributed under the terms of the GNU GPL.
+    See the file COPYING.
+
+    This -- and only this -- header file may also be distributed under
+    the terms of the BSD Licence as follows:
+
+    Copyright (C) 2001-2007 Miklos Szeredi. All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions
+    are met:
+    1. Redistributions of source code must retain the above copyright
+       notice, this list of conditions and the following disclaimer.
+    2. Redistributions in binary form must reproduce the above copyright
+       notice, this list of conditions and the following disclaimer in the
+       documentation and/or other materials provided with the distribution.
+
+    THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+    ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
+    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+    OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+    OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+    SUCH DAMAGE.
+*/
+
+/*
+ * This file defines the kernel interface of FUSE
+ *
+ * Protocol changelog:
+ *
+ * 7.9:
+ *  - new fuse_getattr_in input argument of GETATTR
+ *  - add lk_flags in fuse_lk_in
+ *  - add lock_owner field to fuse_setattr_in, fuse_read_in and fuse_write_in
+ *  - add blksize field to fuse_attr
+ *  - add file flags field to fuse_read_in and fuse_write_in
+ *
+ * 7.10
+ *  - add nonseekable open flag
+ *
+ * 7.11
+ *  - add IOCTL message
+ *  - add unsolicited notification support
+ *  - add POLL message and NOTIFY_POLL notification
+ *
+ * 7.12
+ *  - add umask flag to input argument of open, mknod and mkdir
+ *  - add notification messages for invalidation of inodes and
+ *    directory entries
+ *
+ * 7.13
+ *  - make max number of background requests and congestion threshold
+ *    tunables
+ *
+ * 7.14
+ *  - add splice support to fuse device
+ *
+ * 7.15
+ *  - add store notify
+ *  - add retrieve notify
+ *
+ * 7.16
+ *  - add BATCH_FORGET request
+ *  - FUSE_IOCTL_UNRESTRICTED shall now return with array of 'struct
+ *    fuse_ioctl_iovec' instead of ambiguous 'struct iovec'
+ *  - add FUSE_IOCTL_32BIT flag
+ *
+ * 7.17
+ *  - add FUSE_FLOCK_LOCKS and FUSE_RELEASE_FLOCK_UNLOCK
+ *
+ * 7.18
+ *  - add FUSE_IOCTL_DIR flag
+ *  - add FUSE_NOTIFY_DELETE
+ *
+ * 7.19
+ *  - add FUSE_FALLOCATE
+ */
+
+#ifndef _LINUX_FUSE_H
+#define _LINUX_FUSE_H
+
+#include <sys/types.h>
+#define __u64 uint64_t
+#define __s64 int64_t
+#define __u32 uint32_t
+#define __s32 int32_t
+#define __u16 uint16_t
+
+/*
+ * Version negotiation:
+ *
+ * Both the kernel and userspace send the version they support in the
+ * INIT request and reply respectively.
+ *
+ * If the major versions match then both shall use the smallest
+ * of the two minor versions for communication.
+ *
+ * If the kernel supports a larger major version, then userspace shall
+ * reply with the major version it supports, ignore the rest of the
+ * INIT message and expect a new INIT message from the kernel with a
+ * matching major version.
+ *
+ * If the library supports a larger major version, then it shall fall
+ * back to the major protocol version sent by the kernel for
+ * communication and reply with that major version (and an arbitrary
+ * supported minor version).
+ */
+
+/** Version number of this interface */
+#define FUSE_KERNEL_VERSION 7
+
+/** Minor version number of this interface */
+#define FUSE_KERNEL_MINOR_VERSION 19
+
+/** The node ID of the root inode */
+#define FUSE_ROOT_ID 1
+
+/* Make sure all structures are padded to 64bit boundary, so 32bit
+   userspace works under 64bit kernels */
+
+struct fuse_attr {
+	__u64	ino;
+	__u64	size;
+	__u64	blocks;
+	__u64	atime;
+	__u64	mtime;
+	__u64	ctime;
+	__u32	atimensec;
+	__u32	mtimensec;
+	__u32	ctimensec;
+	__u32	mode;
+	__u32	nlink;
+	__u32	uid;
+	__u32	gid;
+	__u32	rdev;
+	__u32	blksize;
+	__u32	padding;
+};
+
+struct fuse_kstatfs {
+	__u64	blocks;
+	__u64	bfree;
+	__u64	bavail;
+	__u64	files;
+	__u64	ffree;
+	__u32	bsize;
+	__u32	namelen;
+	__u32	frsize;
+	__u32	padding;
+	__u32	spare[6];
+};
+
+struct fuse_file_lock {
+	__u64	start;
+	__u64	end;
+	__u32	type;
+	__u32	pid; /* tgid */
+};
+
+/**
+ * Bitmasks for fuse_setattr_in.valid
+ */
+#define FATTR_MODE	(1 << 0)
+#define FATTR_UID	(1 << 1)
+#define FATTR_GID	(1 << 2)
+#define FATTR_SIZE	(1 << 3)
+#define FATTR_ATIME	(1 << 4)
+#define FATTR_MTIME	(1 << 5)
+#define FATTR_FH	(1 << 6)
+#define FATTR_ATIME_NOW	(1 << 7)
+#define FATTR_MTIME_NOW	(1 << 8)
+#define FATTR_LOCKOWNER	(1 << 9)
+
+/**
+ * Flags returned by the OPEN request
+ *
+ * FOPEN_DIRECT_IO: bypass page cache for this open file
+ * FOPEN_KEEP_CACHE: don't invalidate the data cache on open
+ * FOPEN_NONSEEKABLE: the file is not seekable
+ */
+#define FOPEN_DIRECT_IO		(1 << 0)
+#define FOPEN_KEEP_CACHE	(1 << 1)
+#define FOPEN_NONSEEKABLE	(1 << 2)
+
+/**
+ * INIT request/reply flags
+ *
+ * FUSE_POSIX_LOCKS: remote locking for POSIX file locks
+ * FUSE_EXPORT_SUPPORT: filesystem handles lookups of "." and ".."
+ * FUSE_DONT_MASK: don't apply umask to file mode on create operations
+ * FUSE_FLOCK_LOCKS: remote locking for BSD style file locks
+ */
+#define FUSE_ASYNC_READ		(1 << 0)
+#define FUSE_POSIX_LOCKS	(1 << 1)
+#define FUSE_FILE_OPS		(1 << 2)
+#define FUSE_ATOMIC_O_TRUNC	(1 << 3)
+#define FUSE_EXPORT_SUPPORT	(1 << 4)
+#define FUSE_BIG_WRITES		(1 << 5)
+#define FUSE_DONT_MASK		(1 << 6)
+#define FUSE_FLOCK_LOCKS	(1 << 10)
+
+/**
+ * CUSE INIT request/reply flags
+ *
+ * CUSE_UNRESTRICTED_IOCTL:  use unrestricted ioctl
+ */
+#define CUSE_UNRESTRICTED_IOCTL	(1 << 0)
+
+/**
+ * Release flags
+ */
+#define FUSE_RELEASE_FLUSH	(1 << 0)
+#define FUSE_RELEASE_FLOCK_UNLOCK	(1 << 1)
+
+/**
+ * Getattr flags
+ */
+#define FUSE_GETATTR_FH		(1 << 0)
+
+/**
+ * Lock flags
+ */
+#define FUSE_LK_FLOCK		(1 << 0)
+
+/**
+ * WRITE flags
+ *
+ * FUSE_WRITE_CACHE: delayed write from page cache, file handle is guessed
+ * FUSE_WRITE_LOCKOWNER: lock_owner field is valid
+ */
+#define FUSE_WRITE_CACHE	(1 << 0)
+#define FUSE_WRITE_LOCKOWNER	(1 << 1)
+
+/**
+ * Read flags
+ */
+#define FUSE_READ_LOCKOWNER	(1 << 1)
+
+/**
+ * Ioctl flags
+ *
+ * FUSE_IOCTL_COMPAT: 32bit compat ioctl on 64bit machine
+ * FUSE_IOCTL_UNRESTRICTED: not restricted to well-formed ioctls, retry allowed
+ * FUSE_IOCTL_RETRY: retry with new iovecs
+ * FUSE_IOCTL_32BIT: 32bit ioctl
+ * FUSE_IOCTL_DIR: is a directory
+ *
+ * FUSE_IOCTL_MAX_IOV: maximum of in_iovecs + out_iovecs
+ */
+#define FUSE_IOCTL_COMPAT	(1 << 0)
+#define FUSE_IOCTL_UNRESTRICTED	(1 << 1)
+#define FUSE_IOCTL_RETRY	(1 << 2)
+#define FUSE_IOCTL_32BIT	(1 << 3)
+#define FUSE_IOCTL_DIR		(1 << 4)
+
+#define FUSE_IOCTL_MAX_IOV	256
+
+/**
+ * Poll flags
+ *
+ * FUSE_POLL_SCHEDULE_NOTIFY: request poll notify
+ */
+#define FUSE_POLL_SCHEDULE_NOTIFY (1 << 0)
+
+enum fuse_opcode {
+	FUSE_LOOKUP	   = 1,
+	FUSE_FORGET	   = 2,  /* no reply */
+	FUSE_GETATTR	   = 3,
+	FUSE_SETATTR	   = 4,
+	FUSE_READLINK	   = 5,
+	FUSE_SYMLINK	   = 6,
+	FUSE_MKNOD	   = 8,
+	FUSE_MKDIR	   = 9,
+	FUSE_UNLINK	   = 10,
+	FUSE_RMDIR	   = 11,
+	FUSE_RENAME	   = 12,
+	FUSE_LINK	   = 13,
+	FUSE_OPEN	   = 14,
+	FUSE_READ	   = 15,
+	FUSE_WRITE	   = 16,
+	FUSE_STATFS	   = 17,
+	FUSE_RELEASE       = 18,
+	FUSE_FSYNC         = 20,
+	FUSE_SETXATTR      = 21,
+	FUSE_GETXATTR      = 22,
+	FUSE_LISTXATTR     = 23,
+	FUSE_REMOVEXATTR   = 24,
+	FUSE_FLUSH         = 25,
+	FUSE_INIT          = 26,
+	FUSE_OPENDIR       = 27,
+	FUSE_READDIR       = 28,
+	FUSE_RELEASEDIR    = 29,
+	FUSE_FSYNCDIR      = 30,
+	FUSE_GETLK         = 31,
+	FUSE_SETLK         = 32,
+	FUSE_SETLKW        = 33,
+	FUSE_ACCESS        = 34,
+	FUSE_CREATE        = 35,
+	FUSE_INTERRUPT     = 36,
+	FUSE_BMAP          = 37,
+	FUSE_DESTROY       = 38,
+	FUSE_IOCTL         = 39,
+	FUSE_POLL          = 40,
+	FUSE_NOTIFY_REPLY  = 41,
+	FUSE_BATCH_FORGET  = 42,
+	FUSE_FALLOCATE     = 43,
+
+	/* CUSE specific operations */
+	CUSE_INIT          = 4096,
+};
+
+enum fuse_notify_code {
+	FUSE_NOTIFY_POLL   = 1,
+	FUSE_NOTIFY_INVAL_INODE = 2,
+	FUSE_NOTIFY_INVAL_ENTRY = 3,
+	FUSE_NOTIFY_STORE = 4,
+	FUSE_NOTIFY_RETRIEVE = 5,
+	FUSE_NOTIFY_DELETE = 6,
+	FUSE_NOTIFY_CODE_MAX,
+};
+
+/* The read buffer is required to be at least 8k, but may be much larger */
+#define FUSE_MIN_READ_BUFFER 8192
+
+#define FUSE_COMPAT_ENTRY_OUT_SIZE 120
+
+struct fuse_entry_out {
+	__u64	nodeid;		/* Inode ID */
+	__u64	generation;	/* Inode generation: nodeid:gen must
+				   be unique for the fs's lifetime */
+	__u64	entry_valid;	/* Cache timeout for the name */
+	__u64	attr_valid;	/* Cache timeout for the attributes */
+	__u32	entry_valid_nsec;
+	__u32	attr_valid_nsec;
+	struct fuse_attr attr;
+};
+
+struct fuse_forget_in {
+	__u64	nlookup;
+};
+
+struct fuse_forget_one {
+	__u64	nodeid;
+	__u64	nlookup;
+};
+
+struct fuse_batch_forget_in {
+	__u32	count;
+	__u32	dummy;
+};
+
+struct fuse_getattr_in {
+	__u32	getattr_flags;
+	__u32	dummy;
+	__u64	fh;
+};
+
+#define FUSE_COMPAT_ATTR_OUT_SIZE 96
+
+struct fuse_attr_out {
+	__u64	attr_valid;	/* Cache timeout for the attributes */
+	__u32	attr_valid_nsec;
+	__u32	dummy;
+	struct fuse_attr attr;
+};
+
+#define FUSE_COMPAT_MKNOD_IN_SIZE 8
+
+struct fuse_mknod_in {
+	__u32	mode;
+	__u32	rdev;
+	__u32	umask;
+	__u32	padding;
+};
+
+struct fuse_mkdir_in {
+	__u32	mode;
+	__u32	umask;
+};
+
+struct fuse_rename_in {
+	__u64	newdir;
+};
+
+struct fuse_link_in {
+	__u64	oldnodeid;
+};
+
+struct fuse_setattr_in {
+	__u32	valid;
+	__u32	padding;
+	__u64	fh;
+	__u64	size;
+	__u64	lock_owner;
+	__u64	atime;
+	__u64	mtime;
+	__u64	unused2;
+	__u32	atimensec;
+	__u32	mtimensec;
+	__u32	unused3;
+	__u32	mode;
+	__u32	unused4;
+	__u32	uid;
+	__u32	gid;
+	__u32	unused5;
+};
+
+struct fuse_open_in {
+	__u32	flags;
+	__u32	unused;
+};
+
+struct fuse_create_in {
+	__u32	flags;
+	__u32	mode;
+	__u32	umask;
+	__u32	padding;
+};
+
+struct fuse_open_out {
+	__u64	fh;
+	__u32	open_flags;
+	__u32	padding;
+};
+
+struct fuse_release_in {
+	__u64	fh;
+	__u32	flags;
+	__u32	release_flags;
+	__u64	lock_owner;
+};
+
+struct fuse_flush_in {
+	__u64	fh;
+	__u32	unused;
+	__u32	padding;
+	__u64	lock_owner;
+};
+
+struct fuse_read_in {
+	__u64	fh;
+	__u64	offset;
+	__u32	size;
+	__u32	read_flags;
+	__u64	lock_owner;
+	__u32	flags;
+	__u32	padding;
+};
+
+#define FUSE_COMPAT_WRITE_IN_SIZE 24
+
+struct fuse_write_in {
+	__u64	fh;
+	__u64	offset;
+	__u32	size;
+	__u32	write_flags;
+	__u64	lock_owner;
+	__u32	flags;
+	__u32	padding;
+};
+
+struct fuse_write_out {
+	__u32	size;
+	__u32	padding;
+};
+
+#define FUSE_COMPAT_STATFS_SIZE 48
+
+struct fuse_statfs_out {
+	struct fuse_kstatfs st;
+};
+
+struct fuse_fsync_in {
+	__u64	fh;
+	__u32	fsync_flags;
+	__u32	padding;
+};
+
+struct fuse_setxattr_in {
+	__u32	size;
+	__u32	flags;
+};
+
+struct fuse_getxattr_in {
+	__u32	size;
+	__u32	padding;
+};
+
+struct fuse_getxattr_out {
+	__u32	size;
+	__u32	padding;
+};
+
+struct fuse_lk_in {
+	__u64	fh;
+	__u64	owner;
+	struct fuse_file_lock lk;
+	__u32	lk_flags;
+	__u32	padding;
+};
+
+struct fuse_lk_out {
+	struct fuse_file_lock lk;
+};
+
+struct fuse_access_in {
+	__u32	mask;
+	__u32	padding;
+};
+
+struct fuse_init_in {
+	__u32	major;
+	__u32	minor;
+	__u32	max_readahead;
+	__u32	flags;
+};
+
+struct fuse_init_out {
+	__u32	major;
+	__u32	minor;
+	__u32	max_readahead;
+	__u32	flags;
+	__u16   max_background;
+	__u16   congestion_threshold;
+	__u32	max_write;
+};
+
+#define CUSE_INIT_INFO_MAX 4096
+
+struct cuse_init_in {
+	__u32	major;
+	__u32	minor;
+	__u32	unused;
+	__u32	flags;
+};
+
+struct cuse_init_out {
+	__u32	major;
+	__u32	minor;
+	__u32	unused;
+	__u32	flags;
+	__u32	max_read;
+	__u32	max_write;
+	__u32	dev_major;		/* chardev major */
+	__u32	dev_minor;		/* chardev minor */
+	__u32	spare[10];
+};
+
+struct fuse_interrupt_in {
+	__u64	unique;
+};
+
+struct fuse_bmap_in {
+	__u64	block;
+	__u32	blocksize;
+	__u32	padding;
+};
+
+struct fuse_bmap_out {
+	__u64	block;
+};
+
+struct fuse_ioctl_in {
+	__u64	fh;
+	__u32	flags;
+	__u32	cmd;
+	__u64	arg;
+	__u32	in_size;
+	__u32	out_size;
+};
+
+struct fuse_ioctl_iovec {
+	__u64	base;
+	__u64	len;
+};
+
+struct fuse_ioctl_out {
+	__s32	result;
+	__u32	flags;
+	__u32	in_iovs;
+	__u32	out_iovs;
+};
+
+struct fuse_poll_in {
+	__u64	fh;
+	__u64	kh;
+	__u32	flags;
+	__u32   padding;
+};
+
+struct fuse_poll_out {
+	__u32	revents;
+	__u32	padding;
+};
+
+struct fuse_notify_poll_wakeup_out {
+	__u64	kh;
+};
+
+struct fuse_fallocate_in {
+	__u64	fh;
+	__u64	offset;
+	__u64	length;
+	__u32	mode;
+	__u32	padding;
+};
+
+struct fuse_in_header {
+	__u32	len;
+	__u32	opcode;
+	__u64	unique;
+	__u64	nodeid;
+	__u32	uid;
+	__u32	gid;
+	__u32	pid;
+	__u32	padding;
+};
+
+struct fuse_out_header {
+	__u32	len;
+	__s32	error;
+	__u64	unique;
+};
+
+struct fuse_dirent {
+	__u64	ino;
+	__u64	off;
+	__u32	namelen;
+	__u32	type;
+	char name[];
+};
+
+#define FUSE_NAME_OFFSET offsetof(struct fuse_dirent, name)
+#define FUSE_DIRENT_ALIGN(x) (((x) + sizeof(__u64) - 1) & ~(sizeof(__u64) - 1))
+#define FUSE_DIRENT_SIZE(d) \
+	FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + (d)->namelen)
+
+struct fuse_notify_inval_inode_out {
+	__u64	ino;
+	__s64	off;
+	__s64	len;
+};
+
+struct fuse_notify_inval_entry_out {
+	__u64	parent;
+	__u32	namelen;
+	__u32	padding;
+};
+
+struct fuse_notify_delete_out {
+	__u64	parent;
+	__u64	child;
+	__u32	namelen;
+	__u32	padding;
+};
+
+struct fuse_notify_store_out {
+	__u64	nodeid;
+	__u64	offset;
+	__u32	size;
+	__u32	padding;
+};
+
+struct fuse_notify_retrieve_out {
+	__u64	notify_unique;
+	__u64	nodeid;
+	__u64	offset;
+	__u32	size;
+	__u32	padding;
+};
+
+/* Matches the size of fuse_write_in */
+struct fuse_notify_retrieve_in {
+	__u64	dummy1;
+	__u64	offset;
+	__u32	size;
+	__u32	dummy2;
+	__u64	dummy3;
+	__u64	dummy4;
+};
+
+#endif /* _LINUX_FUSE_H */
diff --git a/external/fuse/include/fuse_lowlevel.h b/external/fuse/include/fuse_lowlevel.h
new file mode 100755
index 0000000000..36cf26ddf6
--- /dev/null
+++ b/external/fuse/include/fuse_lowlevel.h
@@ -0,0 +1,1837 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB.
+*/
+
+#ifndef _FUSE_LOWLEVEL_H_
+#define _FUSE_LOWLEVEL_H_
+
+/** @file
+ *
+ * Low level API
+ *
+ * IMPORTANT: you should define FUSE_USE_VERSION before including this
+ * header.  To use the newest API define it to 26 (recommended for any
+ * new application), to use the old API define it to 24 (default) or
+ * 25
+ */
+
+#ifndef FUSE_USE_VERSION
+#define FUSE_USE_VERSION 24
+#endif
+
+#include "fuse_common.h"
+
+#include <utime.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statvfs.h>
+#include <sys/uio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ----------------------------------------------------------- *
+ * Miscellaneous definitions				       *
+ * ----------------------------------------------------------- */
+
+/** The node ID of the root inode */
+#define FUSE_ROOT_ID 1
+
+/** Inode number type */
+typedef unsigned long fuse_ino_t;
+
+/** Request pointer type */
+typedef struct fuse_req *fuse_req_t;
+
+/**
+ * Session
+ *
+ * This provides hooks for processing requests, and exiting
+ */
+struct fuse_session;
+
+/**
+ * Channel
+ *
+ * A communication channel, providing hooks for sending and receiving
+ * messages
+ */
+struct fuse_chan;
+
+/** Directory entry parameters supplied to fuse_reply_entry() */
+struct fuse_entry_param {
+	/** Unique inode number
+	 *
+	 * In lookup, zero means negative entry (from version 2.5)
+	 * Returning ENOENT also means negative entry, but by setting zero
+	 * ino the kernel may cache negative entries for entry_timeout
+	 * seconds.
+	 */
+	fuse_ino_t ino;
+
+	/** Generation number for this entry.
+	 *
+	 * If the file system will be exported over NFS, the
+	 * ino/generation pairs need to be unique over the file
+	 * system's lifetime (rather than just the mount time). So if
+	 * the file system reuses an inode after it has been deleted,
+	 * it must assign a new, previously unused generation number
+	 * to the inode at the same time.
+	 *
+	 * The generation must be non-zero, otherwise FUSE will treat
+	 * it as an error.
+	 *
+	 */
+	unsigned long generation;
+
+	/** Inode attributes.
+	 *
+	 * Even if attr_timeout == 0, attr must be correct. For example,
+	 * for open(), FUSE uses attr.st_size from lookup() to determine
+	 * how many bytes to request. If this value is not correct,
+	 * incorrect data will be returned.
+	 */
+	struct stat attr;
+
+	/** Validity timeout (in seconds) for the attributes */
+	double attr_timeout;
+
+	/** Validity timeout (in seconds) for the name */
+	double entry_timeout;
+};
+
+/** Additional context associated with requests */
+struct fuse_ctx {
+	/** User ID of the calling process */
+	uid_t uid;
+
+	/** Group ID of the calling process */
+	gid_t gid;
+
+	/** Thread ID of the calling process */
+	pid_t pid;
+
+	/** Umask of the calling process (introduced in version 2.8) */
+	mode_t umask;
+};
+
+struct fuse_forget_data {
+	uint64_t ino;
+	uint64_t nlookup;
+};
+
+/* 'to_set' flags in setattr */
+#define FUSE_SET_ATTR_MODE	(1 << 0)
+#define FUSE_SET_ATTR_UID	(1 << 1)
+#define FUSE_SET_ATTR_GID	(1 << 2)
+#define FUSE_SET_ATTR_SIZE	(1 << 3)
+#define FUSE_SET_ATTR_ATIME	(1 << 4)
+#define FUSE_SET_ATTR_MTIME	(1 << 5)
+#define FUSE_SET_ATTR_ATIME_NOW	(1 << 7)
+#define FUSE_SET_ATTR_MTIME_NOW	(1 << 8)
+
+/* ----------------------------------------------------------- *
+ * Request methods and replies				       *
+ * ----------------------------------------------------------- */
+
+/**
+ * Low level filesystem operations
+ *
+ * Most of the methods (with the exception of init and destroy)
+ * receive a request handle (fuse_req_t) as their first argument.
+ * This handle must be passed to one of the specified reply functions.
+ *
+ * This may be done inside the method invocation, or after the call
+ * has returned.  The request handle is valid until one of the reply
+ * functions is called.
+ *
+ * Other pointer arguments (name, fuse_file_info, etc) are not valid
+ * after the call has returned, so if they are needed later, their
+ * contents have to be copied.
+ *
+ * The filesystem sometimes needs to handle a return value of -ENOENT
+ * from the reply function, which means, that the request was
+ * interrupted, and the reply discarded.  For example if
+ * fuse_reply_open() return -ENOENT means, that the release method for
+ * this file will not be called.
+ */
+struct fuse_lowlevel_ops {
+	/**
+	 * Initialize filesystem
+	 *
+	 * Called before any other filesystem method
+	 *
+	 * There's no reply to this function
+	 *
+	 * @param userdata the user data passed to fuse_lowlevel_new()
+	 */
+	void (*init) (void *userdata, struct fuse_conn_info *conn);
+
+	/**
+	 * Clean up filesystem
+	 *
+	 * Called on filesystem exit
+	 *
+	 * There's no reply to this function
+	 *
+	 * @param userdata the user data passed to fuse_lowlevel_new()
+	 */
+	void (*destroy) (void *userdata);
+
+	/**
+	 * Look up a directory entry by name and get its attributes.
+	 *
+	 * Valid replies:
+	 *   fuse_reply_entry
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param parent inode number of the parent directory
+	 * @param name the name to look up
+	 */
+	void (*lookup) (fuse_req_t req, fuse_ino_t parent, const char *name);
+
+	/**
+	 * Forget about an inode
+	 *
+	 * This function is called when the kernel removes an inode
+	 * from its internal caches.
+	 *
+	 * The inode's lookup count increases by one for every call to
+	 * fuse_reply_entry and fuse_reply_create. The nlookup parameter
+	 * indicates by how much the lookup count should be decreased.
+	 *
+	 * Inodes with a non-zero lookup count may receive request from
+	 * the kernel even after calls to unlink, rmdir or (when
+	 * overwriting an existing file) rename. Filesystems must handle
+	 * such requests properly and it is recommended to defer removal
+	 * of the inode until the lookup count reaches zero. Calls to
+	 * unlink, remdir or rename will be followed closely by forget
+	 * unless the file or directory is open, in which case the
+	 * kernel issues forget only after the release or releasedir
+	 * calls.
+	 *
+	 * Note that if a file system will be exported over NFS the
+	 * inodes lifetime must extend even beyond forget. See the
+	 * generation field in struct fuse_entry_param above.
+	 *
+	 * On unmount the lookup count for all inodes implicitly drops
+	 * to zero. It is not guaranteed that the file system will
+	 * receive corresponding forget messages for the affected
+	 * inodes.
+	 *
+	 * Valid replies:
+	 *   fuse_reply_none
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param nlookup the number of lookups to forget
+	 */
+	void (*forget) (fuse_req_t req, fuse_ino_t ino, unsigned long nlookup);
+
+	/**
+	 * Get file attributes
+	 *
+	 * Valid replies:
+	 *   fuse_reply_attr
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param fi for future use, currently always NULL
+	 */
+	void (*getattr) (fuse_req_t req, fuse_ino_t ino,
+			 struct fuse_file_info *fi);
+
+	/**
+	 * Set file attributes
+	 *
+	 * In the 'attr' argument only members indicated by the 'to_set'
+	 * bitmask contain valid values.  Other members contain undefined
+	 * values.
+	 *
+	 * If the setattr was invoked from the ftruncate() system call
+	 * under Linux kernel versions 2.6.15 or later, the fi->fh will
+	 * contain the value set by the open method or will be undefined
+	 * if the open method didn't set any value.  Otherwise (not
+	 * ftruncate call, or kernel version earlier than 2.6.15) the fi
+	 * parameter will be NULL.
+	 *
+	 * Valid replies:
+	 *   fuse_reply_attr
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param attr the attributes
+	 * @param to_set bit mask of attributes which should be set
+	 * @param fi file information, or NULL
+	 *
+	 * Changed in version 2.5:
+	 *     file information filled in for ftruncate
+	 */
+	void (*setattr) (fuse_req_t req, fuse_ino_t ino, struct stat *attr,
+			 int to_set, struct fuse_file_info *fi);
+
+	/**
+	 * Read symbolic link
+	 *
+	 * Valid replies:
+	 *   fuse_reply_readlink
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 */
+	void (*readlink) (fuse_req_t req, fuse_ino_t ino);
+
+	/**
+	 * Create file node
+	 *
+	 * Create a regular file, character device, block device, fifo or
+	 * socket node.
+	 *
+	 * Valid replies:
+	 *   fuse_reply_entry
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param parent inode number of the parent directory
+	 * @param name to create
+	 * @param mode file type and mode with which to create the new file
+	 * @param rdev the device number (only valid if created file is a device)
+	 */
+	void (*mknod) (fuse_req_t req, fuse_ino_t parent, const char *name,
+		       mode_t mode, dev_t rdev);
+
+	/**
+	 * Create a directory
+	 *
+	 * Valid replies:
+	 *   fuse_reply_entry
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param parent inode number of the parent directory
+	 * @param name to create
+	 * @param mode with which to create the new file
+	 */
+	void (*mkdir) (fuse_req_t req, fuse_ino_t parent, const char *name,
+		       mode_t mode);
+
+	/**
+	 * Remove a file
+	 *
+	 * If the file's inode's lookup count is non-zero, the file
+	 * system is expected to postpone any removal of the inode
+	 * until the lookup count reaches zero (see description of the
+	 * forget function).
+	 *
+	 * Valid replies:
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param parent inode number of the parent directory
+	 * @param name to remove
+	 */
+	void (*unlink) (fuse_req_t req, fuse_ino_t parent, const char *name);
+
+	/**
+	 * Remove a directory
+	 *
+	 * If the directory's inode's lookup count is non-zero, the
+	 * file system is expected to postpone any removal of the
+	 * inode until the lookup count reaches zero (see description
+	 * of the forget function).
+	 *
+	 * Valid replies:
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param parent inode number of the parent directory
+	 * @param name to remove
+	 */
+	void (*rmdir) (fuse_req_t req, fuse_ino_t parent, const char *name);
+
+	/**
+	 * Create a symbolic link
+	 *
+	 * Valid replies:
+	 *   fuse_reply_entry
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param link the contents of the symbolic link
+	 * @param parent inode number of the parent directory
+	 * @param name to create
+	 */
+	void (*symlink) (fuse_req_t req, const char *link, fuse_ino_t parent,
+			 const char *name);
+
+	/** Rename a file
+	 *
+	 * If the target exists it should be atomically replaced. If
+	 * the target's inode's lookup count is non-zero, the file
+	 * system is expected to postpone any removal of the inode
+	 * until the lookup count reaches zero (see description of the
+	 * forget function).
+	 *
+	 * Valid replies:
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param parent inode number of the old parent directory
+	 * @param name old name
+	 * @param newparent inode number of the new parent directory
+	 * @param newname new name
+	 */
+	void (*rename) (fuse_req_t req, fuse_ino_t parent, const char *name,
+			fuse_ino_t newparent, const char *newname);
+
+	/**
+	 * Create a hard link
+	 *
+	 * Valid replies:
+	 *   fuse_reply_entry
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the old inode number
+	 * @param newparent inode number of the new parent directory
+	 * @param newname new name to create
+	 */
+	void (*link) (fuse_req_t req, fuse_ino_t ino, fuse_ino_t newparent,
+		      const char *newname);
+
+	/**
+	 * Open a file
+	 *
+	 * Open flags (with the exception of O_CREAT, O_EXCL, O_NOCTTY and
+	 * O_TRUNC) are available in fi->flags.
+	 *
+	 * Filesystem may store an arbitrary file handle (pointer, index,
+	 * etc) in fi->fh, and use this in other all other file operations
+	 * (read, write, flush, release, fsync).
+	 *
+	 * Filesystem may also implement stateless file I/O and not store
+	 * anything in fi->fh.
+	 *
+	 * There are also some flags (direct_io, keep_cache) which the
+	 * filesystem may set in fi, to change the way the file is opened.
+	 * See fuse_file_info structure in <fuse_common.h> for more details.
+	 *
+	 * Valid replies:
+	 *   fuse_reply_open
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param fi file information
+	 */
+	void (*open) (fuse_req_t req, fuse_ino_t ino,
+		      struct fuse_file_info *fi);
+
+	/**
+	 * Read data
+	 *
+	 * Read should send exactly the number of bytes requested except
+	 * on EOF or error, otherwise the rest of the data will be
+	 * substituted with zeroes.  An exception to this is when the file
+	 * has been opened in 'direct_io' mode, in which case the return
+	 * value of the read system call will reflect the return value of
+	 * this operation.
+	 *
+	 * fi->fh will contain the value set by the open method, or will
+	 * be undefined if the open method didn't set any value.
+	 *
+	 * Valid replies:
+	 *   fuse_reply_buf
+	 *   fuse_reply_iov
+	 *   fuse_reply_data
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param size number of bytes to read
+	 * @param off offset to read from
+	 * @param fi file information
+	 */
+	void (*read) (fuse_req_t req, fuse_ino_t ino, size_t size, off64_t off,
+		      struct fuse_file_info *fi);
+
+	/**
+	 * Write data
+	 *
+	 * Write should return exactly the number of bytes requested
+	 * except on error.  An exception to this is when the file has
+	 * been opened in 'direct_io' mode, in which case the return value
+	 * of the write system call will reflect the return value of this
+	 * operation.
+	 *
+	 * fi->fh will contain the value set by the open method, or will
+	 * be undefined if the open method didn't set any value.
+	 *
+	 * Valid replies:
+	 *   fuse_reply_write
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param buf data to write
+	 * @param size number of bytes to write
+	 * @param off offset to write to
+	 * @param fi file information
+	 */
+	void (*write) (fuse_req_t req, fuse_ino_t ino, const char *buf,
+		       size_t size, off64_t off, struct fuse_file_info *fi);
+
+	/**
+	 * Flush method
+	 *
+	 * This is called on each close() of the opened file.
+	 *
+	 * Since file descriptors can be duplicated (dup, dup2, fork), for
+	 * one open call there may be many flush calls.
+	 *
+	 * Filesystems shouldn't assume that flush will always be called
+	 * after some writes, or that if will be called at all.
+	 *
+	 * fi->fh will contain the value set by the open method, or will
+	 * be undefined if the open method didn't set any value.
+	 *
+	 * NOTE: the name of the method is misleading, since (unlike
+	 * fsync) the filesystem is not forced to flush pending writes.
+	 * One reason to flush data, is if the filesystem wants to return
+	 * write errors.
+	 *
+	 * If the filesystem supports file locking operations (setlk,
+	 * getlk) it should remove all locks belonging to 'fi->owner'.
+	 *
+	 * Valid replies:
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param fi file information
+	 */
+	void (*flush) (fuse_req_t req, fuse_ino_t ino,
+		       struct fuse_file_info *fi);
+
+	/**
+	 * Release an open file
+	 *
+	 * Release is called when there are no more references to an open
+	 * file: all file descriptors are closed and all memory mappings
+	 * are unmapped.
+	 *
+	 * For every open call there will be exactly one release call.
+	 *
+	 * The filesystem may reply with an error, but error values are
+	 * not returned to close() or munmap() which triggered the
+	 * release.
+	 *
+	 * fi->fh will contain the value set by the open method, or will
+	 * be undefined if the open method didn't set any value.
+	 * fi->flags will contain the same flags as for open.
+	 *
+	 * Valid replies:
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param fi file information
+	 */
+	void (*release) (fuse_req_t req, fuse_ino_t ino,
+			 struct fuse_file_info *fi);
+
+	/**
+	 * Synchronize file contents
+	 *
+	 * If the datasync parameter is non-zero, then only the user data
+	 * should be flushed, not the meta data.
+	 *
+	 * Valid replies:
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param datasync flag indicating if only data should be flushed
+	 * @param fi file information
+	 */
+	void (*fsync) (fuse_req_t req, fuse_ino_t ino, int datasync,
+		       struct fuse_file_info *fi);
+
+	/**
+	 * Open a directory
+	 *
+	 * Filesystem may store an arbitrary file handle (pointer, index,
+	 * etc) in fi->fh, and use this in other all other directory
+	 * stream operations (readdir, releasedir, fsyncdir).
+	 *
+	 * Filesystem may also implement stateless directory I/O and not
+	 * store anything in fi->fh, though that makes it impossible to
+	 * implement standard conforming directory stream operations in
+	 * case the contents of the directory can change between opendir
+	 * and releasedir.
+	 *
+	 * Valid replies:
+	 *   fuse_reply_open
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param fi file information
+	 */
+	void (*opendir) (fuse_req_t req, fuse_ino_t ino,
+			 struct fuse_file_info *fi);
+
+	/**
+	 * Read directory
+	 *
+	 * Send a buffer filled using fuse_add_direntry(), with size not
+	 * exceeding the requested size.  Send an empty buffer on end of
+	 * stream.
+	 *
+	 * fi->fh will contain the value set by the opendir method, or
+	 * will be undefined if the opendir method didn't set any value.
+	 *
+	 * Valid replies:
+	 *   fuse_reply_buf
+	 *   fuse_reply_data
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param size maximum number of bytes to send
+	 * @param off offset to continue reading the directory stream
+	 * @param fi file information
+	 */
+	void (*readdir) (fuse_req_t req, fuse_ino_t ino, size_t size, off64_t off,
+			 struct fuse_file_info *fi);
+
+	/**
+	 * Release an open directory
+	 *
+	 * For every opendir call there will be exactly one releasedir
+	 * call.
+	 *
+	 * fi->fh will contain the value set by the opendir method, or
+	 * will be undefined if the opendir method didn't set any value.
+	 *
+	 * Valid replies:
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param fi file information
+	 */
+	void (*releasedir) (fuse_req_t req, fuse_ino_t ino,
+			    struct fuse_file_info *fi);
+
+	/**
+	 * Synchronize directory contents
+	 *
+	 * If the datasync parameter is non-zero, then only the directory
+	 * contents should be flushed, not the meta data.
+	 *
+	 * fi->fh will contain the value set by the opendir method, or
+	 * will be undefined if the opendir method didn't set any value.
+	 *
+	 * Valid replies:
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param datasync flag indicating if only data should be flushed
+	 * @param fi file information
+	 */
+	void (*fsyncdir) (fuse_req_t req, fuse_ino_t ino, int datasync,
+			  struct fuse_file_info *fi);
+
+	/**
+	 * Get file system statistics
+	 *
+	 * Valid replies:
+	 *   fuse_reply_statfs
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number, zero means "undefined"
+	 */
+	void (*statfs) (fuse_req_t req, fuse_ino_t ino);
+
+	/**
+	 * Set an extended attribute
+	 *
+	 * Valid replies:
+	 *   fuse_reply_err
+	 */
+	void (*setxattr) (fuse_req_t req, fuse_ino_t ino, const char *name,
+			  const char *value, size_t size, int flags);
+
+	/**
+	 * Get an extended attribute
+	 *
+	 * If size is zero, the size of the value should be sent with
+	 * fuse_reply_xattr.
+	 *
+	 * If the size is non-zero, and the value fits in the buffer, the
+	 * value should be sent with fuse_reply_buf.
+	 *
+	 * If the size is too small for the value, the ERANGE error should
+	 * be sent.
+	 *
+	 * Valid replies:
+	 *   fuse_reply_buf
+	 *   fuse_reply_data
+	 *   fuse_reply_xattr
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param name of the extended attribute
+	 * @param size maximum size of the value to send
+	 */
+	void (*getxattr) (fuse_req_t req, fuse_ino_t ino, const char *name,
+			  size_t size);
+
+	/**
+	 * List extended attribute names
+	 *
+	 * If size is zero, the total size of the attribute list should be
+	 * sent with fuse_reply_xattr.
+	 *
+	 * If the size is non-zero, and the null character separated
+	 * attribute list fits in the buffer, the list should be sent with
+	 * fuse_reply_buf.
+	 *
+	 * If the size is too small for the list, the ERANGE error should
+	 * be sent.
+	 *
+	 * Valid replies:
+	 *   fuse_reply_buf
+	 *   fuse_reply_data
+	 *   fuse_reply_xattr
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param size maximum size of the list to send
+	 */
+	void (*listxattr) (fuse_req_t req, fuse_ino_t ino, size_t size);
+
+	/**
+	 * Remove an extended attribute
+	 *
+	 * Valid replies:
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param name of the extended attribute
+	 */
+	void (*removexattr) (fuse_req_t req, fuse_ino_t ino, const char *name);
+
+	/**
+	 * Check file access permissions
+	 *
+	 * This will be called for the access() system call.  If the
+	 * 'default_permissions' mount option is given, this method is not
+	 * called.
+	 *
+	 * This method is not called under Linux kernel versions 2.4.x
+	 *
+	 * Introduced in version 2.5
+	 *
+	 * Valid replies:
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param mask requested access mode
+	 */
+	void (*access) (fuse_req_t req, fuse_ino_t ino, int mask);
+
+	/**
+	 * Create and open a file
+	 *
+	 * If the file does not exist, first create it with the specified
+	 * mode, and then open it.
+	 *
+	 * Open flags (with the exception of O_NOCTTY) are available in
+	 * fi->flags.
+	 *
+	 * Filesystem may store an arbitrary file handle (pointer, index,
+	 * etc) in fi->fh, and use this in other all other file operations
+	 * (read, write, flush, release, fsync).
+	 *
+	 * There are also some flags (direct_io, keep_cache) which the
+	 * filesystem may set in fi, to change the way the file is opened.
+	 * See fuse_file_info structure in <fuse_common.h> for more details.
+	 *
+	 * If this method is not implemented or under Linux kernel
+	 * versions earlier than 2.6.15, the mknod() and open() methods
+	 * will be called instead.
+	 *
+	 * Introduced in version 2.5
+	 *
+	 * Valid replies:
+	 *   fuse_reply_create
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param parent inode number of the parent directory
+	 * @param name to create
+	 * @param mode file type and mode with which to create the new file
+	 * @param fi file information
+	 */
+	void (*create) (fuse_req_t req, fuse_ino_t parent, const char *name,
+			mode_t mode, struct fuse_file_info *fi);
+
+	/**
+	 * Test for a POSIX file lock
+	 *
+	 * Introduced in version 2.6
+	 *
+	 * Valid replies:
+	 *   fuse_reply_lock
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param fi file information
+	 * @param lock the region/type to test
+	 */
+	void (*getlk) (fuse_req_t req, fuse_ino_t ino,
+		       struct fuse_file_info *fi, struct flock *lock);
+
+	/**
+	 * Acquire, modify or release a POSIX file lock
+	 *
+	 * For POSIX threads (NPTL) there's a 1-1 relation between pid and
+	 * owner, but otherwise this is not always the case.  For checking
+	 * lock ownership, 'fi->owner' must be used.  The l_pid field in
+	 * 'struct flock' should only be used to fill in this field in
+	 * getlk().
+	 *
+	 * Note: if the locking methods are not implemented, the kernel
+	 * will still allow file locking to work locally.  Hence these are
+	 * only interesting for network filesystems and similar.
+	 *
+	 * Introduced in version 2.6
+	 *
+	 * Valid replies:
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param fi file information
+	 * @param lock the region/type to set
+	 * @param sleep locking operation may sleep
+	 */
+	void (*setlk) (fuse_req_t req, fuse_ino_t ino,
+		       struct fuse_file_info *fi,
+		       struct flock *lock, int sleep);
+
+	/**
+	 * Map block index within file to block index within device
+	 *
+	 * Note: This makes sense only for block device backed filesystems
+	 * mounted with the 'blkdev' option
+	 *
+	 * Introduced in version 2.6
+	 *
+	 * Valid replies:
+	 *   fuse_reply_bmap
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param blocksize unit of block index
+	 * @param idx block index within file
+	 */
+	void (*bmap) (fuse_req_t req, fuse_ino_t ino, size_t blocksize,
+		      uint64_t idx);
+
+	/**
+	 * Ioctl
+	 *
+	 * Note: For unrestricted ioctls (not allowed for FUSE
+	 * servers), data in and out areas can be discovered by giving
+	 * iovs and setting FUSE_IOCTL_RETRY in @flags.  For
+	 * restricted ioctls, kernel prepares in/out data area
+	 * according to the information encoded in cmd.
+	 *
+	 * Introduced in version 2.8
+	 *
+	 * Valid replies:
+	 *   fuse_reply_ioctl_retry
+	 *   fuse_reply_ioctl
+	 *   fuse_reply_ioctl_iov
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param cmd ioctl command
+	 * @param arg ioctl argument
+	 * @param fi file information
+	 * @param flags for FUSE_IOCTL_* flags
+	 * @param in_buf data fetched from the caller
+	 * @param in_bufsz number of fetched bytes
+	 * @param out_bufsz maximum size of output data
+	 */
+	void (*ioctl) (fuse_req_t req, fuse_ino_t ino, int cmd, void *arg,
+		       struct fuse_file_info *fi, unsigned flags,
+		       const void *in_buf, size_t in_bufsz, size_t out_bufsz);
+
+	/**
+	 * Poll for IO readiness
+	 *
+	 * Introduced in version 2.8
+	 *
+	 * Note: If ph is non-NULL, the client should notify
+	 * when IO readiness events occur by calling
+	 * fuse_lowelevel_notify_poll() with the specified ph.
+	 *
+	 * Regardless of the number of times poll with a non-NULL ph
+	 * is received, single notification is enough to clear all.
+	 * Notifying more times incurs overhead but doesn't harm
+	 * correctness.
+	 *
+	 * The callee is responsible for destroying ph with
+	 * fuse_pollhandle_destroy() when no longer in use.
+	 *
+	 * Valid replies:
+	 *   fuse_reply_poll
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param fi file information
+	 * @param ph poll handle to be used for notification
+	 */
+	void (*poll) (fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi,
+		      struct fuse_pollhandle *ph);
+
+	/**
+	 * Write data made available in a buffer
+	 *
+	 * This is a more generic version of the ->write() method.  If
+	 * FUSE_CAP_SPLICE_READ is set in fuse_conn_info.want and the
+	 * kernel supports splicing from the fuse device, then the
+	 * data will be made available in pipe for supporting zero
+	 * copy data transfer.
+	 *
+	 * Introduced in version 2.9
+	 *
+	 * Valid replies:
+	 *   fuse_reply_write
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param bufv buffer containing the data
+	 * @param off offset to write to
+	 * @param fi file information
+	 */
+	void (*write_buf) (fuse_req_t req, fuse_ino_t ino,
+			   struct fuse_bufvec *bufv, off64_t off,
+			   struct fuse_file_info *fi);
+
+	/**
+	 * Callback function for the retrieve request
+	 *
+	 * Introduced in version 2.9
+	 *
+	 * Valid replies:
+	 *	fuse_reply_none
+	 *
+	 * @param req request handle
+	 * @param cookie user data supplied to fuse_lowlevel_notify_retrieve()
+	 * @param ino the inode number supplied to fuse_lowlevel_notify_retrieve()
+	 * @param offset the offset supplied to fuse_lowlevel_notify_retrieve()
+	 * @param bufv the buffer containing the returned data
+	 */
+	void (*retrieve_reply) (fuse_req_t req, void *cookie, fuse_ino_t ino,
+				off64_t offset, struct fuse_bufvec *bufv);
+
+	/**
+	 * Forget about multiple inodes
+	 *
+	 * See description of the forget function for more
+	 * information.
+	 *
+	 * Introduced in version 2.9
+	 *
+	 * Valid replies:
+	 *   fuse_reply_none
+	 *
+	 * @param req request handle
+	 */
+	void (*forget_multi) (fuse_req_t req, size_t count,
+			      struct fuse_forget_data *forgets);
+
+	/**
+	 * Acquire, modify or release a BSD file lock
+	 *
+	 * Note: if the locking methods are not implemented, the kernel
+	 * will still allow file locking to work locally.  Hence these are
+	 * only interesting for network filesystems and similar.
+	 *
+	 * Introduced in version 2.9
+	 *
+	 * Valid replies:
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param fi file information
+	 * @param op the locking operation, see flock(2)
+	 */
+	void (*flock) (fuse_req_t req, fuse_ino_t ino,
+		       struct fuse_file_info *fi, int op);
+
+	/**
+	 * Allocate requested space. If this function returns success then
+	 * subsequent writes to the specified range shall not fail due to the lack
+	 * of free space on the file system storage media.
+	 *
+	 * Introduced in version 2.9
+	 *
+	 * Valid replies:
+	 *   fuse_reply_err
+	 *
+	 * @param req request handle
+	 * @param ino the inode number
+	 * @param offset starting point for allocated region
+	 * @param length size of allocated region
+	 * @param mode determines the operation to be performed on the given range,
+	 *             see fallocate(2)
+	 */
+	void (*fallocate) (fuse_req_t req, fuse_ino_t ino, int mode,
+		       off64_t offset, off64_t length, struct fuse_file_info *fi);
+};
+
+/**
+ * Reply with an error code or success
+ *
+ * Possible requests:
+ *   all except forget
+ *
+ * unlink, rmdir, rename, flush, release, fsync, fsyncdir, setxattr,
+ * removexattr and setlk may send a zero code
+ *
+ * @param req request handle
+ * @param err the positive error value, or zero for success
+ * @return zero for success, -errno for failure to send reply
+ */
+int fuse_reply_err(fuse_req_t req, int err);
+
+/**
+ * Don't send reply
+ *
+ * Possible requests:
+ *   forget
+ *
+ * @param req request handle
+ */
+void fuse_reply_none(fuse_req_t req);
+
+/**
+ * Reply with a directory entry
+ *
+ * Possible requests:
+ *   lookup, mknod, mkdir, symlink, link
+ *
+ * Side effects:
+ *   increments the lookup count on success
+ *
+ * @param req request handle
+ * @param e the entry parameters
+ * @return zero for success, -errno for failure to send reply
+ */
+int fuse_reply_entry(fuse_req_t req, const struct fuse_entry_param *e);
+
+/**
+ * Reply with a directory entry and open parameters
+ *
+ * currently the following members of 'fi' are used:
+ *   fh, direct_io, keep_cache
+ *
+ * Possible requests:
+ *   create
+ *
+ * Side effects:
+ *   increments the lookup count on success
+ *
+ * @param req request handle
+ * @param e the entry parameters
+ * @param fi file information
+ * @return zero for success, -errno for failure to send reply
+ */
+int fuse_reply_create(fuse_req_t req, const struct fuse_entry_param *e,
+		      const struct fuse_file_info *fi);
+
+/**
+ * Reply with attributes
+ *
+ * Possible requests:
+ *   getattr, setattr
+ *
+ * @param req request handle
+ * @param attr the attributes
+ * @param attr_timeout	validity timeout (in seconds) for the attributes
+ * @return zero for success, -errno for failure to send reply
+ */
+int fuse_reply_attr(fuse_req_t req, const struct stat *attr,
+		    double attr_timeout);
+
+/**
+ * Reply with the contents of a symbolic link
+ *
+ * Possible requests:
+ *   readlink
+ *
+ * @param req request handle
+ * @param link symbolic link contents
+ * @return zero for success, -errno for failure to send reply
+ */
+int fuse_reply_readlink(fuse_req_t req, const char *link);
+
+/**
+ * Reply with open parameters
+ *
+ * currently the following members of 'fi' are used:
+ *   fh, direct_io, keep_cache
+ *
+ * Possible requests:
+ *   open, opendir
+ *
+ * @param req request handle
+ * @param fi file information
+ * @return zero for success, -errno for failure to send reply
+ */
+int fuse_reply_open(fuse_req_t req, const struct fuse_file_info *fi);
+
+/**
+ * Reply with number of bytes written
+ *
+ * Possible requests:
+ *   write
+ *
+ * @param req request handle
+ * @param count the number of bytes written
+ * @return zero for success, -errno for failure to send reply
+ */
+int fuse_reply_write(fuse_req_t req, size_t count);
+
+/**
+ * Reply with data
+ *
+ * Possible requests:
+ *   read, readdir, getxattr, listxattr
+ *
+ * @param req request handle
+ * @param buf buffer containing data
+ * @param size the size of data in bytes
+ * @return zero for success, -errno for failure to send reply
+ */
+int fuse_reply_buf(fuse_req_t req, const char *buf, size_t size);
+
+/**
+ * Reply with data copied/moved from buffer(s)
+ *
+ * Possible requests:
+ *   read, readdir, getxattr, listxattr
+ *
+ * @param req request handle
+ * @param bufv buffer vector
+ * @param flags flags controlling the copy
+ * @return zero for success, -errno for failure to send reply
+ */
+int fuse_reply_data(fuse_req_t req, struct fuse_bufvec *bufv,
+		    enum fuse_buf_copy_flags flags);
+
+/**
+ * Reply with data vector
+ *
+ * Possible requests:
+ *   read, readdir, getxattr, listxattr
+ *
+ * @param req request handle
+ * @param iov the vector containing the data
+ * @param count the size of vector
+ * @return zero for success, -errno for failure to send reply
+ */
+int fuse_reply_iov(fuse_req_t req, const struct iovec *iov, int count);
+
+/**
+ * Reply with filesystem statistics
+ *
+ * Possible requests:
+ *   statfs
+ *
+ * @param req request handle
+ * @param stbuf filesystem statistics
+ * @return zero for success, -errno for failure to send reply
+ */
+int fuse_reply_statfs(fuse_req_t req, const struct statvfs *stbuf);
+
+/**
+ * Reply with needed buffer size
+ *
+ * Possible requests:
+ *   getxattr, listxattr
+ *
+ * @param req request handle
+ * @param count the buffer size needed in bytes
+ * @return zero for success, -errno for failure to send reply
+ */
+int fuse_reply_xattr(fuse_req_t req, size_t count);
+
+/**
+ * Reply with file lock information
+ *
+ * Possible requests:
+ *   getlk
+ *
+ * @param req request handle
+ * @param lock the lock information
+ * @return zero for success, -errno for failure to send reply
+ */
+int fuse_reply_lock(fuse_req_t req, const struct flock *lock);
+
+/**
+ * Reply with block index
+ *
+ * Possible requests:
+ *   bmap
+ *
+ * @param req request handle
+ * @param idx block index within device
+ * @return zero for success, -errno for failure to send reply
+ */
+int fuse_reply_bmap(fuse_req_t req, uint64_t idx);
+
+/* ----------------------------------------------------------- *
+ * Filling a buffer in readdir				       *
+ * ----------------------------------------------------------- */
+
+/**
+ * Add a directory entry to the buffer
+ *
+ * Buffer needs to be large enough to hold the entry.  If it's not,
+ * then the entry is not filled in but the size of the entry is still
+ * returned.  The caller can check this by comparing the bufsize
+ * parameter with the returned entry size.  If the entry size is
+ * larger than the buffer size, the operation failed.
+ *
+ * From the 'stbuf' argument the st_ino field and bits 12-15 of the
+ * st_mode field are used.  The other fields are ignored.
+ *
+ * Note: offsets do not necessarily represent physical offsets, and
+ * could be any marker, that enables the implementation to find a
+ * specific point in the directory stream.
+ *
+ * @param req request handle
+ * @param buf the point where the new entry will be added to the buffer
+ * @param bufsize remaining size of the buffer
+ * @param name the name of the entry
+ * @param stbuf the file attributes
+ * @param off the offset of the next entry
+ * @return the space needed for the entry
+ */
+size_t fuse_add_direntry(fuse_req_t req, char *buf, size_t bufsize,
+			 const char *name, const struct stat *stbuf,
+			 off64_t off);
+
+/**
+ * Reply to ask for data fetch and output buffer preparation.  ioctl
+ * will be retried with the specified input data fetched and output
+ * buffer prepared.
+ *
+ * Possible requests:
+ *   ioctl
+ *
+ * @param req request handle
+ * @param in_iov iovec specifying data to fetch from the caller
+ * @param in_count number of entries in in_iov
+ * @param out_iov iovec specifying addresses to write output to
+ * @param out_count number of entries in out_iov
+ * @return zero for success, -errno for failure to send reply
+ */
+int fuse_reply_ioctl_retry(fuse_req_t req,
+			   const struct iovec *in_iov, size_t in_count,
+			   const struct iovec *out_iov, size_t out_count);
+
+/**
+ * Reply to finish ioctl
+ *
+ * Possible requests:
+ *   ioctl
+ *
+ * @param req request handle
+ * @param result result to be passed to the caller
+ * @param buf buffer containing output data
+ * @param size length of output data
+ */
+int fuse_reply_ioctl(fuse_req_t req, int result, const void *buf, size_t size);
+
+/**
+ * Reply to finish ioctl with iov buffer
+ *
+ * Possible requests:
+ *   ioctl
+ *
+ * @param req request handle
+ * @param result result to be passed to the caller
+ * @param iov the vector containing the data
+ * @param count the size of vector
+ */
+int fuse_reply_ioctl_iov(fuse_req_t req, int result, const struct iovec *iov,
+			 int count);
+
+/**
+ * Reply with poll result event mask
+ *
+ * @param req request handle
+ * @param revents poll result event mask
+ */
+int fuse_reply_poll(fuse_req_t req, unsigned revents);
+
+/* ----------------------------------------------------------- *
+ * Notification						       *
+ * ----------------------------------------------------------- */
+
+/**
+ * Notify IO readiness event
+ *
+ * For more information, please read comment for poll operation.
+ *
+ * @param ph poll handle to notify IO readiness event for
+ */
+int fuse_lowlevel_notify_poll(struct fuse_pollhandle *ph);
+
+/**
+ * Notify to invalidate cache for an inode
+ *
+ * @param ch the channel through which to send the invalidation
+ * @param ino the inode number
+ * @param off the offset in the inode where to start invalidating
+ *            or negative to invalidate attributes only
+ * @param len the amount of cache to invalidate or 0 for all
+ * @return zero for success, -errno for failure
+ */
+int fuse_lowlevel_notify_inval_inode(struct fuse_chan *ch, fuse_ino_t ino,
+                                     off64_t off, off64_t len);
+
+/**
+ * Notify to invalidate parent attributes and the dentry matching
+ * parent/name
+ *
+ * @param ch the channel through which to send the invalidation
+ * @param parent inode number
+ * @param name file name
+ * @param namelen strlen() of file name
+ * @return zero for success, -errno for failure
+ */
+int fuse_lowlevel_notify_inval_entry(struct fuse_chan *ch, fuse_ino_t parent,
+                                     const char *name, size_t namelen);
+
+/**
+ * Notify to invalidate parent attributes and delete the dentry matching
+ * parent/name if the dentry's inode number matches child (otherwise it
+ * will invalidate the matching dentry).
+ *
+ * @param ch the channel through which to send the notification
+ * @param parent inode number
+ * @param child inode number
+ * @param name file name
+ * @param namelen strlen() of file name
+ * @return zero for success, -errno for failure
+ */
+int fuse_lowlevel_notify_delete(struct fuse_chan *ch,
+				fuse_ino_t parent, fuse_ino_t child,
+				const char *name, size_t namelen);
+
+/**
+ * Store data to the kernel buffers
+ *
+ * Synchronously store data in the kernel buffers belonging to the
+ * given inode.  The stored data is marked up-to-date (no read will be
+ * performed against it, unless it's invalidated or evicted from the
+ * cache).
+ *
+ * If the stored data overflows the current file size, then the size
+ * is extended, similarly to a write(2) on the filesystem.
+ *
+ * If this function returns an error, then the store wasn't fully
+ * completed, but it may have been partially completed.
+ *
+ * @param ch the channel through which to send the invalidation
+ * @param ino the inode number
+ * @param offset the starting offset into the file to store to
+ * @param bufv buffer vector
+ * @param flags flags controlling the copy
+ * @return zero for success, -errno for failure
+ */
+int fuse_lowlevel_notify_store(struct fuse_chan *ch, fuse_ino_t ino,
+			       off64_t offset, struct fuse_bufvec *bufv,
+			       enum fuse_buf_copy_flags flags);
+/**
+ * Retrieve data from the kernel buffers
+ *
+ * Retrieve data in the kernel buffers belonging to the given inode.
+ * If successful then the retrieve_reply() method will be called with
+ * the returned data.
+ *
+ * Only present pages are returned in the retrieve reply.  Retrieving
+ * stops when it finds a non-present page and only data prior to that is
+ * returned.
+ *
+ * If this function returns an error, then the retrieve will not be
+ * completed and no reply will be sent.
+ *
+ * This function doesn't change the dirty state of pages in the kernel
+ * buffer.  For dirty pages the write() method will be called
+ * regardless of having been retrieved previously.
+ *
+ * @param ch the channel through which to send the invalidation
+ * @param ino the inode number
+ * @param size the number of bytes to retrieve
+ * @param offset the starting offset into the file to retrieve from
+ * @param cookie user data to supply to the reply callback
+ * @return zero for success, -errno for failure
+ */
+int fuse_lowlevel_notify_retrieve(struct fuse_chan *ch, fuse_ino_t ino,
+				  size_t size, off64_t offset, void *cookie);
+
+
+/* ----------------------------------------------------------- *
+ * Utility functions					       *
+ * ----------------------------------------------------------- */
+
+/**
+ * Get the userdata from the request
+ *
+ * @param req request handle
+ * @return the user data passed to fuse_lowlevel_new()
+ */
+void *fuse_req_userdata(fuse_req_t req);
+
+/**
+ * Get the context from the request
+ *
+ * The pointer returned by this function will only be valid for the
+ * request's lifetime
+ *
+ * @param req request handle
+ * @return the context structure
+ */
+const struct fuse_ctx *fuse_req_ctx(fuse_req_t req);
+
+/**
+ * Get the current supplementary group IDs for the specified request
+ *
+ * Similar to the getgroups(2) system call, except the return value is
+ * always the total number of group IDs, even if it is larger than the
+ * specified size.
+ *
+ * The current fuse kernel module in linux (as of 2.6.30) doesn't pass
+ * the group list to userspace, hence this function needs to parse
+ * "/proc/$TID/task/$TID/status" to get the group IDs.
+ *
+ * This feature may not be supported on all operating systems.  In
+ * such a case this function will return -ENOSYS.
+ *
+ * @param req request handle
+ * @param size size of given array
+ * @param list array of group IDs to be filled in
+ * @return the total number of supplementary group IDs or -errno on failure
+ */
+int fuse_req_getgroups(fuse_req_t req, int size, gid_t list[]);
+
+/**
+ * Callback function for an interrupt
+ *
+ * @param req interrupted request
+ * @param data user data
+ */
+typedef void (*fuse_interrupt_func_t)(fuse_req_t req, void *data);
+
+/**
+ * Register/unregister callback for an interrupt
+ *
+ * If an interrupt has already happened, then the callback function is
+ * called from within this function, hence it's not possible for
+ * interrupts to be lost.
+ *
+ * @param req request handle
+ * @param func the callback function or NULL for unregister
+ * @param data user data passed to the callback function
+ */
+void fuse_req_interrupt_func(fuse_req_t req, fuse_interrupt_func_t func,
+			     void *data);
+
+/**
+ * Check if a request has already been interrupted
+ *
+ * @param req request handle
+ * @return 1 if the request has been interrupted, 0 otherwise
+ */
+int fuse_req_interrupted(fuse_req_t req);
+
+/* ----------------------------------------------------------- *
+ * Filesystem setup					       *
+ * ----------------------------------------------------------- */
+
+/* Deprecated, don't use */
+int fuse_lowlevel_is_lib_option(const char *opt);
+
+/**
+ * Create a low level session
+ *
+ * @param args argument vector
+ * @param op the low level filesystem operations
+ * @param op_size sizeof(struct fuse_lowlevel_ops)
+ * @param userdata user data
+ * @return the created session object, or NULL on failure
+ */
+struct fuse_session *fuse_lowlevel_new(struct fuse_args *args,
+				       const struct fuse_lowlevel_ops *op,
+				       size_t op_size, void *userdata);
+
+/* ----------------------------------------------------------- *
+ * Session interface					       *
+ * ----------------------------------------------------------- */
+
+/**
+ * Session operations
+ *
+ * This is used in session creation
+ */
+struct fuse_session_ops {
+	/**
+	 * Hook to process a request (mandatory)
+	 *
+	 * @param data user data passed to fuse_session_new()
+	 * @param buf buffer containing the raw request
+	 * @param len request length
+	 * @param ch channel on which the request was received
+	 */
+	void (*process) (void *data, const char *buf, size_t len,
+			 struct fuse_chan *ch);
+
+	/**
+	 * Hook for session exit and reset (optional)
+	 *
+	 * @param data user data passed to fuse_session_new()
+	 * @param val exited status (1 - exited, 0 - not exited)
+	 */
+	void (*exit) (void *data, int val);
+
+	/**
+	 * Hook for querying the current exited status (optional)
+	 *
+	 * @param data user data passed to fuse_session_new()
+	 * @return 1 if exited, 0 if not exited
+	 */
+	int (*exited) (void *data);
+
+	/**
+	 * Hook for cleaning up the channel on destroy (optional)
+	 *
+	 * @param data user data passed to fuse_session_new()
+	 */
+	void (*destroy) (void *data);
+};
+
+/**
+ * Create a new session
+ *
+ * @param op session operations
+ * @param data user data
+ * @return new session object, or NULL on failure
+ */
+struct fuse_session *fuse_session_new(struct fuse_session_ops *op, void *data);
+
+/**
+ * Assign a channel to a session
+ *
+ * Note: currently only a single channel may be assigned.  This may
+ * change in the future
+ *
+ * If a session is destroyed, the assigned channel is also destroyed
+ *
+ * @param se the session
+ * @param ch the channel
+ */
+void fuse_session_add_chan(struct fuse_session *se, struct fuse_chan *ch);
+
+/**
+ * Remove a channel from a session
+ *
+ * If the channel is not assigned to a session, then this is a no-op
+ *
+ * @param ch the channel to remove
+ */
+void fuse_session_remove_chan(struct fuse_chan *ch);
+
+/**
+ * Iterate over the channels assigned to a session
+ *
+ * The iterating function needs to start with a NULL channel, and
+ * after that needs to pass the previously returned channel to the
+ * function.
+ *
+ * @param se the session
+ * @param ch the previous channel, or NULL
+ * @return the next channel, or NULL if no more channels exist
+ */
+struct fuse_chan *fuse_session_next_chan(struct fuse_session *se,
+					 struct fuse_chan *ch);
+
+/**
+ * Process a raw request
+ *
+ * @param se the session
+ * @param buf buffer containing the raw request
+ * @param len request length
+ * @param ch channel on which the request was received
+ */
+void fuse_session_process(struct fuse_session *se, const char *buf, size_t len,
+			  struct fuse_chan *ch);
+
+/**
+ * Process a raw request supplied in a generic buffer
+ *
+ * This is a more generic version of fuse_session_process().  The
+ * fuse_buf may contain a memory buffer or a pipe file descriptor.
+ *
+ * @param se the session
+ * @param buf the fuse_buf containing the request
+ * @param ch channel on which the request was received
+ */
+void fuse_session_process_buf(struct fuse_session *se,
+			      const struct fuse_buf *buf, struct fuse_chan *ch);
+
+/**
+ * Receive a raw request supplied in a generic buffer
+ *
+ * This is a more generic version of fuse_chan_recv().  The fuse_buf
+ * supplied to this function contains a suitably allocated memory
+ * buffer.  This may be overwritten with a file descriptor buffer.
+ *
+ * @param se the session
+ * @param buf the fuse_buf to store the request in
+ * @param chp pointer to the channel
+ * @return the actual size of the raw request, or -errno on error
+ */
+int fuse_session_receive_buf(struct fuse_session *se, struct fuse_buf *buf,
+			     struct fuse_chan **chp);
+
+/**
+ * Destroy a session
+ *
+ * @param se the session
+ */
+void fuse_session_destroy(struct fuse_session *se);
+
+/**
+ * Exit a session
+ *
+ * @param se the session
+ */
+void fuse_session_exit(struct fuse_session *se);
+
+/**
+ * Reset the exited status of a session
+ *
+ * @param se the session
+ */
+void fuse_session_reset(struct fuse_session *se);
+
+/**
+ * Query the exited status of a session
+ *
+ * @param se the session
+ * @return 1 if exited, 0 if not exited
+ */
+int fuse_session_exited(struct fuse_session *se);
+
+/**
+ * Get the user data provided to the session
+ *
+ * @param se the session
+ * @return the user data
+ */
+void *fuse_session_data(struct fuse_session *se);
+
+/**
+ * Enter a single threaded event loop
+ *
+ * @param se the session
+ * @return 0 on success, -1 on error
+ */
+int fuse_session_loop(struct fuse_session *se);
+
+/**
+ * Enter a multi-threaded event loop
+ *
+ * @param se the session
+ * @return 0 on success, -1 on error
+ */
+int fuse_session_loop_mt(struct fuse_session *se);
+
+/* ----------------------------------------------------------- *
+ * Channel interface					       *
+ * ----------------------------------------------------------- */
+
+/**
+ * Channel operations
+ *
+ * This is used in channel creation
+ */
+struct fuse_chan_ops {
+	/**
+	 * Hook for receiving a raw request
+	 *
+	 * @param ch pointer to the channel
+	 * @param buf the buffer to store the request in
+	 * @param size the size of the buffer
+	 * @return the actual size of the raw request, or -1 on error
+	 */
+	int (*receive)(struct fuse_chan **chp, char *buf, size_t size);
+
+	/**
+	 * Hook for sending a raw reply
+	 *
+	 * A return value of -ENOENT means, that the request was
+	 * interrupted, and the reply was discarded
+	 *
+	 * @param ch the channel
+	 * @param iov vector of blocks
+	 * @param count the number of blocks in vector
+	 * @return zero on success, -errno on failure
+	 */
+	int (*send)(struct fuse_chan *ch, const struct iovec iov[],
+		    size_t count);
+
+	/**
+	 * Destroy the channel
+	 *
+	 * @param ch the channel
+	 */
+	void (*destroy)(struct fuse_chan *ch);
+};
+
+/**
+ * Create a new channel
+ *
+ * @param op channel operations
+ * @param fd file descriptor of the channel
+ * @param bufsize the minimal receive buffer size
+ * @param data user data
+ * @return the new channel object, or NULL on failure
+ */
+struct fuse_chan *fuse_chan_new(struct fuse_chan_ops *op, int fd,
+				size_t bufsize, void *data);
+
+/**
+ * Query the file descriptor of the channel
+ *
+ * @param ch the channel
+ * @return the file descriptor passed to fuse_chan_new()
+ */
+int fuse_chan_fd(struct fuse_chan *ch);
+
+/**
+ * Query the minimal receive buffer size
+ *
+ * @param ch the channel
+ * @return the buffer size passed to fuse_chan_new()
+ */
+size_t fuse_chan_bufsize(struct fuse_chan *ch);
+
+/**
+ * Query the user data
+ *
+ * @param ch the channel
+ * @return the user data passed to fuse_chan_new()
+ */
+void *fuse_chan_data(struct fuse_chan *ch);
+
+/**
+ * Query the session to which this channel is assigned
+ *
+ * @param ch the channel
+ * @return the session, or NULL if the channel is not assigned
+ */
+struct fuse_session *fuse_chan_session(struct fuse_chan *ch);
+
+/**
+ * Receive a raw request
+ *
+ * A return value of -ENODEV means, that the filesystem was unmounted
+ *
+ * @param ch pointer to the channel
+ * @param buf the buffer to store the request in
+ * @param size the size of the buffer
+ * @return the actual size of the raw request, or -errno on error
+ */
+int fuse_chan_recv(struct fuse_chan **ch, char *buf, size_t size);
+
+/**
+ * Send a raw reply
+ *
+ * A return value of -ENOENT means, that the request was
+ * interrupted, and the reply was discarded
+ *
+ * @param ch the channel
+ * @param iov vector of blocks
+ * @param count the number of blocks in vector
+ * @return zero on success, -errno on failure
+ */
+int fuse_chan_send(struct fuse_chan *ch, const struct iovec iov[],
+		   size_t count);
+
+/**
+ * Destroy a channel
+ *
+ * @param ch the channel
+ */
+void fuse_chan_destroy(struct fuse_chan *ch);
+
+/* ----------------------------------------------------------- *
+ * Compatibility stuff					       *
+ * ----------------------------------------------------------- */
+
+#if FUSE_USE_VERSION < 26
+#  include "fuse_lowlevel_compat.h"
+#  define fuse_chan_ops fuse_chan_ops_compat24
+#  define fuse_chan_new fuse_chan_new_compat24
+#  if FUSE_USE_VERSION == 25
+#    define fuse_lowlevel_ops fuse_lowlevel_ops_compat25
+#    define fuse_lowlevel_new fuse_lowlevel_new_compat25
+#  elif FUSE_USE_VERSION == 24
+#    define fuse_lowlevel_ops fuse_lowlevel_ops_compat
+#    define fuse_lowlevel_new fuse_lowlevel_new_compat
+#    define fuse_file_info fuse_file_info_compat
+#    define fuse_reply_statfs fuse_reply_statfs_compat
+#    define fuse_reply_open fuse_reply_open_compat
+#  else
+#    error Compatibility with low-level API version < 24 not supported
+#  endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _FUSE_LOWLEVEL_H_ */
diff --git a/external/fuse/include/fuse_lowlevel_compat.h b/external/fuse/include/fuse_lowlevel_compat.h
new file mode 100755
index 0000000000..78b7c2bd0a
--- /dev/null
+++ b/external/fuse/include/fuse_lowlevel_compat.h
@@ -0,0 +1,155 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB.
+*/
+
+/* these definitions provide source compatibility to prior versions.
+   Do not include this file directly! */
+
+struct fuse_lowlevel_ops_compat25 {
+	void (*init) (void *userdata);
+	void (*destroy) (void *userdata);
+	void (*lookup) (fuse_req_t req, fuse_ino_t parent, const char *name);
+	void (*forget) (fuse_req_t req, fuse_ino_t ino, unsigned long nlookup);
+	void (*getattr) (fuse_req_t req, fuse_ino_t ino,
+			 struct fuse_file_info *fi);
+	void (*setattr) (fuse_req_t req, fuse_ino_t ino, struct stat *attr,
+			 int to_set, struct fuse_file_info *fi);
+	void (*readlink) (fuse_req_t req, fuse_ino_t ino);
+	void (*mknod) (fuse_req_t req, fuse_ino_t parent, const char *name,
+		       mode_t mode, dev_t rdev);
+	void (*mkdir) (fuse_req_t req, fuse_ino_t parent, const char *name,
+		       mode_t mode);
+	void (*unlink) (fuse_req_t req, fuse_ino_t parent, const char *name);
+	void (*rmdir) (fuse_req_t req, fuse_ino_t parent, const char *name);
+	void (*symlink) (fuse_req_t req, const char *link, fuse_ino_t parent,
+			 const char *name);
+	void (*rename) (fuse_req_t req, fuse_ino_t parent, const char *name,
+			fuse_ino_t newparent, const char *newname);
+	void (*link) (fuse_req_t req, fuse_ino_t ino, fuse_ino_t newparent,
+		      const char *newname);
+	void (*open) (fuse_req_t req, fuse_ino_t ino,
+		      struct fuse_file_info *fi);
+	void (*read) (fuse_req_t req, fuse_ino_t ino, size_t size, off64_t off,
+		      struct fuse_file_info *fi);
+	void (*write) (fuse_req_t req, fuse_ino_t ino, const char *buf,
+		       size_t size, off64_t off, struct fuse_file_info *fi);
+	void (*flush) (fuse_req_t req, fuse_ino_t ino,
+		       struct fuse_file_info *fi);
+	void (*release) (fuse_req_t req, fuse_ino_t ino,
+			 struct fuse_file_info *fi);
+	void (*fsync) (fuse_req_t req, fuse_ino_t ino, int datasync,
+		       struct fuse_file_info *fi);
+	void (*opendir) (fuse_req_t req, fuse_ino_t ino,
+			 struct fuse_file_info *fi);
+	void (*readdir) (fuse_req_t req, fuse_ino_t ino, size_t size, off64_t off,
+			 struct fuse_file_info *fi);
+	void (*releasedir) (fuse_req_t req, fuse_ino_t ino,
+			    struct fuse_file_info *fi);
+	void (*fsyncdir) (fuse_req_t req, fuse_ino_t ino, int datasync,
+			  struct fuse_file_info *fi);
+	void (*statfs) (fuse_req_t req);
+	void (*setxattr) (fuse_req_t req, fuse_ino_t ino, const char *name,
+			  const char *value, size_t size, int flags);
+	void (*getxattr) (fuse_req_t req, fuse_ino_t ino, const char *name,
+			  size_t size);
+	void (*listxattr) (fuse_req_t req, fuse_ino_t ino, size_t size);
+	void (*removexattr) (fuse_req_t req, fuse_ino_t ino, const char *name);
+	void (*access) (fuse_req_t req, fuse_ino_t ino, int mask);
+	void (*create) (fuse_req_t req, fuse_ino_t parent, const char *name,
+			mode_t mode, struct fuse_file_info *fi);
+};
+
+struct fuse_session *fuse_lowlevel_new_compat25(struct fuse_args *args,
+				const struct fuse_lowlevel_ops_compat25 *op,
+				size_t op_size, void *userdata);
+
+size_t fuse_dirent_size(size_t namelen);
+
+char *fuse_add_dirent(char *buf, const char *name, const struct stat *stbuf,
+		      off64_t off);
+
+#if !defined(__FreeBSD__) && !defined(__NetBSD__)
+
+#include <sys/statfs.h>
+
+struct fuse_lowlevel_ops_compat {
+	void (*init) (void *userdata);
+	void (*destroy) (void *userdata);
+	void (*lookup) (fuse_req_t req, fuse_ino_t parent, const char *name);
+	void (*forget) (fuse_req_t req, fuse_ino_t ino, unsigned long nlookup);
+	void (*getattr) (fuse_req_t req, fuse_ino_t ino,
+			 struct fuse_file_info_compat *fi);
+	void (*setattr) (fuse_req_t req, fuse_ino_t ino, struct stat *attr,
+			 int to_set, struct fuse_file_info_compat *fi);
+	void (*readlink) (fuse_req_t req, fuse_ino_t ino);
+	void (*mknod) (fuse_req_t req, fuse_ino_t parent, const char *name,
+		       mode_t mode, dev_t rdev);
+	void (*mkdir) (fuse_req_t req, fuse_ino_t parent, const char *name,
+		       mode_t mode);
+	void (*unlink) (fuse_req_t req, fuse_ino_t parent, const char *name);
+	void (*rmdir) (fuse_req_t req, fuse_ino_t parent, const char *name);
+	void (*symlink) (fuse_req_t req, const char *link, fuse_ino_t parent,
+			 const char *name);
+	void (*rename) (fuse_req_t req, fuse_ino_t parent, const char *name,
+			fuse_ino_t newparent, const char *newname);
+	void (*link) (fuse_req_t req, fuse_ino_t ino, fuse_ino_t newparent,
+		      const char *newname);
+	void (*open) (fuse_req_t req, fuse_ino_t ino,
+		      struct fuse_file_info_compat *fi);
+	void (*read) (fuse_req_t req, fuse_ino_t ino, size_t size, off64_t off,
+		      struct fuse_file_info_compat *fi);
+	void (*write) (fuse_req_t req, fuse_ino_t ino, const char *buf,
+		       size_t size, off64_t off, struct fuse_file_info_compat *fi);
+	void (*flush) (fuse_req_t req, fuse_ino_t ino,
+		       struct fuse_file_info_compat *fi);
+	void (*release) (fuse_req_t req, fuse_ino_t ino,
+			 struct fuse_file_info_compat *fi);
+	void (*fsync) (fuse_req_t req, fuse_ino_t ino, int datasync,
+		       struct fuse_file_info_compat *fi);
+	void (*opendir) (fuse_req_t req, fuse_ino_t ino,
+			 struct fuse_file_info_compat *fi);
+	void (*readdir) (fuse_req_t req, fuse_ino_t ino, size_t size, off64_t off,
+			 struct fuse_file_info_compat *fi);
+	void (*releasedir) (fuse_req_t req, fuse_ino_t ino,
+			    struct fuse_file_info_compat *fi);
+	void (*fsyncdir) (fuse_req_t req, fuse_ino_t ino, int datasync,
+			  struct fuse_file_info_compat *fi);
+	void (*statfs) (fuse_req_t req);
+	void (*setxattr) (fuse_req_t req, fuse_ino_t ino, const char *name,
+			  const char *value, size_t size, int flags);
+	void (*getxattr) (fuse_req_t req, fuse_ino_t ino, const char *name,
+			  size_t size);
+	void (*listxattr) (fuse_req_t req, fuse_ino_t ino, size_t size);
+	void (*removexattr) (fuse_req_t req, fuse_ino_t ino, const char *name);
+	void (*access) (fuse_req_t req, fuse_ino_t ino, int mask);
+	void (*create) (fuse_req_t req, fuse_ino_t parent, const char *name,
+			mode_t mode, struct fuse_file_info_compat *fi);
+};
+
+int fuse_reply_statfs_compat(fuse_req_t req, const struct statfs *stbuf);
+
+int fuse_reply_open_compat(fuse_req_t req,
+			   const struct fuse_file_info_compat *fi);
+
+struct fuse_session *fuse_lowlevel_new_compat(const char *opts,
+				const struct fuse_lowlevel_ops_compat *op,
+				size_t op_size, void *userdata);
+
+#endif /* __FreeBSD__ || __NetBSD__ */
+
+struct fuse_chan_ops_compat24 {
+	int (*receive)(struct fuse_chan *ch, char *buf, size_t size);
+	int (*send)(struct fuse_chan *ch, const struct iovec iov[],
+		    size_t count);
+	void (*destroy)(struct fuse_chan *ch);
+};
+
+struct fuse_chan *fuse_chan_new_compat24(struct fuse_chan_ops_compat24 *op,
+					 int fd, size_t bufsize, void *data);
+
+int fuse_chan_receive(struct fuse_chan *ch, char *buf, size_t size);
+struct fuse_chan *fuse_kern_chan_new(int fd);
diff --git a/external/fuse/include/fuse_opt.h b/external/fuse/include/fuse_opt.h
new file mode 100755
index 0000000000..add0a30894
--- /dev/null
+++ b/external/fuse/include/fuse_opt.h
@@ -0,0 +1,270 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB.
+*/
+
+#ifndef _FUSE_OPT_H_
+#define _FUSE_OPT_H_
+
+/** @file
+ *
+ * This file defines the option parsing interface of FUSE
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Option description
+ *
+ * This structure describes a single option, and action associated
+ * with it, in case it matches.
+ *
+ * More than one such match may occur, in which case the action for
+ * each match is executed.
+ *
+ * There are three possible actions in case of a match:
+ *
+ * i) An integer (int or unsigned) variable determined by 'offset' is
+ *    set to 'value'
+ *
+ * ii) The processing function is called, with 'value' as the key
+ *
+ * iii) An integer (any) or string (char *) variable determined by
+ *    'offset' is set to the value of an option parameter
+ *
+ * 'offset' should normally be either set to
+ *
+ *  - 'offsetof(struct foo, member)'  actions i) and iii)
+ *
+ *  - -1			      action ii)
+ *
+ * The 'offsetof()' macro is defined in the <stddef.h> header.
+ *
+ * The template determines which options match, and also have an
+ * effect on the action.  Normally the action is either i) or ii), but
+ * if a format is present in the template, then action iii) is
+ * performed.
+ *
+ * The types of templates are:
+ *
+ * 1) "-x", "-foo", "--foo", "--foo-bar", etc.	These match only
+ *   themselves.  Invalid values are "--" and anything beginning
+ *   with "-o"
+ *
+ * 2) "foo", "foo-bar", etc.  These match "-ofoo", "-ofoo-bar" or
+ *    the relevant option in a comma separated option list
+ *
+ * 3) "bar=", "--foo=", etc.  These are variations of 1) and 2)
+ *    which have a parameter
+ *
+ * 4) "bar=%s", "--foo=%lu", etc.  Same matching as above but perform
+ *    action iii).
+ *
+ * 5) "-x ", etc.  Matches either "-xparam" or "-x param" as
+ *    two separate arguments
+ *
+ * 6) "-x %s", etc.  Combination of 4) and 5)
+ *
+ * If the format is "%s", memory is allocated for the string unlike
+ * with scanf().
+ */
+struct fuse_opt {
+	/** Matching template and optional parameter formatting */
+	const char *templ;
+
+	/**
+	 * Offset of variable within 'data' parameter of fuse_opt_parse()
+	 * or -1
+	 */
+	unsigned long offset;
+
+	/**
+	 * Value to set the variable to, or to be passed as 'key' to the
+	 * processing function.	 Ignored if template has a format
+	 */
+	int value;
+};
+
+/**
+ * Key option.	In case of a match, the processing function will be
+ * called with the specified key.
+ */
+#define FUSE_OPT_KEY(templ, key) { templ, -1U, key }
+
+/**
+ * Last option.	 An array of 'struct fuse_opt' must end with a NULL
+ * template value
+ */
+#define FUSE_OPT_END { NULL, 0, 0 }
+
+/**
+ * Argument list
+ */
+struct fuse_args {
+	/** Argument count */
+	int argc;
+
+	/** Argument vector.  NULL terminated */
+	char **argv;
+
+	/** Is 'argv' allocated? */
+	int allocated;
+};
+
+/**
+ * Initializer for 'struct fuse_args'
+ */
+#define FUSE_ARGS_INIT(argc, argv) { argc, argv, 0 }
+
+/**
+ * Key value passed to the processing function if an option did not
+ * match any template
+ */
+#define FUSE_OPT_KEY_OPT     -1
+
+/**
+ * Key value passed to the processing function for all non-options
+ *
+ * Non-options are the arguments beginning with a character other than
+ * '-' or all arguments after the special '--' option
+ */
+#define FUSE_OPT_KEY_NONOPT  -2
+
+/**
+ * Special key value for options to keep
+ *
+ * Argument is not passed to processing function, but behave as if the
+ * processing function returned 1
+ */
+#define FUSE_OPT_KEY_KEEP -3
+
+/**
+ * Special key value for options to discard
+ *
+ * Argument is not passed to processing function, but behave as if the
+ * processing function returned zero
+ */
+#define FUSE_OPT_KEY_DISCARD -4
+
+/**
+ * Processing function
+ *
+ * This function is called if
+ *    - option did not match any 'struct fuse_opt'
+ *    - argument is a non-option
+ *    - option did match and offset was set to -1
+ *
+ * The 'arg' parameter will always contain the whole argument or
+ * option including the parameter if exists.  A two-argument option
+ * ("-x foo") is always converted to single argument option of the
+ * form "-xfoo" before this function is called.
+ *
+ * Options of the form '-ofoo' are passed to this function without the
+ * '-o' prefix.
+ *
+ * The return value of this function determines whether this argument
+ * is to be inserted into the output argument vector, or discarded.
+ *
+ * @param data is the user data passed to the fuse_opt_parse() function
+ * @param arg is the whole argument or option
+ * @param key determines why the processing function was called
+ * @param outargs the current output argument list
+ * @return -1 on error, 0 if arg is to be discarded, 1 if arg should be kept
+ */
+typedef int (*fuse_opt_proc_t)(void *data, const char *arg, int key,
+			       struct fuse_args *outargs);
+
+/**
+ * Option parsing function
+ *
+ * If 'args' was returned from a previous call to fuse_opt_parse() or
+ * it was constructed from
+ *
+ * A NULL 'args' is equivalent to an empty argument vector
+ *
+ * A NULL 'opts' is equivalent to an 'opts' array containing a single
+ * end marker
+ *
+ * A NULL 'proc' is equivalent to a processing function always
+ * returning '1'
+ *
+ * @param args is the input and output argument list
+ * @param data is the user data
+ * @param opts is the option description array
+ * @param proc is the processing function
+ * @return -1 on error, 0 on success
+ */
+int fuse_opt_parse(struct fuse_args *args, void *data,
+		   const struct fuse_opt opts[], fuse_opt_proc_t proc);
+
+/**
+ * Add an option to a comma separated option list
+ *
+ * @param opts is a pointer to an option list, may point to a NULL value
+ * @param opt is the option to add
+ * @return -1 on allocation error, 0 on success
+ */
+int fuse_opt_add_opt(char **opts, const char *opt);
+
+/**
+ * Add an option, escaping commas, to a comma separated option list
+ *
+ * @param opts is a pointer to an option list, may point to a NULL value
+ * @param opt is the option to add
+ * @return -1 on allocation error, 0 on success
+ */
+int fuse_opt_add_opt_escaped(char **opts, const char *opt);
+
+/**
+ * Add an argument to a NULL terminated argument vector
+ *
+ * @param args is the structure containing the current argument list
+ * @param arg is the new argument to add
+ * @return -1 on allocation error, 0 on success
+ */
+int fuse_opt_add_arg(struct fuse_args *args, const char *arg);
+
+/**
+ * Add an argument at the specified position in a NULL terminated
+ * argument vector
+ *
+ * Adds the argument to the N-th position.  This is useful for adding
+ * options at the beginning of the array which must not come after the
+ * special '--' option.
+ *
+ * @param args is the structure containing the current argument list
+ * @param pos is the position at which to add the argument
+ * @param arg is the new argument to add
+ * @return -1 on allocation error, 0 on success
+ */
+int fuse_opt_insert_arg(struct fuse_args *args, int pos, const char *arg);
+
+/**
+ * Free the contents of argument list
+ *
+ * The structure itself is not freed
+ *
+ * @param args is the structure containing the argument list
+ */
+void fuse_opt_free_args(struct fuse_args *args);
+
+
+/**
+ * Check if an option matches
+ *
+ * @param opts is the option description array
+ * @param opt is the option to match
+ * @return 1 if a match is found, 0 if not
+ */
+int fuse_opt_match(const struct fuse_opt opts[], const char *opt);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _FUSE_OPT_H_ */
diff --git a/external/fuse/include/old/fuse.h b/external/fuse/include/old/fuse.h
new file mode 100755
index 0000000000..3db0945a97
--- /dev/null
+++ b/external/fuse/include/old/fuse.h
@@ -0,0 +1,9 @@
+/*
+   This header is for compatibility with older software using FUSE.
+
+   Please use 'pkg-config --cflags fuse' to set include path.  The
+   correct usage is still '#include <fuse.h>', not '#include
+   <fuse/fuse.h>'.
+*/
+
+#include "fuse/fuse.h"
diff --git a/external/fuse/include/stamp-h1 b/external/fuse/include/stamp-h1
new file mode 100755
index 0000000000..b330768e9b
--- /dev/null
+++ b/external/fuse/include/stamp-h1
@@ -0,0 +1 @@
+timestamp for include/config.h
diff --git a/external/fuse/include/sys/statvfs.h b/external/fuse/include/sys/statvfs.h
new file mode 100755
index 0000000000..6e3e39fd56
--- /dev/null
+++ b/external/fuse/include/sys/statvfs.h
@@ -0,0 +1,18 @@
+#ifndef __STATVFS_H
+#define __STATVFS_H
+
+struct statvfs {
+	unsigned long  f_bsize;    /* file system block size */
+	unsigned long  f_frsize;   /* fragment size */
+	fsblkcnt_t     f_blocks;   /* size of fs in f_frsize units */
+	fsblkcnt_t     f_bfree;    /* # free blocks */
+	fsblkcnt_t     f_bavail;   /* # free blocks for non-root */
+	fsfilcnt_t     f_files;    /* # inodes */
+	fsfilcnt_t     f_ffree;    /* # free inodes */
+	fsfilcnt_t     f_favail;   /* # free inodes for non-root */
+	unsigned long  f_fsid;     /* file system ID */
+	unsigned long  f_flag;     /* mount flags */
+	unsigned long  f_namemax;  /* maximum filename length */
+};
+
+#endif
diff --git a/external/fuse/include/ulockmgr.h b/external/fuse/include/ulockmgr.h
new file mode 100755
index 0000000000..ad555799f5
--- /dev/null
+++ b/external/fuse/include/ulockmgr.h
@@ -0,0 +1,24 @@
+/*
+  libulockmgr: Userspace Lock Manager Library
+  Copyright (C) 2006  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB.
+*/
+
+#include <stdint.h>
+#include <fcntl.h>
+#include <sys/types.h>
+
+/**
+ * Perform POSIX locking operation
+ *
+ * @param fd the file descriptor
+ * @param cmd the locking command (F_GETFL, F_SETLK or F_SETLKW)
+ * @param lock the lock parameters
+ * @param owner the lock owner ID cookie
+ * @param owner_len length of the lock owner ID cookie
+ * @return 0 on success -errno on error
+ */
+int ulockmgr_op(int fd, int cmd, struct flock *lock, const void *owner,
+		size_t owner_len);
diff --git a/external/fuse/mount.c b/external/fuse/mount.c
new file mode 100755
index 0000000000..af7218fa4b
--- /dev/null
+++ b/external/fuse/mount.c
@@ -0,0 +1,638 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB.
+*/
+
+#include "config.h"
+#include "fuse_i.h"
+#include "fuse_misc.h"
+#include "fuse_opt.h"
+#include "fuse_common_compat.h"
+#include "mount_util.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stddef.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/poll.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/wait.h>
+#include <sys/mount.h>
+
+#ifdef __NetBSD__
+#include <perfuse.h>
+
+#define MS_RDONLY 	MNT_RDONLY
+#define MS_NOSUID 	MNT_NOSUID
+#define MS_NODEV 	MNT_NODEV
+#define MS_NOEXEC 	MNT_NOEXEC
+#define MS_SYNCHRONOUS 	MNT_SYNCHRONOUS
+#define MS_NOATIME 	MNT_NOATIME
+
+
+#define umount2(mnt, flags) unmount(mnt, (flags == 2) ? MNT_FORCE : 0)
+#endif
+
+#define FUSERMOUNT_PROG		"fusermount"
+#define FUSE_COMMFD_ENV		"_FUSE_COMMFD"
+
+#ifndef HAVE_FORK
+#define fork() vfork()
+#endif
+
+#ifndef MS_DIRSYNC
+#define MS_DIRSYNC 128
+#endif
+
+enum {
+	KEY_KERN_FLAG,
+	KEY_KERN_OPT,
+	KEY_FUSERMOUNT_OPT,
+	KEY_SUBTYPE_OPT,
+	KEY_MTAB_OPT,
+	KEY_ALLOW_ROOT,
+	KEY_RO,
+	KEY_HELP,
+	KEY_VERSION,
+};
+
+struct mount_opts {
+	int allow_other;
+	int allow_root;
+	int ishelp;
+	int flags;
+	int nonempty;
+	int auto_unmount;
+	int blkdev;
+	char *fsname;
+	char *subtype;
+	char *subtype_opt;
+	char *mtab_opts;
+	char *fusermount_opts;
+	char *kernel_opts;
+};
+
+#define FUSE_MOUNT_OPT(t, p) { t, offsetof(struct mount_opts, p), 1 }
+
+static const struct fuse_opt fuse_mount_opts[] = {
+	FUSE_MOUNT_OPT("allow_other",		allow_other),
+	FUSE_MOUNT_OPT("allow_root",		allow_root),
+	FUSE_MOUNT_OPT("nonempty",		nonempty),
+	FUSE_MOUNT_OPT("blkdev",		blkdev),
+	FUSE_MOUNT_OPT("auto_unmount",		auto_unmount),
+	FUSE_MOUNT_OPT("fsname=%s",		fsname),
+	FUSE_MOUNT_OPT("subtype=%s",		subtype),
+	FUSE_OPT_KEY("allow_other",		KEY_KERN_OPT),
+	FUSE_OPT_KEY("allow_root",		KEY_ALLOW_ROOT),
+	FUSE_OPT_KEY("nonempty",		KEY_FUSERMOUNT_OPT),
+	FUSE_OPT_KEY("auto_unmount",		KEY_FUSERMOUNT_OPT),
+	FUSE_OPT_KEY("blkdev",			KEY_FUSERMOUNT_OPT),
+	FUSE_OPT_KEY("fsname=",			KEY_FUSERMOUNT_OPT),
+	FUSE_OPT_KEY("subtype=",		KEY_SUBTYPE_OPT),
+	FUSE_OPT_KEY("large_read",		KEY_KERN_OPT),
+	FUSE_OPT_KEY("blksize=",		KEY_KERN_OPT),
+	FUSE_OPT_KEY("default_permissions",	KEY_KERN_OPT),
+	FUSE_OPT_KEY("max_read=",		KEY_KERN_OPT),
+	FUSE_OPT_KEY("max_read=",		FUSE_OPT_KEY_KEEP),
+	FUSE_OPT_KEY("user=",			KEY_MTAB_OPT),
+	FUSE_OPT_KEY("-r",			KEY_RO),
+	FUSE_OPT_KEY("ro",			KEY_KERN_FLAG),
+	FUSE_OPT_KEY("rw",			KEY_KERN_FLAG),
+	FUSE_OPT_KEY("suid",			KEY_KERN_FLAG),
+	FUSE_OPT_KEY("nosuid",			KEY_KERN_FLAG),
+	FUSE_OPT_KEY("dev",			KEY_KERN_FLAG),
+	FUSE_OPT_KEY("nodev",			KEY_KERN_FLAG),
+	FUSE_OPT_KEY("exec",			KEY_KERN_FLAG),
+	FUSE_OPT_KEY("noexec",			KEY_KERN_FLAG),
+	FUSE_OPT_KEY("async",			KEY_KERN_FLAG),
+	FUSE_OPT_KEY("sync",			KEY_KERN_FLAG),
+	FUSE_OPT_KEY("dirsync",			KEY_KERN_FLAG),
+	FUSE_OPT_KEY("atime",			KEY_KERN_FLAG),
+	FUSE_OPT_KEY("noatime",			KEY_KERN_FLAG),
+	FUSE_OPT_KEY("-h",			KEY_HELP),
+	FUSE_OPT_KEY("--help",			KEY_HELP),
+	FUSE_OPT_KEY("-V",			KEY_VERSION),
+	FUSE_OPT_KEY("--version",		KEY_VERSION),
+	FUSE_OPT_END
+};
+
+static void mount_help(void)
+{
+	fprintf(stderr,
+"    -o allow_other         allow access to other users\n"
+"    -o allow_root          allow access to root\n"
+"    -o auto_unmount        auto unmount on process termination\n"
+"    -o nonempty            allow mounts over non-empty file/dir\n"
+"    -o default_permissions enable permission checking by kernel\n"
+"    -o fsname=NAME         set filesystem name\n"
+"    -o subtype=NAME        set filesystem type\n"
+"    -o large_read          issue large read requests (2.4 only)\n"
+"    -o max_read=N          set maximum size of read requests\n"
+"\n");
+}
+
+#define FUSERMOUNT_DIR "/usr/bin"
+static void exec_fusermount(const char *argv[])
+{
+	execv(FUSERMOUNT_DIR "/" FUSERMOUNT_PROG, (char **) argv);
+	execvp(FUSERMOUNT_PROG, (char **) argv);
+}
+
+static void mount_version(void)
+{
+	int pid = fork();
+	if (!pid) {
+		const char *argv[] = { FUSERMOUNT_PROG, "--version", NULL };
+		exec_fusermount(argv);
+		_exit(1);
+	} else if (pid != -1)
+		waitpid(pid, NULL, 0);
+}
+
+struct mount_flags {
+	const char *opt;
+	unsigned long flag;
+	int on;
+};
+
+static const struct mount_flags mount_flags[] = {
+	{"rw",	    MS_RDONLY,	    0},
+	{"ro",	    MS_RDONLY,	    1},
+	{"suid",    MS_NOSUID,	    0},
+	{"nosuid",  MS_NOSUID,	    1},
+	{"dev",	    MS_NODEV,	    0},
+	{"nodev",   MS_NODEV,	    1},
+	{"exec",    MS_NOEXEC,	    0},
+	{"noexec",  MS_NOEXEC,	    1},
+	{"async",   MS_SYNCHRONOUS, 0},
+	{"sync",    MS_SYNCHRONOUS, 1},
+	{"atime",   MS_NOATIME,	    0},
+	{"noatime", MS_NOATIME,	    1},
+#ifndef __NetBSD__
+	{"dirsync", MS_DIRSYNC,	    1},
+#endif
+	{NULL,	    0,		    0}
+};
+
+static void set_mount_flag(const char *s, int *flags)
+{
+	int i;
+
+	for (i = 0; mount_flags[i].opt != NULL; i++) {
+		const char *opt = mount_flags[i].opt;
+		if (strcmp(opt, s) == 0) {
+			if (mount_flags[i].on)
+				*flags |= mount_flags[i].flag;
+			else
+				*flags &= ~mount_flags[i].flag;
+			return;
+		}
+	}
+	fprintf(stderr, "fuse: internal error, can't find mount flag\n");
+	abort();
+}
+
+static int fuse_mount_opt_proc(void *data, const char *arg, int key,
+			       struct fuse_args *outargs)
+{
+	struct mount_opts *mo = data;
+
+	switch (key) {
+	case KEY_ALLOW_ROOT:
+		if (fuse_opt_add_opt(&mo->kernel_opts, "allow_other") == -1 ||
+		    fuse_opt_add_arg(outargs, "-oallow_root") == -1)
+			return -1;
+		return 0;
+
+	case KEY_RO:
+		arg = "ro";
+		/* fall through */
+	case KEY_KERN_FLAG:
+		set_mount_flag(arg, &mo->flags);
+		return 0;
+
+	case KEY_KERN_OPT:
+		return fuse_opt_add_opt(&mo->kernel_opts, arg);
+
+	case KEY_FUSERMOUNT_OPT:
+		return fuse_opt_add_opt_escaped(&mo->fusermount_opts, arg);
+
+	case KEY_SUBTYPE_OPT:
+		return fuse_opt_add_opt(&mo->subtype_opt, arg);
+
+	case KEY_MTAB_OPT:
+		return fuse_opt_add_opt(&mo->mtab_opts, arg);
+
+	case KEY_HELP:
+		mount_help();
+		mo->ishelp = 1;
+		break;
+
+	case KEY_VERSION:
+		mount_version();
+		mo->ishelp = 1;
+		break;
+	}
+	return 1;
+}
+
+/* return value:
+ * >= 0	 => fd
+ * -1	 => error
+ */
+static int receive_fd(int fd)
+{
+	struct msghdr msg;
+	struct iovec iov;
+	char buf[1];
+	int rv;
+	size_t ccmsg[CMSG_SPACE(sizeof(int)) / sizeof(size_t)];
+	struct cmsghdr *cmsg;
+
+	iov.iov_base = buf;
+	iov.iov_len = 1;
+
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_name = 0;
+	msg.msg_namelen = 0;
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+	/* old BSD implementations should use msg_accrights instead of
+	 * msg_control; the interface is different. */
+	msg.msg_control = ccmsg;
+	msg.msg_controllen = sizeof(ccmsg);
+
+	while(((rv = recvmsg(fd, &msg, 0)) == -1) && errno == EINTR);
+	if (rv == -1) {
+		perror("recvmsg");
+		return -1;
+	}
+	if(!rv) {
+		/* EOF */
+		return -1;
+	}
+
+	cmsg = CMSG_FIRSTHDR(&msg);
+	if (!cmsg->cmsg_type == SCM_RIGHTS) {
+		fprintf(stderr, "got control message of unknown type %d\n",
+			cmsg->cmsg_type);
+		return -1;
+	}
+	return *(int*)CMSG_DATA(cmsg);
+}
+
+void fuse_kern_unmount(const char *mountpoint, int fd)
+{
+	int res;
+	int pid;
+
+	if (!mountpoint)
+		return;
+
+	if (fd != -1) {
+		struct pollfd pfd;
+
+		pfd.fd = fd;
+		pfd.events = 0;
+		res = poll(&pfd, 1, 0);
+		/* If file poll returns POLLERR on the device file descriptor,
+		   then the filesystem is already unmounted */
+		if (res == 1 && (pfd.revents & POLLERR))
+			return;
+
+		/* Need to close file descriptor, otherwise synchronous umount
+		   would recurse into filesystem, and deadlock */
+		close(fd);
+	}
+
+	if (geteuid() == 0) {
+		fuse_mnt_umount("fuse", mountpoint, mountpoint,  1);
+		return;
+	}
+
+	res = umount2(mountpoint, 2);
+	if (res == 0)
+		return;
+
+	pid = fork();
+	if(pid == -1)
+		return;
+
+	if(pid == 0) {
+		const char *argv[] = { FUSERMOUNT_PROG, "-u", "-q", "-z",
+				       "--", mountpoint, NULL };
+
+		exec_fusermount(argv);
+		_exit(1);
+	}
+	waitpid(pid, NULL, 0);
+}
+
+void fuse_unmount_compat22(const char *mountpoint)
+{
+	fuse_kern_unmount(mountpoint, -1);
+}
+
+static int fuse_mount_fusermount(const char *mountpoint, struct mount_opts *mo,
+		const char *opts, int quiet)
+{
+	int fds[2], pid;
+	int res;
+	int rv;
+
+	if (!mountpoint) {
+		fprintf(stderr, "fuse: missing mountpoint parameter\n");
+		return -1;
+	}
+
+	res = socketpair(PF_UNIX, SOCK_STREAM, 0, fds);
+	if(res == -1) {
+		perror("fuse: socketpair() failed");
+		return -1;
+	}
+
+	pid = fork();
+	if(pid == -1) {
+		perror("fuse: fork() failed");
+		close(fds[0]);
+		close(fds[1]);
+		return -1;
+	}
+
+	if(pid == 0) {
+		char env[10];
+		const char *argv[32];
+		int a = 0;
+
+		if (quiet) {
+			int fd = open("/dev/null", O_RDONLY);
+			if (fd != -1) {
+				dup2(fd, 1);
+				dup2(fd, 2);
+			}
+		}
+
+		argv[a++] = FUSERMOUNT_PROG;
+		if (opts) {
+			argv[a++] = "-o";
+			argv[a++] = opts;
+		}
+		argv[a++] = "--";
+		argv[a++] = mountpoint;
+		argv[a++] = NULL;
+
+		close(fds[1]);
+		fcntl(fds[0], F_SETFD, 0);
+		snprintf(env, sizeof(env), "%i", fds[0]);
+		setenv(FUSE_COMMFD_ENV, env, 1);
+		exec_fusermount(argv);
+		perror("fuse: failed to exec fusermount");
+		_exit(1);
+	}
+
+	close(fds[0]);
+	rv = receive_fd(fds[1]);
+
+	if (!mo->auto_unmount) {
+		/* with auto_unmount option fusermount will not exit until 
+		   this socket is closed */
+		close(fds[1]);
+		waitpid(pid, NULL, 0); /* bury zombie */
+	}
+
+	return rv;
+}
+
+int fuse_mount_compat22(const char *mountpoint, const char *opts)
+{
+	struct mount_opts mo;
+	memset(&mo, 0, sizeof(mo));
+	mo.flags = MS_NOSUID | MS_NODEV;
+
+	return fuse_mount_fusermount(mountpoint, &mo, opts, 0);
+}
+
+static int fuse_mount_sys(const char *mnt, struct mount_opts *mo,
+			  const char *mnt_opts)
+{
+	char tmp[128];
+	const char *devname = "/dev/fuse";
+	char *source = NULL;
+	char *type = NULL;
+	struct stat stbuf;
+	int fd;
+	int res;
+
+	if (!mnt) {
+		fprintf(stderr, "fuse: missing mountpoint parameter\n");
+		return -1;
+	}
+
+	res = stat(mnt, &stbuf);
+	if (res == -1) {
+		fprintf(stderr ,"fuse: failed to access mountpoint %s: %s\n",
+			mnt, strerror(errno));
+		return -1;
+	}
+
+	if (!mo->nonempty) {
+		res = fuse_mnt_check_empty("fuse", mnt, stbuf.st_mode,
+					   stbuf.st_size);
+		if (res == -1)
+			return -1;
+	}
+
+	if (mo->auto_unmount) {
+		/* Tell the caller to fallback to fusermount because
+		   auto-unmount does not work otherwise. */
+		return -2;
+	}
+
+	fd = open(devname, O_RDWR);
+	if (fd == -1) {
+		if (errno == ENODEV || errno == ENOENT)
+			fprintf(stderr, "fuse: device not found, try 'modprobe fuse' first\n");
+		else
+			fprintf(stderr, "fuse: failed to open %s: %s\n",
+				devname, strerror(errno));
+		return -1;
+	}
+
+	snprintf(tmp, sizeof(tmp),  "fd=%i,rootmode=%o,user_id=%i,group_id=%i",
+		 fd, stbuf.st_mode & S_IFMT, getuid(), getgid());
+
+	res = fuse_opt_add_opt(&mo->kernel_opts, tmp);
+	if (res == -1)
+		goto out_close;
+
+	source = malloc((mo->fsname ? strlen(mo->fsname) : 0) +
+			(mo->subtype ? strlen(mo->subtype) : 0) +
+			strlen(devname) + 32);
+
+	type = malloc((mo->subtype ? strlen(mo->subtype) : 0) + 32);
+	if (!type || !source) {
+		fprintf(stderr, "fuse: failed to allocate memory\n");
+		goto out_close;
+	}
+
+	strcpy(type, mo->blkdev ? "fuseblk" : "fuse");
+	if (mo->subtype) {
+		strcat(type, ".");
+		strcat(type, mo->subtype);
+	}
+	strcpy(source,
+	       mo->fsname ? mo->fsname : (mo->subtype ? mo->subtype : devname));
+
+	res = mount(source, mnt, type, mo->flags, mo->kernel_opts);
+	if (res == -1 && errno == ENODEV && mo->subtype) {
+		/* Probably missing subtype support */
+		strcpy(type, mo->blkdev ? "fuseblk" : "fuse");
+		if (mo->fsname) {
+			if (!mo->blkdev)
+				sprintf(source, "%s#%s", mo->subtype,
+					mo->fsname);
+		} else {
+			strcpy(source, type);
+		}
+		res = mount(source, mnt, type, mo->flags, mo->kernel_opts);
+	}
+	if (res == -1) {
+		/*
+		 * Maybe kernel doesn't support unprivileged mounts, in this
+		 * case try falling back to fusermount
+		 */
+		if (errno == EPERM) {
+			res = -2;
+		} else {
+			int errno_save = errno;
+			if (mo->blkdev && errno == ENODEV &&
+			    !fuse_mnt_check_fuseblk())
+				fprintf(stderr,
+					"fuse: 'fuseblk' support missing\n");
+			else
+				fprintf(stderr, "fuse: mount failed: %s\n",
+					strerror(errno_save));
+		}
+
+		goto out_close;
+	}
+
+#ifndef __NetBSD__
+#ifndef IGNORE_MTAB
+	if (geteuid() == 0) {
+		char *newmnt = fuse_mnt_resolve_path("fuse", mnt);
+		res = -1;
+		if (!newmnt)
+			goto out_umount;
+
+		res = fuse_mnt_add_mount("fuse", source, newmnt, type,
+					 mnt_opts);
+		free(newmnt);
+		if (res == -1)
+			goto out_umount;
+	}
+#endif /* IGNORE_MTAB */
+#endif /* __NetBSD__ */
+	free(type);
+	free(source);
+
+	return fd;
+
+out_umount:
+	umount2(mnt, 2); /* lazy umount */
+out_close:
+	free(type);
+	free(source);
+	close(fd);
+	return res;
+}
+
+static int get_mnt_flag_opts(char **mnt_optsp, int flags)
+{
+	int i;
+
+	if (!(flags & MS_RDONLY) && fuse_opt_add_opt(mnt_optsp, "rw") == -1)
+		return -1;
+
+	for (i = 0; mount_flags[i].opt != NULL; i++) {
+		if (mount_flags[i].on && (flags & mount_flags[i].flag) &&
+		    fuse_opt_add_opt(mnt_optsp, mount_flags[i].opt) == -1)
+			return -1;
+	}
+	return 0;
+}
+
+int fuse_kern_mount(const char *mountpoint, struct fuse_args *args)
+{
+	struct mount_opts mo;
+	int res = -1;
+	char *mnt_opts = NULL;
+
+	memset(&mo, 0, sizeof(mo));
+	mo.flags = MS_NOSUID | MS_NODEV;
+
+	if (args &&
+	    fuse_opt_parse(args, &mo, fuse_mount_opts, fuse_mount_opt_proc) == -1)
+		return -1;
+
+	if (mo.allow_other && mo.allow_root) {
+		fprintf(stderr, "fuse: 'allow_other' and 'allow_root' options are mutually exclusive\n");
+		goto out;
+	}
+	res = 0;
+	if (mo.ishelp)
+		goto out;
+
+	res = -1;
+	if (get_mnt_flag_opts(&mnt_opts, mo.flags) == -1)
+		goto out;
+	if (mo.kernel_opts && fuse_opt_add_opt(&mnt_opts, mo.kernel_opts) == -1)
+		goto out;
+	if (mo.mtab_opts &&  fuse_opt_add_opt(&mnt_opts, mo.mtab_opts) == -1)
+		goto out;
+
+	res = fuse_mount_sys(mountpoint, &mo, mnt_opts);
+	if (res == -2) {
+		if (mo.fusermount_opts &&
+		    fuse_opt_add_opt(&mnt_opts, mo.fusermount_opts) == -1)
+			goto out;
+
+		if (mo.subtype) {
+			char *tmp_opts = NULL;
+
+			res = -1;
+			if (fuse_opt_add_opt(&tmp_opts, mnt_opts) == -1 ||
+			    fuse_opt_add_opt(&tmp_opts, mo.subtype_opt) == -1) {
+				free(tmp_opts);
+				goto out;
+			}
+
+			res = fuse_mount_fusermount(mountpoint, &mo, tmp_opts, 1);
+			free(tmp_opts);
+			if (res == -1)
+				res = fuse_mount_fusermount(mountpoint, &mo,
+							    mnt_opts, 0);
+		} else {
+			res = fuse_mount_fusermount(mountpoint, &mo, mnt_opts, 0);
+		}
+	}
+out:
+	free(mnt_opts);
+	free(mo.fsname);
+	free(mo.subtype);
+	free(mo.fusermount_opts);
+	free(mo.subtype_opt);
+	free(mo.kernel_opts);
+	free(mo.mtab_opts);
+	return res;
+}
+
+FUSE_SYMVER(".symver fuse_mount_compat22,fuse_mount@FUSE_2.2");
+FUSE_SYMVER(".symver fuse_unmount_compat22,fuse_unmount@FUSE_2.2");
diff --git a/external/fuse/mount_bsd.c b/external/fuse/mount_bsd.c
new file mode 100755
index 0000000000..62443ac25f
--- /dev/null
+++ b/external/fuse/mount_bsd.c
@@ -0,0 +1,388 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2005-2008 Csaba Henk <csaba.henk@creo.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB.
+*/
+
+#include "fuse_i.h"
+#include "fuse_misc.h"
+#include "fuse_opt.h"
+
+#include <sys/stat.h>
+#include <sys/wait.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stddef.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <paths.h>
+#include <limits.h>
+
+#define FUSERMOUNT_PROG		"mount_fusefs"
+#define FUSE_DEV_TRUNK		"/dev/fuse"
+
+enum {
+	KEY_ALLOW_ROOT,
+	KEY_RO,
+	KEY_HELP,
+	KEY_VERSION,
+	KEY_KERN
+};
+
+struct mount_opts {
+	int allow_other;
+	int allow_root;
+	int ishelp;
+	char *kernel_opts;
+};
+
+#define FUSE_DUAL_OPT_KEY(templ, key) 				\
+	FUSE_OPT_KEY(templ, key), FUSE_OPT_KEY("no" templ, key)
+
+static const struct fuse_opt fuse_mount_opts[] = {
+	{ "allow_other", offsetof(struct mount_opts, allow_other), 1 },
+	{ "allow_root", offsetof(struct mount_opts, allow_root), 1 },
+	FUSE_OPT_KEY("allow_root",		KEY_ALLOW_ROOT),
+	FUSE_OPT_KEY("-r",			KEY_RO),
+	FUSE_OPT_KEY("-h",			KEY_HELP),
+	FUSE_OPT_KEY("--help",			KEY_HELP),
+	FUSE_OPT_KEY("-V",			KEY_VERSION),
+	FUSE_OPT_KEY("--version",		KEY_VERSION),
+	/* standard FreeBSD mount options */
+	FUSE_DUAL_OPT_KEY("dev",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("async",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("atime",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("dev",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("exec",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("suid",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("symfollow",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("rdonly",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("sync",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("union",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("userquota",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("groupquota",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("clusterr",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("clusterw",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("suiddir",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("snapshot",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("multilabel",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("acls",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("force",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("update",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("ro",			KEY_KERN),
+	FUSE_DUAL_OPT_KEY("rw",			KEY_KERN),
+	FUSE_DUAL_OPT_KEY("auto",		KEY_KERN),
+	/* options supported under both Linux and FBSD */
+	FUSE_DUAL_OPT_KEY("allow_other",	KEY_KERN),
+	FUSE_DUAL_OPT_KEY("default_permissions",KEY_KERN),
+	FUSE_OPT_KEY("max_read=",		KEY_KERN),
+	FUSE_OPT_KEY("subtype=",		KEY_KERN),
+	/* FBSD FUSE specific mount options */
+	FUSE_DUAL_OPT_KEY("private",		KEY_KERN),
+	FUSE_DUAL_OPT_KEY("neglect_shares",	KEY_KERN),
+	FUSE_DUAL_OPT_KEY("push_symlinks_in",	KEY_KERN),
+	FUSE_OPT_KEY("nosync_unmount",		KEY_KERN),
+	/* stock FBSD mountopt parsing routine lets anything be negated... */
+	/*
+	 * Linux specific mount options, but let just the mount util
+	 * handle them
+	 */
+	FUSE_OPT_KEY("fsname=",			KEY_KERN),
+	FUSE_OPT_KEY("nonempty",		KEY_KERN),
+	FUSE_OPT_KEY("large_read",		KEY_KERN),
+	FUSE_OPT_END
+};
+
+static void mount_help(void)
+{
+	fprintf(stderr,
+		"    -o allow_root          allow access to root\n"
+		);
+	system(FUSERMOUNT_PROG " --help");
+	fputc('\n', stderr);
+}
+
+static void mount_version(void)
+{
+	system(FUSERMOUNT_PROG " --version");
+}
+
+static int fuse_mount_opt_proc(void *data, const char *arg, int key,
+			       struct fuse_args *outargs)
+{
+	struct mount_opts *mo = data;
+
+	switch (key) {
+	case KEY_ALLOW_ROOT:
+		if (fuse_opt_add_opt(&mo->kernel_opts, "allow_other") == -1 ||
+		    fuse_opt_add_arg(outargs, "-oallow_root") == -1)
+			return -1;
+		return 0;
+
+	case KEY_RO:
+		arg = "ro";
+		/* fall through */
+
+	case KEY_KERN:
+		return fuse_opt_add_opt(&mo->kernel_opts, arg);
+
+	case KEY_HELP:
+		mount_help();
+		mo->ishelp = 1;
+		break;
+
+	case KEY_VERSION:
+		mount_version();
+		mo->ishelp = 1;
+		break;
+	}
+	return 1;
+}
+
+void fuse_unmount_compat22(const char *mountpoint)
+{
+	char dev[128];
+	char *ssc, *umount_cmd;
+	FILE *sf;
+	int rv;
+	char seekscript[] =
+		/* error message is annoying in help output */
+		"exec 2>/dev/null; "
+		"/usr/bin/fstat " FUSE_DEV_TRUNK "* | "
+		"/usr/bin/awk 'BEGIN{ getline; if (! ($3 == \"PID\" && $10 == \"NAME\")) exit 1; }; "
+		"              { if ($3 == %d) print $10; }' | "
+		"/usr/bin/sort | "
+		"/usr/bin/uniq | "
+		"/usr/bin/awk '{ i += 1; if (i > 1){ exit 1; }; printf; }; END{ if (i == 0) exit 1; }'";
+
+	(void) mountpoint;
+
+	/*
+	 * If we don't know the fd, we have to resort to the scripted
+	 * solution -- iterating over the fd-s is unpractical, as we
+	 * don't know how many of open files we have. (This could be
+	 * looked up in procfs -- however, that's optional on FBSD; or
+	 * read out from the kmem -- however, that's bound to
+	 * privileges (in fact, that's what happens when we call the
+	 * setgid kmem fstat(1) utility).
+	 */
+	if (asprintf(&ssc, seekscript, getpid()) == -1)
+		return;
+
+	errno = 0;
+	sf = popen(ssc, "r");
+	free(ssc);
+	if (! sf)
+		return;
+
+	fgets(dev, sizeof(dev), sf);
+	rv = pclose(sf);
+	if (rv)
+		return;
+
+	if (asprintf(&umount_cmd, "/sbin/umount %s", dev) == -1)
+		return;
+	system(umount_cmd);
+	free(umount_cmd);
+}
+
+static void do_unmount(char *dev, int fd)
+{
+	char device_path[SPECNAMELEN + 12];
+	const char *argv[4];
+	const char umount_cmd[] = "/sbin/umount";
+	pid_t pid;
+
+	snprintf(device_path, SPECNAMELEN + 12, _PATH_DEV "%s", dev);
+
+	argv[0] = umount_cmd;
+	argv[1] = "-f";
+	argv[2] = device_path;
+	argv[3] = NULL;
+
+	pid = fork();
+
+	if (pid == -1)
+		return;
+
+	if (pid == 0) {
+		close(fd);
+		execvp(umount_cmd, (char **)argv);
+		exit(1);
+	}
+
+	waitpid(pid, NULL, 0);
+}
+
+void fuse_kern_unmount(const char *mountpoint, int fd)
+{
+	char *ep, dev[128];
+	struct stat sbuf;
+
+	(void)mountpoint;
+
+	if (fstat(fd, &sbuf) == -1)
+		return;
+
+	devname_r(sbuf.st_rdev, S_IFCHR, dev, 128);
+
+	if (strncmp(dev, "fuse", 4))
+		return;
+
+	strtol(dev + 4, &ep, 10);
+	if (*ep != '\0')
+		return;
+
+	do_unmount(dev, fd);
+}
+
+/* Check if kernel is doing init in background */
+static int init_backgrounded(void)
+{
+	unsigned ibg, len;
+
+	len = sizeof(ibg);
+
+	if (sysctlbyname("vfs.fuse.init_backgrounded", &ibg, &len, NULL, 0))
+		return 0;
+
+	return ibg;
+}
+
+
+static int fuse_mount_core(const char *mountpoint, const char *opts)
+{
+	const char *mountprog = FUSERMOUNT_PROG;
+	int fd;
+	char *fdnam, *dev;
+	pid_t pid, cpid;
+	int status;
+
+	fdnam = getenv("FUSE_DEV_FD");
+
+	if (fdnam) {
+		char *ep;
+
+		fd = strtol(fdnam, &ep, 10);
+
+		if (*ep != '\0') {
+			fprintf(stderr, "invalid value given in FUSE_DEV_FD\n");
+			return -1;
+		}
+
+		if (fd < 0)
+			return -1;
+
+		goto mount;
+	}
+
+	dev = getenv("FUSE_DEV_NAME");
+
+	if (! dev)
+		dev = (char *)FUSE_DEV_TRUNK;
+
+	if ((fd = open(dev, O_RDWR)) < 0) {
+		perror("fuse: failed to open fuse device");
+		return -1;
+	}
+
+mount:
+	if (getenv("FUSE_NO_MOUNT") || ! mountpoint)
+		goto out;
+
+	pid = fork();
+	cpid = pid;
+
+	if (pid == -1) {
+		perror("fuse: fork() failed");
+		close(fd);
+		return -1;
+	}
+
+	if (pid == 0) {
+		if (! init_backgrounded()) {
+			/*
+			 * If init is not backgrounded, we have to
+			 * call the mount util backgrounded, to avoid
+			 * deadlock.
+			 */
+
+			pid = fork();
+
+			if (pid == -1) {
+				perror("fuse: fork() failed");
+				close(fd);
+				exit(1);
+			}
+		}
+
+		if (pid == 0) {
+			const char *argv[32];
+			int a = 0;
+
+			if (! fdnam && asprintf(&fdnam, "%d", fd) == -1) {
+				perror("fuse: failed to assemble mount arguments");
+				exit(1);
+			}
+
+			argv[a++] = mountprog;
+			if (opts) {
+				argv[a++] = "-o";
+				argv[a++] = opts;
+			}
+			argv[a++] = fdnam;
+			argv[a++] = mountpoint;
+			argv[a++] = NULL;
+			execvp(mountprog, (char **) argv);
+			perror("fuse: failed to exec mount program");
+			exit(1);
+		}
+
+		exit(0);
+	}
+
+	if (waitpid(cpid, &status, 0) == -1 || WEXITSTATUS(status) != 0) {
+		perror("fuse: failed to mount file system");
+		close(fd);
+		return -1;
+	}
+
+out:
+	return fd;
+}
+
+int fuse_kern_mount(const char *mountpoint, struct fuse_args *args)
+{
+	struct mount_opts mo;
+	int res = -1;
+
+	memset(&mo, 0, sizeof(mo));
+	/* mount util should not try to spawn the daemon */
+	setenv("MOUNT_FUSEFS_SAFE", "1", 1);
+	/* to notify the mount util it's called from lib */
+	setenv("MOUNT_FUSEFS_CALL_BY_LIB", "1", 1);
+
+	if (args &&
+	    fuse_opt_parse(args, &mo, fuse_mount_opts, fuse_mount_opt_proc) == -1)
+		return -1;
+
+	if (mo.allow_other && mo.allow_root) {
+		fprintf(stderr, "fuse: 'allow_other' and 'allow_root' options are mutually exclusive\n");
+		goto out;
+	}
+	if (mo.ishelp)
+		return 0;
+
+	res = fuse_mount_core(mountpoint, mo.kernel_opts);
+out:
+	free(mo.kernel_opts);
+	return res;
+}
+
+FUSE_SYMVER(".symver fuse_unmount_compat22,fuse_unmount@FUSE_2.2");
diff --git a/external/fuse/mount_util.c b/external/fuse/mount_util.c
new file mode 100755
index 0000000000..bfd801fff0
--- /dev/null
+++ b/external/fuse/mount_util.c
@@ -0,0 +1,350 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB.
+*/
+
+#include "mount_util.h"
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+#include <dirent.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <mntent.h>
+#include <paths.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+#include <sys/mount.h>
+#include <sys/param.h>
+
+#ifdef __NetBSD__
+#define umount2(mnt, flags) unmount(mnt, (flags == 2) ? MNT_FORCE : 0)
+#define mtab_needs_update(mnt) 0
+#else
+static int mtab_needs_update(const char *mnt)
+{
+	int res;
+	struct stat stbuf;
+
+	/* If mtab is within new mount, don't touch it */
+	if (strncmp(mnt, _PATH_MOUNTED, strlen(mnt)) == 0 &&
+	    _PATH_MOUNTED[strlen(mnt)] == '/')
+		return 0;
+
+	/*
+	 * Skip mtab update if /etc/mtab:
+	 *
+	 *  - doesn't exist,
+	 *  - is a symlink,
+	 *  - is on a read-only filesystem.
+	 */
+	res = lstat(_PATH_MOUNTED, &stbuf);
+	if (res == -1) {
+		if (errno == ENOENT)
+			return 0;
+	} else {
+		uid_t ruid;
+		int err;
+
+		if (S_ISLNK(stbuf.st_mode))
+			return 0;
+
+		ruid = getuid();
+		if (ruid != 0)
+			setreuid(0, -1);
+
+		res = access(_PATH_MOUNTED, W_OK);
+		err = (res == -1) ? errno : 0;
+		if (ruid != 0)
+			setreuid(ruid, -1);
+
+		if (err == EROFS)
+			return 0;
+	}
+
+	return 1;
+}
+#endif /* __NetBSD__ */
+
+static int add_mount(const char *progname, const char *fsname,
+		       const char *mnt, const char *type, const char *opts)
+{
+	int res;
+	int status;
+	sigset_t blockmask;
+	sigset_t oldmask;
+
+	sigemptyset(&blockmask);
+	sigaddset(&blockmask, SIGCHLD);
+	res = sigprocmask(SIG_BLOCK, &blockmask, &oldmask);
+	if (res == -1) {
+		fprintf(stderr, "%s: sigprocmask: %s\n", progname, strerror(errno));
+		return -1;
+	}
+
+	res = fork();
+	if (res == -1) {
+		fprintf(stderr, "%s: fork: %s\n", progname, strerror(errno));
+		goto out_restore;
+	}
+	if (res == 0) {
+		sigprocmask(SIG_SETMASK, &oldmask, NULL);
+		setuid(geteuid());
+		execl("/bin/mount", "/bin/mount", "--no-canonicalize", "-i",
+		      "-f", "-t", type, "-o", opts, fsname, mnt, NULL);
+		fprintf(stderr, "%s: failed to execute /bin/mount: %s\n",
+			progname, strerror(errno));
+		exit(1);
+	}
+	res = waitpid(res, &status, 0);
+	if (res == -1)
+		fprintf(stderr, "%s: waitpid: %s\n", progname, strerror(errno));
+
+	if (status != 0)
+		res = -1;
+
+ out_restore:
+	sigprocmask(SIG_SETMASK, &oldmask, NULL);
+
+	return res;
+}
+
+int fuse_mnt_add_mount(const char *progname, const char *fsname,
+		       const char *mnt, const char *type, const char *opts)
+{
+	if (!mtab_needs_update(mnt))
+		return 0;
+
+	return add_mount(progname, fsname, mnt, type, opts);
+}
+
+static int exec_umount(const char *progname, const char *rel_mnt, int lazy)
+{
+	int res;
+	int status;
+	sigset_t blockmask;
+	sigset_t oldmask;
+
+	sigemptyset(&blockmask);
+	sigaddset(&blockmask, SIGCHLD);
+	res = sigprocmask(SIG_BLOCK, &blockmask, &oldmask);
+	if (res == -1) {
+		fprintf(stderr, "%s: sigprocmask: %s\n", progname, strerror(errno));
+		return -1;
+	}
+
+	res = fork();
+	if (res == -1) {
+		fprintf(stderr, "%s: fork: %s\n", progname, strerror(errno));
+		goto out_restore;
+	}
+	if (res == 0) {
+		sigprocmask(SIG_SETMASK, &oldmask, NULL);
+		setuid(geteuid());
+		execl("/bin/umount", "/bin/umount", "-i", rel_mnt,
+		      lazy ? "-l" : NULL, NULL);
+		fprintf(stderr, "%s: failed to execute /bin/umount: %s\n",
+			progname, strerror(errno));
+		exit(1);
+	}
+	res = waitpid(res, &status, 0);
+	if (res == -1)
+		fprintf(stderr, "%s: waitpid: %s\n", progname, strerror(errno));
+
+	if (status != 0) {
+		res = -1;
+	}
+
+ out_restore:
+	sigprocmask(SIG_SETMASK, &oldmask, NULL);
+	return res;
+
+}
+
+int fuse_mnt_umount(const char *progname, const char *abs_mnt,
+		    const char *rel_mnt, int lazy)
+{
+	int res;
+
+	if (!mtab_needs_update(abs_mnt)) {
+		res = umount2(rel_mnt, lazy ? 2 : 0);
+		if (res == -1)
+			fprintf(stderr, "%s: failed to unmount %s: %s\n",
+				progname, abs_mnt, strerror(errno));
+		return res;
+	}
+
+	return exec_umount(progname, rel_mnt, lazy);
+}
+
+static int remove_mount(const char *progname, const char *mnt)
+{
+	int res;
+	int status;
+	sigset_t blockmask;
+	sigset_t oldmask;
+
+	sigemptyset(&blockmask);
+	sigaddset(&blockmask, SIGCHLD);
+	res = sigprocmask(SIG_BLOCK, &blockmask, &oldmask);
+	if (res == -1) {
+		fprintf(stderr, "%s: sigprocmask: %s\n", progname, strerror(errno));
+		return -1;
+	}
+
+	res = fork();
+	if (res == -1) {
+		fprintf(stderr, "%s: fork: %s\n", progname, strerror(errno));
+		goto out_restore;
+	}
+	if (res == 0) {
+		sigprocmask(SIG_SETMASK, &oldmask, NULL);
+		setuid(geteuid());
+		execl("/bin/umount", "/bin/umount", "--no-canonicalize", "-i",
+		      "--fake", mnt, NULL);
+		fprintf(stderr, "%s: failed to execute /bin/umount: %s\n",
+			progname, strerror(errno));
+		exit(1);
+	}
+	res = waitpid(res, &status, 0);
+	if (res == -1)
+		fprintf(stderr, "%s: waitpid: %s\n", progname, strerror(errno));
+
+	if (status != 0)
+		res = -1;
+
+ out_restore:
+	sigprocmask(SIG_SETMASK, &oldmask, NULL);
+	return res;
+}
+
+int fuse_mnt_remove_mount(const char *progname, const char *mnt)
+{
+	if (!mtab_needs_update(mnt))
+		return 0;
+
+	return remove_mount(progname, mnt);
+}
+
+char *fuse_mnt_resolve_path(const char *progname, const char *orig)
+{
+	char buf[PATH_MAX];
+	char *copy;
+	char *dst;
+	char *end;
+	char *lastcomp;
+	const char *toresolv;
+
+	if (!orig[0]) {
+		fprintf(stderr, "%s: invalid mountpoint '%s'\n", progname,
+			orig);
+		return NULL;
+	}
+
+	copy = strdup(orig);
+	if (copy == NULL) {
+		fprintf(stderr, "%s: failed to allocate memory\n", progname);
+		return NULL;
+	}
+
+	toresolv = copy;
+	lastcomp = NULL;
+	for (end = copy + strlen(copy) - 1; end > copy && *end == '/'; end --);
+	if (end[0] != '/') {
+		char *tmp;
+		end[1] = '\0';
+		tmp = strrchr(copy, '/');
+		if (tmp == NULL) {
+			lastcomp = copy;
+			toresolv = ".";
+		} else {
+			lastcomp = tmp + 1;
+			if (tmp == copy)
+				toresolv = "/";
+		}
+		if (strcmp(lastcomp, ".") == 0 || strcmp(lastcomp, "..") == 0) {
+			lastcomp = NULL;
+			toresolv = copy;
+		}
+		else if (tmp)
+			tmp[0] = '\0';
+	}
+	if (realpath(toresolv, buf) == NULL) {
+		fprintf(stderr, "%s: bad mount point %s: %s\n", progname, orig,
+			strerror(errno));
+		free(copy);
+		return NULL;
+	}
+	if (lastcomp == NULL)
+		dst = strdup(buf);
+	else {
+		dst = (char *) malloc(strlen(buf) + 1 + strlen(lastcomp) + 1);
+		if (dst) {
+			unsigned buflen = strlen(buf);
+			if (buflen && buf[buflen-1] == '/')
+				sprintf(dst, "%s%s", buf, lastcomp);
+			else
+				sprintf(dst, "%s/%s", buf, lastcomp);
+		}
+	}
+	free(copy);
+	if (dst == NULL)
+		fprintf(stderr, "%s: failed to allocate memory\n", progname);
+	return dst;
+}
+
+int fuse_mnt_check_empty(const char *progname, const char *mnt,
+			 mode_t rootmode, off64_t rootsize)
+{
+	int isempty = 1;
+
+	if (S_ISDIR(rootmode)) {
+		struct dirent *ent;
+		DIR *dp = opendir(mnt);
+		if (dp == NULL) {
+			fprintf(stderr,
+				"%s: failed to open mountpoint for reading: %s\n",
+				progname, strerror(errno));
+			return -1;
+		}
+		while ((ent = readdir(dp)) != NULL) {
+			if (strcmp(ent->d_name, ".") != 0 &&
+			    strcmp(ent->d_name, "..") != 0) {
+				isempty = 0;
+				break;
+			}
+		}
+		closedir(dp);
+	} else if (rootsize)
+		isempty = 0;
+
+	if (!isempty) {
+		fprintf(stderr, "%s: mountpoint is not empty\n", progname);
+		fprintf(stderr, "%s: if you are sure this is safe, use the 'nonempty' mount option\n", progname);
+		return -1;
+	}
+	return 0;
+}
+
+int fuse_mnt_check_fuseblk(void)
+{
+	char buf[256];
+	FILE *f = fopen("/proc/filesystems", "r");
+	if (!f)
+		return 1;
+
+	while (fgets(buf, sizeof(buf), f))
+		if (strstr(buf, "fuseblk\n")) {
+			fclose(f);
+			return 1;
+		}
+
+	fclose(f);
+	return 0;
+}
diff --git a/external/fuse/mount_util.h b/external/fuse/mount_util.h
new file mode 100755
index 0000000000..f89c1154d7
--- /dev/null
+++ b/external/fuse/mount_util.h
@@ -0,0 +1,19 @@
+/*
+  FUSE: Filesystem in Userspace
+  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB.
+*/
+
+#include <sys/types.h>
+
+int fuse_mnt_add_mount(const char *progname, const char *fsname,
+		       const char *mnt, const char *type, const char *opts);
+int fuse_mnt_remove_mount(const char *progname, const char *mnt);
+int fuse_mnt_umount(const char *progname, const char *abs_mnt,
+		    const char *rel_mnt, int lazy);
+char *fuse_mnt_resolve_path(const char *progname, const char *orig);
+int fuse_mnt_check_empty(const char *progname, const char *mnt,
+			 mode_t rootmode, off64_t rootsize);
+int fuse_mnt_check_fuseblk(void);
diff --git a/external/fuse/ulockmgr.c b/external/fuse/ulockmgr.c
new file mode 100755
index 0000000000..f0523ae706
--- /dev/null
+++ b/external/fuse/ulockmgr.c
@@ -0,0 +1,444 @@
+/*
+  libulockmgr: Userspace Lock Manager Library
+  Copyright (C) 2006  Miklos Szeredi <miklos@szeredi.hu>
+
+  This program can be distributed under the terms of the GNU LGPLv2.
+  See the file COPYING.LIB
+*/
+
+/* #define DEBUG 1 */
+
+#include "ulockmgr.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <errno.h>
+#include <assert.h>
+#include <signal.h>
+#include <sys/stat.h>
+#include <sys/socket.h>
+#include <sys/wait.h>
+
+struct message {
+	unsigned intr : 1;
+	unsigned nofd : 1;
+	pthread_t thr;
+	int cmd;
+	int fd;
+	struct flock lock;
+	int error;
+};
+
+struct fd_store {
+	struct fd_store *next;
+	int fd;
+	int inuse;
+};
+
+struct owner {
+	struct owner *next;
+	struct owner *prev;
+	struct fd_store *fds;
+	void *id;
+	size_t id_len;
+	int cfd;
+};
+
+static pthread_mutex_t ulockmgr_lock;
+static int ulockmgr_cfd = -1;
+static struct owner owner_list = { .next = &owner_list, .prev = &owner_list };
+
+#define MAX_SEND_FDS 2
+
+static void list_del_owner(struct owner *owner)
+{
+	struct owner *prev = owner->prev;
+	struct owner *next = owner->next;
+	prev->next = next;
+	next->prev = prev;
+}
+
+static void list_add_owner(struct owner *owner, struct owner *next)
+{
+	struct owner *prev = next->prev;
+	owner->next = next;
+	owner->prev = prev;
+	prev->next = owner;
+	next->prev = owner;
+}
+
+/*
+ * There's a bug in the linux kernel (< 2.6.22) recv() implementation
+ * on AF_UNIX, SOCK_STREAM sockets, that could cause it to return
+ * zero, even if data was available.  Retrying the recv will return
+ * the data in this case.
+ */
+static int do_recv(int sock, void *buf, size_t len, int flags)
+{
+	int res = recv(sock, buf, len, flags);
+	if (res == 0)
+		res = recv(sock, buf, len, flags);
+
+	return res;
+}
+
+static int ulockmgr_send_message(int sock, void *buf, size_t buflen,
+				 int *fdp, int numfds)
+{
+	struct msghdr msg;
+	struct cmsghdr *p_cmsg;
+	struct iovec vec;
+	size_t cmsgbuf[CMSG_SPACE(sizeof(int) * MAX_SEND_FDS) / sizeof(size_t)];
+	int res;
+
+	assert(numfds <= MAX_SEND_FDS);
+	msg.msg_control = cmsgbuf;
+	msg.msg_controllen = sizeof(cmsgbuf);
+	p_cmsg = CMSG_FIRSTHDR(&msg);
+	p_cmsg->cmsg_level = SOL_SOCKET;
+	p_cmsg->cmsg_type = SCM_RIGHTS;
+	p_cmsg->cmsg_len = CMSG_LEN(sizeof(int) * numfds);
+	memcpy(CMSG_DATA(p_cmsg), fdp, sizeof(int) * numfds);
+	msg.msg_controllen = p_cmsg->cmsg_len;
+	msg.msg_name = NULL;
+	msg.msg_namelen = 0;
+	msg.msg_iov = &vec;
+	msg.msg_iovlen = 1;
+	msg.msg_flags = 0;
+	vec.iov_base = buf;
+	vec.iov_len = buflen;
+	res = sendmsg(sock, &msg, MSG_NOSIGNAL);
+	if (res == -1) {
+		perror("libulockmgr: sendmsg");
+		return -1;
+	}
+	if ((size_t) res != buflen) {
+		fprintf(stderr, "libulockmgr: sendmsg short\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int ulockmgr_start_daemon(void)
+{
+	int sv[2];
+	int res;
+	char tmp[64];
+
+	res = socketpair(AF_UNIX, SOCK_STREAM, 0, sv);
+	if (res == -1) {
+		perror("libulockmgr: socketpair");
+		return -1;
+	}
+	snprintf(tmp, sizeof(tmp), "exec ulockmgr_server %i", sv[0]);
+	res = system(tmp);
+	close(sv[0]);
+	if (res == -1 || !WIFEXITED(res) || WEXITSTATUS(res) != 0) {
+		close(sv[1]);
+		return -1;
+	}
+	ulockmgr_cfd = sv[1];
+	return 0;
+}
+
+static struct owner *ulockmgr_new_owner(const void *id, size_t id_len)
+{
+	int sv[2];
+	int res;
+	char c = 'm';
+	struct owner *o;
+
+	if (ulockmgr_cfd == -1 && ulockmgr_start_daemon() == -1)
+		return NULL;
+
+	o = calloc(1, sizeof(struct owner) + id_len);
+	if (!o) {
+		fprintf(stderr, "libulockmgr: failed to allocate memory\n");
+		return NULL;
+	}
+	o->id = o + 1;
+	o->id_len = id_len;
+	res = socketpair(AF_UNIX, SOCK_STREAM, 0, sv);
+	if (res == -1) {
+		perror("libulockmgr: socketpair");
+		goto out_free;
+	}
+	res = ulockmgr_send_message(ulockmgr_cfd, &c, sizeof(c), &sv[0], 1);
+	close(sv[0]);
+	if (res == -1) {
+		close(ulockmgr_cfd);
+		ulockmgr_cfd = -1;
+		goto out_close;
+	}
+
+	o->cfd = sv[1];
+	memcpy(o->id, id, id_len);
+	list_add_owner(o, &owner_list);
+
+	return o;
+
+out_close:
+	close(sv[1]);
+out_free:
+	free(o);
+	return NULL;
+}
+
+static int ulockmgr_send_request(struct message *msg, const void *id,
+				 size_t id_len)
+{
+	int sv[2];
+	int cfd;
+	struct owner *o;
+	struct fd_store *f = NULL;
+	struct fd_store *newf = NULL;
+	struct fd_store **fp;
+	int fd = msg->fd;
+	int cmd = msg->cmd;
+	int res;
+	int unlockall = (cmd == F_SETLK && msg->lock.l_type == F_UNLCK &&
+			 msg->lock.l_start == 0 && msg->lock.l_len == 0);
+
+	for (o = owner_list.next; o != &owner_list; o = o->next)
+		if (o->id_len == id_len && memcmp(o->id, id, id_len) == 0)
+			break;
+
+	if (o == &owner_list)
+		o = NULL;
+
+	if (!o && cmd != F_GETLK && msg->lock.l_type != F_UNLCK)
+		o = ulockmgr_new_owner(id, id_len);
+
+	if (!o) {
+		if (cmd == F_GETLK) {
+			res = fcntl(msg->fd, F_GETLK, &msg->lock);
+			return (res == -1) ? -errno : 0;
+		} else if (msg->lock.l_type == F_UNLCK)
+			return 0;
+		else
+			return -ENOLCK;
+	}
+
+	if (unlockall)
+		msg->nofd = 1;
+	else {
+		for (fp = &o->fds; *fp; fp = &(*fp)->next) {
+			f = *fp;
+			if (f->fd == fd) {
+				msg->nofd = 1;
+				break;
+			}
+		}
+	}
+
+	if (!msg->nofd) {
+		newf = f = calloc(1, sizeof(struct fd_store));
+		if (!f) {
+			fprintf(stderr, "libulockmgr: failed to allocate memory\n");
+			return -ENOLCK;
+		}
+	}
+
+	res = socketpair(AF_UNIX, SOCK_STREAM, 0, sv);
+	if (res == -1) {
+		perror("libulockmgr: socketpair");
+		free(newf);
+		return -ENOLCK;
+	}
+
+	cfd = sv[1];
+	sv[1] = msg->fd;
+	res = ulockmgr_send_message(o->cfd, msg, sizeof(struct message), sv,
+				    msg->nofd ? 1 : 2);
+	close(sv[0]);
+	if (res == -1) {
+		free(newf);
+		close(cfd);
+		return -EIO;
+	}
+
+	if (newf) {
+		newf->fd = msg->fd;
+		newf->next = o->fds;
+		o->fds = newf;
+	}
+	if (f)
+		f->inuse++;
+
+	res = do_recv(cfd, msg, sizeof(struct message), MSG_WAITALL);
+	if (res == -1) {
+		perror("libulockmgr: recv");
+		msg->error = EIO;
+	} else if (res != sizeof(struct message)) {
+		fprintf(stderr, "libulockmgr: recv short\n");
+		msg->error = EIO;
+	} else if (cmd == F_SETLKW && msg->error == EAGAIN) {
+		pthread_mutex_unlock(&ulockmgr_lock);
+		while (1) {
+			sigset_t old;
+			sigset_t unblock;
+			int errno_save;
+
+			sigemptyset(&unblock);
+			sigaddset(&unblock, SIGUSR1);
+			pthread_sigmask(SIG_UNBLOCK, &unblock, &old);
+			res = do_recv(cfd, msg, sizeof(struct message),
+				      MSG_WAITALL);
+			errno_save = errno;
+			pthread_sigmask(SIG_SETMASK, &old, NULL);
+			if (res == sizeof(struct message))
+				break;
+			else if (res >= 0) {
+				fprintf(stderr, "libulockmgr: recv short\n");
+				msg->error = EIO;
+				break;
+			} else if (errno_save != EINTR) {
+				errno = errno_save;
+				perror("libulockmgr: recv");
+				msg->error = EIO;
+				break;
+			}
+			msg->intr = 1;
+			res = send(o->cfd, msg, sizeof(struct message),
+				   MSG_NOSIGNAL);
+			if (res == -1) {
+				perror("libulockmgr: send");
+				msg->error = EIO;
+				break;
+			}
+			if (res != sizeof(struct message)) {
+				fprintf(stderr, "libulockmgr: send short\n");
+				msg->error = EIO;
+				break;
+			}
+		}
+		pthread_mutex_lock(&ulockmgr_lock);
+
+	}
+	if (f)
+		f->inuse--;
+	close(cfd);
+	if (unlockall) {
+		for (fp = &o->fds; *fp;) {
+			f = *fp;
+			if (f->fd == fd && !f->inuse) {
+				*fp = f->next;
+				free(f);
+			} else
+				fp = &f->next;
+		}
+		if (!o->fds) {
+			list_del_owner(o);
+			close(o->cfd);
+			free(o);
+		}
+		/* Force OK on unlock-all, since it _will_ succeed once the
+		   owner is deleted */
+		msg->error = 0;
+	}
+
+	return -msg->error;
+}
+
+#ifdef DEBUG
+static uint32_t owner_hash(const unsigned char *id, size_t id_len)
+{
+	uint32_t h = 0;
+	size_t i;
+	for (i = 0; i < id_len; i++)
+		h = ((h << 8) | (h >> 24)) ^ id[i];
+
+	return h;
+}
+#endif
+
+static int ulockmgr_canonicalize(int fd, struct flock *lock)
+{
+	off64_t offset;
+	if (lock->l_whence == SEEK_CUR) {
+		offset = lseek(fd, 0, SEEK_CUR);
+		if (offset == (off64_t) -1)
+			return -errno;
+	} else if (lock->l_whence == SEEK_END) {
+		struct stat stbuf;
+		int res = fstat(fd, &stbuf);
+		if (res == -1)
+			return -errno;
+
+		offset = stbuf.st_size;
+	} else
+		offset = 0;
+
+	lock->l_whence = SEEK_SET;
+	lock->l_start += offset;
+
+	if (lock->l_start < 0)
+		return -EINVAL;
+
+	if (lock->l_len < 0) {
+		lock->l_start += lock->l_len;
+		if (lock->l_start < 0)
+			return -EINVAL;
+		lock->l_len = -lock->l_len;
+	}
+	if (lock->l_len && lock->l_start + lock->l_len - 1 < 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+int ulockmgr_op(int fd, int cmd, struct flock *lock, const void *owner,
+		size_t owner_len)
+{
+	int err;
+	struct message msg;
+	sigset_t old;
+	sigset_t block;
+
+	if (cmd != F_GETLK && cmd != F_SETLK && cmd != F_SETLKW)
+		return -EINVAL;
+
+	if (lock->l_type != F_RDLCK && lock->l_type != F_WRLCK &&
+	    lock->l_type != F_UNLCK)
+		return -EINVAL;
+
+	if (lock->l_whence != SEEK_SET && lock->l_whence != SEEK_CUR &&
+	    lock->l_whence != SEEK_END)
+		return -EINVAL;
+
+#ifdef DEBUG
+	fprintf(stderr, "libulockmgr: %i %i %i %lli %lli own: 0x%08x\n",
+		cmd, lock->l_type, lock->l_whence, lock->l_start, lock->l_len,
+		owner_hash(owner, owner_len));
+#endif
+
+	/* Unlock should never block anyway */
+	if (cmd == F_SETLKW && lock->l_type == F_UNLCK)
+		cmd = F_SETLK;
+
+	memset(&msg, 0, sizeof(struct message));
+	msg.cmd = cmd;
+	msg.fd = fd;
+	msg.lock = *lock;
+	err = ulockmgr_canonicalize(fd, &msg.lock);
+	if (err)
+		return err;
+
+	sigemptyset(&block);
+	sigaddset(&block, SIGUSR1);
+	pthread_sigmask(SIG_BLOCK, &block, &old);
+	pthread_mutex_lock(&ulockmgr_lock);
+	err = ulockmgr_send_request(&msg, owner, owner_len);
+	pthread_mutex_unlock(&ulockmgr_lock);
+	pthread_sigmask(SIG_SETMASK, &old, NULL);
+	if (!err && cmd == F_GETLK) {
+		if (msg.lock.l_type == F_UNLCK)
+			lock->l_type = F_UNLCK;
+		else
+			*lock = msg.lock;
+	}
+
+	return err;
+}
diff --git a/kernel/.config b/kernel/.config
index 6c7d379e1e..5bd51e500d 100644
--- a/kernel/.config
+++ b/kernel/.config
@@ -4616,7 +4616,16 @@ CONFIG_MSDOS_FS=y
 CONFIG_VFAT_FS=y
 CONFIG_FAT_DEFAULT_CODEPAGE=437
 CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_NTFS_FS is not set
+CONFIG_EXFAT_FS=y
+CONFIG_EXFAT_DISCARD=y
+# CONFIG_EXFAT_DELAYED_SYNC is not set
+# CONFIG_EXFAT_KERNEL_DEBUG is not set
+# CONFIG_EXFAT_DEBUG_MSG is not set
+CONFIG_EXFAT_DEFAULT_CODEPAGE=437
+CONFIG_EXFAT_DEFAULT_IOCHARSET="utf8"
+CONFIG_NTFS_FS=y
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
 
 #
 # Pseudo filesystems
diff --git a/kernel/drivers/rk_nand/rk_zftl_arm64.S b/kernel/drivers/rk_nand/rk_zftl_arm64.S
old mode 100644
new mode 100755
index cca796acde..c9a7387ae0
--- a/kernel/drivers/rk_nand/rk_zftl_arm64.S
+++ b/kernel/drivers/rk_nand/rk_zftl_arm64.S
@@ -5,8 +5,8 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * date: 2018-11-28
- * function: rk ftl v5 for rockchip soc base on arm v8 to support 3D/2D
+ * date: 2019-06-03
+ * function: rk ftl v6 for rockchip soc base on arm v8 to support 3D/2D
  *	     TLC and MLC.
  */
 	.cpu generic+fp+simd
@@ -713,8 +713,8 @@ zftl_get_gc_node.part.12:
 	.size	zftl_get_gc_node.part.12, .-zftl_get_gc_node.part.12
 	.section	.text.unlikely
 	.align	2
-	.type	rk_simple_strtoull.constprop.30, %function
-rk_simple_strtoull.constprop.30:
+	.type	rk_simple_strtoull.constprop.33, %function
+rk_simple_strtoull.constprop.33:
 	stp	x29, x30, [sp, -64]!
 	add	x29, sp, 0
 	stp	x19, x20, [sp,16]
@@ -773,7 +773,7 @@ rk_simple_strtoull.constprop.30:
 	ldp	x21, x22, [sp,32]
 	ldp	x29, x30, [sp], 64
 	ret
-	.size	rk_simple_strtoull.constprop.30, .-rk_simple_strtoull.constprop.30
+	.size	rk_simple_strtoull.constprop.33, .-rk_simple_strtoull.constprop.33
 	.text
 	.align	2
 	.global	nand_flash_print_info
@@ -1042,17 +1042,19 @@ nand_flash_print_info:
 	ldr	w0, [x19,#:lo12:.LANCHOR2]
 	tbz	x0, 12, .L145
 	adrp	x1, .LANCHOR0
-	adrp	x0, .LC17
-	add	x0, x0, :lo12:.LC17
+	adrp	x0, .LC31
+	add	x2, x1, :lo12:.LANCHOR0
+	add	x0, x0, :lo12:.LC31
 	ldrb	w1, [x1,#:lo12:.LANCHOR0]
+	ldrb	w2, [x2,634]
 	bl	printk
 .L145:
 	ldr	w0, [x19,#:lo12:.LANCHOR2]
 	tbz	x0, 12, .L146
 	adrp	x2, .LANCHOR0
-	adrp	x0, .LC31
+	adrp	x0, .LC32
 	add	x2, x2, :lo12:.LANCHOR0
-	add	x0, x0, :lo12:.LC31
+	add	x0, x0, :lo12:.LC32
 	add	x2, x2, 640
 	ldrb	w1, [x2,10]
 	ldrb	w2, [x2,11]
@@ -1061,9 +1063,9 @@ nand_flash_print_info:
 	ldr	w0, [x19,#:lo12:.LANCHOR2]
 	tbz	x0, 12, .L147
 	adrp	x2, .LANCHOR0
-	adrp	x0, .LC32
+	adrp	x0, .LC33
 	add	x2, x2, :lo12:.LANCHOR0
-	add	x0, x0, :lo12:.LC32
+	add	x0, x0, :lo12:.LC33
 	add	x2, x2, 640
 	ldrb	w1, [x2,8]
 	ldrb	w2, [x2,9]
@@ -1072,8 +1074,8 @@ nand_flash_print_info:
 	ldr	w0, [x19,#:lo12:.LANCHOR2]
 	tbz	x0, 12, .L117
 	adrp	x1, .LANCHOR0+672
-	adrp	x0, .LC33
-	add	x0, x0, :lo12:.LC33
+	adrp	x0, .LC34
+	add	x0, x0, :lo12:.LC34
 	ldrb	w1, [x1,#:lo12:.LANCHOR0+672]
 	bl	printk
 .L117:
@@ -1095,9 +1097,9 @@ nandc_init:
 	ldr	w0, [x21,#:lo12:.LANCHOR2]
 	tbz	x0, 12, .L243
 	adrp	x1, .LANCHOR1
-	adrp	x0, .LC34
+	adrp	x0, .LC35
 	add	x1, x1, :lo12:.LANCHOR1
-	add	x0, x0, :lo12:.LC34
+	add	x0, x0, :lo12:.LC35
 	add	x1, x1, 72
 	mov	x2, x22
 	bl	printk
@@ -1199,8 +1201,8 @@ nandc_init:
 	ldr	w4, [x0,308]
 	ldr	w5, [x0,312]
 .L260:
-	adrp	x0, .LC35
-	add	x0, x0, :lo12:.LC35
+	adrp	x0, .LC36
+	add	x0, x0, :lo12:.LC36
 	bl	printk
 .L248:
 	add	x1, x20, :lo12:.LANCHOR0
@@ -1210,9 +1212,9 @@ nandc_init:
 	strh	wzr, [x1,722]
 	strb	wzr, [x1,724]
 	tbz	x0, 12, .L242
-	adrp	x0, .LC36
+	adrp	x0, .LC37
 	ldrb	w1, [x1,516]
-	add	x0, x0, :lo12:.LC36
+	add	x0, x0, :lo12:.LC37
 	bl	printk
 .L242:
 	ldp	x19, x20, [sp,16]
@@ -1537,7 +1539,7 @@ flash_wait_device_ready_raw:
 	adrp	x1, .LANCHOR1
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 677
+	mov	w2, 678
 	add	x1, x1, 240
 	add	x0, x0, :lo12:.LC0
 	bl	printk
@@ -1827,7 +1829,7 @@ flash_start_page_read:
 	adrp	x1, .LANCHOR1
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 845
+	mov	w2, 846
 	add	x1, x1, 272
 	add	x0, x0, :lo12:.LC0
 	bl	printk
@@ -2114,7 +2116,7 @@ flash_start_plane_read:
 	adrp	x1, .LANCHOR1
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 940
+	mov	w2, 941
 	add	x1, x1, 712
 	add	x0, x0, :lo12:.LC0
 	bl	printk
@@ -2231,13 +2233,13 @@ flash_set_interface_mode:
 	mov	x21, 0
 	stp	x23, x24, [sp,48]
 	add	x22, x22, :lo12:.LANCHOR0
-	adrp	x23, .LC38
+	adrp	x23, .LC39
 	stp	x25, x26, [sp,64]
 	stp	x19, x20, [sp,16]
 	mov	w25, w0
 	add	x26, x22, 748
 	adrp	x24, .LANCHOR2
-	add	x23, x23, :lo12:.LC38
+	add	x23, x23, :lo12:.LC39
 .L422:
 	lsl	x0, x21, 3
 	ldr	x20, [x22,536]
@@ -2263,8 +2265,8 @@ flash_set_interface_mode:
 	tbz	x1, 0, .L409
 	ldr	w0, [x24,#:lo12:.LANCHOR2]
 	tbz	x0, 12, .L412
-	adrp	x0, .LC37
-	add	x0, x0, :lo12:.LC37
+	adrp	x0, .LC38
+	add	x0, x0, :lo12:.LC38
 	bl	printk
 .L412:
 	add	x1, x20, x21, lsl 8
@@ -2397,10 +2399,10 @@ flash_read_id:
 	uxtb	w0, w0
 	cmp	w0, 253
 	bhi	.L445
-	adrp	x0, .LC39
+	adrp	x0, .LC40
 	ldrb	w3, [x19,1]
 	ldrb	w4, [x19,2]
-	add	x0, x0, :lo12:.LC39
+	add	x0, x0, :lo12:.LC40
 	ldrb	w5, [x19,3]
 	add	w1, w21, 1
 	ldrb	w6, [x19,4]
@@ -2480,9 +2482,9 @@ flash_read_otp_data:
 	mov	w0, 238
 	str	w0, [x19,2056]
 	str	w22, [x19,2052]
-	adrp	x0, .LC40
+	adrp	x0, .LC41
 	mov	w1, w20
-	add	x0, x0, :lo12:.LC40
+	add	x0, x0, :lo12:.LC41
 	ldr	w2, [x19,2048]
 	ldr	w3, [x19,2048]
 	ldr	w4, [x19,2048]
@@ -2573,8 +2575,8 @@ sandisk_prog_test_bad_block:
 	ldr	w0, [x20,#:lo12:.LANCHOR2]
 	ldr	x1, [x29,40]
 	tbz	x0, 12, .L454
-	adrp	x0, .LC41
-	add	x0, x0, :lo12:.LC41
+	adrp	x0, .LC42
+	add	x0, x0, :lo12:.LC42
 	bl	printk
 .L454:
 	mov	w0, w19
@@ -2813,7 +2815,7 @@ flash_erase_duplane_block:
 	adrp	x1, .LANCHOR1
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 588
+	mov	w2, 589
 	add	x1, x1, 736
 	add	x0, x0, :lo12:.LC0
 	bl	printk
@@ -2829,9 +2831,9 @@ flash_erase_duplane_block:
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
 	add	x23, x19, x23, lsl 8
 	tbz	x0, 4, .L495
-	adrp	x0, .LC42
+	adrp	x0, .LC43
 	mov	w1, w21
-	add	x0, x0, :lo12:.LC42
+	add	x0, x0, :lo12:.LC43
 	mov	w2, w22
 	mov	w3, w24
 	bl	printk
@@ -2891,9 +2893,9 @@ flash_erase_duplane_block:
 	and	w19, w2, w19
 	orr	w19, w19, w20
 	cbz	w19, .L499
-	adrp	x0, .LC43
+	adrp	x0, .LC44
 	mov	w1, w22
-	add	x0, x0, :lo12:.LC43
+	add	x0, x0, :lo12:.LC44
 	bl	printk
 .L499:
 	mov	w0, w19
@@ -2926,7 +2928,7 @@ flash_erase_block_en:
 	adrp	x1, .LANCHOR1
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 633
+	mov	w2, 634
 	add	x1, x1, 768
 	add	x0, x0, :lo12:.LC0
 	bl	printk
@@ -2942,9 +2944,9 @@ flash_erase_block_en:
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
 	add	x21, x25, x21, lsl 8
 	tbz	x0, 4, .L509
-	adrp	x0, .LC44
+	adrp	x0, .LC45
 	mov	w1, w20
-	add	x0, x0, :lo12:.LC44
+	add	x0, x0, :lo12:.LC45
 	mov	w2, w22
 	mov	w3, w26
 	bl	printk
@@ -2982,8 +2984,8 @@ flash_erase_block_en:
 	ands	w20, w21, w3
 	beq	.L512
 	add	x19, x19, :lo12:.LANCHOR0
-	adrp	x0, .LC45
-	add	x0, x0, :lo12:.LC45
+	adrp	x0, .LC46
+	add	x0, x0, :lo12:.LC46
 	mov	w1, w23
 	mov	w3, w20
 	ldrh	w2, [x19,2]
@@ -3051,9 +3053,9 @@ flash_erase_all:
 	uxth	w19, w19
 	b	.L521
 .L525:
-	adrp	x0, .LC46
+	adrp	x0, .LC47
 	mov	w1, 0
-	add	x0, x0, :lo12:.LC46
+	add	x0, x0, :lo12:.LC47
 	bl	printk
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
@@ -3284,7 +3286,7 @@ zftl_flash_de_init:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrb	w1, [x19,#:lo12:.LANCHOR0]
 	cbz	w1, .L551
-	ldrb	w0, [x0,782]
+	ldrb	w0, [x0,634]
 	cbnz	w0, .L551
 	bl	zftl_flash_exit_slc_mode
 .L551:
@@ -3335,47 +3337,46 @@ nandc_get_chip_if:
 	ret
 	.size	nandc_get_chip_if, .-nandc_get_chip_if
 	.align	2
-	.global	buf_init
-	.type	buf_init, %function
-buf_init:
+	.global	zbuf_init
+	.type	zbuf_init, %function
+zbuf_init:
 	stp	x29, x30, [sp, -48]!
 	adrp	x0, .LANCHOR0
 	add	x29, sp, 0
 	stp	x19, x20, [sp,16]
 	add	x19, x0, :lo12:.LANCHOR0
+	mov	w20, 0
 	stp	x21, x22, [sp,32]
 	add	x19, x19, 784
-	mov	w21, 0
 	mov	x22, x0
 .L569:
-	add	x20, x22, :lo12:.LANCHOR0
-	uxtb	w0, w21
+	add	x21, x22, :lo12:.LANCHOR0
+	uxtb	w0, w20
 	add	w1, w0, 1
 	strb	w0, [x19,1]
 	strb	w1, [x19]
-	add	w21, w21, 1
-	ldrb	w0, [x20,2832]
+	add	w20, w20, 1
+	ldrb	w0, [x21,2832]
 	add	x19, x19, 64
 	strb	wzr, [x19,-62]
 	str	xzr, [x19,-48]
 	lsl	w0, w0, 9
 	bl	ftl_malloc
 	str	x0, [x19,-56]
-	ldrb	w0, [x20,2832]
-	lsl	w0, w0, 1
+	mov	w0, 64
 	bl	ftl_malloc
 	str	x0, [x19,-40]
-	cmp	w21, 32
+	cmp	w20, 32
 	bne	.L569
-	strb	w21, [x20,2834]
+	strb	w20, [x21,2834]
 	mov	w0, -1
-	strb	wzr, [x20,2833]
-	strb	w0, [x20,2768]
-	ldp	x21, x22, [sp,32]
+	strb	wzr, [x21,2833]
+	strb	w0, [x21,2768]
 	ldp	x19, x20, [sp,16]
+	ldp	x21, x22, [sp,32]
 	ldp	x29, x30, [sp], 48
 	ret
-	.size	buf_init, .-buf_init
+	.size	zbuf_init, .-zbuf_init
 	.align	2
 	.global	buf_reinit
 	.type	buf_reinit, %function
@@ -3489,9 +3490,9 @@ queue_read_cmd:
 	ret
 	.size	queue_read_cmd, .-queue_read_cmd
 	.align	2
-	.global	buf_free
-	.type	buf_free, %function
-buf_free:
+	.global	zbuf_free
+	.type	zbuf_free, %function
+zbuf_free:
 	stp	x29, x30, [sp, -32]!
 	add	x29, sp, 0
 	str	x19, [sp,16]
@@ -3523,7 +3524,7 @@ buf_free:
 	ldr	x19, [sp,16]
 	ldp	x29, x30, [sp], 32
 	ret
-	.size	buf_free, .-buf_free
+	.size	zbuf_free, .-zbuf_free
 	.align	2
 	.global	buf_alloc
 	.type	buf_alloc, %function
@@ -3709,8 +3710,8 @@ flash_mask_bad_block:
 	mov	w2, w21
 	ldrh	w20, [x3,22]
 	mul	w20, w0, w20
-	adrp	x0, .LC47
-	add	x0, x0, :lo12:.LC47
+	adrp	x0, .LC48
+	add	x0, x0, :lo12:.LC48
 	uxth	w20, w20
 	add	w20, w20, 31
 	bl	printk
@@ -3793,13 +3794,13 @@ zftl_proc_debug_init:
 	stp	x29, x30, [sp, -16]!
 	adrp	x3, .LANCHOR1
 	mov	x2, 0
-	adrp	x0, .LC48
+	adrp	x0, .LC49
 	add	x3, x3, :lo12:.LANCHOR1
 	add	x29, sp, 0
 	mov	w1, 292
 	add	x3, x3, 1096
 	mov	x4, x2
-	add	x0, x0, :lo12:.LC48
+	add	x0, x0, :lo12:.LC49
 	bl	proc_create_data
 	ldp	x29, x30, [sp], 16
 	ret
@@ -3821,11 +3822,11 @@ ftl_print_info_to_buf:
 	adrp	x7, .LANCHOR2
 	adrp	x22, .LANCHOR0
 	add	x7, x7, :lo12:.LANCHOR2
-	adrp	x1, .LC49
+	adrp	x1, .LC50
 	add	x7, x7, 8
 	add	x21, x22, :lo12:.LANCHOR0
 	add	x19, x20, x0, sxtw
-	add	x1, x1, :lo12:.LC49
+	add	x1, x1, :lo12:.LC50
 	ldrb	w5, [x7,4]
 	mov	x0, x19
 	ldrb	w6, [x7,5]
@@ -3836,105 +3837,105 @@ ftl_print_info_to_buf:
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldr	w2, [x21,520]
-	adrp	x1, .LC50
+	adrp	x1, .LC51
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC50
+	add	x1, x1, :lo12:.LC51
 	lsr	w2, w2, 11
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldr	w2, [x21,2836]
-	adrp	x1, .LC51
+	adrp	x1, .LC52
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC51
+	add	x1, x1, :lo12:.LC52
 	lsr	w2, w2, 11
 	bl	sprintf
 	add	x19, x19, x0, sxtw
-	adrp	x1, .LC52
+	adrp	x1, .LC53
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC52
+	add	x1, x1, :lo12:.LC53
 	add	x19, x19, 10
 	bl	strcpy
 	ldr	w2, [x21,2840]
-	adrp	x1, .LC53
-	mov	x0, x19
-	add	x1, x1, :lo12:.LC53
-	bl	sprintf
-	add	x19, x19, x0, sxtw
-	ldr	w2, [x21,520]
 	adrp	x1, .LC54
 	mov	x0, x19
 	add	x1, x1, :lo12:.LC54
 	bl	sprintf
 	add	x19, x19, x0, sxtw
-	ldr	x2, [x21,608]
+	ldr	w2, [x21,520]
 	adrp	x1, .LC55
 	mov	x0, x19
 	add	x1, x1, :lo12:.LC55
-	ldr	w2, [x2,524]
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldr	x2, [x21,608]
 	adrp	x1, .LC56
 	mov	x0, x19
 	add	x1, x1, :lo12:.LC56
-	ldr	w2, [x2,528]
+	ldr	w2, [x2,524]
 	bl	sprintf
 	add	x19, x19, x0, sxtw
-	ldrh	w2, [x21,2844]
+	ldr	x2, [x21,608]
 	adrp	x1, .LC57
 	mov	x0, x19
 	add	x1, x1, :lo12:.LC57
+	ldr	w2, [x2,528]
 	bl	sprintf
 	add	x19, x19, x0, sxtw
-	ldrh	w2, [x21,2846]
+	ldrh	w2, [x21,2844]
 	adrp	x1, .LC58
 	mov	x0, x19
 	add	x1, x1, :lo12:.LC58
 	bl	sprintf
 	add	x19, x19, x0, sxtw
-	ldrh	w2, [x21,2848]
+	ldrh	w2, [x21,2846]
 	adrp	x1, .LC59
 	mov	x0, x19
 	add	x1, x1, :lo12:.LC59
 	bl	sprintf
 	add	x19, x19, x0, sxtw
-	ldrh	w2, [x21,2850]
+	ldrh	w2, [x21,2848]
 	adrp	x1, .LC60
 	mov	x0, x19
 	add	x1, x1, :lo12:.LC60
 	bl	sprintf
 	add	x19, x19, x0, sxtw
-	ldrh	w2, [x21,2852]
+	ldrh	w2, [x21,2850]
 	adrp	x1, .LC61
 	mov	x0, x19
 	add	x1, x1, :lo12:.LC61
 	bl	sprintf
 	add	x19, x19, x0, sxtw
-	ldrh	w2, [x21,2854]
+	ldrh	w2, [x21,2852]
 	adrp	x1, .LC62
 	mov	x0, x19
 	add	x1, x1, :lo12:.LC62
 	bl	sprintf
 	add	x19, x19, x0, sxtw
-	ldrb	w4, [x21,2857]
+	ldrh	w2, [x21,2854]
 	adrp	x1, .LC63
-	ldrb	w2, [x21,2834]
 	mov	x0, x19
-	ldrb	w3, [x21,2856]
 	add	x1, x1, :lo12:.LC63
 	bl	sprintf
 	add	x19, x19, x0, sxtw
-	ldr	x3, [x21,2864]
+	ldrb	w4, [x21,2857]
 	adrp	x1, .LC64
+	ldrb	w2, [x21,2834]
 	mov	x0, x19
+	ldrb	w3, [x21,2856]
 	add	x1, x1, :lo12:.LC64
+	bl	sprintf
+	add	x19, x19, x0, sxtw
+	ldr	x3, [x21,2864]
+	adrp	x1, .LC65
+	mov	x0, x19
+	add	x1, x1, :lo12:.LC65
 	ldrh	w2, [x3,148]
 	ldrh	w3, [x3,146]
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldr	x0, [x21,2864]
-	adrp	x1, .LC65
-	add	x1, x1, :lo12:.LC65
+	adrp	x1, .LC66
+	add	x1, x1, :lo12:.LC66
 	ldr	w3, [x0,16]
 	ldr	w2, [x0,20]
 	mov	x0, x19
@@ -3942,8 +3943,8 @@ ftl_print_info_to_buf:
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldr	x0, [x21,2864]
-	adrp	x1, .LC66
-	add	x1, x1, :lo12:.LC66
+	adrp	x1, .LC67
+	add	x1, x1, :lo12:.LC67
 	ldr	w3, [x0,24]
 	ldr	w2, [x0,28]
 	mov	x0, x19
@@ -3951,107 +3952,107 @@ ftl_print_info_to_buf:
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldr	x2, [x21,2864]
-	adrp	x1, .LC67
+	adrp	x1, .LC68
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC67
+	add	x1, x1, :lo12:.LC68
 	ldr	w2, [x2,64]
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldr	x2, [x21,2864]
-	adrp	x1, .LC68
+	adrp	x1, .LC69
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC68
+	add	x1, x1, :lo12:.LC69
 	ldr	w2, [x2,68]
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldr	x0, [x21,608]
 	mov	w2, 10
-	adrp	x1, .LC69
-	add	x1, x1, :lo12:.LC69
+	adrp	x1, .LC70
+	add	x1, x1, :lo12:.LC70
 	ldr	w3, [x0,12]
 	mov	x0, x19
 	udiv	w2, w3, w2
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldrb	w2, [x22,#:lo12:.LANCHOR0]
-	adrp	x1, .LC70
-	mov	x0, x19
-	add	x1, x1, :lo12:.LC70
-	bl	sprintf
-	add	x19, x19, x0, sxtw
-	ldr	x2, [x21,608]
 	adrp	x1, .LC71
 	mov	x0, x19
 	add	x1, x1, :lo12:.LC71
-	ldr	w2, [x2,556]
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldr	x2, [x21,608]
 	adrp	x1, .LC72
 	mov	x0, x19
 	add	x1, x1, :lo12:.LC72
-	ldr	w2, [x2,552]
+	ldr	w2, [x2,556]
 	bl	sprintf
 	add	x19, x19, x0, sxtw
-	ldr	x2, [x21,2864]
+	ldr	x2, [x21,608]
 	adrp	x1, .LC73
 	mov	x0, x19
 	add	x1, x1, :lo12:.LC73
-	ldr	w2, [x2,52]
+	ldr	w2, [x2,552]
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldr	x2, [x21,2864]
 	adrp	x1, .LC74
 	mov	x0, x19
 	add	x1, x1, :lo12:.LC74
-	ldr	w2, [x2,60]
+	ldr	w2, [x2,52]
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldr	x2, [x21,2864]
 	adrp	x1, .LC75
 	mov	x0, x19
 	add	x1, x1, :lo12:.LC75
-	ldr	w2, [x2,76]
+	ldr	w2, [x2,60]
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldr	x2, [x21,2864]
 	adrp	x1, .LC76
 	mov	x0, x19
 	add	x1, x1, :lo12:.LC76
-	ldr	w2, [x2,8]
+	ldr	w2, [x2,76]
 	bl	sprintf
 	add	x19, x19, x0, sxtw
-	ldr	x4, [x21,608]
+	ldr	x2, [x21,2864]
 	adrp	x1, .LC77
 	mov	x0, x19
 	add	x1, x1, :lo12:.LC77
+	ldr	w2, [x2,8]
+	bl	sprintf
+	add	x19, x19, x0, sxtw
+	ldr	x4, [x21,608]
+	adrp	x1, .LC78
+	mov	x0, x19
+	add	x1, x1, :lo12:.LC78
 	ldrh	w2, [x4,16]
 	ldrh	w3, [x4,22]
 	ldrb	w4, [x4,25]
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldr	x4, [x21,608]
-	adrp	x1, .LC78
+	adrp	x1, .LC79
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC78
+	add	x1, x1, :lo12:.LC79
 	ldrh	w2, [x4,48]
 	ldrh	w3, [x4,54]
 	ldrb	w4, [x4,57]
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldr	x4, [x21,608]
-	adrp	x1, .LC79
+	adrp	x1, .LC80
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC79
+	add	x1, x1, :lo12:.LC80
 	ldrh	w2, [x4,80]
 	ldrh	w3, [x4,86]
 	ldrb	w4, [x4,89]
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldr	x6, [x21,2864]
-	adrp	x1, .LC80
+	adrp	x1, .LC81
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC80
+	add	x1, x1, :lo12:.LC81
 	ldrh	w2, [x6,74]
 	ldr	w3, [x6,84]
 	ldrh	w4, [x6,88]
@@ -4060,9 +4061,9 @@ ftl_print_info_to_buf:
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldr	x6, [x21,2864]
-	adrp	x1, .LC81
+	adrp	x1, .LC82
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC81
+	add	x1, x1, :lo12:.LC82
 	ldr	w3, [x6,80]
 	ldrh	w4, [x6,90]
 	ldrh	w5, [x6,94]
@@ -4071,25 +4072,25 @@ ftl_print_info_to_buf:
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldrh	w2, [x21,2872]
-	adrp	x1, .LC82
+	adrp	x1, .LC83
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC82
+	add	x1, x1, :lo12:.LC83
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldr	w6, [x21,2884]
-	adrp	x1, .LC83
+	adrp	x1, .LC84
 	ldrh	w2, [x21,2874]
 	mov	x0, x19
 	ldrh	w3, [x21,2876]
-	add	x1, x1, :lo12:.LC83
+	add	x1, x1, :lo12:.LC84
 	ldrh	w4, [x21,2878]
 	ldrh	w5, [x21,2880]
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldr	x5, [x21,608]
-	adrp	x1, .LC84
+	adrp	x1, .LC85
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC84
+	add	x1, x1, :lo12:.LC85
 	ldrh	w2, [x5,584]
 	ldrh	w3, [x5,586]
 	ldrh	w4, [x5,588]
@@ -4097,10 +4098,10 @@ ftl_print_info_to_buf:
 	bl	sprintf
 	add	x19, x19, x0, sxtw
 	ldr	x6, [x21,608]
-	adrp	x1, .LC85
+	adrp	x1, .LC86
 	ldr	x5, [x21,2864]
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC85
+	add	x1, x1, :lo12:.LC86
 	ldr	w2, [x6,536]
 	ldr	w3, [x6,540]
 	ldr	w4, [x6,544]
@@ -4180,7 +4181,7 @@ gc_add_sblk:
 	adrp	x1, .LANCHOR1
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 339
+	mov	w2, 338
 	add	x1, x1, 1312
 	add	x0, x0, :lo12:.LC0
 	bl	printk
@@ -4202,8 +4203,8 @@ gc_add_sblk:
 	ldrh	w6, [x6,2878]
 	mov	w4, w26
 	ldrb	w3, [x0,2]
-	adrp	x0, .LC86
-	add	x0, x0, :lo12:.LC86
+	adrp	x0, .LC87
+	add	x0, x0, :lo12:.LC87
 	ubfx	x3, x3, 5, 3
 	bl	printk
 .L637:
@@ -4217,7 +4218,7 @@ gc_add_sblk:
 	adrp	x1, .LANCHOR1
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 344
+	mov	w2, 343
 	add	x1, x1, 1312
 	add	x0, x0, :lo12:.LC0
 	bl	printk
@@ -4255,12 +4256,12 @@ gc_add_sblk:
 	cbnz	w23, .L642
 	add	x4, x22, :lo12:.LANCHOR0
 	mov	w19, w23
-	ldrh	w7, [x4,3224]
+	ldrh	w7, [x4,3240]
 	cmp	w7, w21
 	beq	.L639
 	mov	x6, 0
 .L644:
-	add	x1, x4, 3232
+	add	x1, x4, 3248
 	ldrh	w1, [x6,x1]
 	cmp	w21, w1
 	bne	.L643
@@ -4270,12 +4271,12 @@ gc_add_sblk:
 	ldr	x3, [x4,600]
 	mov	w1, w21
 	ldrb	w2, [x0,2]
-	adrp	x0, .LC87
+	adrp	x0, .LC88
 	mov	w4, w21
 	mov	w5, w7
 	ldrh	w3, [x3,x25]
 	ubfx	x2, x2, 5, 3
-	add	x0, x0, :lo12:.LC87
+	add	x0, x0, :lo12:.LC88
 	bl	printk
 	b	.L639
 .L643:
@@ -4293,9 +4294,9 @@ gc_add_sblk:
 	tbz	x1, 8, .L647
 	add	x6, x22, :lo12:.LANCHOR0
 	ldrb	w3, [x0,2]
-	adrp	x0, .LC86
+	adrp	x0, .LC87
 	mov	w1, w21
-	add	x0, x0, :lo12:.LC86
+	add	x0, x0, :lo12:.LC87
 	mov	w2, w23
 	ldr	x4, [x6,600]
 	ubfx	x3, x3, 5, 3
@@ -4342,12 +4343,75 @@ gc_add_sblk:
 	ret
 	.size	gc_add_sblk, .-gc_add_sblk
 	.align	2
+	.global	gc_mark_bad_ppa
+	.type	gc_mark_bad_ppa, %function
+gc_mark_bad_ppa:
+	stp	x29, x30, [sp, -64]!
+	mov	w1, 21
+	mov	w3, w0
+	add	x29, sp, 0
+	stp	x19, x20, [sp,16]
+	adrp	x20, .LANCHOR0
+	str	x23, [sp,48]
+	stp	x21, x22, [sp,32]
+	add	x21, x20, :lo12:.LANCHOR0
+	mov	w23, 1
+	add	x21, x21, 2896
+	ldrh	w19, [x21,368]
+	lsr	w2, w0, w19
+	sub	w19, w1, w19
+	lsl	w19, w23, w19
+	ldrb	w0, [x21,370]
+	sub	w19, w19, #1
+	uxth	w22, w2
+	and	w19, w19, w2
+	mov	w2, w22
+	ldr	w1, [x21,328]
+	udiv	w19, w19, w0
+	adrp	x0, .LC89
+	add	x0, x0, :lo12:.LC89
+	bl	printk
+	mov	w1, w23
+	mov	w2, 0
+	uxth	w19, w19
+	mov	w0, w19
+	bl	gc_add_sblk
+	ldr	w0, [x21,328]
+	mov	w1, 0
+.L673:
+	cmp	w1, w0
+	bcs	.L676
+	add	x2, x21, x1, sxtw 1
+	ldrh	w2, [x2,332]
+	cmp	w2, w22
+	beq	.L674
+	add	w1, w1, 1
+	uxth	w1, w1
+	b	.L673
+.L676:
+	cmp	w0, 5
+	bhi	.L674
+	add	x20, x20, :lo12:.LANCHOR0
+	add	w1, w0, 1
+	add	x20, x20, 2896
+	str	w1, [x20,328]
+	add	x20, x20, x0, uxtw 1
+	strh	w22, [x20,332]
+.L674:
+	mov	w0, 0
+	ldr	x23, [sp,48]
+	ldp	x19, x20, [sp,16]
+	ldp	x21, x22, [sp,32]
+	ldp	x29, x30, [sp], 64
+	ret
+	.size	gc_mark_bad_ppa, .-gc_mark_bad_ppa
+	.align	2
 	.global	gc_get_src_ppa_from_index
 	.type	gc_get_src_ppa_from_index, %function
 gc_get_src_ppa_from_index:
-	adrp	x1, .LANCHOR0+3248
+	adrp	x1, .LANCHOR0+3272
 	ubfiz	x0, x0, 2, 16
-	ldr	x1, [x1,#:lo12:.LANCHOR0+3248]
+	ldr	x1, [x1,#:lo12:.LANCHOR0+3272]
 	ldr	w0, [x1,x0]
 	ret
 	.size	gc_get_src_ppa_from_index, .-gc_get_src_ppa_from_index
@@ -4368,133 +4432,133 @@ gc_write_completed:
 	str	x27, [sp,80]
 	add	x24, x21, 784
 	add	x22, x22, 1328
-.L674:
-	ldrb	w0, [x21,3256]
+.L679:
+	ldrb	w0, [x21,3280]
 	adrp	x19, .LANCHOR0
 	cmp	w0, 255
-	beq	.L704
+	beq	.L709
 	sxtw	x25, w0
 	lsl	x0, x25, 6
 	add	x2, x24, x0
 	ldrb	w0, [x24,x0]
 	ldr	w1, [x2,52]
-	strb	w0, [x21,3256]
+	strb	w0, [x21,3280]
 	ldrh	w23, [x2,48]
-	cbz	w1, .L675
+	cbz	w1, .L680
 	ldr	w2, [x2,40]
-	adrp	x0, .LC88
+	adrp	x0, .LC90
 	mov	w3, 1
-	add	x0, x0, :lo12:.LC88
+	add	x0, x0, :lo12:.LC90
 	strh	w3, [x21,3216]
 	str	w2, [x21,3220]
 	bl	printk
 	adrp	x0, .LC0
 	mov	x1, x22
-	mov	w2, 625
+	mov	w2, 672
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L675:
+.L680:
 	add	x1, x19, :lo12:.LANCHOR0
-	ldrb	w0, [x1,3257]
+	ldrb	w0, [x1,3281]
 	cmp	w0, 3
-	bne	.L676
+	bne	.L681
 	ldr	x0, [x1,608]
 	ldrb	w20, [x0,89]
 	add	w20, w20, w20, lsl 1
 	and	w20, w20, 1023
-	b	.L677
-.L676:
-	ldrb	w0, [x1,3258]
+	b	.L682
+.L681:
+	ldrb	w0, [x1,3282]
 	mov	w20, 1
-	cbz	w0, .L677
-	ldrb	w0, [x1,3259]
-	cbz	w0, .L677
+	cbz	w0, .L682
+	ldrb	w0, [x1,3283]
+	cbz	w0, .L682
 	ldr	x0, [x1,608]
 	ldrb	w20, [x0,89]
 	ubfiz	w20, w20, 1, 8
-.L677:
+.L682:
 	adrp	x0, .LANCHOR2
 	uxth	x26, w23
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 8, .L678
+	tbz	x0, 8, .L683
 	add	x0, x19, :lo12:.LANCHOR0
 	mov	w1, w23
 	add	x2, x0, x25, lsl 6
 	mov	w3, w23
-	ldr	x4, [x0,3264]
-	adrp	x0, .LC89
+	ldr	x4, [x0,3288]
+	adrp	x0, .LC91
 	ldrb	w2, [x2,785]
-	add	x0, x0, :lo12:.LC89
+	add	x0, x0, :lo12:.LC91
 	ldrb	w4, [x4,x26]
 	bl	printk
-.L678:
+.L683:
 	add	x0, x19, :lo12:.LANCHOR0
-	ldr	x1, [x0,3264]
+	ldr	x1, [x0,3288]
 	add	x0, x0, x25, lsl 6
 	ldrb	w1, [x1,x26]
 	ldrb	w0, [x0,785]
 	cmp	w1, w0
-	beq	.L679
+	beq	.L684
 	adrp	x0, .LC0
 	mov	x1, x22
-	mov	w2, 634
+	mov	w2, 681
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L679:
+.L684:
 	add	x1, x19, :lo12:.LANCHOR0
 	add	x0, x1, x25, lsl 6
 	ldrb	w0, [x0,845]
 	cmp	w0, 3
-	beq	.L680
-	ldrb	w0, [x1,3257]
+	beq	.L685
+	ldrb	w0, [x1,3281]
 	cmp	w0, 3
-	bne	.L680
-	ldrb	w0, [x1,3272]
-	cbnz	w0, .L680
-	ldrb	w0, [x1,3258]
-	cbz	w0, .L681
-	ldrb	w0, [x1,3259]
-	cbnz	w0, .L680
-.L681:
+	bne	.L685
+	ldrb	w0, [x1,3296]
+	cbnz	w0, .L685
+	ldrb	w0, [x1,3282]
+	cbz	w0, .L686
+	ldrb	w0, [x1,3283]
+	cbnz	w0, .L685
+.L686:
 	add	x19, x19, :lo12:.LANCHOR0
 	mov	w0, 0
 	add	x19, x19, 784
-	ldr	x2, [x19,2480]
-	b	.L682
-.L680:
+	ldr	x2, [x19,2504]
+	b	.L687
+.L685:
 	add	x19, x19, :lo12:.LANCHOR0
 	mov	w25, 0
 	mov	w26, -1
 	add	x27, x19, 784
 	strh	w23, [x19,3212]
-.L683:
+.L688:
 	cmp	w20, w25, uxth
-	bls	.L674
+	bls	.L679
 	add	w1, w25, w23
-	ldr	x2, [x19,3264]
+	ldr	x2, [x19,3288]
 	add	w25, w25, 1
 	ldrb	w0, [x2,x1]
 	strb	w26, [x2,x1]
 	sbfiz	x0, x0, 6, 32
 	add	x0, x27, x0
 	strb	wzr, [x0,61]
-	bl	buf_free
+	bl	zbuf_free
 	ldrb	w0, [x19,2903]
 	sub	w0, w0, #1
 	strb	w0, [x19,2903]
-	b	.L683
-.L682:
+	b	.L688
+.L687:
 	cmp	w20, w0, uxth
-	bls	.L674
+	bls	.L679
 	add	w1, w0, w23
 	add	w0, w0, 1
 	ldrb	w1, [x2,x1]
 	add	x1, x19, x1, lsl 6
 	strb	wzr, [x1,61]
-	b	.L682
-.L704:
+	b	.L687
+.L709:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -4510,50 +4574,50 @@ gc_get_src_blk:
 	adrp	x3, .LANCHOR0
 	add	x0, x3, :lo12:.LANCHOR0
 	ldr	x1, [x0,608]
-	ldrb	w0, [x0,3273]
+	ldrb	w0, [x0,3297]
 	ldrh	w4, [x1,124]
-	cbz	w4, .L706
+	cbz	w4, .L711
 	add	x1, x1, 392
 	mov	w2, 1
-	b	.L707
-.L706:
+	b	.L712
+.L711:
 	sxtw	x2, w0
 	add	x0, x1, x2, lsl 1
 	ldrh	w5, [x0,120]
 	mov	w0, 65535
-	cbz	w5, .L708
+	cbz	w5, .L713
 	add	x1, x1, x2, lsl 7
 	mov	w2, w4
 	add	x1, x1, 136
-.L707:
+.L712:
 	add	x4, x1, 128
 	mov	w5, 65535
-.L711:
+.L716:
 	ldrh	w0, [x1]
 	cmp	w0, w5
-	beq	.L709
+	beq	.L714
 	mov	w4, -1
 	strh	w4, [x1]
 	add	x3, x3, :lo12:.LANCHOR0
-	cbz	w2, .L710
+	cbz	w2, .L715
 	ldr	x2, [x3,608]
 	ldrh	w1, [x2,124]
 	sub	w1, w1, #1
 	strh	w1, [x2,124]
-	b	.L708
-.L710:
-	ldrb	w1, [x3,3273]
+	b	.L713
+.L715:
+	ldrb	w1, [x3,3297]
 	ldr	x2, [x3,608]
 	add	x1, x2, x1, lsl 1
 	ldrh	w2, [x1,120]
 	sub	w2, w2, #1
 	strh	w2, [x1,120]
-	b	.L708
-.L709:
+	b	.L713
+.L714:
 	add	x1, x1, 2
 	cmp	x1, x4
-	bne	.L711
-.L708:
+	bne	.L716
+.L713:
 	ret
 	.size	gc_get_src_blk, .-gc_get_src_blk
 	.align	2
@@ -4568,58 +4632,58 @@ gc_free_temp_buf:
 	str	x21, [sp,32]
 	add	x2, x19, :lo12:.LANCHOR0
 	ldrb	w3, [x2,2903]
-	cbz	w3, .L716
+	cbz	w3, .L721
 	ldrb	w3, [x2,2834]
 	cmp	w3, 1
-	bhi	.L716
-	ldrh	w4, [x2,3274]
+	bhi	.L721
+	ldrh	w4, [x2,3298]
 	mov	x20, x2
-	ldrb	w0, [x2,3276]
+	ldrb	w0, [x2,3300]
 	add	x2, x2, 784
 	ldrh	w1, [x2,2428]
 	mul	w0, w4, w0
 	add	w3, w1, 24
-	ldr	x4, [x2,2480]
+	ldr	x4, [x2,2504]
 	cmp	w0, w3
 	csel	w3, w0, w3, ls
-.L717:
+.L722:
 	cmp	w1, w3
-	bcs	.L730
+	bcs	.L735
 	uxtw	x21, w1
 	ldrb	w0, [x4,x21]
 	cmp	w0, 255
-	beq	.L718
+	beq	.L723
 	sbfiz	x0, x0, 6, 32
 	add	x0, x2, x0
 	ldrb	w5, [x0,61]
-	cbnz	w5, .L718
+	cbnz	w5, .L723
 	str	x1, [x29,56]
-	bl	buf_free
+	bl	zbuf_free
 	adrp	x0, .LANCHOR2
 	ldr	x1, [x29,56]
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 8, .L719
-	ldr	x2, [x20,3264]
-	adrp	x0, .LC90
-	add	x0, x0, :lo12:.LC90
+	tbz	x0, 8, .L724
+	ldr	x2, [x20,3288]
+	adrp	x0, .LC92
+	add	x0, x0, :lo12:.LC92
 	ldrb	w2, [x2,x21]
 	bl	printk
-.L719:
+.L724:
 	add	x19, x19, :lo12:.LANCHOR0
 	mov	w1, -1
-	ldr	x0, [x19,3264]
+	ldr	x0, [x19,3288]
 	strb	w1, [x0,x21]
 	ldrb	w0, [x19,2903]
 	sub	w0, w0, #1
 	strb	w0, [x19,2903]
 	mov	w0, 1
-	b	.L716
-.L718:
+	b	.L721
+.L723:
 	add	w1, w1, 1
-	b	.L717
-.L730:
+	b	.L722
+.L735:
 	mov	w0, 0
-.L716:
+.L721:
 	ldp	x19, x20, [sp,16]
 	ldr	x21, [sp,32]
 	ldp	x29, x30, [sp], 64
@@ -4630,9 +4694,9 @@ gc_free_temp_buf:
 	.type	print_gc_debug_info, %function
 print_gc_debug_info:
 	adrp	x6, .LANCHOR0
-	adrp	x0, .LC91
+	adrp	x0, .LC93
 	add	x6, x6, :lo12:.LANCHOR0
-	add	x0, x0, :lo12:.LC91
+	add	x0, x0, :lo12:.LC93
 	stp	x29, x30, [sp, -16]!
 	add	x29, sp, 0
 	ldrh	w1, [x6,2896]
@@ -4654,23 +4718,23 @@ zftl_get_gc_node:
 	uxth	w2, w0
 	cmp	w1, 5
 	add	x29, sp, 0
-	bne	.L733
-	adrp	x0, .LANCHOR0+3280
-	ldr	x0, [x0,#:lo12:.LANCHOR0+3280]
-	b	.L736
-.L733:
+	bne	.L738
+	adrp	x0, .LANCHOR0+3304
+	ldr	x0, [x0,#:lo12:.LANCHOR0+3304]
+	b	.L741
+.L738:
 	cmp	w1, 2
-	bne	.L735
+	bne	.L740
 	mov	w0, w2
 	bl	zftl_get_gc_node.part.12
-	b	.L737
-.L735:
-	adrp	x0, .LANCHOR0+3288
-	ldr	x0, [x0,#:lo12:.LANCHOR0+3288]
-.L736:
+	b	.L742
+.L740:
+	adrp	x0, .LANCHOR0+3312
+	ldr	x0, [x0,#:lo12:.LANCHOR0+3312]
+.L741:
 	mov	w1, w2
 	bl	_list_get_gc_head_node.isra.5
-.L737:
+.L742:
 	uxth	w0, w0
 	ldp	x29, x30, [sp], 16
 	ret
@@ -4694,23 +4758,23 @@ gc_search_src_blk:
 	ldr	x1, [x0,608]
 	add	x1, x1, x21, sxtw 1
 	ldrh	w19, [x1,120]
-	cbnz	w19, .L785
-	cbnz	w21, .L741
-	adrp	x26, .LC92
-	strh	w21, [x0,3296]
+	cbnz	w19, .L790
+	cbnz	w21, .L746
+	adrp	x26, .LC94
+	strh	w21, [x0,3320]
 	mov	w19, w21
 	mov	w25, w21
 	uxth	w23, w22
 	mov	w27, 65535
 	adrp	x28, .LANCHOR2
-	add	x26, x26, :lo12:.LC92
-.L742:
+	add	x26, x26, :lo12:.LC94
+.L747:
 	cmp	w25, w23
-	bcs	.L747
+	bcs	.L752
 	add	x3, x20, :lo12:.LANCHOR0
 	mov	w1, 3
 	str	x3, [x29,96]
-	ldrh	w2, [x3,3296]
+	ldrh	w2, [x3,3320]
 	str	x2, [x29,104]
 	mov	w0, w2
 	bl	zftl_get_gc_node
@@ -4721,11 +4785,11 @@ gc_search_src_blk:
 	mov	w4, w1
 	add	w2, w2, 1
 	uxth	w2, w2
-	strh	w2, [x3,3296]
-	beq	.L743
+	strh	w2, [x3,3320]
+	beq	.L748
 	ldr	w0, [x28,#:lo12:.LANCHOR2]
 	uxtw	x5, w1
-	tbz	x0, 8, .L744
+	tbz	x0, 8, .L749
 	ldr	x3, [x3,600]
 	mov	x0, x26
 	str	x4, [x29,96]
@@ -4734,232 +4798,232 @@ gc_search_src_blk:
 	bl	printk
 	ldr	x4, [x29,96]
 	ldr	x5, [x29,104]
-.L744:
+.L749:
 	add	x1, x20, :lo12:.LANCHOR0
 	ldr	x0, [x1,600]
 	ldrh	w2, [x0,x5,lsl 1]
 	ldrh	w0, [x1,2878]
 	cmp	w2, w0
-	bcs	.L745
+	bcs	.L750
 	mov	w1, 0
 	mov	w0, w4
 	mov	w2, w1
 	bl	gc_add_sblk
-	cbz	w0, .L746
+	cbz	w0, .L751
 	add	w19, w19, 1
 	uxth	w19, w19
 	cmp	w19, w23
-	bls	.L746
-	b	.L747
-.L745:
-	strh	wzr, [x1,3296]
-	b	.L747
-.L743:
-	strh	wzr, [x3,3296]
-	b	.L747
-.L746:
+	bls	.L751
+	b	.L752
+.L750:
+	strh	wzr, [x1,3320]
+	b	.L752
+.L748:
+	strh	wzr, [x3,3320]
+	b	.L752
+.L751:
 	add	w25, w25, 1
 	uxth	w25, w25
-	b	.L742
-.L747:
-	tbz	x24, 1, .L749
+	b	.L747
+.L752:
+	tbz	x24, 1, .L754
 	mov	w26, 0
 	mov	w27, 65535
-.L750:
+.L755:
 	cmp	w26, w23
-	beq	.L754
+	beq	.L759
 	add	x25, x20, :lo12:.LANCHOR0
 	mov	w1, 5
-	ldrh	w28, [x25,3298]
+	ldrh	w28, [x25,3322]
 	mov	w0, w28
 	add	w28, w28, 1
 	bl	zftl_get_gc_node
 	uxth	w1, w0
-	strh	w28, [x25,3298]
+	strh	w28, [x25,3322]
 	cmp	w1, w27
-	beq	.L751
+	beq	.L756
 	ubfiz	x1, x1, 1, 16
 	ldr	x2, [x25,600]
 	ldrh	w2, [x2,x1]
 	ldrh	w1, [x25,2880]
 	cmp	w2, w1
-	bcs	.L751
+	bcs	.L756
 	mov	w1, 0
 	mov	w2, w1
 	bl	gc_add_sblk
-	cbz	w0, .L753
+	cbz	w0, .L758
 	add	w19, w19, 1
 	uxth	w19, w19
 	cmp	w19, w23
-	bls	.L753
-	b	.L756
-.L751:
-	strh	wzr, [x25,3298]
-	b	.L754
-.L753:
+	bls	.L758
+	b	.L761
+.L756:
+	strh	wzr, [x25,3322]
+	b	.L759
+.L758:
 	add	w26, w26, 1
 	uxth	w26, w26
-	b	.L750
-.L754:
+	b	.L755
+.L759:
 	cmp	w19, w23
-	bcs	.L756
+	bcs	.L761
 	add	x0, x20, :lo12:.LANCHOR0
-	ldrh	w1, [x0,3274]
-	ldrb	w4, [x0,3276]
-	ldrh	w2, [x0,3300]
+	ldrh	w1, [x0,3298]
+	ldrb	w4, [x0,3300]
+	ldrh	w2, [x0,3324]
 	ldrh	w3, [x0,2880]
 	mul	w1, w1, w4
 	sub	w1, w1, w2, lsr 2
 	cmp	w3, w1
-	bge	.L749
+	bge	.L754
 	add	w2, w3, w2, lsr 3
 	strh	w2, [x0,2880]
-	b	.L749
-.L756:
+	b	.L754
+.L761:
 	add	x1, x20, :lo12:.LANCHOR0
 	ldrh	w2, [x1,2880]
-	ldrh	w0, [x1,3300]
+	ldrh	w0, [x1,3324]
 	cmp	w2, w0
-	bls	.L749
+	bls	.L754
 	sub	w0, w2, w0, lsr 3
 	strh	w0, [x1,2880]
-.L749:
-	tbz	x24, 0, .L757
+.L754:
+	tbz	x24, 0, .L762
 	cmp	w19, w23
-	bcs	.L757
+	bcs	.L762
 	mov	w25, 0
 	mov	w27, 65535
-.L758:
+.L763:
 	cmp	w25, w23
-	beq	.L761
+	beq	.L766
 	add	x28, x20, :lo12:.LANCHOR0
-	ldrh	w26, [x28,3302]
+	ldrh	w26, [x28,3326]
 	mov	w0, w26
 	add	w26, w26, 1
 	bl	zftl_get_gc_node.part.12
-	strh	w26, [x28,3302]
+	strh	w26, [x28,3326]
 	cmp	w27, w0, uxth
-	beq	.L759
+	beq	.L764
 	mov	w1, 0
 	mov	w2, w1
 	bl	gc_add_sblk
-	cbz	w0, .L760
+	cbz	w0, .L765
 	add	w19, w19, 1
 	uxth	w19, w19
 	cmp	w19, w23
-	bcc	.L760
-	b	.L763
-.L759:
-	strh	wzr, [x28,3302]
-	b	.L761
-.L760:
+	bcc	.L765
+	b	.L768
+.L764:
+	strh	wzr, [x28,3326]
+	b	.L766
+.L765:
 	add	w25, w25, 1
 	uxth	w25, w25
-	b	.L758
-.L761:
+	b	.L763
+.L766:
 	cmp	w19, w23
-	bcs	.L763
+	bcs	.L768
 	add	x20, x20, :lo12:.LANCHOR0
 	ldrh	w1, [x20,2878]
-	ldrh	w0, [x20,3300]
+	ldrh	w0, [x20,3324]
 	cmp	w1, w0
-	bcs	.L757
+	bcs	.L762
 	add	w0, w1, w0, lsr 3
-	b	.L838
-.L763:
+	b	.L843
+.L768:
 	add	x20, x20, :lo12:.LANCHOR0
-	ldrh	w0, [x20,3300]
+	ldrh	w0, [x20,3324]
 	ldrh	w1, [x20,2878]
 	cmp	w1, w0, lsr 1
-	bls	.L757
+	bls	.L762
 	sub	w0, w1, w0, lsr 3
-.L838:
+.L843:
 	strh	w0, [x20,2878]
-	b	.L757
-.L741:
+	b	.L762
+.L746:
 	and	w1, w24, 1
 	strh	w19, [x0,3214]
-	strh	w19, [x0,3304]
+	strh	w19, [x0,3328]
 	str	w1, [x29,104]
-	tbz	x24, 0, .L764
-	ldrh	w2, [x0,3306]
+	tbz	x24, 0, .L769
+	ldrh	w2, [x0,3330]
 	ldrh	w1, [x0,2852]
 	cmp	w1, w2, lsr 2
-	bcc	.L765
+	bcc	.L770
 	ldrh	w0, [x0,2850]
 	cmp	w0, w1
-	bls	.L766
-.L765:
+	bls	.L771
+.L770:
 	add	x23, x20, :lo12:.LANCHOR0
 	mov	w19, 0
 	ldrh	w0, [x23,2850]
 	lsr	w0, w0, 2
-	strh	w0, [x23,3302]
+	strh	w0, [x23,3326]
 	mov	w0, 0
 	bl	zftl_get_gc_node.part.12
 	uxth	w1, w0
 	mov	w2, 65535
 	cmp	w1, w2
-	beq	.L767
+	beq	.L772
 	ubfiz	x1, x1, 1, 16
 	ldr	x3, [x23,600]
-	ldrh	w2, [x23,3300]
+	ldrh	w2, [x23,3324]
 	ldrh	w1, [x3,x1]
 	cmp	w1, w2, lsr 2
-	bcs	.L767
+	bcs	.L772
 	mov	w1, w19
 	mov	w2, w21
-	strh	w19, [x23,3302]
+	strh	w19, [x23,3326]
 	bl	gc_add_sblk
 	cmp	w0, w19
 	cset	w19, ne
-.L767:
+.L772:
 	mov	w23, 64
 	mov	w26, 65535
 	uxth	w27, w22
-.L769:
+.L774:
 	add	x25, x20, :lo12:.LANCHOR0
-	ldrh	w28, [x25,3302]
+	ldrh	w28, [x25,3326]
 	mov	w0, w28
 	add	w28, w28, 1
 	bl	zftl_get_gc_node.part.12
-	strh	w28, [x25,3302]
+	strh	w28, [x25,3326]
 	cmp	w26, w0, uxth
-	beq	.L766
+	beq	.L771
 	mov	w1, 0
 	mov	w2, w21
 	bl	gc_add_sblk
-	cbz	w0, .L768
+	cbz	w0, .L773
 	add	w19, w19, 1
 	uxth	w19, w19
 	cmp	w19, w27
-	bcs	.L766
-.L768:
+	bcs	.L771
+.L773:
 	sub	w23, w23, #1
 	uxth	w23, w23
-	cbnz	w23, .L769
-.L766:
+	cbnz	w23, .L774
+.L771:
 	add	x0, x20, :lo12:.LANCHOR0
-	ldrh	w2, [x0,3306]
+	ldrh	w2, [x0,3330]
 	ldrh	w1, [x0,2852]
 	cmp	w1, w2, lsr 3
-	bhi	.L786
+	bhi	.L791
 	ldrh	w0, [x0,2850]
 	add	w0, w0, 8
 	cmp	w1, w0
-	bgt	.L786
-.L764:
-	tbz	x24, 1, .L772
+	bgt	.L791
+.L769:
+	tbz	x24, 1, .L777
 	add	x0, x20, :lo12:.LANCHOR0
 	mov	w25, 64
 	mov	w26, 0
 	mov	w27, 65535
 	uxth	w28, w22
-	strh	wzr, [x0,3298]
-.L777:
+	strh	wzr, [x0,3322]
+.L782:
 	add	x23, x20, :lo12:.LANCHOR0
 	mov	w1, 5
-	ldrh	w2, [x23,3298]
+	ldrh	w2, [x23,3322]
 	str	x2, [x29,96]
 	mov	w0, w2
 	bl	zftl_get_gc_node
@@ -4967,152 +5031,152 @@ gc_search_src_blk:
 	ldr	x2, [x29,96]
 	cmp	w1, w27
 	add	w2, w2, 1
-	strh	w2, [x23,3298]
-	beq	.L773
+	strh	w2, [x23,3322]
+	beq	.L778
 	cmp	w22, 1
-	bne	.L774
-	ldrh	w3, [x23,3274]
-	ldrb	w2, [x23,3276]
+	bne	.L779
+	ldrh	w3, [x23,3298]
+	ldrb	w2, [x23,3300]
 	mul	w2, w2, w3
-	ldrh	w3, [x23,3300]
+	ldrh	w3, [x23,3324]
 	sub	w2, w2, w3, lsr 3
 	strh	w2, [x23,2874]
-.L774:
+.L779:
 	add	x2, x20, :lo12:.LANCHOR0
 	ubfiz	x1, x1, 1, 16
 	ldr	x3, [x2,600]
 	ldrh	w3, [x3,x1]
 	ldrh	w1, [x2,2874]
 	cmp	w3, w1
-	bcs	.L775
+	bcs	.L780
 	mov	w1, 0
 	mov	w2, w21
 	bl	gc_add_sblk
-	cbz	w0, .L776
+	cbz	w0, .L781
 	add	w19, w19, 1
 	add	w26, w26, 1
 	uxth	w19, w19
 	uxth	w26, w26
 	cmp	w19, w28
-	bcc	.L776
-	b	.L773
-.L775:
-	strh	wzr, [x2,3298]
-	b	.L773
-.L776:
+	bcc	.L781
+	b	.L778
+.L780:
+	strh	wzr, [x2,3322]
+	b	.L778
+.L781:
 	sub	w0, w25, #1
 	uxth	w25, w0
-	cbnz	w25, .L777
-.L773:
+	cbnz	w25, .L782
+.L778:
 	cmp	w19, w22
-	bcc	.L778
-	cbnz	w26, .L779
+	bcc	.L783
+	cbnz	w26, .L784
 	add	x0, x20, :lo12:.LANCHOR0
 	ldrh	w1, [x0,2854]
-	ldrh	w0, [x0,3308]
+	ldrh	w0, [x0,3332]
 	cmp	w1, w0
-	bls	.L779
-.L778:
+	bls	.L784
+.L783:
 	add	x0, x20, :lo12:.LANCHOR0
-	ldrh	w1, [x0,3274]
-	ldrb	w4, [x0,3276]
-	ldrh	w3, [x0,3300]
+	ldrh	w1, [x0,3298]
+	ldrb	w4, [x0,3300]
+	ldrh	w3, [x0,3324]
 	ldrh	w2, [x0,2874]
 	mul	w1, w1, w4
 	lsr	w3, w3, 3
 	sub	w1, w1, w3
 	cmp	w2, w1
-	bge	.L772
+	bge	.L777
 	add	w2, w3, w2
 	strh	w2, [x0,2874]
-	b	.L772
-.L779:
+	b	.L777
+.L784:
 	add	x0, x20, :lo12:.LANCHOR0
-	ldrh	w1, [x0,3300]
-	ldrb	w2, [x0,3276]
+	ldrh	w1, [x0,3324]
+	ldrb	w2, [x0,3300]
 	ldrh	w3, [x0,2874]
 	mul	w2, w1, w2
 	cmp	w3, w2
-	ble	.L772
+	ble	.L777
 	sub	w1, w3, w1, lsr 3
 	strh	w1, [x0,2874]
-.L772:
+.L777:
 	ldr	w0, [x29,104]
-	cbz	w0, .L757
+	cbz	w0, .L762
 	add	x0, x20, :lo12:.LANCHOR0
 	mov	w25, 64
 	mov	w26, 65535
 	uxth	w27, w22
-	strh	wzr, [x0,3296]
-.L783:
+	strh	wzr, [x0,3320]
+.L788:
 	add	x23, x20, :lo12:.LANCHOR0
 	mov	w1, 3
-	ldrh	w28, [x23,3296]
+	ldrh	w28, [x23,3320]
 	mov	w0, w28
 	add	w28, w28, 1
 	bl	zftl_get_gc_node
 	uxth	w1, w0
-	strh	w28, [x23,3296]
+	strh	w28, [x23,3320]
 	cmp	w1, w26
-	beq	.L780
+	beq	.L785
 	ubfiz	x1, x1, 1, 16
 	ldr	x2, [x23,600]
 	ldrh	w1, [x2,x1]
 	cmp	w1, 2
-	bls	.L781
+	bls	.L786
 	ldrh	w2, [x23,2876]
 	cmp	w2, w1
-	bls	.L781
-	ldrh	w2, [x23,3306]
+	bls	.L786
+	ldrh	w2, [x23,3330]
 	ldrh	w1, [x23,2852]
 	cmp	w1, w2, lsr 1
-	bls	.L780
-.L781:
+	bls	.L785
+.L786:
 	mov	w1, 0
 	mov	w2, w21
 	bl	gc_add_sblk
-	cbz	w0, .L782
+	cbz	w0, .L787
 	add	w19, w19, 1
 	uxth	w19, w19
 	cmp	w19, w27
-	bcs	.L780
-.L782:
+	bcs	.L785
+.L787:
 	sub	w25, w25, #1
 	uxth	w25, w25
-	cbnz	w25, .L783
-.L780:
+	cbnz	w25, .L788
+.L785:
 	cmp	w19, w22
 	add	x20, x20, :lo12:.LANCHOR0
-	bcs	.L784
-	ldrh	w0, [x20,3300]
+	bcs	.L789
+	ldrh	w0, [x20,3324]
 	ldrh	w1, [x20,2876]
 	cmp	w1, w0, lsr 1
-	bls	.L757
+	bls	.L762
 	sub	w0, w1, w0, lsr 3
 	strh	w0, [x20,2876]
-	b	.L757
-.L784:
-	ldrh	w1, [x20,3300]
-	ldrb	w0, [x20,3276]
+	b	.L762
+.L789:
+	ldrh	w1, [x20,3324]
+	ldrb	w0, [x20,3300]
 	ldrh	w2, [x20,2876]
 	mul	w0, w1, w0
 	sub	w0, w0, #32
 	cmp	w2, w0
-	bge	.L757
+	bge	.L762
 	add	w1, w2, w1, lsr 3
 	strh	w1, [x20,2876]
-.L757:
+.L762:
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 8, .L785
-	adrp	x0, .LC93
+	tbz	x0, 8, .L790
+	adrp	x0, .LC95
 	mov	w1, w21
-	add	x0, x0, :lo12:.LC93
+	add	x0, x0, :lo12:.LC95
 	mov	w2, w24
 	mov	w3, w19
 	mov	w4, w22
 	bl	printk
-.L785:
+.L790:
 	mov	w0, w19
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
@@ -5121,35 +5185,35 @@ gc_search_src_blk:
 	ldp	x27, x28, [sp,80]
 	ldp	x29, x30, [sp], 112
 	ret
-.L786:
+.L791:
 	add	x0, x20, :lo12:.LANCHOR0
 	mov	w23, 64
 	mov	w26, 65535
 	uxth	w27, w22
-	strh	wzr, [x0,3296]
-.L771:
+	strh	wzr, [x0,3320]
+.L776:
 	add	x25, x20, :lo12:.LANCHOR0
 	mov	w1, 3
-	ldrh	w28, [x25,3296]
+	ldrh	w28, [x25,3320]
 	mov	w0, w28
 	add	w28, w28, 1
 	bl	zftl_get_gc_node
-	strh	w28, [x25,3296]
+	strh	w28, [x25,3320]
 	cmp	w26, w0, uxth
-	beq	.L764
+	beq	.L769
 	mov	w1, 0
 	mov	w2, w21
 	bl	gc_add_sblk
-	cbz	w0, .L770
+	cbz	w0, .L775
 	add	w19, w19, 1
 	uxth	w19, w19
 	cmp	w19, w27
-	bcs	.L764
-.L770:
+	bcs	.L769
+.L775:
 	sub	w23, w23, #1
 	uxth	w23, w23
-	cbnz	w23, .L771
-	b	.L764
+	cbnz	w23, .L776
+	b	.L769
 	.size	gc_search_src_blk, .-gc_search_src_blk
 	.align	2
 	.global	zftl_insert_free_list
@@ -5164,20 +5228,20 @@ zftl_insert_free_list:
 	add	x0, x0, x1, uxth 2
 	ldrb	w0, [x0,2]
 	ands	w0, w0, 24
-	bne	.L840
-	add	x0, x2, 3312
+	bne	.L845
+	add	x0, x2, 3336
 	add	x2, x2, 2844
-	b	.L843
-.L840:
+	b	.L848
+.L845:
 	cmp	w0, 16
-	bne	.L842
-	add	x0, x2, 3320
+	bne	.L847
+	add	x0, x2, 3344
 	add	x2, x2, 2846
-	b	.L843
-.L842:
-	add	x0, x2, 3328
+	b	.L848
+.L847:
+	add	x0, x2, 3352
 	add	x2, x2, 2848
-.L843:
+.L848:
 	bl	_insert_free_list
 	ldp	x29, x30, [sp], 16
 	ret
@@ -5196,24 +5260,24 @@ zftl_insert_data_list:
 	ldrb	w3, [x0,2]
 	and	w3, w3, 224
 	cmp	w3, 64
-	bne	.L845
+	bne	.L850
 	add	x0, x2, 616
 	add	x2, x2, 2850
-	b	.L848
-.L845:
+	b	.L853
+.L850:
 	cmp	w3, 96
-	bne	.L847
-	add	x0, x2, 3288
+	bne	.L852
+	add	x0, x2, 3312
 	add	x2, x2, 2852
-	b	.L848
-.L847:
+	b	.L853
+.L852:
 	cmp	w3, 160
-	bne	.L844
-	add	x0, x2, 3280
+	bne	.L849
+	add	x0, x2, 3304
 	add	x2, x2, 2854
-.L848:
+.L853:
 	bl	_insert_data_list
-.L844:
+.L849:
 	ldp	x29, x30, [sp], 16
 	ret
 	.size	zftl_insert_data_list, .-zftl_insert_data_list
@@ -5232,64 +5296,64 @@ zftl_gc_get_free_sblk:
 	uxth	w22, w1
 	ldr	x0, [x23,608]
 	ldrh	w19, [x0,588]
-	cbnz	w21, .L850
+	cbnz	w21, .L855
 	mov	w0, 65535
 	cmp	w19, w0
-	beq	.L850
-	adrp	x0, .LC94
+	beq	.L855
+	adrp	x0, .LC96
 	mov	w1, w19
-	add	x0, x0, :lo12:.LC94
+	add	x0, x0, :lo12:.LC96
 	bl	printk
 	ldr	x0, [x23,608]
 	mov	w1, -1
 	strh	w1, [x0,588]
-	b	.L851
-.L850:
+	b	.L856
+.L855:
 	add	x0, x20, :lo12:.LANCHOR0
 	ldrh	w3, [x0,2846]
 	ldrh	w1, [x0,2848]
 	cmp	w3, w1
-	bls	.L852
+	bls	.L857
 	mov	w1, 0
 	mov	x2, x0
 	lsr	w3, w3, 3
 	cmp	w21, w1
 	csel	w1, w3, w1, ne
-	add	x0, x0, 3320
+	add	x0, x0, 3344
 	add	x2, x2, 2846
-	b	.L870
-.L852:
+	b	.L875
+.L857:
 	lsr	w1, w1, 2
-	cbz	w21, .L856
+	cbz	w21, .L861
 	mov	w1, 7
 	mul	w3, w3, w1
 	mov	w1, 8
 	sdiv	w3, w3, w1
 	uxth	w1, w3
-.L856:
+.L861:
 	add	x2, x20, :lo12:.LANCHOR0
-	add	x0, x2, 3328
+	add	x0, x2, 3352
 	add	x2, x2, 2848
-.L870:
+.L875:
 	bl	_list_pop_index_node
 	uxth	w19, w0
 	mov	w0, 65535
 	cmp	w19, w0
-	bne	.L857
+	bne	.L862
 	add	x5, x20, :lo12:.LANCHOR0
-	adrp	x0, .LC95
-	add	x0, x0, :lo12:.LC95
+	adrp	x0, .LC97
+	add	x0, x0, :lo12:.LC97
 	mov	w1, w19
 	mov	w2, w22
-	ldr	x3, [x5,3312]
+	ldr	x3, [x5,3336]
 	ldrh	w4, [x5,2844]
 	ldrh	w5, [x5,2848]
 	bl	printk
-.L857:
-	cbz	w21, .L851
+.L862:
+	cbz	w21, .L856
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 8, .L851
+	tbz	x0, 8, .L856
 	add	x20, x20, :lo12:.LANCHOR0
 	uxtw	x6, w19
 	lsl	x0, x6, 2
@@ -5298,9 +5362,9 @@ zftl_gc_get_free_sblk:
 	add	x2, x1, x0
 	ldr	w4, [x1,x0]
 	ldrh	w5, [x1,x0]
-	adrp	x0, .LC96
+	adrp	x0, .LC98
 	ldrb	w3, [x2,2]
-	add	x0, x0, :lo12:.LC96
+	add	x0, x0, :lo12:.LC98
 	ldrh	w6, [x7,x6,lsl 1]
 	mov	w1, w19
 	ubfx	x2, x3, 5, 3
@@ -5308,7 +5372,7 @@ zftl_gc_get_free_sblk:
 	ubfx	x3, x3, 3, 2
 	and	w5, w5, 2047
 	bl	printk
-.L851:
+.L856:
 	mov	w0, w19
 	ldr	x23, [sp,48]
 	ldp	x19, x20, [sp,16]
@@ -5328,89 +5392,89 @@ zftl_get_free_sblk:
 	stp	x19, x20, [sp,16]
 	cmp	w21, 5
 	adrp	x19, .LANCHOR0
-	bne	.L872
+	bne	.L877
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrh	w2, [x0,2846]
 	ldrh	w1, [x0,2848]
 	cmp	w2, w1
-	bcc	.L873
+	bcc	.L878
 	ldrh	w0, [x0,2844]
 	cmp	w0, w2
-	bls	.L874
-	cbz	w1, .L874
-.L873:
+	bls	.L879
+	cbz	w1, .L879
+.L878:
 	add	x2, x19, :lo12:.LANCHOR0
 	lsr	w1, w1, 1
-	add	x0, x2, 3328
-	b	.L902
-.L874:
+	add	x0, x2, 3352
+	b	.L907
+.L879:
 	add	x2, x19, :lo12:.LANCHOR0
 	mov	w1, 0
-	add	x0, x2, 3320
+	add	x0, x2, 3344
 	add	x2, x2, 2846
-	b	.L901
-.L872:
+	b	.L906
+.L877:
 	add	x22, x19, :lo12:.LANCHOR0
 	cmp	w21, 1
 	ldr	x0, [x22,608]
 	ldrh	w20, [x0,590]
-	beq	.L876
+	beq	.L881
 	mov	w0, 65535
 	cmp	w20, w0
-	beq	.L876
-	adrp	x0, .LC97
+	beq	.L881
+	adrp	x0, .LC99
 	mov	w1, w20
-	add	x0, x0, :lo12:.LC97
+	add	x0, x0, :lo12:.LC99
 	bl	printk
 	ldr	x0, [x22,608]
 	mov	w1, -1
 	strh	w1, [x0,590]
-	b	.L877
-.L876:
+	b	.L882
+.L881:
 	add	x2, x19, :lo12:.LANCHOR0
 	ldrh	w0, [x2,2844]
 	ldrh	w1, [x2,2848]
 	cmp	w0, w1
-	bcc	.L878
+	bcc	.L883
 	ldrh	w2, [x2,2846]
 	cmp	w2, w0
-	bls	.L879
-	cbz	w1, .L879
-.L878:
+	bls	.L884
+	cbz	w1, .L884
+.L883:
 	lsr	w1, w1, 1
 	cmp	w21, 1
 	csel	w3, w1, w3, eq
 	add	x2, x19, :lo12:.LANCHOR0
-	add	x0, x2, 3328
+	add	x0, x2, 3352
 	mov	w1, w3
-.L902:
+.L907:
 	add	x2, x2, 2848
-	b	.L901
-.L879:
+	b	.L906
+.L884:
 	lsr	w0, w0, 1
 	cmp	w21, 1
 	csel	w3, w0, w3, eq
 	add	x2, x19, :lo12:.LANCHOR0
-	add	x0, x2, 3312
+	add	x0, x2, 3336
 	mov	w1, w3
 	add	x2, x2, 2844
-.L901:
+.L906:
 	bl	_list_pop_index_node
 	uxth	w0, w0
 	mov	w20, w0
 	mov	w0, 65535
 	cmp	w20, w0
-	bne	.L877
+	bne	.L882
 	add	x19, x19, :lo12:.LANCHOR0
-	adrp	x0, .LC95
-	add	x0, x0, :lo12:.LC95
+	adrp	x0, .LC97
+	add	x0, x0, :lo12:.LC97
 	mov	w1, w20
 	mov	w2, w21
-	ldr	x3, [x19,3312]
+	ldr	x3, [x19,3336]
 	ldrh	w4, [x19,2844]
 	ldrh	w5, [x19,2848]
 	bl	printk
-.L877:
+.L882:
 	mov	w0, w20
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
@@ -5431,24 +5495,24 @@ zftl_remove_data_node:
 	ldrb	w3, [x0,2]
 	and	w3, w3, 224
 	cmp	w3, 64
-	bne	.L904
+	bne	.L909
 	add	x0, x2, 616
 	add	x2, x2, 2850
-	b	.L907
-.L904:
+	b	.L912
+.L909:
 	cmp	w3, 96
-	bne	.L906
-	add	x0, x2, 3288
+	bne	.L911
+	add	x0, x2, 3312
 	add	x2, x2, 2852
-	b	.L907
-.L906:
+	b	.L912
+.L911:
 	cmp	w3, 160
-	bne	.L903
-	add	x0, x2, 3280
+	bne	.L908
+	add	x0, x2, 3304
 	add	x2, x2, 2854
-.L907:
+.L912:
 	bl	_list_remove_node
-.L903:
+.L908:
 	ldp	x29, x30, [sp], 16
 	ret
 	.size	zftl_remove_data_node, .-zftl_remove_data_node
@@ -5465,20 +5529,20 @@ zftl_remove_free_node:
 	add	x0, x0, x1, uxth 2
 	ldrb	w0, [x0,2]
 	ands	w0, w0, 24
-	bne	.L909
-	add	x0, x2, 3312
+	bne	.L914
+	add	x0, x2, 3336
 	add	x2, x2, 2844
-	b	.L912
-.L909:
+	b	.L917
+.L914:
 	cmp	w0, 16
-	bne	.L911
-	add	x0, x2, 3320
+	bne	.L916
+	add	x0, x2, 3344
 	add	x2, x2, 2846
-	b	.L912
-.L911:
-	add	x0, x2, 3328
+	b	.L917
+.L916:
+	add	x0, x2, 3352
 	add	x2, x2, 2848
-.L912:
+.L917:
 	bl	_list_remove_node
 	ldp	x29, x30, [sp], 16
 	ret
@@ -5497,24 +5561,24 @@ zftl_list_update_data_list:
 	ldrb	w3, [x0,2]
 	and	w3, w3, 224
 	cmp	w3, 64
-	bne	.L914
+	bne	.L919
 	add	x0, x2, 616
 	add	x2, x2, 2850
-	b	.L917
-.L914:
+	b	.L922
+.L919:
 	cmp	w3, 96
-	bne	.L916
-	add	x0, x2, 3288
+	bne	.L921
+	add	x0, x2, 3312
 	add	x2, x2, 2852
-	b	.L917
-.L916:
+	b	.L922
+.L921:
 	cmp	w3, 160
-	bne	.L913
-	add	x0, x2, 3280
+	bne	.L918
+	add	x0, x2, 3304
 	add	x2, x2, 2854
-.L917:
+.L922:
 	bl	_list_update_data_list
-.L913:
+.L918:
 	ldp	x29, x30, [sp], 16
 	ret
 	.size	zftl_list_update_data_list, .-zftl_list_update_data_list
@@ -5527,25 +5591,25 @@ print_list_info:
 	add	x29, sp, 32
 	stp	x19, x20, [sp,48]
 	mov	x19, x0
-	adrp	x0, .LC98
+	adrp	x0, .LC100
 	stp	x21, x22, [sp,64]
 	stp	x23, x24, [sp,80]
 	stp	x25, x26, [sp,96]
-	add	x0, x0, :lo12:.LC98
+	add	x0, x0, :lo12:.LC100
 	ldrh	w2, [x1]
 	ldr	x1, [x19]
 	bl	printk
 	ldr	x19, [x19]
-	cbz	x19, .L918
+	cbz	x19, .L923
 	mov	x22, -6148914691236517206
-	adrp	x23, .LC99
+	adrp	x23, .LC101
 	mov	w20, 0
 	adrp	x25, .LANCHOR0
 	add	x22, x22, 1
-	add	x23, x23, :lo12:.LC99
+	add	x23, x23, :lo12:.LC101
 	mov	w26, 65535
 	mov	w24, 6
-.L921:
+.L926:
 	add	x21, x25, :lo12:.LANCHOR0
 	ldrh	w3, [x19]
 	ldrh	w4, [x19,2]
@@ -5576,16 +5640,16 @@ print_list_info:
 	bl	printk
 	ldrh	w19, [x19]
 	cmp	w19, w26
-	beq	.L918
+	beq	.L923
 	ldr	x0, [x21,528]
 	add	w20, w20, 1
 	umull	x19, w19, w24
 	uxth	w20, w20
 	add	x19, x0, x19
-	ldrh	w0, [x21,3336]
+	ldrh	w0, [x21,3360]
 	cmp	w0, w20
-	bcs	.L921
-.L918:
+	bcs	.L926
+.L923:
 	sub	sp, x29, #32
 	ldp	x19, x20, [sp,48]
 	ldp	x21, x22, [sp,64]
@@ -5604,22 +5668,22 @@ dump_all_list_info:
 	str	x19, [sp,16]
 	adrp	x19, .LANCHOR0
 	add	x19, x19, :lo12:.LANCHOR0
-	add	x0, x19, 3312
+	add	x0, x19, 3336
 	add	x1, x19, 2844
 	bl	print_list_info
-	add	x0, x19, 3320
+	add	x0, x19, 3344
 	add	x1, x19, 2846
 	bl	print_list_info
-	add	x0, x19, 3328
+	add	x0, x19, 3352
 	add	x1, x19, 2848
 	bl	print_list_info
 	add	x0, x19, 616
 	add	x1, x19, 2850
 	bl	print_list_info
-	add	x0, x19, 3288
+	add	x0, x19, 3312
 	add	x1, x19, 2852
 	bl	print_list_info
-	add	x0, x19, 3280
+	add	x0, x19, 3304
 	add	x1, x19, 2854
 	bl	print_list_info
 	ldr	x19, [sp,16]
@@ -5634,44 +5698,44 @@ ftl_tmp_into_update:
 	ldr	x0, [x0,#:lo12:.LANCHOR0+2864]
 	ldr	w2, [x0,16]
 	cmp	w2, 2048
-	bls	.L924
+	bls	.L929
 	lsr	w1, w2, 11
 	ldr	w3, [x0,20]
 	add	w3, w3, w1
 	sub	w1, w2, w1, lsl 11
 	str	w3, [x0,20]
 	str	w1, [x0,16]
-.L924:
+.L929:
 	ldr	w2, [x0,24]
 	cmp	w2, 2048
-	bls	.L925
+	bls	.L930
 	lsr	w1, w2, 11
 	ldr	w3, [x0,28]
 	add	w3, w3, w1
 	sub	w1, w2, w1, lsl 11
 	str	w3, [x0,28]
 	str	w1, [x0,24]
-.L925:
+.L930:
 	ldr	w2, [x0,32]
 	cmp	w2, 1024
-	bls	.L926
+	bls	.L931
 	lsr	w1, w2, 10
 	ldr	w3, [x0,36]
 	add	w3, w3, w1
 	sub	w1, w2, w1, lsl 10
 	str	w3, [x0,36]
 	str	w1, [x0,32]
-.L926:
+.L931:
 	ldr	w2, [x0,40]
 	cmp	w2, 1024
-	bls	.L923
+	bls	.L928
 	lsr	w1, w2, 10
 	ldr	w3, [x0,44]
 	add	w3, w3, w1
 	sub	w1, w2, w1, lsl 10
 	str	w3, [x0,44]
 	str	w1, [x0,40]
-.L923:
+.L928:
 	ret
 	.size	ftl_tmp_into_update, .-ftl_tmp_into_update
 	.align	2
@@ -5687,354 +5751,49 @@ ftl_get_blk_list_in_sblk:
 	ldrb	w11, [x2,3]
 	mov	w2, 0
 	mov	w6, w2
-.L929:
+.L934:
 	add	x8, x7, :lo12:.LANCHOR0
-	ldrb	w3, [x8,3276]
+	ldrb	w3, [x8,3300]
 	cmp	w6, w3
-	bge	.L935
+	bge	.L940
 	asr	w3, w11, w6
-	tbnz	x3, 0, .L930
-	ldrb	w5, [x8,3338]
+	tbnz	x3, 0, .L935
+	ldrb	w5, [x8,3266]
 	sbfiz	x10, x2, 1, 32
-	ldrh	w3, [x8,3340]
+	ldrh	w3, [x8,3264]
 	sdiv	w9, w6, w5
 	sub	w3, w12, w3
 	lsl	w3, w9, w3
 	madd	w3, w0, w5, w3
 	uxth	w4, w3
 	strh	w4, [x1,x10]
-	ldrb	w3, [x8,3338]
+	ldrb	w3, [x8,3266]
 	cmp	w3, 1
-	bls	.L931
+	bls	.L936
 	sub	w3, w3, #1
 	and	w3, w6, w3
 	add	w3, w4, w3
 	strh	w3, [x1,x10]
-.L931:
+.L936:
 	add	w2, w2, 1
-.L930:
-	add	w6, w6, 1
-	b	.L929
 .L935:
+	add	w6, w6, 1
+	b	.L934
+.L940:
 	mov	w0, w2
 	mov	w4, -1
-.L933:
+.L938:
 	add	x3, x7, :lo12:.LANCHOR0
-	ldrb	w3, [x3,3276]
+	ldrb	w3, [x3,3300]
 	cmp	w2, w3
-	bge	.L936
+	bge	.L941
 	strh	w4, [x1,w2,sxtw 1]
 	add	w2, w2, 1
-	b	.L933
-.L936:
+	b	.L938
+.L941:
 	ret
 	.size	ftl_get_blk_list_in_sblk, .-ftl_get_blk_list_in_sblk
 	.align	2
-	.global	ftl_free_sblk
-	.type	ftl_free_sblk, %function
-ftl_free_sblk:
-	stp	x29, x30, [sp, -64]!
-	add	x29, sp, 0
-	stp	x21, x22, [sp,32]
-	uxth	x22, w0
-	adrp	x0, .LANCHOR0
-	add	x3, x0, :lo12:.LANCHOR0
-	mov	x1, x22
-	stp	x19, x20, [sp,16]
-	lsl	x19, x22, 2
-	mov	x21, x0
-	ldr	x7, [x3,584]
-	add	x20, x7, x19
-	ldrb	w2, [x20,2]
-	tbz	x2, 3, .L939
-	ldr	x6, [x3,2864]
-	ldrh	w4, [x7,x19]
-	ldrh	w10, [x3,3342]
-	ldrh	w0, [x6,74]
-	and	w5, w4, 2047
-	ldr	w4, [x7,x19]
-	add	w0, w5, w0
-	ldrh	w6, [x6,72]
-	ubfx	x9, x4, 11, 8
-	ldrh	w4, [x3,592]
-	uxth	w8, w0
-	add	w6, w9, w6
-	uxth	w0, w6
-	udiv	w6, w8, w4
-	add	w6, w0, w6
-	cmp	w6, w10
-	ble	.L940
-	ldrh	w0, [x3,2846]
-	ldrh	w6, [x3,2854]
-	add	w6, w6, w0
-	ldrh	w0, [x3,3308]
-	add	w0, w0, 8
-	cmp	w6, w0
-	blt	.L956
-	ldrh	w0, [x3,2844]
-	ldrh	w6, [x3,2850]
-	add	w6, w6, w0
-	ldrh	w0, [x3,2852]
-	add	w6, w6, w0
-	ldrh	w0, [x3,3344]
-	add	w0, w0, 8
-	cmp	w6, w0
-	bge	.L956
-	b	.L945
-.L940:
-	madd	w0, w0, w4, w8
-	ldrh	w6, [x3,3346]
-	cmp	w0, w6
-	ble	.L942
-	ldrh	w0, [x3,2844]
-	ldrh	w6, [x3,2850]
-	add	w6, w6, w0
-	ldrh	w0, [x3,2852]
-	add	w6, w6, w0
-	ldrh	w0, [x3,3344]
-	add	w0, w0, 8
-	cmp	w6, w0
-	blt	.L945
-	ldrh	w0, [x3,2846]
-	ldrh	w6, [x3,2854]
-	add	w6, w6, w0
-	ldrh	w0, [x3,3308]
-	add	w0, w0, 8
-	cmp	w6, w0
-	bge	.L945
-.L956:
-	mov	w0, 2
-	bfi	w2, w0, 3, 2
-	b	.L954
-.L945:
-	and	w2, w2, -25
-.L954:
-	strb	w2, [x20,2]
-.L942:
-	ldrb	w0, [x20,2]
-	ands	w0, w0, 24
-	bne	.L946
-	mul	w4, w9, w4
-	ldrh	w0, [x7,x19]
-	add	w4, w4, w4, lsl 1
-	add	w4, w5, w4, lsr 2
-	ubfx	x5, x4, 2, 9
-	bfi	w0, w5, 0, 11
-	strh	w0, [x7,x19]
-	b	.L939
-.L946:
-	cmp	w0, 16
-	bne	.L939
-	sdiv	w4, w5, w4
-	ldr	w0, [x7,x19]
-	add	w4, w4, w4, lsl 1
-	add	w4, w9, w4, lsr 2
-	ubfx	x4, x4, 2, 6
-	bfi	w0, w4, 11, 8
-	str	w0, [x7,x19]
-.L939:
-	mov	w0, w1
-	str	x1, [x29,56]
-	bl	zftl_remove_data_node
-	add	x0, x21, :lo12:.LANCHOR0
-	ldr	x1, [x29,56]
-	ldr	x2, [x0,584]
-	add	x2, x2, x19
-	ldrb	w3, [x2,2]
-	and	w3, w3, 31
-	strb	w3, [x2,2]
-	ldr	x2, [x0,600]
-	strh	wzr, [x2,x22,lsl 1]
-	ldrb	w2, [x20,2]
-	tbz	x2, 3, .L948
-	ldr	x2, [x0,608]
-	ldrh	w0, [x2,584]
-	cmp	w0, w1
-	bne	.L949
-	mov	w0, -1
-	ldrh	w3, [x2,588]
-	strh	w0, [x2,584]
-	mov	w0, 65535
-	cmp	w3, w0
-	bne	.L948
-	adrp	x0, .LC100
-	strh	w1, [x2,588]
-	add	x0, x0, :lo12:.LC100
-	b	.L955
-.L949:
-	ldrh	w0, [x2,586]
-	cmp	w0, w1
-	bne	.L948
-	mov	w0, -1
-	ldrh	w3, [x2,590]
-	strh	w0, [x2,586]
-	mov	w0, 65535
-	cmp	w3, w0
-	bne	.L948
-	adrp	x0, .LC101
-	strh	w1, [x2,590]
-	add	x0, x0, :lo12:.LC101
-.L955:
-	bl	printk
-	b	.L937
-.L948:
-	mov	w0, w1
-	bl	zftl_insert_free_list
-.L937:
-	ldp	x19, x20, [sp,16]
-	ldp	x21, x22, [sp,32]
-	ldp	x29, x30, [sp], 64
-	ret
-	.size	ftl_free_sblk, .-ftl_free_sblk
-	.align	2
-	.global	gc_free_src_blk
-	.type	gc_free_src_blk, %function
-gc_free_src_blk:
-	stp	x29, x30, [sp, -80]!
-	add	x29, sp, 0
-	stp	x23, x24, [sp,48]
-	stp	x21, x22, [sp,32]
-	adrp	x23, .LANCHOR0
-	adrp	x21, .LANCHOR1
-	add	x23, x23, :lo12:.LANCHOR0
-	add	x21, x21, :lo12:.LANCHOR1
-	stp	x19, x20, [sp,16]
-	stp	x25, x26, [sp,64]
-	mov	w20, 0
-	add	x24, x23, 2896
-	add	x21, x21, 1352
-.L958:
-	ldrh	w0, [x24,56]
-	adrp	x25, .LANCHOR0
-	cmp	w0, w20
-	bls	.L996
-	add	x0, x24, x20, sxtw 1
-	ldrh	w22, [x0,58]
-	ldr	x0, [x23,600]
-	lsl	x26, x22, 1
-	mov	x19, x22
-	ldrh	w2, [x0,x26]
-	cbz	w2, .L959
-	adrp	x0, .LC102
-	mov	w1, w22
-	add	x0, x0, :lo12:.LC102
-	bl	printk
-.L959:
-	add	x0, x25, :lo12:.LANCHOR0
-	ldr	x1, [x0,600]
-	strh	wzr, [x1,x26]
-	ldr	x1, [x0,600]
-	ldrh	w1, [x1,x26]
-	cbnz	w1, .L960
-	ldr	x0, [x0,584]
-	add	x22, x0, x22, lsl 2
-	adrp	x0, .LANCHOR2
-	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 8, .L961
-	ldrb	w2, [x22,2]
-	adrp	x0, .LC103
-	add	x0, x0, :lo12:.LC103
-	mov	w1, w19
-	ubfx	x2, x2, 5, 3
-	bl	printk
-.L961:
-	ldrb	w0, [x22,2]
-	tst	w0, 192
-	beq	.L974
-	and	w0, w0, 224
-	cmp	w0, 224
-	bne	.L962
-.L974:
-	adrp	x0, .LC0
-	mov	x1, x21
-	mov	w2, 884
-	add	x0, x0, :lo12:.LC0
-	bl	printk
-	bl	dump_stack
-.L962:
-	mov	w0, w19
-	add	x25, x25, :lo12:.LANCHOR0
-	bl	ftl_free_sblk
-	ldr	x2, [x25,608]
-	ldrh	w1, [x2,124]
-	cbz	w1, .L964
-	mov	x0, 0
-.L966:
-	add	x4, x2, x0, lsl 1
-	mov	w3, w0
-	ldrh	w4, [x4,392]
-	cmp	w4, w19
-	bne	.L965
-	add	x0, x2, x3, sxtw 1
-	mov	w3, -1
-	strh	w3, [x0,392]
-	sub	w1, w1, #1
-	strh	w1, [x2,124]
-	b	.L964
-.L965:
-	add	x0, x0, 1
-	cmp	x0, 64
-	bne	.L966
-.L964:
-	ldrh	w1, [x2,120]
-	cbz	w1, .L967
-	mov	x0, 0
-.L969:
-	add	x4, x2, x0, lsl 1
-	mov	w3, w0
-	ldrh	w4, [x4,136]
-	cmp	w4, w19
-	bne	.L968
-	add	x0, x2, x3, sxtw 1
-	mov	w3, -1
-	strh	w3, [x0,136]
-	sub	w1, w1, #1
-	strh	w1, [x2,120]
-	b	.L967
-.L968:
-	add	x0, x0, 1
-	cmp	x0, 64
-	bne	.L969
-.L967:
-	ldrh	w1, [x2,122]
-	cbz	w1, .L970
-	mov	x0, 0
-.L972:
-	add	x4, x2, x0, lsl 1
-	mov	w3, w0
-	ldrh	w4, [x4,264]
-	cmp	w4, w19
-	bne	.L971
-	add	x0, x2, x3, sxtw 1
-	mov	w3, -1
-	strh	w3, [x0,264]
-	sub	w1, w1, #1
-	strh	w1, [x2,122]
-	b	.L970
-.L971:
-	add	x0, x0, 1
-	cmp	x0, 64
-	bne	.L972
-	b	.L970
-.L960:
-	mov	w0, w19
-	mov	w1, 1
-	mov	w2, 0
-	bl	gc_add_sblk
-.L970:
-	add	w20, w20, 1
-	uxth	w20, w20
-	b	.L958
-.L996:
-	strh	wzr, [x24,56]
-	ldp	x19, x20, [sp,16]
-	ldp	x21, x22, [sp,32]
-	ldp	x23, x24, [sp,48]
-	ldp	x25, x26, [sp,64]
-	ldp	x29, x30, [sp], 80
-	ret
-	.size	gc_free_src_blk, .-gc_free_src_blk
-	.align	2
 	.global	ftl_erase_phy_blk
 	.type	ftl_erase_phy_blk, %function
 ftl_erase_phy_blk:
@@ -6048,29 +5807,29 @@ ftl_erase_phy_blk:
 	stp	x19, x20, [sp,16]
 	mov	w4, 1
 	mov	w21, w1
-	ldrh	w19, [x5,3340]
+	ldrh	w19, [x5,3264]
 	mov	x20, x3
 	sub	w19, w0, w19
-	ldrb	w0, [x5,3258]
+	ldrb	w0, [x5,3282]
 	asr	w22, w2, w19
 	lsl	w19, w4, w19
 	sub	w19, w19, #1
 	and	w19, w19, w2
 	sxth	w19, w19
-	cbz	w0, .L998
-	ldrb	w0, [x5,3259]
-	cbnz	w0, .L998
-	ldrh	w2, [x5,3348]
+	cbz	w0, .L943
+	ldrb	w0, [x5,3283]
+	cbnz	w0, .L943
+	ldrh	w2, [x5,3362]
 	cmp	w1, wzr
 	mov	w0, w22
 	cset	w1, eq
 	mul	w2, w19, w2
 	bl	flash_erase_block_en
-.L998:
+.L943:
 	add	x3, x20, :lo12:.LANCHOR0
 	mov	w1, w21
 	mov	w0, w22
-	ldrh	w2, [x3,3348]
+	ldrh	w2, [x3,3362]
 	mul	w2, w19, w2
 	bl	flash_erase_block_en
 	ldp	x19, x20, [sp,16]
@@ -6097,91 +5856,91 @@ ftl_erase_sblk:
 	mov	w19, 0
 	add	x0, x0, x20
 	ldrb	w25, [x0,3]
-.L1003:
+.L948:
 	add	x2, x23, :lo12:.LANCHOR0
-	ldrb	w0, [x2,3350]
+	ldrb	w0, [x2,3364]
 	cmp	w19, w0
-	bge	.L1014
-	ldrb	w3, [x2,3338]
+	bge	.L959
+	ldrb	w3, [x2,3266]
 	mov	w21, 0
-	ldrh	w2, [x2,3348]
+	ldrh	w2, [x2,3362]
 	mov	w1, w21
 	sub	w4, w3, #1
 	mul	w6, w19, w3
 	mul	w5, w24, w3
-.L1015:
+.L960:
 	cmp	w1, w3
-	bge	.L1028
+	bge	.L973
 	add	w0, w1, w6
 	asr	w0, w25, w0
-	tbnz	x0, 0, .L1004
+	tbnz	x0, 0, .L949
 	and	w0, w1, w4
 	add	x7, x29, 80
 	add	w0, w5, w0
 	mul	w0, w0, w2
 	str	w0, [x7,w21,sxtw 2]
 	add	w21, w21, 1
-.L1004:
+.L949:
 	add	w1, w1, 1
-	b	.L1015
-.L1028:
+	b	.L960
+.L973:
 	cmp	w3, 4
-	bne	.L1027
+	bne	.L972
 	mov	x26, 0
-.L1006:
+.L951:
 	cmp	w21, w26
-	ble	.L1009
+	ble	.L954
 	add	x2, x29, 80
 	mov	w0, w19
 	mov	w1, w22
 	ldr	w2, [x2,x26,lsl 2]
 	add	x26, x26, 1
 	bl	flash_erase_block_en
-	b	.L1006
-.L1027:
+	b	.L951
+.L972:
 	cmp	w21, 2
-	bne	.L1010
+	bne	.L955
 	add	x0, x23, :lo12:.LANCHOR0
-	ldrb	w1, [x0,3258]
-	cbz	w1, .L1011
-	ldrb	w0, [x0,3259]
-	cbnz	w0, .L1011
+	ldrb	w1, [x0,3282]
+	cbz	w1, .L956
+	ldrb	w0, [x0,3283]
+	cbnz	w0, .L956
 	cmp	w22, wzr
 	ldr	w2, [x29,80]
 	ldr	w3, [x29,84]
 	mov	w0, w19
 	cset	w1, eq
 	bl	flash_erase_duplane_block
-.L1011:
+.L956:
 	ldr	w2, [x29,80]
 	mov	w0, w19
 	ldr	w3, [x29,84]
 	mov	w1, w22
 	bl	flash_erase_duplane_block
-	b	.L1009
-.L1010:
+	b	.L954
+.L955:
 	cmp	w21, 1
-	bne	.L1009
+	bne	.L954
 	add	x0, x23, :lo12:.LANCHOR0
-	ldrb	w1, [x0,3258]
-	cbz	w1, .L1013
-	ldrb	w0, [x0,3259]
-	cbnz	w0, .L1013
+	ldrb	w1, [x0,3282]
+	cbz	w1, .L958
+	ldrb	w0, [x0,3283]
+	cbnz	w0, .L958
 	cmp	w22, wzr
 	ldr	w2, [x29,80]
 	mov	w0, w19
 	cset	w1, eq
 	bl	flash_erase_block_en
-.L1013:
+.L958:
 	ldr	w2, [x29,80]
 	mov	w0, w19
 	mov	w1, w22
 	bl	flash_erase_block_en
-.L1009:
+.L954:
 	add	w19, w19, 1
-	b	.L1003
-.L1014:
-	cbnz	w22, .L1016
+	b	.L948
+.L959:
+	cbnz	w22, .L961
 	ldr	x1, [x2,584]
 	ldrh	w0, [x1,x20]
 	add	w3, w0, 1
@@ -6197,10 +5956,10 @@ ftl_erase_sblk:
 	ubfx	x1, x1, 0, 11
 	uxth	w2, w1
 	cmp	w3, w2
-	bge	.L1018
+	bge	.L963
 	strh	w1, [x0,96]
-	b	.L1018
-.L1016:
+	b	.L963
+.L961:
 	ldr	x3, [x2,584]
 	ldr	w0, [x3,x20]
 	ubfx	x1, x0, 11, 8
@@ -6216,9 +5975,9 @@ ftl_erase_sblk:
 	ldr	w1, [x1,x20]
 	ubfx	x1, x1, 11, 8
 	cmp	w2, w1, uxtb
-	bcs	.L1018
+	bcs	.L963
 	strh	w1, [x0,98]
-.L1018:
+.L963:
 	mov	w0, 0
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
@@ -6240,39 +5999,39 @@ ftl_alloc_sys_blk:
 	ldr	x1, [x1,2864]
 	ldrh	w2, [x1,136]
 	cmp	w2, 63
-	bls	.L1030
+	bls	.L975
 	strh	wzr, [x1,136]
-.L1030:
+.L975:
 	ldrh	w0, [x1,112]
-	cbnz	w0, .L1031
+	cbnz	w0, .L976
 	adrp	x1, .LANCHOR1
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 1117
-	add	x1, x1, 1368
+	mov	w2, 1130
+	add	x1, x1, 1352
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L1031:
+.L976:
 	add	x0, x19, :lo12:.LANCHOR0
 	mov	w4, 65535
 	ldr	x1, [x0,2864]
-.L1035:
+.L980:
 	ldrh	w2, [x1,136]
-.L1032:
+.L977:
 	cmp	w2, 63
-	bgt	.L1038
+	bgt	.L983
 	sxtw	x3, w2
 	add	x3, x3, 80
 	ldrh	w0, [x1,x3,lsl 1]
 	cmp	w0, w4
-	bne	.L1037
+	bne	.L982
 	add	w2, w2, 1
-	b	.L1032
-.L1038:
+	b	.L977
+.L983:
 	strh	wzr, [x1,136]
-	b	.L1035
-.L1037:
+	b	.L980
+.L982:
 	mov	w4, -1
 	strh	w4, [x1,x3,lsl 1]
 	strh	w2, [x1,136]
@@ -6297,34 +6056,34 @@ ftl_free_sys_blk:
 	ldr	x2, [x0,2864]
 	ldrh	w0, [x2,138]
 	cmp	w0, 63
-	bls	.L1040
+	bls	.L985
 	strh	wzr, [x2,138]
-.L1040:
+.L985:
 	ldrh	w0, [x2,112]
 	cmp	w0, 63
-	bls	.L1041
+	bls	.L986
 	adrp	x1, .LANCHOR1
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 1141
-	add	x1, x1, 1392
+	mov	w2, 1154
+	add	x1, x1, 1376
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L1041:
+.L986:
 	add	x1, x19, :lo12:.LANCHOR0
 	mov	w0, 65535
 	ldr	x1, [x1,2864]
-.L1045:
+.L990:
 	ldrh	w2, [x1,138]
-.L1042:
+.L987:
 	cmp	w2, 63
-	bgt	.L1047
+	bgt	.L992
 	sxtw	x3, w2
 	add	x3, x3, 80
 	ldrh	w4, [x1,x3,lsl 1]
 	cmp	w4, w0
-	bne	.L1043
+	bne	.L988
 	strh	w20, [x1,x3,lsl 1]
 	strh	w2, [x1,138]
 	ldrh	w0, [x1,112]
@@ -6333,12 +6092,12 @@ ftl_free_sys_blk:
 	ldp	x19, x20, [sp,16]
 	ldp	x29, x30, [sp], 32
 	ret
-.L1043:
+.L988:
 	add	w2, w2, 1
-	b	.L1042
-.L1047:
+	b	.L987
+.L992:
 	strh	wzr, [x1,138]
-	b	.L1045
+	b	.L990
 	.size	ftl_free_sys_blk, .-ftl_free_sys_blk
 	.align	2
 	.global	ftl_info_data_recovery
@@ -6352,7 +6111,7 @@ ftl_info_data_recovery:
 	str	x23, [sp,48]
 	ldrh	w2, [x0]
 	cmp	w2, w1
-	beq	.L1048
+	beq	.L993
 	adrp	x19, .LANCHOR0
 	ubfiz	x20, x2, 2, 16
 	add	x23, x19, :lo12:.LANCHOR0
@@ -6360,36 +6119,36 @@ ftl_info_data_recovery:
 	add	x22, x21, x20
 	ldrb	w1, [x22,2]
 	tst	w1, 224
-	bne	.L1048
+	bne	.L993
 	ldrb	w0, [x0,4]
 	bfi	w1, w0, 5, 3
 	mov	w0, w2
 	strb	w1, [x22,2]
 	bl	zftl_remove_free_node
 	ldrb	w0, [x22,2]
-	tbz	x0, 3, .L1052
+	tbz	x0, 3, .L997
 	ldr	x1, [x23,2864]
 	ldrh	w0, [x1,116]
 	sub	w0, w0, #1
 	strh	w0, [x1,116]
-	b	.L1053
-.L1052:
+	b	.L998
+.L997:
 	tst	w0, 24
 	ldr	x1, [x23,2864]
-	bne	.L1054
+	bne	.L999
 	ldrh	w0, [x1,114]
 	sub	w0, w0, #1
 	strh	w0, [x1,114]
-	b	.L1053
-.L1054:
+	b	.L998
+.L999:
 	ldrh	w0, [x1,118]
 	sub	w0, w0, #1
 	strh	w0, [x1,118]
-.L1053:
+.L998:
 	ldrb	w0, [x22,2]
 	and	w0, w0, 224
 	cmp	w0, 160
-	bne	.L1055
+	bne	.L1000
 	ldr	w0, [x21,x20]
 	add	x19, x19, :lo12:.LANCHOR0
 	ubfx	x1, x0, 11, 8
@@ -6400,29 +6159,29 @@ ftl_info_data_recovery:
 	ldrh	w0, [x1,120]
 	sub	w0, w0, #1
 	strh	w0, [x1,120]
-	b	.L1048
-.L1055:
+	b	.L993
+.L1000:
 	ldrh	w1, [x21,x20]
 	cmp	w0, 64
 	add	w2, w1, 1
 	bfi	w1, w2, 0, 11
 	strh	w1, [x21,x20]
-	bne	.L1056
+	bne	.L1001
 	add	x19, x19, :lo12:.LANCHOR0
 	ldr	x1, [x19,2864]
 	ldrh	w0, [x1,122]
 	sub	w0, w0, #1
 	strh	w0, [x1,122]
-	b	.L1048
-.L1056:
+	b	.L993
+.L1001:
 	cmp	w0, 96
-	bne	.L1048
+	bne	.L993
 	add	x19, x19, :lo12:.LANCHOR0
 	ldr	x1, [x19,2864]
 	ldrh	w0, [x1,124]
 	sub	w0, w0, #1
 	strh	w0, [x1,124]
-.L1048:
+.L993:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldr	x23, [sp,48]
@@ -6441,19 +6200,19 @@ ftl_get_ppa_from_index:
 	stp	x19, x20, [sp,16]
 	str	x21, [sp,32]
 	mov	x19, x2
-	ldrh	w0, [x4,3300]
+	ldrh	w0, [x4,3324]
 	ldr	x3, [x4,608]
-	ldrb	w4, [x4,3276]
+	ldrb	w4, [x4,3300]
 	mul	w0, w0, w4
 	cmp	w1, w0
-	bge	.L1058
+	bge	.L1003
 	add	x3, x3, 16
-	b	.L1059
-.L1058:
+	b	.L1004
+.L1003:
 	sub	w1, w1, w0
 	add	x3, x3, 48
 	uxth	w1, w1
-.L1059:
+.L1004:
 	ldrb	w2, [x3,9]
 	mov	w0, 65535
 	sdiv	w20, w1, w2
@@ -6461,18 +6220,18 @@ ftl_get_ppa_from_index:
 	add	x1, x3, x1, uxth 1
 	ldrh	w21, [x1,16]
 	cmp	w21, w0
-	bne	.L1060
+	bne	.L1005
 	adrp	x1, .LANCHOR1
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 1580
-	add	x1, x1, 1416
+	mov	w2, 1593
+	add	x1, x1, 1400
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L1060:
+.L1005:
 	add	x2, x19, :lo12:.LANCHOR0
-	ldrh	w0, [x2,3348]
+	ldrh	w0, [x2,3362]
 	madd	w0, w21, w0, w20
 	ldp	x19, x20, [sp,16]
 	ldr	x21, [sp,32]
@@ -6489,25 +6248,25 @@ lpa_hash_get_ppa:
 	add	x2, x1, x0, uxtb 1
 	stp	x29, x30, [sp, -16]!
 	add	x29, sp, 0
-	ldrh	w2, [x2,3352]
-	ldr	x4, [x1,3864]
-	ldr	x5, [x1,3872]
-.L1062:
+	ldrh	w2, [x2,3368]
+	ldr	x4, [x1,3880]
+	ldr	x5, [x1,3888]
+.L1007:
 	cmp	w2, w3
-	beq	.L1066
+	beq	.L1011
 	uxtw	x1, w2
 	ldr	w6, [x4,x1,lsl 2]
 	cmp	w6, w0
-	bne	.L1063
+	bne	.L1008
 	mov	w0, w2
 	bl	ftl_get_ppa_from_index
-	b	.L1064
-.L1063:
+	b	.L1009
+.L1008:
 	ldrh	w2, [x5,x1,lsl 1]
-	b	.L1062
-.L1066:
+	b	.L1007
+.L1011:
 	mov	w0, -1
-.L1064:
+.L1009:
 	ldp	x29, x30, [sp], 16
 	ret
 	.size	lpa_hash_get_ppa, .-lpa_hash_get_ppa
@@ -6522,71 +6281,71 @@ ftl_get_new_free_page:
 	ldrh	w1, [x0]
 	mov	w0, 65535
 	cmp	w1, w0
-	bne	.L1068
+	bne	.L1013
 	adrp	x1, .LANCHOR1
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 1695
-	add	x1, x1, 1440
+	mov	w2, 1716
+	add	x1, x1, 1424
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L1068:
+.L1013:
 	adrp	x20, .LANCHOR0
 	ldrh	w1, [x19,2]
 	add	x0, x20, :lo12:.LANCHOR0
-	ldrh	w0, [x0,3300]
+	ldrh	w0, [x0,3324]
 	cmp	w1, w0
-	bne	.L1069
+	bne	.L1014
 	adrp	x1, .LANCHOR1
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 1696
-	add	x1, x1, 1440
+	mov	w2, 1717
+	add	x1, x1, 1424
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L1069:
+.L1014:
 	ldrh	w0, [x19,6]
-	cbnz	w0, .L1070
+	cbnz	w0, .L1015
 	adrp	x1, .LANCHOR1
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 1697
-	add	x1, x1, 1440
+	mov	w2, 1718
+	add	x1, x1, 1424
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L1070:
+.L1015:
 	ldrb	w0, [x19,5]
 	add	x1, x20, :lo12:.LANCHOR0
 	add	x0, x0, 8
-	ldrb	w2, [x1,3276]
+	ldrb	w2, [x1,3300]
 	mov	w1, 65535
 	ldrh	w0, [x19,x0,lsl 1]
-.L1071:
+.L1016:
 	cmp	w0, w1
-	bne	.L1075
+	bne	.L1020
 	ldrb	w0, [x19,5]
 	add	w0, w0, 1
 	uxtb	w0, w0
 	strb	w0, [x19,5]
 	cmp	w0, w2
-	bne	.L1072
+	bne	.L1017
 	ldrh	w0, [x19,2]
 	strb	wzr, [x19,5]
 	add	w0, w0, 1
 	strh	w0, [x19,2]
-.L1072:
+.L1017:
 	ldrb	w0, [x19,5]
 	add	x0, x0, 8
 	ldrh	w0, [x19,x0,lsl 1]
-	b	.L1071
-.L1075:
+	b	.L1016
+.L1020:
 	add	x20, x20, :lo12:.LANCHOR0
 	ldrh	w2, [x19,2]
-	ldrh	w1, [x20,3348]
-	ldrb	w3, [x20,3276]
+	ldrh	w1, [x20,3362]
+	ldrb	w3, [x20,3300]
 	mul	w0, w0, w1
 	ldrh	w1, [x19,6]
 	orr	w0, w0, w2
@@ -6600,11 +6359,11 @@ ftl_get_new_free_page:
 	uxtb	w1, w1
 	strb	w1, [x19,5]
 	cmp	w3, w1
-	bne	.L1074
+	bne	.L1019
 	add	w2, w2, 1
 	strb	wzr, [x19,5]
 	strh	w2, [x19,2]
-.L1074:
+.L1019:
 	ldp	x19, x20, [sp,16]
 	ldp	x29, x30, [sp], 32
 	ret
@@ -6622,16 +6381,16 @@ ftl_ext_alloc_new_blk:
 	mov	w1, 65533
 	sub	w0, w0, #1
 	cmp	w1, w0, uxth
-	bcs	.L1077
+	bcs	.L1022
 	adrp	x1, .LANCHOR1
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 1728
-	add	x1, x1, 1464
+	mov	w2, 1749
+	add	x1, x1, 1448
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L1077:
+.L1022:
 	adrp	x19, .LANCHOR0
 	mov	w1, 0
 	add	x19, x19, :lo12:.LANCHOR0
@@ -6654,52 +6413,52 @@ ftl_ext_alloc_new_blk:
 ftl_total_vpn_update:
 	adrp	x1, .LANCHOR0
 	add	x3, x1, :lo12:.LANCHOR0
-	ldrh	w2, [x3,3880]
-	cbnz	w0, .L1079
+	ldrh	w2, [x3,3896]
+	cbnz	w0, .L1024
 	cmp	w2, 4
-	bhi	.L1079
+	bhi	.L1024
 	add	w2, w2, 1
-	strh	w2, [x3,3880]
-	b	.L1078
-.L1079:
+	strh	w2, [x3,3896]
+	b	.L1023
+.L1024:
 	add	x0, x1, :lo12:.LANCHOR0
 	mov	w9, 65535
-	strh	wzr, [x0,3880]
+	strh	wzr, [x0,3896]
 	ldrh	w6, [x0,576]
 	ldr	x7, [x0,600]
 	ldr	x8, [x0,584]
 	mov	x0, 0
 	mov	w2, w0
 	mov	w3, w0
-.L1081:
+.L1026:
 	cmp	w6, w0, uxth
-	bls	.L1089
+	bls	.L1034
 	ldrh	w4, [x7,x0,lsl 1]
 	cmp	w4, w9
-	beq	.L1082
+	beq	.L1027
 	add	x5, x8, x0, lsl 2
 	ldrb	w5, [x5,2]
 	and	w5, w5, 224
 	cmp	w5, 160
-	bne	.L1083
+	bne	.L1028
 	add	w2, w2, w4
-	b	.L1082
-.L1083:
+	b	.L1027
+.L1028:
 	add	w3, w3, w4
-.L1082:
+.L1027:
 	add	x0, x0, 1
-	b	.L1081
-.L1089:
+	b	.L1026
+.L1034:
 	add	x1, x1, :lo12:.LANCHOR0
 	ldr	x0, [x1,608]
 	ldr	x1, [x1,2864]
 	str	w3, [x0,524]
 	str	w2, [x0,528]
 	ldrh	w1, [x1,120]
-	cbz	w1, .L1078
+	cbz	w1, .L1023
 	udiv	w2, w2, w1
 	str	w2, [x0,532]
-.L1078:
+.L1023:
 	ret
 	.size	ftl_total_vpn_update, .-ftl_total_vpn_update
 	.align	2
@@ -6725,10 +6484,10 @@ ftl_vpn_update:
 	ldr	x0, [x1,600]
 	ldrh	w2, [x0,x19]
 	mov	w0, 0
-	cbnz	w2, .L1092
+	cbnz	w2, .L1037
 	mov	w0, 1
 	str	w0, [x1,2884]
-.L1092:
+.L1037:
 	ldr	x19, [sp,16]
 	ldp	x29, x30, [sp], 32
 	ret
@@ -6744,56 +6503,56 @@ ftl_vpn_decrement:
 	str	x19, [sp,16]
 	cmp	w1, w0
 	adrp	x2, .LANCHOR0
-	beq	.L1095
+	beq	.L1040
 	add	x5, x2, :lo12:.LANCHOR0
 	uxtw	x0, w1
 	lsl	x3, x0, 1
 	ldr	x4, [x5,600]
 	ldrh	w19, [x4,x3]
-	cbnz	w19, .L1096
+	cbnz	w19, .L1041
 	ldr	x2, [x5,584]
 	add	x0, x2, x0, lsl 2
 	mov	w2, w19
 	ldrb	w3, [x0,2]
-	adrp	x0, .LC104
-	add	x0, x0, :lo12:.LC104
+	adrp	x0, .LC102
+	add	x0, x0, :lo12:.LC102
 	ubfx	x3, x3, 5, 3
 	bl	printk
-	b	.L1102
-.L1096:
+	b	.L1047
+.L1041:
 	sub	w19, w19, #1
 	strh	w19, [x4,x3]
-.L1095:
+.L1040:
 	add	x19, x2, :lo12:.LANCHOR0
 	mov	w0, 0
-	ldrh	w2, [x19,3224]
+	ldrh	w2, [x19,3240]
 	cmp	w2, w1
-	beq	.L1097
+	beq	.L1042
 	mov	w0, 65535
 	cmp	w2, w0
-	bne	.L1098
-	strh	w1, [x19,3224]
-.L1102:
+	bne	.L1043
+	strh	w1, [x19,3240]
+.L1047:
 	mov	w0, 0
-	b	.L1097
-.L1098:
+	b	.L1042
+.L1043:
 	mov	w0, w2
 	str	x1, [x29,40]
 	bl	ftl_vpn_update
 	cmp	w0, wzr
-	ldrh	w3, [x19,3882]
+	ldrh	w3, [x19,3898]
 	cset	w0, ne
-	ldrh	w2, [x19,3224]
+	ldrh	w2, [x19,3240]
 	add	w3, w3, 1
 	ldr	x1, [x29,40]
-	strh	w1, [x19,3224]
+	strh	w1, [x19,3240]
 	uxth	w3, w3
 	cmp	w3, 7
 	csel	w3, w3, wzr, ls
-	strh	w3, [x19,3882]
+	strh	w3, [x19,3898]
 	add	x3, x19, x3, uxth 1
-	strh	w2, [x3,3232]
-.L1097:
+	strh	w2, [x3,3248]
+.L1042:
 	ldr	x19, [sp,16]
 	ldp	x29, x30, [sp], 48
 	ret
@@ -6806,73 +6565,73 @@ lpa_hash_update_ppa:
 	uxtb	w5, w0
 	add	x6, x3, :lo12:.LANCHOR0
 	uxth	w2, w2
-	add	x4, x6, 3352
+	add	x4, x6, 3368
 	stp	x29, x30, [sp, -16]!
 	add	x29, sp, 0
-	ldr	x8, [x6,3864]
-	ldr	x12, [x6,3872]
+	ldr	x8, [x6,3880]
+	ldr	x12, [x6,3888]
 	mov	w6, 65535
 	ldrh	w4, [x4,w5,sxtw 1]
 	mov	w11, w6
-.L1104:
+.L1049:
 	cmp	w4, w11
-	beq	.L1108
+	beq	.L1053
 	uxtw	x9, w4
 	uxth	x7, w4
 	lsl	x10, x9, 2
 	add	x13, x8, x10
 	ldr	w10, [x8,x10]
 	cmp	w10, w0
-	bne	.L1105
+	bne	.L1050
 	mov	w4, -1
 	str	w4, [x13]
 	mov	w4, 65535
 	cmp	w6, w4
 	add	x4, x3, :lo12:.LANCHOR0
-	bne	.L1106
-	ldr	x6, [x4,3872]
-	add	x4, x4, 3352
+	bne	.L1051
+	ldr	x6, [x4,3888]
+	add	x4, x4, 3368
 	ldrh	w6, [x6,x7,lsl 1]
 	strh	w6, [x4,w5,sxtw 1]
-	b	.L1107
-.L1106:
-	ldr	x4, [x4,3872]
+	b	.L1052
+.L1051:
+	ldr	x4, [x4,3888]
 	ldrh	w8, [x4,x7,lsl 1]
 	strh	w8, [x4,w6,uxtw 1]
-.L1107:
+.L1052:
 	add	x4, x3, :lo12:.LANCHOR0
 	mov	w6, -1
-	ldr	x4, [x4,3872]
+	ldr	x4, [x4,3888]
 	strh	w6, [x4,x7,lsl 1]
-	b	.L1108
-.L1105:
+	b	.L1053
+.L1050:
 	mov	w6, w4
 	ldrh	w4, [x12,x9,lsl 1]
-	b	.L1104
-.L1108:
+	b	.L1049
+.L1053:
 	add	x3, x3, :lo12:.LANCHOR0
 	uxtw	x4, w2
 	cmn	w1, #1
-	ldr	x6, [x3,3864]
+	ldr	x6, [x3,3880]
 	str	w0, [x6,x4,lsl 2]
-	add	x0, x3, 3352
+	add	x0, x3, 3368
 	ldrh	w6, [x0,w5,sxtw 1]
 	strh	w2, [x0,w5,sxtw 1]
-	ldr	x0, [x3,3872]
+	ldr	x0, [x3,3888]
 	strh	w6, [x0,x4,lsl 1]
-	beq	.L1110
-	ldrh	w0, [x3,3340]
+	beq	.L1055
+	ldrh	w0, [x3,3264]
 	mov	w2, 21
 	mov	w4, 1
 	sub	w2, w2, w0
 	lsr	w1, w1, w0
 	lsl	w2, w4, w2
-	ldrb	w0, [x3,3338]
+	ldrb	w0, [x3,3266]
 	sub	w2, w2, #1
 	and	w1, w2, w1
 	udiv	w0, w1, w0
 	bl	ftl_vpn_decrement
-.L1110:
+.L1055:
 	mov	w0, -1
 	ldp	x29, x30, [sp], 16
 	ret
@@ -6882,455 +6641,890 @@ lpa_hash_update_ppa:
 	.type	ftl_mask_bad_block, %function
 ftl_mask_bad_block:
 	stp	x29, x30, [sp, -48]!
-	adrp	x3, .LANCHOR0
-	mov	w2, 21
-	add	x1, x3, :lo12:.LANCHOR0
+	adrp	x6, .LANCHOR0
+	ubfx	x1, x0, 21, 3
+	add	x3, x6, :lo12:.LANCHOR0
 	add	x29, sp, 0
-	mov	w4, 1
 	stp	x19, x20, [sp,16]
 	str	x21, [sp,32]
-	ubfx	x21, x0, 21, 3
-	mov	x19, x3
-	ldrh	w5, [x1,3340]
-	sub	w2, w2, w5
-	lsr	w0, w0, w5
-	lsl	w2, w4, w2
-	sub	w2, w2, #1
-	and	w0, w2, w0
-	ldrb	w2, [x1,3338]
-	udiv	w2, w0, w2
+	mov	x19, x6
+	ldrb	w5, [x3,3266]
+	ldrh	w3, [x3,3264]
+	mul	w2, w1, w5
+	lsr	w0, w0, w3
+	uxtb	w20, w2
+	mov	w2, 21
+	sub	w3, w2, w3
+	mov	w2, 1
+	lsl	w3, w2, w3
+	cmp	w5, w2
+	sub	w3, w3, #1
+	and	w3, w3, w0
+	uxth	w4, w3
+	udiv	w3, w3, w5
+	uxth	w21, w3
+	bls	.L1060
+	sub	w5, w5, #1
+	and	w5, w4, w5
+	add	w2, w20, w5
+	uxtb	w20, w2
+.L1060:
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	uxth	w20, w2
-	tbz	x0, 14, .L1115
-	adrp	x0, .LC105
-	mov	w1, w21
-	add	x0, x0, :lo12:.LC105
+	tbz	x0, 14, .L1061
+	adrp	x0, .LC103
 	mov	w2, w20
+	add	x0, x0, :lo12:.LC103
+	uxth	w3, w3
 	bl	printk
-.L1115:
+.L1061:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrh	w1, [x0,576]
-	cmp	w1, w20
-	bls	.L1114
+	cmp	w1, w21
+	bls	.L1059
 	ldr	x0, [x0,584]
-	add	x20, x0, x20, uxth 2
-	mov	w0, 1
-	lsl	w1, w0, w21
-	ldrb	w0, [x20,3]
-	orr	w1, w1, w0
-	strb	w1, [x20,3]
-.L1114:
+	mov	w2, 1
+	add	x21, x0, x21, uxth 2
+	ldrb	w0, [x21,3]
+	lsl	w2, w2, w20
+	orr	w2, w2, w0
+	strb	w2, [x21,3]
+.L1059:
 	ldp	x19, x20, [sp,16]
 	ldr	x21, [sp,32]
 	ldp	x29, x30, [sp], 48
 	ret
 	.size	ftl_mask_bad_block, .-ftl_mask_bad_block
 	.align	2
-	.global	print_ftl_debug_info
-	.type	print_ftl_debug_info, %function
-print_ftl_debug_info:
-	sub	sp, sp, #64
-	stp	x29, x30, [sp,32]
-	add	x29, sp, 32
-	str	x19, [sp,48]
-	adrp	x19, .LANCHOR0
-	add	x19, x19, :lo12:.LANCHOR0
-	ldr	x2, [x19,2864]
-	ldr	x0, [x19,608]
-	ldrh	w8, [x19,2854]
-	ldrh	w1, [x2,148]
-	ldrh	w2, [x2,146]
-	str	w8, [sp]
-	ldrh	w6, [x19,2850]
-	ldr	w8, [x0,524]
-	str	w8, [sp,8]
-	ldrh	w7, [x19,2852]
-	ldr	w0, [x0,528]
-	str	w0, [sp,16]
-	ldr	w0, [x19,2840]
-	ldrh	w3, [x19,2844]
-	ldrh	w4, [x19,2846]
-	ldrh	w5, [x19,2848]
-	str	w0, [sp,24]
-	adrp	x0, .LC106
-	add	x0, x0, :lo12:.LC106
-	bl	printk
-	ldr	x5, [x19,2864]
-	adrp	x0, .LC107
-	ldrb	w3, [x19,2857]
-	add	x0, x0, :lo12:.LC107
-	ldr	w4, [x5,8]
-	ldr	w1, [x5,20]
-	ldr	w2, [x5,28]
-	ldr	w5, [x5,64]
-	bl	printk
-	ldr	x2, [x19,2864]
-	adrp	x0, .LC108
-	add	x0, x0, :lo12:.LC108
-	ldr	w3, [x2,16]
-	ldr	w1, [x2,52]
-	ldr	w2, [x2,60]
-	lsr	w3, w3, 11
-	bl	printk
-	ldr	x7, [x19,2864]
-	ldrh	w0, [x7,90]
-	ldrh	w6, [x7,72]
-	ldrh	w1, [x7,74]
-	ldrh	w3, [x7,88]
-	ldrh	w4, [x7,92]
-	ldrh	w5, [x7,96]
-	str	w0, [sp]
-	ldrh	w0, [x7,94]
-	str	w0, [sp,8]
-	ldrh	w0, [x7,98]
-	str	w0, [sp,16]
-	adrp	x0, .LC109
-	add	x0, x0, :lo12:.LC109
-	ldr	w2, [x7,84]
-	ldr	w7, [x7,80]
-	bl	printk
-	ldrh	w5, [x19,2872]
-	adrp	x0, .LC110
-	ldrh	w1, [x19,2874]
-	add	x0, x0, :lo12:.LC110
-	ldrh	w2, [x19,2876]
-	ldrh	w3, [x19,2878]
-	ldrh	w4, [x19,2880]
-	bl	printk
-	ldr	x4, [x19,608]
-	adrp	x0, .LC111
-	add	x0, x0, :lo12:.LC111
-	ldrh	w1, [x4,584]
-	ldrh	w2, [x4,586]
-	ldrh	w3, [x4,588]
-	ldrh	w4, [x4,590]
+	.global	gc_free_bad_sblk
+	.type	gc_free_bad_sblk, %function
+gc_free_bad_sblk:
+	stp	x29, x30, [sp, -80]!
+	add	x29, sp, 0
+	stp	x19, x20, [sp,16]
+	adrp	x20, .LANCHOR0
+	add	x20, x20, :lo12:.LANCHOR0
+	stp	x21, x22, [sp,32]
+	add	x21, x20, 2896
+	stp	x23, x24, [sp,48]
+	stp	x25, x26, [sp,64]
+	uxth	w25, w0
+	mov	w24, 0
+	ldr	w0, [x21,328]
+	cbz	w0, .L1077
+	adrp	x23, .LC104
+	mov	w26, 21
+	add	x23, x23, :lo12:.LC104
+.L1078:
+	ldrb	w1, [x20,3300]
+	cmp	w1, w24
+	bls	.L1077
+	ldrb	w3, [x20,3266]
+	ldrh	w19, [x20,3264]
+	cmp	w3, 1
+	sdiv	w1, w24, w3
+	sub	w19, w26, w19
+	uxth	w2, w3
+	lsl	w19, w1, w19
+	madd	w19, w25, w2, w19
+	uxth	w19, w19
+	bls	.L1068
+	sub	w2, w2, #1
+	and	w2, w24, w2
+	add	w19, w19, w2
+	uxth	w19, w19
+.L1068:
+	mov	w22, 0
+.L1069:
+	ldr	w0, [x21,328]
+	cmp	w22, w0
+	bcs	.L1079
+	add	x0, x21, x22, sxtw 1
+	ldrh	w0, [x0,332]
+	cmp	w0, w19
+	bne	.L1070
+	mov	w1, w19
+	mov	x0, x23
 	bl	printk
-	sub	sp, x29, #32
-	ldr	x19, [sp,48]
-	ldp	x29, x30, [sp,32]
-	add	sp, sp, 64
+	ldrh	w0, [x20,3264]
+	lsl	w0, w19, w0
+	bl	ftl_mask_bad_block
+	ldr	w2, [x21,328]
+	mov	w1, w22
+.L1071:
+	cmp	w1, w2
+	bcs	.L1080
+	add	w3, w1, 1
+	add	x1, x21, x1, sxtw 1
+	add	x0, x21, x3, sxtw 1
+	ldrh	w0, [x0,332]
+	strh	w0, [x1,332]
+	uxth	w1, w3
+	b	.L1071
+.L1080:
+	sub	w2, w2, #1
+	str	w2, [x21,328]
+.L1070:
+	add	w22, w22, 1
+	uxth	w22, w22
+	b	.L1069
+.L1079:
+	add	w24, w24, 1
+	uxth	w24, w24
+	b	.L1078
+.L1077:
+	mov	w0, 0
+	ldp	x19, x20, [sp,16]
+	ldp	x21, x22, [sp,32]
+	ldp	x23, x24, [sp,48]
+	ldp	x25, x26, [sp,64]
+	ldp	x29, x30, [sp], 80
 	ret
-	.size	print_ftl_debug_info, .-print_ftl_debug_info
+	.size	gc_free_bad_sblk, .-gc_free_bad_sblk
 	.align	2
-	.global	ftl_write_buf
-	.type	ftl_write_buf, %function
-ftl_write_buf:
-	stp	x29, x30, [sp, -48]!
+	.global	ftl_free_sblk
+	.type	ftl_free_sblk, %function
+ftl_free_sblk:
+	stp	x29, x30, [sp, -80]!
 	add	x29, sp, 0
 	stp	x19, x20, [sp,16]
-	str	x21, [sp,32]
-	mov	x20, x0
-	cbnz	x0, .L1122
-	adrp	x1, .LANCHOR1
-	adrp	x0, .LC0
-	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 667
-	add	x1, x1, 1488
-	add	x0, x0, :lo12:.LC0
-	bl	printk
-	bl	dump_stack
-	bl	print_ftl_debug_info
-	mov	w0, -1
-	b	.L1131
-.L1122:
 	adrp	x19, .LANCHOR0
-	ldrb	w1, [x20,56]
-	add	x0, x19, :lo12:.LANCHOR0
-	ldrb	w0, [x0,2832]
-	cmp	w1, w0
-	bls	.L1127
-	adrp	x1, .LANCHOR1
-	adrp	x0, .LC0
-	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 672
-	add	x1, x1, 1488
-	add	x0, x0, :lo12:.LC0
-	bl	printk
-	bl	dump_stack
-.L1127:
-	ldrb	w0, [x20,56]
-	cbz	w0, .L1124
-	add	x21, x19, :lo12:.LANCHOR0
-	ldrb	w1, [x21,2832]
-	cmp	w1, w0
-	bcs	.L1125
-.L1124:
-	mov	x0, x20
-	add	x19, x19, :lo12:.LANCHOR0
-	bl	buf_free
-	ldrb	w0, [x19,2856]
-	b	.L1131
-.L1125:
-	add	x0, x21, 2888
-	mov	x1, x20
-	bl	buf_add_tail
-	ldr	x0, [x21,2864]
-	ldrb	w1, [x20,56]
-	ldrb	w2, [x21,2856]
-	ldr	w3, [x0,16]
-	add	w2, w2, 1
-	add	w1, w3, w1
-	str	w1, [x0,16]
-	ldr	w1, [x0,32]
-	uxtb	w2, w2
-	strb	w2, [x21,2856]
-	add	w1, w1, 1
-	str	w1, [x0,32]
-	mov	w0, w2
-.L1131:
-	ldp	x19, x20, [sp,16]
-	ldr	x21, [sp,32]
-	ldp	x29, x30, [sp], 48
-	ret
-	.size	ftl_write_buf, .-ftl_write_buf
-	.align	2
-	.global	ftl_write_completed
-	.type	ftl_write_completed, %function
-ftl_write_completed:
-	stp	x29, x30, [sp, -80]!
-	add	x29, sp, 0
-	stp	x19, x20, [sp,16]
-	adrp	x19, .LANCHOR0
-	str	x25, [sp,64]
+	str	x23, [sp,48]
+	add	x3, x19, :lo12:.LANCHOR0
+	uxth	x23, w0
 	stp	x21, x22, [sp,32]
+	lsl	x20, x23, 2
+	mov	x1, x23
+	ldr	x7, [x3,584]
+	add	x21, x7, x20
+	ldrb	w2, [x21,2]
+	ubfx	x22, x2, 5, 3
+	tbz	x2, 3, .L1083
+	ldr	x6, [x3,2864]
+	ldrh	w4, [x7,x20]
+	ldrh	w10, [x3,3900]
+	ldrh	w0, [x6,74]
+	and	w5, w4, 2047
+	ldr	w4, [x7,x20]
+	add	w0, w5, w0
+	ldrh	w6, [x6,72]
+	ubfx	x9, x4, 11, 8
+	ldrh	w4, [x3,592]
+	uxth	w8, w0
+	add	w6, w9, w6
+	uxth	w0, w6
+	udiv	w6, w8, w4
+	add	w6, w0, w6
+	cmp	w6, w10
+	ble	.L1084
+	ldrh	w0, [x3,2846]
+	ldrh	w6, [x3,2854]
+	add	w6, w6, w0
+	ldrh	w0, [x3,3332]
+	add	w0, w0, 8
+	cmp	w6, w0
+	blt	.L1101
+	ldrh	w0, [x3,2844]
+	ldrh	w6, [x3,2850]
+	add	w6, w6, w0
+	ldrh	w0, [x3,2852]
+	add	w6, w6, w0
+	ldrh	w0, [x3,3902]
+	add	w0, w0, 8
+	cmp	w6, w0
+	bge	.L1101
+	b	.L1089
+.L1084:
+	madd	w0, w0, w4, w8
+	ldrh	w6, [x3,3904]
+	cmp	w0, w6
+	ble	.L1086
+	ldrh	w0, [x3,2844]
+	ldrh	w6, [x3,2850]
+	add	w6, w6, w0
+	ldrh	w0, [x3,2852]
+	add	w6, w6, w0
+	ldrh	w0, [x3,3902]
+	add	w0, w0, 8
+	cmp	w6, w0
+	blt	.L1089
+	ldrh	w0, [x3,2846]
+	ldrh	w6, [x3,2854]
+	add	w6, w6, w0
+	ldrh	w0, [x3,3332]
+	add	w0, w0, 8
+	cmp	w6, w0
+	bge	.L1089
+.L1101:
+	mov	w0, 2
+	bfi	w2, w0, 3, 2
+	b	.L1099
+.L1089:
+	and	w2, w2, -25
+.L1099:
+	strb	w2, [x21,2]
+.L1086:
+	ldrb	w0, [x21,2]
+	ands	w0, w0, 24
+	bne	.L1090
+	mul	w4, w9, w4
+	ldrh	w0, [x7,x20]
+	add	w4, w4, w4, lsl 1
+	add	w4, w5, w4, lsr 2
+	ubfx	x5, x4, 2, 9
+	bfi	w0, w5, 0, 11
+	strh	w0, [x7,x20]
+	b	.L1083
+.L1090:
+	cmp	w0, 16
+	bne	.L1083
+	sdiv	w4, w5, w4
+	ldr	w0, [x7,x20]
+	add	w4, w4, w4, lsl 1
+	add	w4, w9, w4, lsr 2
+	ubfx	x4, x4, 2, 6
+	bfi	w0, w4, 11, 8
+	str	w0, [x7,x20]
+.L1083:
+	mov	w0, w1
+	str	x1, [x29,72]
+	add	w22, w22, 6
+	bl	zftl_remove_data_node
+	and	w22, w22, 7
+	add	x3, x19, :lo12:.LANCHOR0
+	cmp	w22, 4
+	ldr	x1, [x29,72]
+	ldr	x2, [x3,584]
+	add	x2, x2, x20
+	ldrb	w0, [x2,2]
+	and	w0, w0, 31
+	strb	w0, [x2,2]
+	ldr	x0, [x3,600]
+	strh	wzr, [x0,x23,lsl 1]
+	bhi	.L1092
+	mov	w0, w1
+	bl	gc_free_bad_sblk
+	ldr	x1, [x29,72]
+.L1092:
+	ldrb	w0, [x21,2]
+	tbz	x0, 3, .L1093
 	add	x19, x19, :lo12:.LANCHOR0
-	adrp	x21, .LC112
-	stp	x23, x24, [sp,48]
-	add	x22, x19, 784
-	mov	w23, 21
-	mov	w24, 1
-	add	x21, x21, :lo12:.LC112
-.L1133:
-	ldrb	w0, [x19,3884]
-	cmp	w0, 255
-	beq	.L1140
-	sbfiz	x0, x0, 6, 32
-	add	x20, x22, x0
-	add	x4, x20, 32
-	ldrb	w0, [x22,x0]
-	strb	w0, [x19,3884]
-	ldr	w0, [x20,52]
-	cmn	w0, #1
-	bne	.L1134
-	ldrh	w2, [x19,3340]
-	mov	x0, x21
-	ldr	w3, [x4,8]
-	sub	w1, w23, w2
-	lsl	w1, w24, w1
-	lsr	w2, w3, w2
-	sub	w1, w1, #1
-	and	w2, w1, w2
-	ldrb	w1, [x19,3338]
-	udiv	w1, w2, w1
-	ldr	w2, [x4,4]
-	uxth	w25, w1
-	mov	w1, w25
+	ldr	x2, [x19,608]
+	ldrh	w0, [x2,584]
+	cmp	w0, w1
+	bne	.L1094
+	mov	w0, -1
+	ldrh	w3, [x2,588]
+	strh	w0, [x2,584]
+	mov	w0, 65535
+	cmp	w3, w0
+	bne	.L1093
+	adrp	x0, .LC105
+	strh	w1, [x2,588]
+	add	x0, x0, :lo12:.LC105
+	b	.L1100
+.L1094:
+	ldrh	w0, [x2,586]
+	cmp	w0, w1
+	bne	.L1093
+	mov	w0, -1
+	ldrh	w3, [x2,590]
+	strh	w0, [x2,586]
+	mov	w0, 65535
+	cmp	w3, w0
+	bne	.L1093
+	adrp	x0, .LC106
+	strh	w1, [x2,590]
+	add	x0, x0, :lo12:.LC106
+.L1100:
 	bl	printk
-	mov	w1, 1
-	mov	w0, w25
-	mov	w2, 0
-	bl	gc_add_sblk
-	ldr	x0, [x19,608]
-	ldr	w1, [x0,556]
-	add	w1, w1, 1
-	str	w1, [x0,556]
-	ldrh	w1, [x0,16]
-	cmp	w1, w25
-	bne	.L1135
-	strh	wzr, [x0,22]
-	b	.L1136
-.L1135:
-	ldrh	w1, [x0,48]
-	cmp	w1, w25
-	bne	.L1136
-	strh	wzr, [x0,54]
-.L1136:
-	mov	x0, x20
-	bl	ftl_write_buf
-	b	.L1133
-.L1134:
-	ldr	w0, [x4,4]
-	ldr	w1, [x4,12]
-	ldrh	w2, [x20,48]
-	bl	lpa_hash_update_ppa
-	ldrb	w0, [x20,2]
-	tbz	x0, 2, .L1138
-	and	w0, w0, -3
-	strb	w0, [x20,2]
-	b	.L1133
-.L1138:
-	mov	x0, x20
-	bl	buf_free
-	b	.L1133
-.L1140:
+	b	.L1081
+.L1093:
+	mov	w0, w1
+	bl	zftl_insert_free_list
+.L1081:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
-	ldp	x23, x24, [sp,48]
-	ldr	x25, [sp,64]
+	ldr	x23, [sp,48]
 	ldp	x29, x30, [sp], 80
 	ret
-	.size	ftl_write_completed, .-ftl_write_completed
+	.size	ftl_free_sblk, .-ftl_free_sblk
 	.align	2
-	.global	zftl_add_read_buf
-	.type	zftl_add_read_buf, %function
-zftl_add_read_buf:
-	stp	x29, x30, [sp, -32]!
+	.global	gc_free_src_blk
+	.type	gc_free_src_blk, %function
+gc_free_src_blk:
+	stp	x29, x30, [sp, -80]!
 	add	x29, sp, 0
+	stp	x23, x24, [sp,48]
+	stp	x21, x22, [sp,32]
+	adrp	x23, .LANCHOR0
+	adrp	x21, .LANCHOR1
+	add	x23, x23, :lo12:.LANCHOR0
+	add	x21, x21, :lo12:.LANCHOR1
 	stp	x19, x20, [sp,16]
-	mov	x20, x0
-	cbnz	x0, .L1142
-	adrp	x1, .LANCHOR1
-	adrp	x0, .LC0
-	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 954
-	add	x1, x1, 1504
-	add	x0, x0, :lo12:.LC0
+	stp	x25, x26, [sp,64]
+	mov	w20, 0
+	add	x24, x23, 2896
+	add	x21, x21, 1472
+.L1103:
+	ldrh	w0, [x24,56]
+	adrp	x25, .LANCHOR0
+	cmp	w0, w20
+	bls	.L1141
+	add	x0, x24, x20, sxtw 1
+	ldrh	w22, [x0,58]
+	ldr	x0, [x23,600]
+	lsl	x26, x22, 1
+	mov	x19, x22
+	ldrh	w2, [x0,x26]
+	cbz	w2, .L1104
+	adrp	x0, .LC107
+	mov	w1, w22
+	add	x0, x0, :lo12:.LC107
 	bl	printk
-	bl	dump_stack
-	bl	print_ftl_debug_info
-	b	.L1141
-.L1142:
-	adrp	x19, .LANCHOR0
-	ldrb	w1, [x20,56]
-	add	x0, x19, :lo12:.LANCHOR0
-	ldrb	w0, [x0,2832]
-	cmp	w1, w0
-	bls	.L1145
-	adrp	x1, .LANCHOR1
+.L1104:
+	add	x0, x25, :lo12:.LANCHOR0
+	ldr	x1, [x0,600]
+	strh	wzr, [x1,x26]
+	ldr	x1, [x0,600]
+	ldrh	w1, [x1,x26]
+	cbnz	w1, .L1105
+	ldr	x0, [x0,584]
+	add	x22, x0, x22, lsl 2
+	adrp	x0, .LANCHOR2
+	ldr	w0, [x0,#:lo12:.LANCHOR2]
+	tbz	x0, 8, .L1106
+	ldrb	w2, [x22,2]
+	adrp	x0, .LC108
+	add	x0, x0, :lo12:.LC108
+	mov	w1, w19
+	ubfx	x2, x2, 5, 3
+	bl	printk
+.L1106:
+	ldrb	w0, [x22,2]
+	tst	w0, 192
+	beq	.L1119
+	and	w0, w0, 224
+	cmp	w0, 224
+	bne	.L1107
+.L1119:
 	adrp	x0, .LC0
-	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 959
-	add	x1, x1, 1504
+	mov	x1, x21
+	mov	w2, 931
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L1145:
-	add	x19, x19, :lo12:.LANCHOR0
-	mov	x1, x20
-	add	x0, x19, 3885
-	bl	buf_add_tail
-	ldrb	w0, [x19,3886]
-	add	w0, w0, 1
-	strb	w0, [x19,3886]
-.L1141:
-	ldp	x19, x20, [sp,16]
-	ldp	x29, x30, [sp], 32
-	ret
-	.size	zftl_add_read_buf, .-zftl_add_read_buf
-	.align	2
-	.global	ftl_alloc_sblk
-	.type	ftl_alloc_sblk, %function
-ftl_alloc_sblk:
-	stp	x29, x30, [sp, -64]!
-	cmp	w0, 5
-	add	x29, sp, 0
-	stp	x19, x20, [sp,16]
-	mov	w20, w0
-	str	x23, [sp,48]
-	mov	w0, 2
-	uxth	w23, w20
-	stp	x21, x22, [sp,32]
-	mov	w1, w23
-	csel	w22, wzr, w0, ne
-	mov	w0, 0
-	bl	zftl_get_free_sblk
-	uxth	w19, w0
-	mov	w0, 65535
-	cmp	w19, w0
-	beq	.L1148
-	adrp	x0, .LANCHOR0+584
-	ldr	x21, [x0,#:lo12:.LANCHOR0+584]
-	add	x21, x21, x19, uxth 2
-	ldrb	w0, [x21,2]
-	tst	w0, 224
-	beq	.L1149
+.L1107:
+	mov	w0, w19
+	add	x25, x25, :lo12:.LANCHOR0
+	bl	ftl_free_sblk
+	ldr	x2, [x25,608]
+	ldrh	w1, [x2,124]
+	cbz	w1, .L1109
+	mov	x0, 0
+.L1111:
+	add	x4, x2, x0, lsl 1
+	mov	w3, w0
+	ldrh	w4, [x4,392]
+	cmp	w4, w19
+	bne	.L1110
+	add	x0, x2, x3, sxtw 1
+	mov	w3, -1
+	strh	w3, [x0,392]
+	sub	w1, w1, #1
+	strh	w1, [x2,124]
+	b	.L1109
+.L1110:
+	add	x0, x0, 1
+	cmp	x0, 64
+	bne	.L1111
+.L1109:
+	ldrh	w1, [x2,120]
+	cbz	w1, .L1112
+	mov	x0, 0
+.L1114:
+	add	x4, x2, x0, lsl 1
+	mov	w3, w0
+	ldrh	w4, [x4,136]
+	cmp	w4, w19
+	bne	.L1113
+	add	x0, x2, x3, sxtw 1
+	mov	w3, -1
+	strh	w3, [x0,136]
+	sub	w1, w1, #1
+	strh	w1, [x2,120]
+	b	.L1112
+.L1113:
+	add	x0, x0, 1
+	cmp	x0, 64
+	bne	.L1114
+.L1112:
+	ldrh	w1, [x2,122]
+	cbz	w1, .L1115
+	mov	x0, 0
+.L1117:
+	add	x4, x2, x0, lsl 1
+	mov	w3, w0
+	ldrh	w4, [x4,264]
+	cmp	w4, w19
+	bne	.L1116
+	add	x0, x2, x3, sxtw 1
+	mov	w3, -1
+	strh	w3, [x0,264]
+	sub	w1, w1, #1
+	strh	w1, [x2,122]
+	b	.L1115
+.L1116:
+	add	x0, x0, 1
+	cmp	x0, 64
+	bne	.L1117
+	b	.L1115
+.L1105:
+	mov	w0, w19
+	mov	w1, 1
+	mov	w2, 0
+	bl	gc_add_sblk
+.L1115:
+	add	w20, w20, 1
+	uxth	w20, w20
+	b	.L1103
+.L1141:
+	strh	wzr, [x24,56]
+	ldp	x19, x20, [sp,16]
+	ldp	x21, x22, [sp,32]
+	ldp	x23, x24, [sp,48]
+	ldp	x25, x26, [sp,64]
+	ldp	x29, x30, [sp], 80
+	ret
+	.size	gc_free_src_blk, .-gc_free_src_blk
+	.align	2
+	.global	print_ftl_debug_info
+	.type	print_ftl_debug_info, %function
+print_ftl_debug_info:
+	sub	sp, sp, #64
+	stp	x29, x30, [sp,32]
+	add	x29, sp, 32
+	str	x19, [sp,48]
+	adrp	x19, .LANCHOR0
+	add	x19, x19, :lo12:.LANCHOR0
+	ldr	x2, [x19,2864]
+	ldr	x0, [x19,608]
+	ldrh	w8, [x19,2854]
+	ldrh	w1, [x2,148]
+	ldrh	w2, [x2,146]
+	str	w8, [sp]
+	ldrh	w6, [x19,2850]
+	ldr	w8, [x0,524]
+	str	w8, [sp,8]
+	ldrh	w7, [x19,2852]
+	ldr	w0, [x0,528]
+	str	w0, [sp,16]
+	ldr	w0, [x19,2840]
+	ldrh	w3, [x19,2844]
+	ldrh	w4, [x19,2846]
+	ldrh	w5, [x19,2848]
+	str	w0, [sp,24]
+	adrp	x0, .LC109
+	add	x0, x0, :lo12:.LC109
+	bl	printk
+	ldr	x5, [x19,2864]
+	adrp	x0, .LC110
+	ldrb	w3, [x19,2857]
+	add	x0, x0, :lo12:.LC110
+	ldr	w4, [x5,8]
+	ldr	w1, [x5,20]
+	ldr	w2, [x5,28]
+	ldr	w5, [x5,64]
+	bl	printk
+	ldr	x2, [x19,2864]
+	adrp	x0, .LC111
+	add	x0, x0, :lo12:.LC111
+	ldr	w3, [x2,16]
+	ldr	w1, [x2,52]
+	ldr	w2, [x2,60]
+	lsr	w3, w3, 11
+	bl	printk
+	ldr	x7, [x19,2864]
+	ldrh	w0, [x7,90]
+	ldrh	w6, [x7,72]
+	ldrh	w1, [x7,74]
+	ldrh	w3, [x7,88]
+	ldrh	w4, [x7,92]
+	ldrh	w5, [x7,96]
+	str	w0, [sp]
+	ldrh	w0, [x7,94]
+	str	w0, [sp,8]
+	ldrh	w0, [x7,98]
+	str	w0, [sp,16]
+	adrp	x0, .LC112
+	add	x0, x0, :lo12:.LC112
+	ldr	w2, [x7,84]
+	ldr	w7, [x7,80]
+	bl	printk
+	ldrh	w5, [x19,2872]
+	adrp	x0, .LC113
+	ldrh	w1, [x19,2874]
+	add	x0, x0, :lo12:.LC113
+	ldrh	w2, [x19,2876]
+	ldrh	w3, [x19,2878]
+	ldrh	w4, [x19,2880]
+	bl	printk
+	ldr	x4, [x19,608]
+	adrp	x0, .LC114
+	add	x0, x0, :lo12:.LC114
+	ldrh	w1, [x4,584]
+	ldrh	w2, [x4,586]
+	ldrh	w3, [x4,588]
+	ldrh	w4, [x4,590]
+	bl	printk
+	sub	sp, x29, #32
+	ldr	x19, [sp,48]
+	ldp	x29, x30, [sp,32]
+	add	sp, sp, 64
+	ret
+	.size	print_ftl_debug_info, .-print_ftl_debug_info
+	.align	2
+	.global	ftl_write_buf
+	.type	ftl_write_buf, %function
+ftl_write_buf:
+	stp	x29, x30, [sp, -48]!
+	add	x29, sp, 0
+	stp	x19, x20, [sp,16]
+	str	x21, [sp,32]
+	mov	x20, x0
+	cbnz	x0, .L1144
 	adrp	x1, .LANCHOR1
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 827
-	add	x1, x1, 1528
+	mov	w2, 668
+	add	x1, x1, 1488
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L1149:
-	ldrb	w1, [x21,2]
-	bfi	w1, w20, 5, 3
-	ubfx	x2, x1, 3, 2
-	orr	w0, w22, w2
-	bfi	w1, w0, 3, 2
-	strb	w1, [x21,2]
-	b	.L1155
-.L1148:
-	adrp	x21, .LC113
 	bl	print_ftl_debug_info
-	add	x21, x21, :lo12:.LC113
-	mov	w1, w19
-	mov	w2, w20
-	mov	x0, x21
-	bl	printk
-	mov	w1, w23
-	mov	w0, 0
-	bl	zftl_get_free_sblk
-	uxth	w19, w0
-	mov	w1, w19
-	mov	w2, w20
-	mov	x0, x21
-	bl	printk
-	bl	dump_all_list_info
+	mov	w0, -1
+	b	.L1153
+.L1144:
+	adrp	x19, .LANCHOR0
+	ldrb	w1, [x20,56]
+	add	x0, x19, :lo12:.LANCHOR0
+	ldrb	w0, [x0,2832]
+	cmp	w1, w0
+	bls	.L1149
 	adrp	x1, .LANCHOR1
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR1
-	mov	w2, 837
-	add	x1, x1, 1528
+	mov	w2, 673
+	add	x1, x1, 1488
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L1155:
-	mov	w0, w19
-	ldr	x23, [sp,48]
+.L1149:
+	ldrb	w0, [x20,56]
+	cbz	w0, .L1146
+	add	x21, x19, :lo12:.LANCHOR0
+	ldrb	w1, [x21,2832]
+	cmp	w1, w0
+	bcs	.L1147
+.L1146:
+	mov	x0, x20
+	add	x19, x19, :lo12:.LANCHOR0
+	bl	zbuf_free
+	ldrb	w0, [x19,2856]
+	b	.L1153
+.L1147:
+	add	x0, x21, 2888
+	mov	x1, x20
+	bl	buf_add_tail
+	ldr	x0, [x21,2864]
+	ldrb	w1, [x20,56]
+	ldrb	w2, [x21,2856]
+	ldr	w3, [x0,16]
+	add	w2, w2, 1
+	add	w1, w3, w1
+	str	w1, [x0,16]
+	ldr	w1, [x0,32]
+	uxtb	w2, w2
+	strb	w2, [x21,2856]
+	add	w1, w1, 1
+	str	w1, [x0,32]
+	mov	w0, w2
+.L1153:
 	ldp	x19, x20, [sp,16]
-	ldp	x21, x22, [sp,32]
-	ldp	x29, x30, [sp], 64
-	ret
-	.size	ftl_alloc_sblk, .-ftl_alloc_sblk
-	.align	2
-	.global	sblk_init
-	.type	sblk_init, %function
-sblk_init:
-	adrp	x0, .LANCHOR0
-	mov	w1, -1
-	add	x0, x0, :lo12:.LANCHOR0
-	strb	w1, [x0,2835]
-	strb	w1, [x0,3884]
-	strb	w1, [x0,3887]
-	strb	w1, [x0,3256]
-	mov	w0, 0
+	ldr	x21, [sp,32]
+	ldp	x29, x30, [sp], 48
 	ret
-	.size	sblk_init, .-sblk_init
+	.size	ftl_write_buf, .-ftl_write_buf
 	.align	2
-	.global	dump_sblk_queue
-	.type	dump_sblk_queue, %function
-dump_sblk_queue:
-	stp	x29, x30, [sp, -48]!
-	adrp	x0, .LC114
+	.global	ftl_write_completed
+	.type	ftl_write_completed, %function
+ftl_write_completed:
+	stp	x29, x30, [sp, -64]!
 	add	x29, sp, 0
 	stp	x19, x20, [sp,16]
-	adrp	x20, .LANCHOR0
-	str	x21, [sp,32]
-	add	x20, x20, :lo12:.LANCHOR0
-	add	x0, x0, :lo12:.LC114
-	ldrb	w1, [x20,2835]
+	adrp	x19, .LANCHOR0
+	add	x19, x19, :lo12:.LANCHOR0
+	add	x20, x19, 784
+	stp	x21, x22, [sp,32]
+	stp	x23, x24, [sp,48]
+	mov	x21, x19
+	mov	w23, 0
+	mov	x22, x20
+.L1155:
+	ldrb	w3, [x19,3906]
+	cmp	w3, 255
+	beq	.L1164
+	lsl	x0, x3, 6
+	add	x24, x20, x0
+	add	x4, x24, 32
+	ldrb	w0, [x20,x0]
+	strb	w0, [x19,3906]
+	ldr	w0, [x24,52]
+	cmn	w0, #1
+	bne	.L1156
+	ldrh	w1, [x19,3264]
+	mov	w0, 21
+	mov	w2, 1
+	sub	w0, w0, w1
+	lsl	w0, w2, w0
+	ldr	w2, [x4,8]
+	sub	w0, w0, #1
+	lsr	w1, w2, w1
+	mov	w2, 65535
+	and	w1, w0, w1
+	ldrb	w0, [x19,3266]
+	udiv	w1, w1, w0
+	ldr	x0, [x19,608]
+	ldr	w5, [x0,560]
+	cmp	w5, w2
+	uxth	w23, w1
+	and	w1, w1, w2
+	bne	.L1157
+	str	w1, [x0,560]
+	ldr	w2, [x4,8]
+	str	w2, [x0,564]
+.L1157:
+	add	x3, x22, x3, lsl 6
+	adrp	x0, .LC115
+	add	x3, x3, 32
+	add	x0, x0, :lo12:.LC115
+	ldr	w2, [x3,4]
+	ldr	w3, [x3,8]
+	bl	printk
+	ldr	x0, [x21,608]
+	ldr	w1, [x0,556]
+	add	w1, w1, 1
+	str	w1, [x0,556]
+	ldrh	w1, [x0,16]
+	cmp	w1, w23
+	bne	.L1158
+	strh	wzr, [x0,22]
+	b	.L1159
+.L1158:
+	ldrh	w1, [x0,48]
+	cmp	w1, w23
+	bne	.L1159
+	strh	wzr, [x0,54]
+.L1159:
+	mov	x0, x24
+	mov	w23, 1
+	bl	ftl_write_buf
+	b	.L1155
+.L1156:
+	cmp	w23, 1
+	bne	.L1161
+	ldr	w1, [x4,4]
+	adrp	x0, .LC116
+	ldr	w2, [x4,8]
+	add	x0, x0, :lo12:.LC116
+	bl	printk
+	mov	x0, x24
+	bl	ftl_write_buf
+	b	.L1155
+.L1161:
+	ldr	w0, [x4,4]
+	ldr	w1, [x4,12]
+	ldrh	w2, [x24,48]
+	bl	lpa_hash_update_ppa
+	ldrb	w0, [x24,2]
+	and	w23, w0, 4
+	uxtb	w23, w23
+	cbz	w23, .L1162
+	and	w0, w0, -3
+	mov	w23, 0
+	strb	w0, [x24,2]
+	b	.L1155
+.L1162:
+	mov	x0, x24
+	bl	zbuf_free
+	b	.L1155
+.L1164:
+	ldp	x19, x20, [sp,16]
+	ldp	x21, x22, [sp,32]
+	ldp	x23, x24, [sp,48]
+	ldp	x29, x30, [sp], 64
+	ret
+	.size	ftl_write_completed, .-ftl_write_completed
+	.align	2
+	.global	zftl_add_read_buf
+	.type	zftl_add_read_buf, %function
+zftl_add_read_buf:
+	stp	x29, x30, [sp, -32]!
+	add	x29, sp, 0
+	stp	x19, x20, [sp,16]
+	mov	x20, x0
+	cbnz	x0, .L1166
+	adrp	x1, .LANCHOR1
+	adrp	x0, .LC0
+	add	x1, x1, :lo12:.LANCHOR1
+	mov	w2, 964
+	add	x1, x1, 1504
+	add	x0, x0, :lo12:.LC0
+	bl	printk
+	bl	dump_stack
+	bl	print_ftl_debug_info
+	b	.L1165
+.L1166:
+	adrp	x19, .LANCHOR0
+	ldrb	w1, [x20,56]
+	add	x0, x19, :lo12:.LANCHOR0
+	ldrb	w0, [x0,2832]
+	cmp	w1, w0
+	bls	.L1169
+	adrp	x1, .LANCHOR1
+	adrp	x0, .LC0
+	add	x1, x1, :lo12:.LANCHOR1
+	mov	w2, 969
+	add	x1, x1, 1504
+	add	x0, x0, :lo12:.LC0
+	bl	printk
+	bl	dump_stack
+.L1169:
+	add	x19, x19, :lo12:.LANCHOR0
+	mov	x1, x20
+	add	x0, x19, 3907
+	bl	buf_add_tail
+	ldrb	w0, [x19,3908]
+	add	w0, w0, 1
+	strb	w0, [x19,3908]
+.L1165:
+	ldp	x19, x20, [sp,16]
+	ldp	x29, x30, [sp], 32
+	ret
+	.size	zftl_add_read_buf, .-zftl_add_read_buf
+	.align	2
+	.global	ftl_alloc_sblk
+	.type	ftl_alloc_sblk, %function
+ftl_alloc_sblk:
+	stp	x29, x30, [sp, -64]!
+	cmp	w0, 5
+	add	x29, sp, 0
+	stp	x19, x20, [sp,16]
+	mov	w20, w0
+	str	x23, [sp,48]
+	mov	w0, 2
+	uxth	w23, w20
+	stp	x21, x22, [sp,32]
+	mov	w1, w23
+	csel	w22, wzr, w0, ne
+	mov	w0, 0
+	bl	zftl_get_free_sblk
+	uxth	w19, w0
+	mov	w0, 65535
+	cmp	w19, w0
+	beq	.L1172
+	adrp	x0, .LANCHOR0+584
+	ldr	x21, [x0,#:lo12:.LANCHOR0+584]
+	add	x21, x21, x19, uxth 2
+	ldrb	w0, [x21,2]
+	tst	w0, 224
+	beq	.L1173
+	adrp	x1, .LANCHOR1
+	adrp	x0, .LC0
+	add	x1, x1, :lo12:.LANCHOR1
+	mov	w2, 833
+	add	x1, x1, 1528
+	add	x0, x0, :lo12:.LC0
+	bl	printk
+	bl	dump_stack
+.L1173:
+	ldrb	w1, [x21,2]
+	bfi	w1, w20, 5, 3
+	ubfx	x2, x1, 3, 2
+	orr	w0, w22, w2
+	bfi	w1, w0, 3, 2
+	strb	w1, [x21,2]
+	b	.L1179
+.L1172:
+	adrp	x21, .LC117
+	bl	print_ftl_debug_info
+	add	x21, x21, :lo12:.LC117
+	mov	w1, w19
+	mov	w2, w20
+	mov	x0, x21
+	bl	printk
+	mov	w1, w23
+	mov	w0, 0
+	bl	zftl_get_free_sblk
+	uxth	w19, w0
+	mov	w1, w19
+	mov	w2, w20
+	mov	x0, x21
+	bl	printk
+	bl	dump_all_list_info
+	adrp	x1, .LANCHOR1
+	adrp	x0, .LC0
+	add	x1, x1, :lo12:.LANCHOR1
+	mov	w2, 843
+	add	x1, x1, 1528
+	add	x0, x0, :lo12:.LC0
+	bl	printk
+	bl	dump_stack
+.L1179:
+	mov	w0, w19
+	ldr	x23, [sp,48]
+	ldp	x19, x20, [sp,16]
+	ldp	x21, x22, [sp,32]
+	ldp	x29, x30, [sp], 64
+	ret
+	.size	ftl_alloc_sblk, .-ftl_alloc_sblk
+	.align	2
+	.global	sblk_init
+	.type	sblk_init, %function
+sblk_init:
+	adrp	x0, .LANCHOR0
+	mov	w1, -1
+	add	x0, x0, :lo12:.LANCHOR0
+	strb	w1, [x0,2835]
+	strb	w1, [x0,3906]
+	strb	w1, [x0,3909]
+	strb	w1, [x0,3280]
+	mov	w0, 0
+	ret
+	.size	sblk_init, .-sblk_init
+	.align	2
+	.global	dump_sblk_queue
+	.type	dump_sblk_queue, %function
+dump_sblk_queue:
+	stp	x29, x30, [sp, -48]!
+	adrp	x0, .LC118
+	add	x29, sp, 0
+	stp	x19, x20, [sp,16]
+	adrp	x20, .LANCHOR0
+	str	x21, [sp,32]
+	add	x20, x20, :lo12:.LANCHOR0
+	add	x0, x0, :lo12:.LC118
+	ldrb	w1, [x20,2835]
 	bl	printk
 	ldrb	w19, [x20,2835]
 	cmp	w19, 255
-	beq	.L1157
+	beq	.L1181
 	add	x20, x20, 784
 	sbfiz	x19, x19, 6, 32
-	adrp	x21, .LC115
+	adrp	x21, .LC119
 	add	x19, x20, x19
-	add	x21, x21, :lo12:.LC115
-.L1159:
+	add	x21, x21, :lo12:.LC119
+.L1183:
 	ldrb	w1, [x19,1]
 	mov	x0, x21
 	ldrb	w2, [x19,58]
@@ -7338,11 +7532,11 @@ dump_sblk_queue:
 	bl	printk
 	ldrb	w19, [x19]
 	cmp	w19, 255
-	beq	.L1157
+	beq	.L1181
 	sbfiz	x19, x19, 6, 32
 	add	x19, x20, x19
-	b	.L1159
-.L1157:
+	b	.L1183
+.L1181:
 	ldp	x19, x20, [sp,16]
 	ldr	x21, [sp,32]
 	ldp	x29, x30, [sp], 48
@@ -7358,10 +7552,10 @@ queue_lun_state:
 	mov	w0, 0
 	ldrb	w2, [x3,2835]
 	cmp	w2, 255
-	beq	.L1167
-	ldrh	w8, [x3,3340]
+	beq	.L1191
+	ldrh	w8, [x3,3264]
 	mov	w4, 21
-	ldrb	w7, [x3,3338]
+	ldrb	w7, [x3,3266]
 	mov	w0, 1
 	sub	w4, w4, w8
 	ubfx	x9, x5, 21, 3
@@ -7370,60 +7564,60 @@ queue_lun_state:
 	sub	w4, w4, #1
 	asr	w5, w5, w8
 	uxth	w7, w7
-	adrp	x10, .L1170
+	adrp	x10, .L1194
 	uxth	w4, w4
 	and	w5, w5, w7
 	and	w5, w5, w4
 	add	x3, x3, 784
-	add	x10, x10, :lo12:.L1170
-.L1173:
+	add	x10, x10, :lo12:.L1194
+.L1197:
 	add	x0, x3, x2, lsl 6
 	ldr	w6, [x0,40]
 	ubfx	x11, x6, 21, 3
 	cmp	w11, w9
-	bne	.L1168
+	bne	.L1192
 	lsr	w6, w6, w8
 	ldrb	w0, [x0,58]
 	and	w6, w7, w6
 	and	w6, w4, w6
 	cmp	w6, w5
-	bne	.L1169
+	bne	.L1193
 	cmp	w1, 1
-	beq	.L1171
-	b	.L1167
-.L1169:
+	beq	.L1195
+	b	.L1191
+.L1193:
 	cmp	w1, 3
-	bhi	.L1168
+	bhi	.L1192
 	ldrb	w6, [x10,w1,uxtw]
-	adr	x11, .Lrtx1170
+	adr	x11, .Lrtx1194
 	add	x6, x11, w6, sxtb #2
 	br	x6
-.Lrtx1170:
+.Lrtx1194:
 	.section	.rodata
 	.align	0
 	.align	2
-.L1170:
-	.byte	(.L1167 - .Lrtx1170) / 4
-	.byte	(.L1171 - .Lrtx1170) / 4
-	.byte	(.L1172 - .Lrtx1170) / 4
-	.byte	(.L1167 - .Lrtx1170) / 4
+.L1194:
+	.byte	(.L1191 - .Lrtx1194) / 4
+	.byte	(.L1195 - .Lrtx1194) / 4
+	.byte	(.L1196 - .Lrtx1194) / 4
+	.byte	(.L1191 - .Lrtx1194) / 4
 	.text
-.L1171:
+.L1195:
 	sub	w6, w0, #7
 	and	w6, w6, -3
 	uxtb	w6, w6
-	cbz	w6, .L1168
-	b	.L1167
-.L1172:
+	cbz	w6, .L1192
+	b	.L1191
+.L1196:
 	cmp	w0, 11
-	bne	.L1167
-.L1168:
+	bne	.L1191
+.L1192:
 	lsl	x2, x2, 6
 	ldrb	w2, [x3,x2]
 	cmp	w2, 255
-	bne	.L1173
+	bne	.L1197
 	mov	w0, 0
-.L1167:
+.L1191:
 	ret
 	.size	queue_lun_state, .-queue_lun_state
 	.align	2
@@ -7435,15 +7629,15 @@ queue_remove_completed_req:
 	add	x0, x3, :lo12:.LANCHOR0
 	mov	w11, -1
 	add	x4, x0, 784
-	add	x12, x0, 3887
-	add	x13, x0, 3884
+	add	x12, x0, 3909
+	add	x13, x0, 3906
 	ldrb	w7, [x0,2835]
-	ldrb	w9, [x0,3887]
-	ldrb	w8, [x0,3256]
-	ldrb	w10, [x0,3884]
-.L1183:
+	ldrb	w9, [x0,3909]
+	ldrb	w8, [x0,3280]
+	ldrb	w10, [x0,3906]
+.L1207:
 	cmp	w7, 255
-	beq	.L1184
+	beq	.L1208
 	sbfiz	x6, x7, 6, 32
 	sxtw	x1, w7
 	add	x2, x4, x6
@@ -7451,64 +7645,64 @@ queue_remove_completed_req:
 	sub	w2, w2, #12
 	uxtb	w2, w2
 	cmp	w2, 1
-	bls	.L1185
-	cbz	w5, .L1182
+	bls	.L1209
+	cbz	w5, .L1206
 	strb	w7, [x0,2835]
-	b	.L1182
-.L1185:
+	b	.L1206
+.L1209:
 	lsl	x5, x1, 6
 	ldrb	w7, [x4,x6]
 	add	x2, x4, x5
 	strb	w11, [x4,x5]
 	ldrb	w5, [x2,59]
 	cmp	w5, 1
-	bne	.L1188
+	bne	.L1212
 	ldrh	w2, [x2,50]
-	cbnz	w2, .L1196
+	cbnz	w2, .L1220
 	mov	w2, w10
 	mov	x5, x13
-	b	.L1189
-.L1188:
-	cbz	w5, .L1206
-.L1190:
+	b	.L1213
+.L1212:
+	cbz	w5, .L1230
+.L1214:
 	mov	w5, 1
-	b	.L1183
-.L1206:
+	b	.L1207
+.L1230:
 	ldr	w2, [x2,36]
 	cmn	w2, #1
-	beq	.L1190
+	beq	.L1214
 	mov	w2, w9
 	mov	x5, x12
-	b	.L1189
-.L1196:
+	b	.L1213
+.L1220:
 	mov	w2, w8
-	add	x5, x0, 3256
-.L1189:
+	add	x5, x0, 3280
+.L1213:
 	cmp	w2, 255
-	bne	.L1194
+	bne	.L1218
 	add	x3, x3, :lo12:.LANCHOR0
 	add	x1, x3, x1, lsl 6
 	strb	w7, [x3,2835]
 	ldrb	w0, [x1,785]
 	strb	w0, [x5]
-	b	.L1182
-.L1194:
+	b	.L1206
+.L1218:
 	mov	w5, w2
 	sbfiz	x2, x2, 6, 32
 	ldrb	w2, [x4,x2]
 	cmp	w2, 255
-	bne	.L1194
+	bne	.L1218
 	add	x1, x4, x1, lsl 6
 	sbfiz	x5, x5, 6, 32
 	ldrb	w1, [x1,1]
 	strb	w1, [x4,x5]
-	b	.L1190
-.L1184:
-	cbz	w5, .L1182
+	b	.L1214
+.L1208:
+	cbz	w5, .L1206
 	add	x3, x3, :lo12:.LANCHOR0
 	mov	w0, -1
 	strb	w0, [x3,2835]
-.L1182:
+.L1206:
 	ret
 	.size	queue_remove_completed_req, .-queue_remove_completed_req
 	.align	2
@@ -7526,19 +7720,19 @@ pm_alloc_new_blk:
 	ldrh	w1, [x2,690]
 	add	w1, w1, 1
 	uxth	w0, w1
-	ldrb	w1, [x3,3276]
+	ldrb	w1, [x3,3300]
 	strh	w0, [x2,690]
 	cmp	w1, w0
-	bls	.L1208
+	bls	.L1232
 	add	x0, x2, x0, sxtw 1
 	ldrh	w1, [x0,672]
 	mov	w0, 65535
 	cmp	w1, w0
-	bne	.L1209
-.L1208:
-	adrp	x22, .LC116
-	add	x22, x22, :lo12:.LC116
-.L1221:
+	bne	.L1233
+.L1232:
+	adrp	x22, .LC120
+	add	x22, x22, :lo12:.LC120
+.L1245:
 	mov	w0, 1
 	add	x20, x19, :lo12:.LANCHOR0
 	bl	ftl_alloc_sblk
@@ -7550,7 +7744,7 @@ pm_alloc_new_blk:
 	add	x1, x1, 672
 	bl	ftl_get_blk_list_in_sblk
 	uxth	w0, w0
-	cbnz	w0, .L1210
+	cbnz	w0, .L1234
 	mov	w1, w21
 	mov	x0, x22
 	bl	printk
@@ -7559,23 +7753,23 @@ pm_alloc_new_blk:
 	ldrb	w2, [x1,2]
 	orr	w2, w2, -32
 	strb	w2, [x1,2]
-	b	.L1221
-.L1210:
+	b	.L1245
+.L1234:
 	ldr	x1, [x20,2864]
 	mov	w0, 1
 	mov	w2, 65535
-	str	w0, [x20,3888]
+	str	w0, [x20,3912]
 	mov	x20, 0
 	strh	wzr, [x1,690]
-.L1212:
+.L1236:
 	add	x3, x1, x20, lsl 1
 	uxth	w0, w20
 	ldrh	w3, [x3,416]
 	cmp	w3, w2
-	beq	.L1211
+	beq	.L1235
 	add	x20, x20, 1
 	cmp	x20, 128
-	bne	.L1212
+	bne	.L1236
 	adrp	x0, .LC0
 	adrp	x1, .LANCHOR3
 	add	x1, x1, :lo12:.LANCHOR3
@@ -7584,7 +7778,7 @@ pm_alloc_new_blk:
 	bl	printk
 	bl	dump_stack
 	mov	w0, w20
-.L1211:
+.L1235:
 	add	x1, x19, :lo12:.LANCHOR0
 	ldr	x1, [x1,2864]
 	add	x0, x1, x0, sxtw 1
@@ -7592,7 +7786,7 @@ pm_alloc_new_blk:
 	ldrh	w0, [x1,688]
 	add	w0, w0, 1
 	strh	w0, [x1,688]
-.L1209:
+.L1233:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldr	x1, [x0,2864]
 	ldrh	w0, [x1,690]
@@ -7601,7 +7795,7 @@ pm_alloc_new_blk:
 	mov	w0, 65533
 	sub	w1, w20, #1
 	cmp	w0, w1, uxth
-	bcs	.L1214
+	bcs	.L1238
 	adrp	x0, .LC0
 	adrp	x1, .LANCHOR3
 	add	x1, x1, :lo12:.LANCHOR3
@@ -7609,11 +7803,11 @@ pm_alloc_new_blk:
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L1214:
+.L1238:
 	add	x19, x19, :lo12:.LANCHOR0
 	mov	w0, 21
 	ldr	x1, [x19,2864]
-	ldrh	w2, [x19,3340]
+	ldrh	w2, [x19,3264]
 	sub	w0, w0, w2
 	strh	wzr, [x1,696]
 	asr	w4, w20, w0
@@ -7621,17 +7815,17 @@ pm_alloc_new_blk:
 	strh	w4, [x1,694]
 	adrp	x1, .LANCHOR2
 	ldr	w1, [x1,#:lo12:.LANCHOR2]
-	tbz	x1, 12, .L1218
+	tbz	x1, 12, .L1242
 	mov	w2, 1
 	mov	w1, w20
 	lsl	w2, w2, w0
-	adrp	x0, .LC117
-	add	x0, x0, :lo12:.LC117
+	adrp	x0, .LC121
+	add	x0, x0, :lo12:.LC121
 	sub	w2, w2, #1
 	mov	w3, w20
 	uxth	w4, w4
 	bl	printk
-.L1218:
+.L1242:
 	mov	w0, 0
 	ldr	x23, [sp,48]
 	ldp	x19, x20, [sp,16]
@@ -7650,58 +7844,58 @@ pm_select_ram_region:
 	str	x19, [sp,16]
 	add	x2, x2, :lo12:.LANCHOR0
 	mov	x19, 0
-.L1225:
-	add	x1, x2, 3896
+.L1249:
+	add	x1, x2, 3920
 	lsl	x4, x19, 4
 	uxth	w0, w19
 	ldrh	w4, [x4,x1]
 	cmp	w4, w3
-	beq	.L1224
+	beq	.L1248
 	add	x19, x19, 1
 	cmp	x19, 32
-	bne	.L1225
+	bne	.L1249
 	mov	x0, 0
 	mov	w3, 32768
-.L1227:
+.L1251:
 	add	x2, x1, x0, lsl 4
 	uxth	w4, w0
 	ldrh	w2, [x2,2]
-	tbnz	x2, 15, .L1226
+	tbnz	x2, 15, .L1250
 	cmp	w2, w3
-	bcs	.L1226
+	bcs	.L1250
 	mov	w3, w2
 	mov	w19, w4
-.L1226:
+.L1250:
 	add	x0, x0, 1
 	cmp	x0, 32
-	bne	.L1227
+	bne	.L1251
 	cmp	w19, 32
 	mov	w0, w19
-	bne	.L1224
-	adrp	x0, .LANCHOR4+56
+	bne	.L1248
+	adrp	x0, .LANCHOR4+80
 	mov	w2, -1
 	mov	w1, 0
-	ldrb	w3, [x0,#:lo12:.LANCHOR4+56]
+	ldrb	w3, [x0,#:lo12:.LANCHOR4+80]
 	adrp	x0, .LANCHOR0
 	add	x0, x0, :lo12:.LANCHOR0
-	add	x0, x0, 3896
-.L1229:
+	add	x0, x0, 3920
+.L1253:
 	ldrh	w5, [x0,2]
 	cmp	w5, w2
-	bcs	.L1228
+	bcs	.L1252
 	ldrh	w4, [x0]
 	cmp	w4, w3
 	csel	w2, w2, w5, eq
 	cmp	w4, w3
 	csel	w19, w19, w1, eq
-.L1228:
+.L1252:
 	add	w1, w1, 1
 	add	x0, x0, 16
 	uxth	w1, w1
 	cmp	w1, 32
-	bne	.L1229
+	bne	.L1253
 	cmp	w19, 32
-	bne	.L1230
+	bne	.L1254
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
@@ -7710,9 +7904,9 @@ pm_select_ram_region:
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L1230:
+.L1254:
 	mov	w0, w19
-.L1224:
+.L1248:
 	ldr	x19, [sp,16]
 	ldp	x29, x30, [sp], 32
 	ret
@@ -7736,57 +7930,57 @@ flash_lsb_page_tbl_build:
 	add	x29, sp, 0
 	stp	x19, x20, [sp,16]
 	adrp	x19, .LANCHOR0
-	cbnz	w0, .L1238
+	cbnz	w0, .L1262
 	mov	x0, 0
 	add	x2, x19, :lo12:.LANCHOR0
-.L1239:
+.L1263:
 	add	x1, x2, 4
 	strh	w0, [x1,x0,lsl 1]
 	add	x0, x0, 1
 	cmp	x0, 256
-	bne	.L1239
-.L1245:
+	bne	.L1263
+.L1269:
 	adrp	x20, .LANCHOR4
 	mov	w1, 255
 	add	x20, x20, :lo12:.LANCHOR4
 	mov	w2, 1024
-	add	x0, x20, 60
+	add	x0, x20, 84
 	add	x19, x19, :lo12:.LANCHOR0
 	bl	ftl_memset
 	mov	x0, 0
-	b	.L1240
-.L1238:
+	b	.L1264
+.L1262:
 	cmp	w0, 1
-	bne	.L1241
+	bne	.L1265
 	mov	x0, 0
 	mov	w4, 3
 	mov	w5, 2
 	add	x3, x19, :lo12:.LANCHOR0
-.L1244:
+.L1268:
 	cmp	x0, 3
 	uxth	w2, w0
 	mov	w1, w2
-	bls	.L1242
+	bls	.L1266
 	ubfiz	w1, w2, 1, 15
 	and	w2, w2, 1
 	cmp	w2, wzr
 	csel	w2, w4, w5, ne
 	sub	w1, w1, w2
 	uxth	w1, w1
-.L1242:
+.L1266:
 	add	x2, x3, 4
 	strh	w1, [x2,x0,lsl 1]
 	add	x0, x0, 1
 	cmp	x0, 256
-	bne	.L1244
-	b	.L1245
-.L1241:
+	bne	.L1268
+	b	.L1269
+.L1265:
 	cmp	w0, 2
-	bne	.L1246
+	bne	.L1270
 	mov	w1, 65535
 	mov	x0, 0
 	add	x4, x19, :lo12:.LANCHOR0
-.L1248:
+.L1272:
 	add	x3, x4, 4
 	cmp	x0, 1
 	uxth	w2, w0
@@ -7796,36 +7990,36 @@ flash_lsb_page_tbl_build:
 	add	x0, x0, 1
 	cmp	x0, 256
 	uxth	w1, w1
-	bne	.L1248
-	b	.L1245
-.L1246:
+	bne	.L1272
+	b	.L1269
+.L1270:
 	cmp	w0, 3
-	bne	.L1249
+	bne	.L1273
 	mov	x0, 0
 	mov	w4, 5
 	mov	w5, 4
 	add	x3, x19, :lo12:.LANCHOR0
-.L1252:
+.L1276:
 	cmp	x0, 5
 	uxth	w2, w0
 	mov	w1, w2
-	bls	.L1250
+	bls	.L1274
 	ubfiz	w1, w2, 1, 15
 	and	w2, w2, 1
 	cmp	w2, wzr
 	csel	w2, w4, w5, ne
 	sub	w1, w1, w2
 	uxth	w1, w1
-.L1250:
+.L1274:
 	add	x2, x3, 4
 	strh	w1, [x2,x0,lsl 1]
 	add	x0, x0, 1
 	cmp	x0, 256
-	bne	.L1252
-	b	.L1245
-.L1249:
+	bne	.L1276
+	b	.L1269
+.L1273:
 	cmp	w0, 4
-	bne	.L1253
+	bne	.L1277
 	add	x2, x19, :lo12:.LANCHOR0
 	mov	w5, 7
 	add	x1, x2, 4
@@ -7845,7 +8039,7 @@ flash_lsb_page_tbl_build:
 	strh	w0, [x1,14]
 	mov	w0, 8
 	strh	w2, [x1,6]
-.L1255:
+.L1279:
 	and	w3, w0, 1
 	ubfiz	w2, w0, 1, 15
 	add	w0, w0, 1
@@ -7856,43 +8050,43 @@ flash_lsb_page_tbl_build:
 	sub	w2, w2, w3
 	cmp	w0, 256
 	strh	w2, [x1,14]
-	bne	.L1255
-	b	.L1245
-.L1253:
+	bne	.L1279
+	b	.L1269
+.L1277:
 	cmp	w0, 5
-	bne	.L1256
+	bne	.L1280
 	mov	x0, 0
 	add	x2, x19, :lo12:.LANCHOR0
-.L1257:
+.L1281:
 	add	x1, x2, 4
 	strh	w0, [x1,x0,lsl 1]
 	add	x0, x0, 1
 	cmp	x0, 16
-	bne	.L1257
+	bne	.L1281
 	mov	x0, 0
-.L1258:
+.L1282:
 	add	x2, x1, x0
 	add	w3, w0, 16
 	add	x0, x0, 2
 	cmp	x0, 480
 	strh	w3, [x2,32]
-	bne	.L1258
-	b	.L1245
-.L1256:
+	bne	.L1282
+	b	.L1269
+.L1280:
 	cmp	w0, 8
-	bne	.L1259
+	bne	.L1283
 	mov	x0, 0
 	add	x2, x19, :lo12:.LANCHOR0
-.L1260:
+.L1284:
 	add	x1, x2, 4
 	strh	w0, [x0,x1]
 	add	x0, x0, 2
 	cmp	x0, 512
-	bne	.L1260
-	b	.L1245
-.L1259:
+	bne	.L1284
+	b	.L1269
+.L1283:
 	cmp	w0, 9
-	bne	.L1245
+	bne	.L1269
 	add	x0, x19, :lo12:.LANCHOR0
 	add	x1, x0, 4
 	strh	wzr, [x0,4]
@@ -7901,22 +8095,22 @@ flash_lsb_page_tbl_build:
 	mov	w0, 2
 	strh	w0, [x1,4]
 	mov	x0, 0
-.L1261:
+.L1285:
 	add	x2, x1, x0
 	add	w3, w0, 3
 	add	x0, x0, 2
 	cmp	x0, 506
 	strh	w3, [x2,6]
-	bne	.L1261
-	b	.L1245
-.L1240:
+	bne	.L1285
+	b	.L1269
+.L1264:
 	add	x1, x19, 4
-	add	x2, x20, 60
+	add	x2, x20, 84
 	ldrh	w1, [x0,x1]
 	add	x0, x0, 2
 	cmp	x0, 512
 	strh	w1, [x2,w1,sxtw 1]
-	bne	.L1240
+	bne	.L1264
 	ldp	x19, x20, [sp,16]
 	ldp	x29, x30, [sp], 32
 	ret
@@ -7934,14 +8128,14 @@ flash_die_info_init:
 	ldr	w0, [x19,#:lo12:.LANCHOR2]
 	stp	x25, x26, [sp,64]
 	stp	x27, x28, [sp,80]
-	tbz	x0, 12, .L1279
+	tbz	x0, 12, .L1303
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC4
 	add	x1, x1, :lo12:.LANCHOR3
 	add	x0, x0, :lo12:.LC4
 	add	x1, x1, 48
 	bl	printk
-.L1279:
+.L1303:
 	add	x24, x19, :lo12:.LANCHOR2
 	adrp	x21, .LANCHOR0
 	add	x20, x21, :lo12:.LANCHOR0
@@ -7959,23 +8153,23 @@ flash_die_info_init:
 	strb	wzr, [x20,633]
 	sdiv	w0, w0, w1
 	mov	w1, 0
-	strh	w0, [x25,1084]
+	strh	w0, [x25,1108]
 	add	x0, x20, 736
 	bl	ftl_memset
-	add	x0, x25, 1088
+	add	x0, x25, 1112
 	mov	w1, 0
 	mov	w2, 32
 	bl	ftl_memset
-.L1281:
+.L1305:
 	add	x0, x20, 744
 	ldrb	w2, [x24,8]
 	add	x1, x28, x23, lsl 3
 	strb	w26, [x23,x0]
 	mov	x0, x27
 	bl	flash_mem_cmp8
-	cbnz	w0, .L1280
+	cbnz	w0, .L1304
 	ldrb	w1, [x20,633]
-	add	x2, x25, 1088
+	add	x2, x25, 1112
 	str	w0, [x2,w1,sxtw 2]
 	add	w0, w1, 1
 	strb	w0, [x20,633]
@@ -7983,16 +8177,16 @@ flash_die_info_init:
 	add	x1, x20, x1, sxtw
 	strb	w0, [x1,736]
 	bl	zftl_flash_enter_slc_mode
-.L1280:
+.L1304:
 	add	x23, x23, 1
 	cmp	x23, 4
-	bne	.L1281
+	bne	.L1305
 	add	x0, x19, :lo12:.LANCHOR2
 	add	x1, x0, 8
 	ldrb	w2, [x1,8]
 	cmp	w2, 2
-	beq	.L1282
-.L1286:
+	beq	.L1306
+.L1310:
 	add	x19, x19, :lo12:.LANCHOR2
 	add	x21, x21, :lo12:.LANCHOR0
 	add	x22, x22, :lo12:.LANCHOR4
@@ -8005,11 +8199,11 @@ flash_die_info_init:
 	ldrh	w1, [x19,22]
 	ldp	x19, x20, [sp,16]
 	mul	w0, w0, w1
-	strh	w0, [x22,1120]
+	strh	w0, [x22,1144]
 	ldp	x21, x22, [sp,32]
 	ldp	x29, x30, [sp], 112
 	ret
-.L1282:
+.L1306:
 	add	x23, x21, :lo12:.LANCHOR0
 	ldrh	w20, [x1,14]
 	ldrb	w26, [x0,8]
@@ -8024,7 +8218,7 @@ flash_die_info_init:
 	ldrb	w2, [x1,13]
 	mul	w20, w20, w2
 	lsl	w28, w20, 1
-.L1285:
+.L1309:
 	add	x1, x3, x24, lsl 3
 	mov	x0, x25
 	mov	w2, w26
@@ -8033,9 +8227,9 @@ flash_die_info_init:
 	bl	flash_mem_cmp8
 	ldr	x3, [x29,104]
 	ldr	x4, [x29,96]
-	cbnz	w0, .L1283
+	cbnz	w0, .L1307
 	ldrb	w0, [x23,633]
-	add	x1, x4, 1088
+	add	x1, x4, 1112
 	cmp	w27, wzr
 	csel	w2, w20, w28, eq
 	str	w2, [x1,w0,sxtw 2]
@@ -8043,11 +8237,11 @@ flash_die_info_init:
 	add	x0, x23, x0, sxtw
 	strb	w1, [x23,633]
 	strb	w24, [x0,736]
-.L1283:
+.L1307:
 	add	x24, x24, 1
 	cmp	x24, 4
-	bne	.L1285
-	b	.L1286
+	bne	.L1309
+	b	.L1310
 	.size	flash_die_info_init, .-flash_die_info_init
 	.align	2
 	.global	lpa_hash_init
@@ -8060,13 +8254,13 @@ lpa_hash_init:
 	str	x19, [sp,16]
 	adrp	x19, .LANCHOR0
 	add	x19, x19, :lo12:.LANCHOR0
-	add	x0, x19, 3352
+	add	x0, x19, 3368
 	bl	ftl_memset
-	ldrh	w0, [x19,3300]
+	ldrh	w0, [x19,3324]
 	mov	w1, 255
-	ldrb	w2, [x19,3276]
+	ldrb	w2, [x19,3300]
 	mul	w2, w0, w2
-	ldr	x0, [x19,3872]
+	ldr	x0, [x19,3888]
 	lsl	w2, w2, 2
 	bl	ftl_memset
 	ldr	x19, [sp,16]
@@ -8082,52 +8276,52 @@ lpa_rebuild_hash:
 	add	x29, sp, 0
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
 	str	x19, [sp,16]
-	tbz	x0, 12, .L1297
+	tbz	x0, 12, .L1321
 	adrp	x1, .LANCHOR3
-	adrp	x0, .LC118
+	adrp	x0, .LC122
 	add	x1, x1, :lo12:.LANCHOR3
-	add	x0, x0, :lo12:.LC118
+	add	x0, x0, :lo12:.LC122
 	add	x1, x1, 72
 	mov	w2, 224
 	mov	w3, 0
 	bl	printk
-.L1297:
+.L1321:
 	adrp	x19, .LANCHOR0
 	mov	w1, 255
 	add	x19, x19, :lo12:.LANCHOR0
 	mov	w2, 512
-	add	x0, x19, 3352
+	add	x0, x19, 3368
 	bl	ftl_memset
-	ldrh	w0, [x19,3300]
+	ldrh	w0, [x19,3324]
 	mov	w1, 255
-	ldrb	w2, [x19,3276]
+	ldrb	w2, [x19,3300]
 	mul	w2, w0, w2
-	ldr	x0, [x19,3872]
+	ldr	x0, [x19,3888]
 	lsl	w2, w2, 2
 	bl	ftl_memset
 	mov	w0, 0
-.L1298:
-	ldrh	w1, [x19,3300]
-	ldrb	w2, [x19,3276]
+.L1322:
+	ldrh	w1, [x19,3324]
+	ldrb	w2, [x19,3300]
 	mul	w1, w1, w2
 	cmp	w0, w1, lsl 1
-	bge	.L1307
+	bge	.L1331
 	uxtw	x2, w0
-	ldr	x1, [x19,3864]
+	ldr	x1, [x19,3880]
 	ldr	w1, [x1,x2,lsl 2]
 	cmn	w1, #1
-	beq	.L1299
+	beq	.L1323
 	uxtb	w1, w1
-	add	x3, x19, 3352
+	add	x3, x19, 3368
 	ldrh	w4, [x3,w1,sxtw 1]
 	strh	w0, [x3,w1,sxtw 1]
-	ldr	x1, [x19,3872]
+	ldr	x1, [x19,3888]
 	strh	w4, [x1,x2,lsl 1]
-.L1299:
+.L1323:
 	add	w0, w0, 1
 	uxth	w0, w0
-	b	.L1298
-.L1307:
+	b	.L1322
+.L1331:
 	ldr	x19, [sp,16]
 	ldp	x29, x30, [sp], 32
 	ret
@@ -8166,9 +8360,9 @@ zftl_read_flash_info:
 	strb	w1, [x19,9]
 	mov	x1, 0
 	strb	w2, [x19,8]
-.L1309:
+.L1333:
 	cmp	w4, w1, uxtb
-	bls	.L1311
+	bls	.L1335
 	add	x2, x0, 736
 	ldrb	w3, [x19,10]
 	ldrb	w2, [x1,x2]
@@ -8176,8 +8370,8 @@ zftl_read_flash_info:
 	lsl	w2, w5, w2
 	orr	w2, w2, w3
 	strb	w2, [x19,10]
-	b	.L1309
-.L1311:
+	b	.L1333
+.L1335:
 	ldr	x19, [sp,16]
 	ldp	x29, x30, [sp], 32
 	ret
@@ -8188,7 +8382,7 @@ zftl_read_flash_info:
 gc_init:
 	stp	x29, x30, [sp, -48]!
 	mov	w1, 0
-	mov	w2, 328
+	mov	w2, 344
 	add	x29, sp, 0
 	stp	x19, x20, [sp,16]
 	adrp	x19, .LANCHOR0
@@ -8198,20 +8392,20 @@ gc_init:
 	str	x21, [sp,32]
 	add	x21, x19, 2896
 	mov	x0, x21
-	strb	wzr, [x19,3273]
-	strb	wzr, [x20,1122]
-	str	wzr, [x20,1124]
-	strh	wzr, [x19,3304]
+	strb	wzr, [x19,3297]
+	strb	wzr, [x20,1146]
+	str	wzr, [x20,1148]
+	strh	wzr, [x19,3328]
 	bl	ftl_memset
-	ldrh	w1, [x19,3300]
+	ldrh	w1, [x19,3324]
 	mov	w0, -1
-	ldrb	w3, [x19,3276]
+	ldrb	w3, [x19,3300]
 	strh	w0, [x19,2896]
 	lsr	w0, w1, 2
 	lsr	w2, w1, 1
 	strh	w0, [x19,2932]
 	strh	w0, [x19,2878]
-	ldrh	w0, [x19,3274]
+	ldrh	w0, [x19,3298]
 	strh	w2, [x19,2934]
 	mul	w2, w1, w3
 	mul	w0, w0, w3
@@ -8221,36 +8415,36 @@ gc_init:
 	sub	w4, w2, #32
 	strh	w2, [x19,2874]
 	strh	w4, [x19,2876]
-	strh	wzr, [x19,3302]
-	strh	wzr, [x19,3296]
-	strh	wzr, [x19,3298]
+	strh	wzr, [x19,3326]
+	strh	wzr, [x19,3320]
+	strh	wzr, [x19,3322]
 	str	xzr, [x19,2904]
 	bl	ftl_malloc
-	ldrb	w1, [x19,3276]
-	str	x0, [x20,1128]
-	ldrh	w0, [x19,3274]
+	ldrb	w1, [x19,3300]
+	str	x0, [x20,1152]
+	ldrh	w0, [x19,3298]
 	mul	w0, w0, w1
 	lsl	w0, w0, 2
 	bl	ftl_malloc
-	str	x0, [x20,1136]
-	ldrh	w1, [x19,3274]
-	ldrb	w0, [x19,3276]
+	str	x0, [x20,1160]
+	ldrh	w1, [x19,3298]
+	ldrb	w0, [x19,3300]
 	mul	w0, w1, w0
 	bl	ftl_malloc
-	str	x0, [x19,3264]
-	ldrb	w1, [x19,3276]
-	ldrh	w0, [x19,3274]
+	str	x0, [x19,3288]
+	ldrb	w1, [x19,3300]
+	ldrh	w0, [x19,3298]
 	mul	w0, w0, w1
 	lsl	w0, w0, 2
 	bl	ftl_malloc
-	str	x0, [x19,3248]
-	ldrb	w1, [x19,3276]
-	ldrh	w0, [x19,3274]
+	str	x0, [x19,3272]
+	ldrb	w1, [x19,3300]
+	ldrh	w0, [x19,3298]
 	mul	w0, w0, w1
 	lsl	w0, w0, 2
 	bl	ftl_malloc
-	str	x0, [x20,1144]
-	ldrh	w0, [x19,3306]
+	str	x0, [x20,1168]
+	ldrh	w0, [x19,3330]
 	ldr	x21, [sp,32]
 	lsr	w0, w0, 2
 	strh	w0, [x19,2872]
@@ -8275,9 +8469,9 @@ gc_static_wearleveling:
 	ldr	w1, [x0,32]
 	mov	w0, 10240
 	cmp	w1, w0
-	bls	.L1314
+	bls	.L1338
 	bl	ftl_tmp_into_update
-.L1314:
+.L1338:
 	add	x3, x19, :lo12:.LANCHOR0
 	ldr	x0, [x3,608]
 	ldr	w1, [x0,568]
@@ -8285,18 +8479,18 @@ gc_static_wearleveling:
 	add	w1, w1, 860160
 	add	w1, w1, 3840
 	cmp	w2, w1
-	bhi	.L1315
+	bhi	.L1339
 	ldr	x3, [x3,2864]
 	ldr	w1, [x0,572]
 	ldr	w3, [x3,36]
 	add	w1, w1, 32
 	cmp	w3, w1
-	bls	.L1365
-.L1315:
+	bls	.L1389
+.L1339:
 	add	x1, x19, :lo12:.LANCHOR0
 	mov	w22, 0
 	mov	w20, 65535
-	adrp	x8, .LC119
+	adrp	x8, .LC123
 	mov	w28, w22
 	str	w22, [x29,136]
 	ldr	x1, [x1,2864]
@@ -8311,13 +8505,13 @@ gc_static_wearleveling:
 	mov	w9, w20
 	str	w2, [x0,568]
 	adrp	x10, .LANCHOR2
-	add	x8, x8, :lo12:.LC119
+	add	x8, x8, :lo12:.LC123
 	ldrh	w23, [x1,134]
-.L1317:
+.L1341:
 	add	x4, x19, :lo12:.LANCHOR0
 	ldrh	w0, [x4,576]
 	cmp	w0, w23
-	bls	.L1426
+	bls	.L1450
 	uxtw	x7, w23
 	ldr	x0, [x4,584]
 	lsl	x1, x7, 2
@@ -8325,70 +8519,70 @@ gc_static_wearleveling:
 	ldrb	w2, [x6,2]
 	and	w3, w2, 224
 	cmp	w3, 224
-	beq	.L1318
-	tbz	x2, 3, .L1319
+	beq	.L1342
+	tbz	x2, 3, .L1343
 	ldrh	w3, [x0,x1]
 	ldr	w2, [x0,x1]
 	and	w3, w3, 2047
 	ubfx	x2, x2, 11, 8
-	b	.L1320
-.L1319:
+	b	.L1344
+.L1343:
 	tst	w2, 24
-	bne	.L1321
+	bne	.L1345
 	ldrh	w3, [x0,x1]
 	mov	w2, 65535
 	and	w3, w3, 2047
-	b	.L1320
-.L1321:
+	b	.L1344
+.L1345:
 	ldr	w2, [x0,x1]
 	mov	w3, 65535
 	ubfx	x2, x2, 11, 8
-	b	.L1322
-.L1320:
+	b	.L1346
+.L1344:
 	ldr	w4, [x29,136]
 	add	w26, w26, 1
 	cmp	w20, w3
 	add	w4, w4, w3
 	str	w4, [x29,136]
 	uxth	w26, w26
-	bls	.L1364
+	bls	.L1388
 	add	x4, x19, :lo12:.LANCHOR0
 	mov	w20, w3
 	ldr	x4, [x4,608]
 	strh	w23, [x4,586]
-.L1364:
+.L1388:
 	cmp	w25, w3
-	bcs	.L1323
+	bcs	.L1347
 	mov	w22, w23
 	mov	w25, w3
-.L1323:
+.L1347:
 	cmp	w2, w9
-	beq	.L1324
-.L1322:
+	beq	.L1348
+.L1346:
 	ldr	w4, [x29,140]
 	add	w27, w27, 1
 	cmp	w21, w2
 	add	w4, w4, w2
 	str	w4, [x29,140]
 	uxth	w27, w27
-	bls	.L1325
+	bls	.L1349
 	add	x4, x19, :lo12:.LANCHOR0
 	mov	w21, w2
 	ldr	x4, [x4,608]
 	strh	w23, [x4,584]
-.L1325:
+.L1349:
 	cmp	w24, w2
-	bcs	.L1324
+	bcs	.L1348
 	mov	w28, w23
 	mov	w24, w2
-.L1324:
+.L1348:
 	cmp	w3, 9
-	bls	.L1367
+	bls	.L1391
 	cmp	w2, 9
-	bhi	.L1318
-.L1367:
+	bhi	.L1342
+.L1391:
 	ldr	w2, [x10,#:lo12:.LANCHOR2]
-	tbz	x2, 8, .L1318
+	tbz	x2, 8, .L1342
 	ldrh	w2, [x0,x1]
 	ldr	w3, [x0,x1]
 	add	x0, x19, :lo12:.LANCHOR0
@@ -8409,11 +8603,11 @@ gc_static_wearleveling:
 	ldr	x10, [x29,112]
 	ldr	x9, [x29,120]
 	ldr	x8, [x29,128]
-.L1318:
+.L1342:
 	add	w23, w23, 1
 	uxth	w23, w23
-	b	.L1317
-.L1426:
+	b	.L1341
+.L1450:
 	ldr	x0, [x4,608]
 	mov	w1, 255
 	mov	w2, 128
@@ -8430,29 +8624,29 @@ gc_static_wearleveling:
 	lsl	x0, x7, 2
 	mov	x1, x7
 	add	x8, x3, x0
-	tbz	x2, 10, .L1328
+	tbz	x2, 10, .L1352
 	ldr	x9, [x4,600]
 	ldrh	w2, [x3,x0]
 	ldrb	w5, [x8,2]
 	ldr	w3, [x3,x0]
-	adrp	x0, .LC120
+	adrp	x0, .LC124
 	ldrb	w6, [x8,3]
 	ubfx	x4, x5, 3, 2
 	ldrh	w7, [x9,x7,lsl 1]
-	add	x0, x0, :lo12:.LC120
+	add	x0, x0, :lo12:.LC124
 	and	w2, w2, 2047
 	ubfx	x3, x3, 11, 8
 	ubfx	x5, x5, 5, 3
 	str	x8, [x29,128]
 	bl	printk
 	ldr	x8, [x29,128]
-.L1328:
+.L1352:
 	ldrb	w0, [x8,2]
-	tbz	x0, 3, .L1329
+	tbz	x0, 3, .L1353
 	ldrb	w0, [x8,2]
 	and	w1, w0, 192
 	cmp	w1, 64
-	bne	.L1330
+	bne	.L1354
 	add	x3, x19, :lo12:.LANCHOR0
 	mov	w1, 0
 	mov	w2, 1
@@ -8463,21 +8657,21 @@ gc_static_wearleveling:
 	ldr	x3, [x29,128]
 	mov	w0, 1
 	strh	w0, [x3,3214]
-	b	.L1329
-.L1330:
+	b	.L1353
+.L1354:
 	tst	w0, 224
-	bne	.L1329
+	bne	.L1353
 	add	x2, x19, :lo12:.LANCHOR0
 	mov	w0, 65535
 	ldr	x1, [x2,608]
 	ldrh	w3, [x1,590]
 	cmp	w3, w0
-	bne	.L1329
+	bne	.L1353
 	ldrh	w0, [x1,586]
 	ldrh	w1, [x1,588]
 	str	x2, [x29,128]
 	cmp	w1, w0
-	beq	.L1329
+	beq	.L1353
 	bl	zftl_remove_free_node
 	ldr	x2, [x29,128]
 	ldr	x0, [x2,608]
@@ -8485,7 +8679,7 @@ gc_static_wearleveling:
 	strh	w1, [x0,590]
 	mov	w1, -1
 	strh	w1, [x0,586]
-.L1329:
+.L1353:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldr	w2, [x23,#:lo12:.LANCHOR2]
 	ldr	x1, [x0,608]
@@ -8494,11 +8688,11 @@ gc_static_wearleveling:
 	lsl	x3, x7, 2
 	mov	x1, x7
 	add	x8, x4, x3
-	tbz	x2, 10, .L1331
+	tbz	x2, 10, .L1355
 	ldr	x9, [x0,600]
-	adrp	x0, .LC121
+	adrp	x0, .LC125
 	ldrh	w2, [x4,x3]
-	add	x0, x0, :lo12:.LC121
+	add	x0, x0, :lo12:.LC125
 	ldrb	w5, [x8,2]
 	ldr	w3, [x4,x3]
 	and	w2, w2, 2047
@@ -8510,13 +8704,13 @@ gc_static_wearleveling:
 	str	x8, [x29,128]
 	bl	printk
 	ldr	x8, [x29,128]
-.L1331:
+.L1355:
 	ldrb	w0, [x8,2]
-	tbz	x0, 3, .L1332
+	tbz	x0, 3, .L1356
 	ldrb	w0, [x8,2]
 	and	w1, w0, 192
 	cmp	w1, 64
-	bne	.L1333
+	bne	.L1357
 	add	x3, x19, :lo12:.LANCHOR0
 	mov	w1, 0
 	mov	w2, 1
@@ -8527,21 +8721,21 @@ gc_static_wearleveling:
 	ldr	x3, [x29,128]
 	mov	w0, 1
 	strh	w0, [x3,3214]
-	b	.L1332
-.L1333:
+	b	.L1356
+.L1357:
 	tst	w0, 224
-	bne	.L1332
+	bne	.L1356
 	add	x2, x19, :lo12:.LANCHOR0
 	mov	w0, 65535
 	ldr	x1, [x2,608]
 	ldrh	w3, [x1,588]
 	cmp	w3, w0
-	bne	.L1332
+	bne	.L1356
 	ldrh	w0, [x1,584]
 	ldrh	w1, [x1,590]
 	str	x2, [x29,128]
 	cmp	w1, w0
-	beq	.L1332
+	beq	.L1356
 	bl	zftl_remove_free_node
 	ldr	x2, [x29,128]
 	ldr	x0, [x2,608]
@@ -8549,11 +8743,11 @@ gc_static_wearleveling:
 	strh	w1, [x0,588]
 	mov	w1, -1
 	strh	w1, [x0,584]
-.L1332:
+.L1356:
 	add	x4, x19, :lo12:.LANCHOR0
 	ldr	w0, [x23,#:lo12:.LANCHOR2]
 	ldr	x1, [x4,584]
-	tbz	x0, 10, .L1334
+	tbz	x0, 10, .L1358
 	uxtw	x7, w22
 	ldr	x8, [x4,600]
 	lsl	x0, x7, 2
@@ -8561,9 +8755,9 @@ gc_static_wearleveling:
 	ldrh	w7, [x8,x7,lsl 1]
 	ldrh	w2, [x1,x0]
 	ldr	w3, [x1,x0]
-	adrp	x0, .LC122
+	adrp	x0, .LC126
 	ldrb	w5, [x6,2]
-	add	x0, x0, :lo12:.LC122
+	add	x0, x0, :lo12:.LC126
 	ldrb	w6, [x6,3]
 	mov	w1, w22
 	ubfx	x4, x5, 3, 2
@@ -8571,11 +8765,11 @@ gc_static_wearleveling:
 	ubfx	x3, x3, 11, 8
 	ubfx	x5, x5, 5, 3
 	bl	printk
-.L1334:
+.L1358:
 	add	x4, x19, :lo12:.LANCHOR0
 	ldr	w0, [x23,#:lo12:.LANCHOR2]
 	ldr	x1, [x4,584]
-	tbz	x0, 10, .L1335
+	tbz	x0, 10, .L1359
 	uxtw	x7, w28
 	ldr	x8, [x4,600]
 	lsl	x0, x7, 2
@@ -8583,9 +8777,9 @@ gc_static_wearleveling:
 	ldrh	w7, [x8,x7,lsl 1]
 	ldrh	w2, [x1,x0]
 	ldr	w3, [x1,x0]
-	adrp	x0, .LC123
+	adrp	x0, .LC127
 	ldrb	w5, [x6,2]
-	add	x0, x0, :lo12:.LC123
+	add	x0, x0, :lo12:.LC127
 	ldrb	w6, [x6,3]
 	mov	w1, w28
 	ubfx	x4, x5, 3, 2
@@ -8593,7 +8787,7 @@ gc_static_wearleveling:
 	ubfx	x3, x3, 11, 8
 	ubfx	x5, x5, 5, 3
 	bl	printk
-.L1335:
+.L1359:
 	ldr	w1, [x29,136]
 	add	x0, x19, :lo12:.LANCHOR0
 	udiv	w3, w1, w26
@@ -8607,41 +8801,41 @@ gc_static_wearleveling:
 	strh	w3, [x0,88]
 	strh	w4, [x0,90]
 	ldr	w0, [x23,#:lo12:.LANCHOR2]
-	tbz	x0, 10, .L1336
-	adrp	x0, .LC124
+	tbz	x0, 10, .L1360
+	adrp	x0, .LC128
 	mov	w1, w26
-	add	x0, x0, :lo12:.LC124
+	add	x0, x0, :lo12:.LC128
 	mov	w2, w27
 	uxth	w3, w3
 	uxth	w4, w4
 	bl	printk
-.L1336:
+.L1360:
 	ldr	w0, [x23,#:lo12:.LANCHOR2]
 	adrp	x28, .LANCHOR4
-	tbz	x0, 10, .L1337
+	tbz	x0, 10, .L1361
 	add	x6, x28, :lo12:.LANCHOR4
-	adrp	x0, .LC125
-	add	x0, x0, :lo12:.LC125
+	adrp	x0, .LC129
+	add	x0, x0, :lo12:.LC129
 	mov	w1, w20
 	mov	w2, w21
 	mov	w3, w25
-	ldrh	w5, [x6,1152]
+	ldrh	w5, [x6,1176]
 	mov	w4, w24
-	ldrh	w6, [x6,1154]
+	ldrh	w6, [x6,1178]
 	bl	printk
-.L1337:
+.L1361:
 	add	x1, x28, :lo12:.LANCHOR4
 	sub	w0, w24, w21
 	str	w0, [x29,140]
-	ldrh	w0, [x1,1154]
+	ldrh	w0, [x1,1178]
 	ldr	w2, [x29,140]
 	cmp	w2, w0
-	bgt	.L1338
-	ldrh	w1, [x1,1152]
+	bgt	.L1362
+	ldrh	w1, [x1,1176]
 	sub	w0, w25, w20
 	cmp	w0, w1
-	ble	.L1366
-.L1338:
+	ble	.L1390
+.L1362:
 	add	x0, x19, :lo12:.LANCHOR0
 	mov	w26, 0
 	mov	w22, w26
@@ -8651,17 +8845,17 @@ gc_static_wearleveling:
 	ldrh	w27, [x0,134]
 	sub	w0, w25, w20
 	str	w0, [x29,136]
-	adrp	x0, .LC127
-	add	x0, x0, :lo12:.LC127
-	adrp	x25, .LC126
+	adrp	x0, .LC131
+	add	x0, x0, :lo12:.LC131
+	adrp	x25, .LC130
 	str	x0, [x29,128]
-	add	x0, x25, :lo12:.LC126
+	add	x0, x25, :lo12:.LC130
 	str	x0, [x29,120]
-.L1340:
+.L1364:
 	add	x1, x19, :lo12:.LANCHOR0
 	ldrh	w0, [x1,576]
 	cmp	w27, w0
-	bcs	.L1349
+	bcs	.L1373
 	add	w7, w24, 1
 	ldr	x4, [x1,584]
 	uxth	w24, w7
@@ -8673,31 +8867,31 @@ gc_static_wearleveling:
 	ldrb	w0, [x0,2]
 	and	w2, w0, 224
 	cmp	w2, 224
-	beq	.L1342
+	beq	.L1366
 	tst	w0, 192
-	beq	.L1342
+	beq	.L1366
 	ubfx	x0, x0, 3, 2
 	cmp	w2, 160
 	and	w1, w0, 1
-	tbnz	x0, 0, .L1424
+	tbnz	x0, 0, .L1448
 	cmp	w0, 2
-.L1424:
+.L1448:
 	add	x0, x28, :lo12:.LANCHOR4
-	bne	.L1345
-	ldrh	w0, [x0,1154]
+	bne	.L1369
+	ldrh	w0, [x0,1178]
 	ldr	w2, [x29,140]
 	cmp	w2, w0
-	ble	.L1346
+	ble	.L1370
 	ldr	w0, [x4,x3]
 	ubfx	x0, x0, 11, 8
 	cmp	w0, w21
-	bls	.L1347
-	cbz	w1, .L1346
+	bls	.L1371
+	cbz	w1, .L1370
 	ldrh	w0, [x4,x3]
 	and	w0, w0, 2047
 	cmp	w0, w20
-	bgt	.L1346
-.L1347:
+	bgt	.L1370
+.L1371:
 	mov	w1, 0
 	mov	w0, w24
 	mov	w2, 1
@@ -8712,7 +8906,7 @@ gc_static_wearleveling:
 	ldr	x4, [x29,104]
 	strh	w1, [x0,3214]
 	ldr	w1, [x23,#:lo12:.LANCHOR2]
-	tbz	x1, 10, .L1346
+	tbz	x1, 10, .L1370
 	ldr	x1, [x0,584]
 	ldr	x10, [x0,600]
 	add	x1, x1, x3
@@ -8720,24 +8914,24 @@ gc_static_wearleveling:
 	ldr	w6, [x4,x3]
 	ldr	x0, [x29,120]
 	ldrb	w2, [x1,2]
-	b	.L1425
-.L1345:
-	ldrh	w0, [x0,1152]
+	b	.L1449
+.L1369:
+	ldrh	w0, [x0,1176]
 	ldr	w2, [x29,136]
 	cmp	w2, w0
-	ble	.L1346
+	ble	.L1370
 	ldrh	w0, [x4,x3]
 	add	w2, w20, 8
 	and	w0, w0, 2047
 	cmp	w0, w2
-	ble	.L1348
-	cbz	w1, .L1346
+	ble	.L1372
+	cbz	w1, .L1370
 	ldr	w0, [x4,x3]
 	add	w1, w21, 4
 	ubfx	x0, x0, 11, 8
 	cmp	w0, w1
-	bgt	.L1346
-.L1348:
+	bgt	.L1370
+.L1372:
 	mov	w1, 0
 	mov	w0, w24
 	mov	w2, 1
@@ -8752,7 +8946,7 @@ gc_static_wearleveling:
 	ldr	x4, [x29,104]
 	strh	w1, [x0,3214]
 	ldr	w1, [x23,#:lo12:.LANCHOR2]
-	tbz	x1, 10, .L1346
+	tbz	x1, 10, .L1370
 	ldr	x1, [x0,584]
 	ldr	x10, [x0,600]
 	add	x1, x1, x3
@@ -8760,7 +8954,7 @@ gc_static_wearleveling:
 	ldr	w6, [x4,x3]
 	ldr	x0, [x29,128]
 	ldrb	w2, [x1,2]
-.L1425:
+.L1449:
 	ldrh	w3, [x10,x25,lsl 1]
 	mov	w1, w24
 	ldrh	w4, [x9,56]
@@ -8768,122 +8962,122 @@ gc_static_wearleveling:
 	and	w5, w5, 2047
 	ubfx	x6, x6, 11, 8
 	bl	printk
-.L1346:
+.L1370:
 	cmp	w26, 4
-	bhi	.L1349
+	bhi	.L1373
 	cmp	w22, 4
-	bhi	.L1349
-.L1342:
+	bhi	.L1373
+.L1366:
 	add	w27, w27, 1
 	uxth	w27, w27
-	b	.L1340
-.L1349:
+	b	.L1364
+.L1373:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldr	x0, [x0,608]
 	str	w24, [x0,580]
-	b	.L1339
-.L1366:
+	b	.L1363
+.L1390:
 	mov	w26, 0
 	mov	w22, w26
-.L1339:
-	cbz	w21, .L1352
+.L1363:
+	cbz	w21, .L1376
 	add	x0, x19, :lo12:.LANCHOR0
 	ldr	x0, [x0,2864]
 	ldrh	w0, [x0,134]
-.L1353:
+.L1377:
 	add	x1, x19, :lo12:.LANCHOR0
 	ldrh	w2, [x1,576]
 	cmp	w2, w0
-	bls	.L1427
+	bls	.L1451
 	ubfiz	x3, x0, 2, 16
 	ldr	x4, [x1,584]
 	add	x5, x4, x3
 	ldr	w1, [x4,x3]
 	ubfx	x2, x1, 11, 8
 	cmp	w2, w21
-	bcc	.L1354
+	bcc	.L1378
 	ldrb	w5, [x5,2]
 	tst	w5, 24
-	beq	.L1354
+	beq	.L1378
 	sub	w2, w2, w21
 	bfi	w1, w2, 11, 8
 	str	w1, [x4,x3]
-.L1354:
+.L1378:
 	add	w0, w0, 1
 	uxth	w0, w0
-	b	.L1353
-.L1427:
+	b	.L1377
+.L1451:
 	ldr	x0, [x1,2864]
 	ldrh	w1, [x0,72]
 	add	w1, w21, w1
 	strh	w1, [x0,72]
 	ldrh	w1, [x0,98]
 	cmp	w1, w21
-	bls	.L1352
+	bls	.L1376
 	sub	w21, w1, w21
 	strh	w21, [x0,98]
-.L1352:
-	cbz	w20, .L1358
+.L1376:
+	cbz	w20, .L1382
 	add	x0, x19, :lo12:.LANCHOR0
 	ldr	x0, [x0,2864]
 	ldrh	w0, [x0,134]
-.L1359:
+.L1383:
 	add	x1, x19, :lo12:.LANCHOR0
 	ldrh	w2, [x1,576]
 	cmp	w2, w0
-	bls	.L1428
+	bls	.L1452
 	ubfiz	x3, x0, 2, 16
 	ldr	x4, [x1,584]
 	add	x5, x4, x3
 	ldrh	w1, [x4,x3]
 	and	w2, w1, 2047
 	cmp	w2, w20
-	blt	.L1360
+	blt	.L1384
 	ldrb	w5, [x5,2]
 	and	w5, w5, 24
 	cmp	w5, 16
-	beq	.L1360
+	beq	.L1384
 	sub	w2, w2, w20
 	bfi	w1, w2, 0, 11
 	strh	w1, [x4,x3]
-.L1360:
+.L1384:
 	add	w0, w0, 1
 	uxth	w0, w0
-	b	.L1359
-.L1428:
+	b	.L1383
+.L1452:
 	ldr	x0, [x1,2864]
 	ldrh	w1, [x0,74]
 	add	w1, w20, w1
 	strh	w1, [x0,74]
 	ldrh	w1, [x0,96]
 	cmp	w1, w20
-	bls	.L1358
+	bls	.L1382
 	sub	w20, w1, w20
 	strh	w20, [x0,96]
-.L1358:
+.L1382:
 	mov	w1, 5
 	mov	w0, 0
 	bl	zftl_get_gc_node
 	uxth	w1, w0
 	mov	w2, 65535
 	cmp	w1, w2
-	beq	.L1316
+	beq	.L1340
 	add	x19, x19, :lo12:.LANCHOR0
 	ubfiz	x1, x1, 1, 16
 	ldr	x2, [x19,600]
 	ldrh	w2, [x2,x1]
-	ldrh	w1, [x19,3300]
+	ldrh	w1, [x19,3324]
 	cmp	w2, w1
-	bhi	.L1316
+	bhi	.L1340
 	mov	w1, 0
 	mov	w2, 1
 	add	w22, w22, 1
 	bl	gc_add_sblk
-	b	.L1316
-.L1365:
+	b	.L1340
+.L1389:
 	mov	w26, 0
 	mov	w22, w26
-.L1316:
+.L1340:
 	add	w0, w26, w22
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
@@ -8910,24 +9104,24 @@ zftl_sblk_list_init:
 	mov	w24, 6
 	mov	w23, 32768
 	ldrh	w2, [x19,576]
-	adrp	x26, .LC128
+	adrp	x26, .LC132
 	ldr	x0, [x19,528]
 	mov	w25, -1
-	add	x26, x26, :lo12:.LC128
+	add	x26, x26, :lo12:.LC132
 	mul	w2, w2, w24
 	bl	ftl_memset
-	ldrh	w22, [x19,3274]
+	ldrh	w22, [x19,3298]
 	mov	w0, 16
-	strh	w0, [x19,3336]
-	ldrb	w0, [x19,3276]
-	str	xzr, [x19,3312]
-	str	xzr, [x19,3320]
+	strh	w0, [x19,3360]
+	ldrb	w0, [x19,3300]
+	str	xzr, [x19,3336]
+	str	xzr, [x19,3344]
 	mul	w22, w0, w22
-	str	xzr, [x19,3328]
-	str	xzr, [x19,3288]
+	str	xzr, [x19,3352]
+	str	xzr, [x19,3312]
 	sdiv	w22, w23, w22
 	str	xzr, [x19,616]
-	str	xzr, [x19,3280]
+	str	xzr, [x19,3304]
 	strh	wzr, [x19,2844]
 	strh	wzr, [x19,2846]
 	strh	wzr, [x19,2848]
@@ -8939,52 +9133,52 @@ zftl_sblk_list_init:
 	ldr	x0, [x19,2864]
 	ldrsh	w19, [x0,134]
 	strh	wzr, [x0,146]
-.L1430:
+.L1454:
 	add	x0, x21, :lo12:.LANCHOR0
 	ldrh	w1, [x0,576]
 	cmp	w19, w1
-	bge	.L1460
+	bge	.L1484
 	sxtw	x22, w19
 	ldr	x27, [x0,584]
 	ldr	w1, [x29,108]
 	add	x27, x27, x22, lsl 2
 	ldrb	w2, [x27,3]
-	cbz	w2, .L1431
-	ldrb	w5, [x0,3276]
-	ldrh	w6, [x0,3274]
+	cbz	w2, .L1455
+	ldrb	w5, [x0,3300]
+	ldrh	w6, [x0,3298]
 	ldr	x4, [x0,2864]
 	mov	w0, 0
 	mov	w1, w0
-.L1432:
+.L1456:
 	cmp	w0, w5
-	bge	.L1461
+	bge	.L1485
 	ldrb	w2, [x27,3]
 	asr	w2, w2, w0
-	tbnz	x2, 0, .L1433
+	tbnz	x2, 0, .L1457
 	add	w1, w6, w1
 	sxth	w1, w1
-	b	.L1434
-.L1433:
+	b	.L1458
+.L1457:
 	ldrh	w2, [x4,146]
 	add	w2, w2, 1
 	strh	w2, [x4,146]
-.L1434:
+.L1458:
 	add	w0, w0, 1
-	b	.L1432
-.L1461:
-	cbz	w1, .L1436
+	b	.L1456
+.L1485:
+	cbz	w1, .L1460
 	sdiv	w1, w23, w1
 	add	w1, w1, 1
 	sxth	w1, w1
-	b	.L1431
-.L1436:
+	b	.L1455
+.L1460:
 	ldrb	w0, [x27,2]
 	orr	w0, w0, -32
 	strb	w0, [x27,2]
 	add	x0, x21, :lo12:.LANCHOR0
 	ldr	x0, [x0,600]
 	strh	w25, [x0,x22,lsl 1]
-.L1431:
+.L1455:
 	add	x20, x21, :lo12:.LANCHOR0
 	smull	x0, w19, w24
 	ldr	x2, [x20,528]
@@ -8997,101 +9191,101 @@ zftl_sblk_list_init:
 	ldrb	w1, [x27,2]
 	and	w0, w1, 224
 	cmp	w0, 224
-	beq	.L1439
+	beq	.L1463
 	cmp	w0, 32
 	cset	w28, eq
-	cbnz	w28, .L1439
+	cbnz	w28, .L1463
 	ldr	x2, [x20,608]
 	ldrh	w4, [x2,16]
 	cmp	w19, w4
-	beq	.L1439
+	beq	.L1463
 	ldrh	w4, [x2,48]
 	cmp	w19, w4
-	beq	.L1439
+	beq	.L1463
 	ldrh	w2, [x2,80]
 	cmp	w19, w2
-	beq	.L1439
+	beq	.L1463
 	cmp	w0, 64
-	bne	.L1441
+	bne	.L1465
 	uxth	w27, w19
 	add	x0, x20, 616
 	mov	w1, w27
 	add	x2, x20, 2850
-	b	.L1458
-.L1441:
+	b	.L1482
+.L1465:
 	cmp	w0, 96
-	bne	.L1442
+	bne	.L1466
 	uxth	w27, w19
-	add	x0, x20, 3288
+	add	x0, x20, 3312
 	mov	w1, w27
 	add	x2, x20, 2852
-	b	.L1458
-.L1442:
+	b	.L1482
+.L1466:
 	cmp	w0, 160
-	bne	.L1443
+	bne	.L1467
 	uxth	w27, w19
-	add	x0, x20, 3280
+	add	x0, x20, 3304
 	mov	w1, w27
 	add	x2, x20, 2854
-.L1458:
+.L1482:
 	bl	_insert_data_list
 	ldr	x0, [x20,600]
 	ldrh	w0, [x0,x22,lsl 1]
 	cmp	w0, 7
-	bhi	.L1439
+	bhi	.L1463
 	mov	w0, w27
 	mov	w1, 1
 	mov	w2, w28
-	b	.L1456
-.L1443:
-	cbnz	w0, .L1439
+	b	.L1480
+.L1467:
+	cbnz	w0, .L1463
 	ldr	x0, [x20,600]
 	ldrh	w2, [x0,x22,lsl 1]
-	cbz	w2, .L1444
+	cbz	w2, .L1468
 	mov	x0, x26
 	mov	w1, w19
 	bl	printk
 	ldrb	w0, [x27,2]
-	tbz	x0, 4, .L1445
+	tbz	x0, 4, .L1469
 	mov	w1, 5
-	b	.L1452
-.L1445:
+	b	.L1476
+.L1469:
 	mov	w1, 2
-.L1452:
+.L1476:
 	bfi	w0, w1, 5, 3
 	mov	w2, 0
 	strb	w0, [x27,2]
 	mov	w1, 1
 	mov	w0, w19
-.L1456:
+.L1480:
 	bl	gc_add_sblk
-	b	.L1439
-.L1444:
+	b	.L1463
+.L1468:
 	ands	w1, w1, 24
 	add	x2, x21, :lo12:.LANCHOR0
-	bne	.L1447
-	add	x0, x2, 3312
+	bne	.L1471
+	add	x0, x2, 3336
 	mov	w1, w19
 	add	x2, x2, 2844
-	b	.L1454
-.L1447:
+	b	.L1478
+.L1471:
 	cmp	w1, 16
-	bne	.L1448
-	add	x0, x2, 3320
+	bne	.L1472
+	add	x0, x2, 3344
 	mov	w1, w19
 	add	x2, x2, 2846
-	b	.L1454
-.L1448:
-	add	x0, x2, 3328
+	b	.L1478
+.L1472:
+	add	x0, x2, 3352
 	mov	w1, w19
 	add	x2, x2, 2848
-.L1454:
+.L1478:
 	bl	_insert_free_list
-.L1439:
+.L1463:
 	add	w19, w19, 1
 	sxth	w19, w19
-	b	.L1430
-.L1460:
+	b	.L1454
+.L1484:
 	ldr	x1, [x0,2864]
 	ldrh	w2, [x0,2844]
 	strh	w2, [x1,114]
@@ -9121,7 +9315,7 @@ ftl_open_sblk_init:
 	add	x29, sp, 0
 	stp	x19, x20, [sp,16]
 	stp	x23, x24, [sp,48]
-	adrp	x20, .LC116
+	adrp	x20, .LC120
 	adrp	x23, .LANCHOR0
 	stp	x25, x26, [sp,64]
 	stp	x21, x22, [sp,32]
@@ -9130,10 +9324,10 @@ ftl_open_sblk_init:
 	mov	w21, w1
 	add	x25, x0, 16
 	mov	x26, x23
-	add	x20, x20, :lo12:.LC116
+	add	x20, x20, :lo12:.LC120
 	mov	w24, -1
-.L1463:
-.L1466:
+.L1487:
+.L1490:
 	mov	w0, w21
 	bl	ftl_alloc_sblk
 	uxth	w22, w0
@@ -9149,22 +9343,22 @@ ftl_open_sblk_init:
 	cmp	w21, 2
 	strh	wzr, [x19,2]
 	mov	w3, 0
-	ldrh	w1, [x0,3300]
+	ldrh	w1, [x0,3324]
 	strb	wzr, [x19,5]
 	strh	wzr, [x19,10]
 	mul	w2, w1, w2
 	strh	w2, [x19,6]
 	strb	w21, [x19,4]
-	beq	.L1464
-	ldrb	w3, [x0,3276]
+	beq	.L1488
+	ldrb	w3, [x0,3300]
 	mul	w3, w1, w3
 	uxth	w3, w3
-.L1464:
+.L1488:
 	add	x27, x26, :lo12:.LANCHOR0
 	strh	w3, [x19,12]
 	ubfiz	x28, x22, 1, 16
-	ldrb	w2, [x27,3276]
-	ldr	x0, [x27,3864]
+	ldrb	w2, [x27,3300]
+	ldr	x0, [x27,3880]
 	add	x0, x0, x3, uxth 2
 	mul	w2, w1, w2
 	mov	w1, 255
@@ -9174,7 +9368,7 @@ ftl_open_sblk_init:
 	ldrh	w1, [x19,6]
 	strh	w1, [x0,x28]
 	ldrb	w0, [x19,9]
-	cbnz	w0, .L1462
+	cbnz	w0, .L1486
 	mov	x0, x20
 	mov	w1, w22
 	bl	printk
@@ -9182,8 +9376,8 @@ ftl_open_sblk_init:
 	strh	w24, [x0,x28]
 	mov	w0, 7
 	strb	w0, [x19,4]
-	b	.L1466
-.L1462:
+	b	.L1490
+.L1486:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -9205,9 +9399,9 @@ pm_free_sblk:
 	stp	x21, x22, [sp,32]
 	stp	x25, x26, [sp,64]
 	stp	x27, x28, [sp,80]
-	ldrh	w0, [x0,1156]
+	ldrh	w0, [x0,1180]
 	cmp	w0, 128
-	bls	.L1469
+	bls	.L1493
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
@@ -9216,7 +9410,7 @@ pm_free_sblk:
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L1469:
+.L1493:
 	add	x28, x29, 112
 	mov	w1, 0
 	mov	w2, 256
@@ -9227,18 +9421,18 @@ pm_free_sblk:
 	mov	w0, 21
 	mov	w1, 1
 	mov	x3, 0
-	ldrh	w6, [x2,3340]
+	ldrh	w6, [x2,3264]
 	ldr	x4, [x2,2864]
 	sub	w0, w0, w6
-	ldrb	w8, [x2,3338]
+	ldrb	w8, [x2,3266]
 	lsl	w0, w1, w0
 	add	x1, x23, :lo12:.LANCHOR4
 	ldrh	w7, [x4,698]
 	sub	w0, w0, #1
-	ldrh	w9, [x1,1156]
-.L1470:
+	ldrh	w9, [x1,1180]
+.L1494:
 	cmp	w7, w3, uxth
-	bls	.L1495
+	bls	.L1519
 	add	x1, x4, x3, lsl 2
 	mov	x2, 0
 	ldr	w1, [x1,704]
@@ -9246,73 +9440,73 @@ pm_free_sblk:
 	and	w1, w1, w0
 	udiv	w1, w1, w8
 	uxth	w1, w1
-.L1471:
+.L1495:
 	cmp	w9, w2, uxth
-	bls	.L1496
+	bls	.L1520
 	add	x5, x4, x2, lsl 1
 	ldrh	w5, [x5,416]
 	cmp	w5, w1
-	bne	.L1472
+	bne	.L1496
 	ldrh	w5, [x28,x2,lsl 1]
 	add	w5, w5, 1
 	strh	w5, [x28,x2,lsl 1]
-.L1472:
-	add	x2, x2, 1
-	b	.L1471
 .L1496:
+	add	x2, x2, 1
+	b	.L1495
+.L1520:
 	add	x3, x3, 1
-	b	.L1470
-.L1495:
+	b	.L1494
+.L1519:
 	add	x1, x21, :lo12:.LANCHOR0
 	mov	w25, 0
-	adrp	x24, .LC129
+	adrp	x24, .LC133
 	mov	w19, w25
 	adrp	x26, .LANCHOR2
 	mov	w27, -1
-	ldrb	w0, [x1,3276]
-	add	x24, x24, :lo12:.LC129
-	ldrh	w20, [x1,3300]
+	ldrb	w0, [x1,3300]
+	add	x24, x24, :lo12:.LC133
+	ldrh	w20, [x1,3324]
 	mul	w20, w0, w20
 	uxth	w20, w20
-.L1475:
+.L1499:
 	add	x0, x23, :lo12:.LANCHOR4
-	ldrh	w0, [x0,1156]
+	ldrh	w0, [x0,1180]
 	cmp	w0, w19
-	bls	.L1497
+	bls	.L1521
 	add	x0, x21, :lo12:.LANCHOR0
 	sxtw	x22, w19
 	add	x1, x22, 208
 	ldr	x4, [x0,2864]
-	ldrb	w2, [x0,3338]
+	ldrb	w2, [x0,3266]
 	ldrh	w3, [x4,x1,lsl 1]
 	ldrh	w1, [x4,692]
 	sdiv	w1, w1, w2
 	cmp	w1, w3
-	bne	.L1476
-	ldrb	w1, [x0,3276]
-	ldrh	w0, [x0,3300]
+	bne	.L1500
+	ldrb	w1, [x0,3300]
+	ldrh	w0, [x0,3324]
 	mul	w0, w1, w0
 	strh	w0, [x28,w19,sxtw 1]
-.L1476:
+.L1500:
 	ldrh	w0, [x28,x22,lsl 1]
 	cmp	w20, w0
-	bls	.L1477
+	bls	.L1501
 	cmp	w0, wzr
 	csel	w25, w25, w19, eq
 	csel	w20, w20, w0, eq
-.L1477:
-	cbnz	w0, .L1479
+.L1501:
+	cbnz	w0, .L1503
 	mov	w0, 65535
 	cmp	w3, w0
-	beq	.L1479
+	beq	.L1503
 	ldr	w0, [x26,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L1480
+	tbz	x0, 12, .L1504
 	ldrh	w4, [x4,688]
 	mov	x0, x24
 	mov	w1, w19
 	mov	w2, 0
 	bl	printk
-.L1480:
+.L1504:
 	add	x1, x21, :lo12:.LANCHOR0
 	add	x22, x22, 208
 	str	x1, [x29,104]
@@ -9325,11 +9519,11 @@ pm_free_sblk:
 	ldrh	w1, [x0,688]
 	sub	w1, w1, #1
 	strh	w1, [x0,688]
-.L1479:
+.L1503:
 	add	w19, w19, 1
 	uxth	w19, w19
-	b	.L1475
-.L1497:
+	b	.L1499
+.L1521:
 	mov	w0, w25
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
@@ -9360,15 +9554,15 @@ flash_info_data_init:
 	ldr	w0, [x1,#:lo12:.LANCHOR2]
 	stp	x19, x20, [sp,16]
 	mov	x20, x1
-	tbz	x0, 12, .L1500
+	tbz	x0, 12, .L1524
 	adrp	x2, .LANCHOR3
-	adrp	x0, .LC130
+	adrp	x0, .LC134
 	add	x2, x2, :lo12:.LANCHOR3
-	add	x0, x0, :lo12:.LC130
+	add	x0, x0, :lo12:.LC134
 	mov	w1, 105
 	add	x2, x2, 112
 	bl	printk
-.L1500:
+.L1524:
 	adrp	x19, .LANCHOR0
 	mov	w1, 0
 	add	x19, x19, :lo12:.LANCHOR0
@@ -9403,14 +9597,14 @@ flash_info_data_init:
 	.type	ftl_memcpy32, %function
 ftl_memcpy32:
 	mov	x3, 0
-.L1505:
+.L1529:
 	cmp	w2, w3
-	bls	.L1507
+	bls	.L1531
 	ldr	w4, [x1,x3,lsl 2]
 	str	w4, [x0,x3,lsl 2]
 	add	x3, x3, 1
-	b	.L1505
-.L1507:
+	b	.L1529
+.L1531:
 	ret
 	.size	ftl_memcpy32, .-ftl_memcpy32
 	.align	2
@@ -9432,8 +9626,8 @@ timer_get_time:
 	stp	x29, x30, [sp, -16]!
 	add	x29, sp, 0
 	ldr	x1, [x0,#:lo12:jiffies]
-	adrp	x0, .LANCHOR4+1160
-	ldr	x0, [x0,#:lo12:.LANCHOR4+1160]
+	adrp	x0, .LANCHOR4+1184
+	ldr	x0, [x0,#:lo12:.LANCHOR4+1184]
 	sub	x0, x1, x0
 	bl	jiffies_to_msecs
 	ldp	x29, x30, [sp], 16
@@ -9453,10 +9647,10 @@ StorageSysDataLoad:
 	mov	w1, 0
 	bl	ftl_memset
 	bl	rknand_device_lock
-	adrp	x0, .LANCHOR4+1168
+	adrp	x0, .LANCHOR4+1192
 	mov	x2, x19
 	mov	w1, 1
-	ldr	x0, [x0,#:lo12:.LANCHOR4+1168]
+	ldr	x0, [x0,#:lo12:.LANCHOR4+1192]
 	ldr	x3, [x0,24]
 	mov	w0, w20
 	blr	x3
@@ -9476,10 +9670,10 @@ StorageSysDataStore:
 	str	x0, [x29,16]
 	str	x1, [x29,24]
 	bl	rknand_device_lock
-	adrp	x1, .LANCHOR4+1168
+	adrp	x1, .LANCHOR4+1192
 	ldr	x2, [x29,24]
 	ldr	x0, [x29,16]
-	ldr	x1, [x1,#:lo12:.LANCHOR4+1168]
+	ldr	x1, [x1,#:lo12:.LANCHOR4+1192]
 	ldr	x3, [x1,32]
 	mov	w1, 1
 	blr	x3
@@ -9499,11 +9693,11 @@ FlashBootVendorRead:
 	str	x1, [x29,32]
 	str	x2, [x29,40]
 	bl	rknand_device_lock
-	adrp	x3, .LANCHOR4+1168
+	adrp	x3, .LANCHOR4+1192
 	ldr	x1, [x29,32]
 	ldr	x2, [x29,40]
 	ldr	x0, [x29,24]
-	ldr	x3, [x3,#:lo12:.LANCHOR4+1168]
+	ldr	x3, [x3,#:lo12:.LANCHOR4+1192]
 	ldr	x3, [x3,8]
 	blr	x3
 	str	x0, [x29,40]
@@ -9522,11 +9716,11 @@ FlashBootVendorWrite:
 	str	x1, [x29,32]
 	str	x2, [x29,40]
 	bl	rknand_device_lock
-	adrp	x3, .LANCHOR4+1168
+	adrp	x3, .LANCHOR4+1192
 	ldr	x1, [x29,32]
 	ldr	x2, [x29,40]
 	ldr	x0, [x29,24]
-	ldr	x3, [x3,#:lo12:.LANCHOR4+1168]
+	ldr	x3, [x3,#:lo12:.LANCHOR4+1192]
 	ldr	x3, [x3,16]
 	blr	x3
 	str	x0, [x29,40]
@@ -9539,20 +9733,20 @@ FlashBootVendorWrite:
 	.global	flash_sram_load_store
 	.type	flash_sram_load_store, %function
 flash_sram_load_store:
-	adrp	x4, .LANCHOR4+1176
+	adrp	x4, .LANCHOR4+1200
 	mov	x6, x0
 	stp	x29, x30, [sp, -16]!
 	uxtw	x1, w1
 	add	x29, sp, 0
-	ldr	x4, [x4,#:lo12:.LANCHOR4+1176]
+	ldr	x4, [x4,#:lo12:.LANCHOR4+1200]
 	add	x4, x4, 4096
-	cbnz	w2, .L1515
+	cbnz	w2, .L1539
 	add	x1, x4, x1
-	b	.L1517
-.L1515:
+	b	.L1541
+.L1539:
 	add	x0, x4, x1
 	mov	x1, x6
-.L1517:
+.L1541:
 	mov	w2, w3
 	bl	ftl_memcpy
 	ldp	x29, x30, [sp], 16
@@ -9569,13 +9763,13 @@ FlashCs123Init:
 	.type	rk_ftl_de_init, %function
 rk_ftl_de_init:
 	stp	x29, x30, [sp, -16]!
-	adrp	x0, .LC131
+	adrp	x0, .LC135
 	mov	w1, 0
 	add	x29, sp, 0
-	add	x0, x0, :lo12:.LC131
+	add	x0, x0, :lo12:.LC135
 	bl	printk
-	adrp	x0, .LANCHOR4+1168
-	ldr	x0, [x0,#:lo12:.LANCHOR4+1168]
+	adrp	x0, .LANCHOR4+1192
+	ldr	x0, [x0,#:lo12:.LANCHOR4+1192]
 	ldr	x0, [x0,80]
 	blr	x0
 	ldp	x29, x30, [sp], 16
@@ -9585,10 +9779,10 @@ rk_ftl_de_init:
 	.global	rk_ftl_cache_write_back
 	.type	rk_ftl_cache_write_back, %function
 rk_ftl_cache_write_back:
-	adrp	x0, .LANCHOR4+1168
+	adrp	x0, .LANCHOR4+1192
 	stp	x29, x30, [sp, -16]!
 	add	x29, sp, 0
-	ldr	x0, [x0,#:lo12:.LANCHOR4+1168]
+	ldr	x0, [x0,#:lo12:.LANCHOR4+1192]
 	ldr	x1, [x0,64]
 	mov	w0, 0
 	blr	x1
@@ -9599,10 +9793,10 @@ rk_ftl_cache_write_back:
 	.global	rk_nand_suspend
 	.type	rk_nand_suspend, %function
 rk_nand_suspend:
-	adrp	x0, .LANCHOR4+1168
+	adrp	x0, .LANCHOR4+1192
 	stp	x29, x30, [sp, -16]!
 	add	x29, sp, 0
-	ldr	x0, [x0,#:lo12:.LANCHOR4+1168]
+	ldr	x0, [x0,#:lo12:.LANCHOR4+1192]
 	ldr	x0, [x0,88]
 	blr	x0
 	ldp	x29, x30, [sp], 16
@@ -9612,10 +9806,10 @@ rk_nand_suspend:
 	.global	rk_nand_resume
 	.type	rk_nand_resume, %function
 rk_nand_resume:
-	adrp	x0, .LANCHOR4+1168
+	adrp	x0, .LANCHOR4+1192
 	stp	x29, x30, [sp, -16]!
 	add	x29, sp, 0
-	ldr	x0, [x0,#:lo12:.LANCHOR4+1168]
+	ldr	x0, [x0,#:lo12:.LANCHOR4+1192]
 	ldr	x0, [x0,96]
 	blr	x0
 	ldp	x29, x30, [sp], 16
@@ -9625,10 +9819,10 @@ rk_nand_resume:
 	.global	rk_ftl_get_capacity
 	.type	rk_ftl_get_capacity, %function
 rk_ftl_get_capacity:
-	adrp	x0, .LANCHOR4+1168
+	adrp	x0, .LANCHOR4+1192
 	stp	x29, x30, [sp, -16]!
 	add	x29, sp, 0
-	ldr	x0, [x0,#:lo12:.LANCHOR4+1168]
+	ldr	x0, [x0,#:lo12:.LANCHOR4+1192]
 	ldr	x1, [x0,72]
 	mov	w0, 0
 	blr	x1
@@ -9639,10 +9833,10 @@ rk_ftl_get_capacity:
 	.global	rk_nandc_get_irq_status
 	.type	rk_nandc_get_irq_status, %function
 rk_nandc_get_irq_status:
-	adrp	x1, .LANCHOR4+1168
+	adrp	x1, .LANCHOR4+1192
 	stp	x29, x30, [sp, -16]!
 	add	x29, sp, 0
-	ldr	x1, [x1,#:lo12:.LANCHOR4+1168]
+	ldr	x1, [x1,#:lo12:.LANCHOR4+1192]
 	ldr	x1, [x1,120]
 	blr	x1
 	ldp	x29, x30, [sp], 16
@@ -9652,10 +9846,10 @@ rk_nandc_get_irq_status:
 	.global	rknand_proc_ftlread
 	.type	rknand_proc_ftlread, %function
 rknand_proc_ftlread:
-	adrp	x1, .LANCHOR4+1168
+	adrp	x1, .LANCHOR4+1192
 	stp	x29, x30, [sp, -16]!
 	add	x29, sp, 0
-	ldr	x1, [x1,#:lo12:.LANCHOR4+1168]
+	ldr	x1, [x1,#:lo12:.LANCHOR4+1192]
 	ldr	x1, [x1,128]
 	blr	x1
 	ldp	x29, x30, [sp], 16
@@ -9665,11 +9859,11 @@ rknand_proc_ftlread:
 	.global	FtlRead
 	.type	FtlRead, %function
 FtlRead:
-	adrp	x4, .LANCHOR4+1168
+	adrp	x4, .LANCHOR4+1192
 	uxtb	w0, w0
 	stp	x29, x30, [sp, -16]!
 	add	x29, sp, 0
-	ldr	x4, [x4,#:lo12:.LANCHOR4+1168]
+	ldr	x4, [x4,#:lo12:.LANCHOR4+1192]
 	ldr	x4, [x4,40]
 	blr	x4
 	ldp	x29, x30, [sp], 16
@@ -9679,10 +9873,10 @@ FtlRead:
 	.global	FtlDiscard
 	.type	FtlDiscard, %function
 FtlDiscard:
-	adrp	x2, .LANCHOR4+1168
+	adrp	x2, .LANCHOR4+1192
 	stp	x29, x30, [sp, -16]!
 	add	x29, sp, 0
-	ldr	x2, [x2,#:lo12:.LANCHOR4+1168]
+	ldr	x2, [x2,#:lo12:.LANCHOR4+1192]
 	ldr	x2, [x2,56]
 	blr	x2
 	ldp	x29, x30, [sp], 16
@@ -9692,10 +9886,10 @@ FtlDiscard:
 	.global	rk_ftl_garbage_collect
 	.type	rk_ftl_garbage_collect, %function
 rk_ftl_garbage_collect:
-	adrp	x2, .LANCHOR4+1168
+	adrp	x2, .LANCHOR4+1192
 	stp	x29, x30, [sp, -16]!
 	add	x29, sp, 0
-	ldr	x2, [x2,#:lo12:.LANCHOR4+1168]
+	ldr	x2, [x2,#:lo12:.LANCHOR4+1192]
 	ldr	x2, [x2,104]
 	blr	x2
 	ldp	x29, x30, [sp], 16
@@ -9705,10 +9899,10 @@ rk_ftl_garbage_collect:
 	.global	ReadFlashInfo
 	.type	ReadFlashInfo, %function
 ReadFlashInfo:
-	adrp	x1, .LANCHOR4+1168
+	adrp	x1, .LANCHOR4+1192
 	stp	x29, x30, [sp, -16]!
 	add	x29, sp, 0
-	ldr	x1, [x1,#:lo12:.LANCHOR4+1168]
+	ldr	x1, [x1,#:lo12:.LANCHOR4+1192]
 	ldr	x1, [x1,112]
 	blr	x1
 	ldp	x29, x30, [sp], 16
@@ -9724,8 +9918,8 @@ rknand_print_hex:
 	stp	x21, x22, [sp,32]
 	stp	x23, x24, [sp,48]
 	mov	x19, 0
-	adrp	x23, .LC132
-	adrp	x21, .LC133
+	adrp	x23, .LC136
+	adrp	x21, .LC137
 	adrp	x24, .LC1
 	stp	x25, x26, [sp,64]
 	str	x27, [sp,80]
@@ -9734,48 +9928,48 @@ rknand_print_hex:
 	mov	w25, w2
 	uxtw	x26, w3
 	mov	w20, w19
-	add	x23, x23, :lo12:.LC132
-	add	x21, x21, :lo12:.LC133
+	add	x23, x23, :lo12:.LC136
+	add	x21, x21, :lo12:.LC137
 	add	x24, x24, :lo12:.LC1
-.L1531:
+.L1555:
 	cmp	x19, x26
-	beq	.L1539
-	cbnz	w20, .L1532
+	beq	.L1563
+	cbnz	w20, .L1556
 	mov	x0, x23
 	mov	x1, x27
 	mov	x2, x22
 	mov	w3, w19
 	bl	printk
-.L1532:
+.L1556:
 	cmp	w25, 4
 	mov	x0, x21
-	bne	.L1533
+	bne	.L1557
 	ldr	w1, [x22,x19,lsl 2]
-	b	.L1538
-.L1533:
+	b	.L1562
+.L1557:
 	cmp	w25, 2
-	bne	.L1535
+	bne	.L1559
 	ldrsh	w1, [x22,x19,lsl 1]
-	b	.L1538
-.L1535:
+	b	.L1562
+.L1559:
 	ldrb	w1, [x22,x19]
-.L1538:
+.L1562:
 	bl	printk
 	add	w20, w20, 1
 	cmp	w20, 15
-	bls	.L1536
-	adrp	x1, .LC134
+	bls	.L1560
+	adrp	x1, .LC138
 	mov	x0, x24
-	add	x1, x1, :lo12:.LC134
+	add	x1, x1, :lo12:.LC138
 	mov	w20, 0
 	bl	printk
-.L1536:
+.L1560:
 	add	x19, x19, 1
-	b	.L1531
-.L1539:
+	b	.L1555
+.L1563:
 	adrp	x0, .LC1
-	adrp	x1, .LC134
-	add	x1, x1, :lo12:.LC134
+	adrp	x1, .LC138
+	add	x1, x1, :lo12:.LC138
 	add	x0, x0, :lo12:.LC1
 	bl	printk
 	ldr	x27, [sp,80]
@@ -9814,29 +10008,29 @@ hynix_get_read_retry_default:
 	strb	w2, [x25,129]
 	strb	w1, [x25,130]
 	strb	w0, [x25,131]
-	bne	.L1541
+	bne	.L1565
 	mov	w0, -89
 	strb	w0, [x22,16]
 	adrp	x0, .LANCHOR2+425
 	mov	w1, -9
 	strb	w1, [x0,#:lo12:.LANCHOR2+425]
-	b	.L1604
-.L1541:
+	b	.L1628
+.L1565:
 	cmp	w19, 3
-	bne	.L1543
+	bne	.L1567
 	mov	x5, 0
-.L1544:
+.L1568:
 	sub	w0, w5, #80
 	strb	w0, [x26,x5]
 	add	x5, x5, 1
 	cmp	x5, 8
-	bne	.L1544
+	bne	.L1568
 	mov	w27, w5
 	mov	w28, w5
-	b	.L1542
-.L1543:
+	b	.L1566
+.L1567:
 	cmp	w19, 4
-	bne	.L1545
+	bne	.L1569
 	mov	w5, -52
 	strb	w5, [x25,128]
 	mov	w5, -65
@@ -9852,10 +10046,10 @@ hynix_get_read_retry_default:
 	strb	w1, [x25,134]
 	strb	w5, [x25,132]
 	strb	w0, [x25,135]
-	b	.L1542
-.L1545:
+	b	.L1566
+.L1569:
 	cmp	w19, 5
-	bne	.L1546
+	bne	.L1570
 	mov	w0, 56
 	strb	w0, [x25,128]
 	mov	w0, 57
@@ -9865,10 +10059,10 @@ hynix_get_read_retry_default:
 	strb	w0, [x25,130]
 	mov	w0, 59
 	strb	w0, [x25,131]
-	b	.L1646
-.L1546:
+	b	.L1670
+.L1570:
 	cmp	w19, 6
-	bne	.L1547
+	bne	.L1571
 	mov	w0, 14
 	strb	w0, [x25,128]
 	mov	w0, 15
@@ -9878,27 +10072,27 @@ hynix_get_read_retry_default:
 	strb	w0, [x25,130]
 	mov	w0, 17
 	strb	w0, [x25,131]
-	b	.L1646
-.L1547:
+	b	.L1670
+.L1571:
 	cmp	w19, 7
-	bne	.L1548
+	bne	.L1572
 	mov	x0, 0
-.L1549:
+.L1573:
 	sub	w1, w0, #80
 	strb	w1, [x26,x0]
 	add	x0, x0, 1
 	cmp	x0, 8
-	bne	.L1549
+	bne	.L1573
 	mov	w0, -44
 	mov	w27, 12
 	strb	w0, [x25,136]
 	mov	w28, 10
 	mov	w0, -43
 	strb	w0, [x25,137]
-	b	.L1542
-.L1548:
+	b	.L1566
+.L1572:
 	cmp	w19, 8
-	bne	.L1604
+	bne	.L1628
 	mov	w0, 6
 	strb	w0, [x25,128]
 	mov	w0, 7
@@ -9910,15 +10104,15 @@ hynix_get_read_retry_default:
 	mov	w0, 10
 	mov	w28, 5
 	strb	w0, [x25,132]
-	b	.L1542
-.L1604:
+	b	.L1566
+.L1628:
 	mov	w27, 7
-.L1646:
+.L1670:
 	mov	w28, 4
-.L1542:
+.L1566:
 	sub	w0, w19, #1
 	cmp	w0, 1
-	bhi	.L1643
+	bhi	.L1667
 	ldr	x0, [x29,136]
 	adrp	x24, .LANCHOR2
 	add	x24, x24, :lo12:.LANCHOR2
@@ -9926,10 +10120,10 @@ hynix_get_read_retry_default:
 	add	x19, x0, :lo12:.LANCHOR0
 	mov	w5, 55
 	add	x24, x24, 408
-.L1550:
+.L1574:
 	ldrb	w0, [x19,633]
 	cmp	w0, w23
-	bls	.L1557
+	bls	.L1581
 	add	x0, x19, x23, sxtw
 	ldrb	w0, [x0,736]
 	mov	x20, 160
@@ -9939,7 +10133,7 @@ hynix_get_read_retry_default:
 	madd	x20, x0, x20, x22
 	add	x21, x21, x1
 	add	x20, x20, 32
-.L1552:
+.L1576:
 	str	w5, [x21,2056]
 	str	x5, [x29,136]
 	ldrb	w0, [x26,x25]
@@ -9951,12 +10145,12 @@ hynix_get_read_retry_default:
 	add	x25, x25, 1
 	ldr	x5, [x29,136]
 	cmp	w28, w25, uxtb
-	bhi	.L1552
+	bhi	.L1576
 	mov	x0, 0
-.L1553:
+.L1577:
 	add	w2, w0, 8
 	mov	x1, 0
-.L1554:
+.L1578:
 	add	x3, x1, x0
 	add	x1, x1, 4
 	add	x3, x24, x3
@@ -9966,10 +10160,10 @@ hynix_get_read_retry_default:
 	add	w3, w4, w3
 	strb	w3, [x20,w2,sxtw]
 	add	w2, w2, 8
-	bne	.L1554
+	bne	.L1578
 	add	x0, x0, 1
 	cmp	x0, 4
-	bne	.L1553
+	bne	.L1577
 	add	w23, w23, 1
 	strb	wzr, [x20,16]
 	strb	wzr, [x20,24]
@@ -9979,11 +10173,11 @@ hynix_get_read_retry_default:
 	strb	wzr, [x20,48]
 	strb	wzr, [x20,41]
 	strb	wzr, [x20,49]
-	b	.L1550
-.L1643:
+	b	.L1574
+.L1667:
 	sub	w0, w19, #3
 	cmp	w0, 5
-	bhi	.L1557
+	bhi	.L1581
 	mul	w0, w28, w27
 	sub	w24, w28, #1
 	mov	w20, 0
@@ -9998,13 +10192,13 @@ hynix_get_read_retry_default:
 	str	w0, [x29,132]
 	add	x0, x24, 1
 	str	x0, [x29,112]
-.L1558:
+.L1582:
 	ldr	x0, [x29,136]
 	add	x1, x0, :lo12:.LANCHOR0
 	ldrb	w0, [x1,633]
 	cmp	w0, w20
-	bhi	.L1603
-.L1557:
+	bhi	.L1627
+.L1581:
 	strb	w28, [x22,1]
 	strb	w27, [x22,2]
 	ldp	x19, x20, [sp,16]
@@ -10014,7 +10208,7 @@ hynix_get_read_retry_default:
 	ldp	x27, x28, [sp,80]
 	ldp	x29, x30, [sp], 144
 	ret
-.L1603:
+.L1627:
 	add	x0, x1, x20, sxtw
 	ldrb	w24, [x0,736]
 	str	x1, [x29,104]
@@ -10034,7 +10228,7 @@ hynix_get_read_retry_default:
 	bl	nandc_wait_flash_ready
 	cmp	w19, 8
 	ldr	x1, [x29,104]
-	bne	.L1559
+	bne	.L1583
 	mov	w0, 120
 	str	w0, [x24,2056]
 	str	wzr, [x24,2052]
@@ -10054,38 +10248,38 @@ hynix_get_read_retry_default:
 	str	wzr, [x24,2052]
 	str	wzr, [x24,2052]
 	str	w1, [x24,2052]
-	b	.L1649
-.L1559:
+	b	.L1673
+.L1583:
 	mov	w0, 54
 	cmp	w19, 4
 	str	w0, [x24,2056]
-	bne	.L1561
+	bne	.L1585
 	mov	w0, 64
 	str	w1, [x24,2052]
 	str	w0, [x24,2048]
 	mov	w0, 204
-	b	.L1647
-.L1561:
+	b	.L1671
+.L1585:
 	ldr	w0, [x29,132]
 	cmp	w0, 1
-	bhi	.L1563
+	bhi	.L1587
 	ldrb	w0, [x25,128]
 	str	w0, [x24,2052]
 	mov	w0, 82
-	b	.L1648
-.L1563:
+	b	.L1672
+.L1587:
 	cmp	w19, 7
-	bne	.L1562
+	bne	.L1586
 	mov	w0, 174
 	str	w0, [x24,2052]
 	str	wzr, [x24,2048]
 	mov	w0, 176
-.L1647:
+.L1671:
 	str	w0, [x24,2052]
 	mov	w0, 77
-.L1648:
+.L1672:
 	str	w0, [x24,2048]
-.L1562:
+.L1586:
 	mov	w0, 22
 	str	w0, [x24,2056]
 	mov	w0, 23
@@ -10098,15 +10292,15 @@ hynix_get_read_retry_default:
 	cmp	w19, 6
 	str	wzr, [x24,2052]
 	str	wzr, [x24,2052]
-	bne	.L1564
+	bne	.L1588
 	mov	w0, 31
 	str	w0, [x24,2052]
-	b	.L1565
-.L1564:
+	b	.L1589
+.L1588:
 	str	wzr, [x24,2052]
-.L1565:
+.L1589:
 	mov	w0, 2
-.L1649:
+.L1673:
 	str	w0, [x24,2052]
 	mov	w0, 48
 	str	wzr, [x24,2052]
@@ -10117,119 +10311,119 @@ hynix_get_read_retry_default:
 	cset	w8, ls
 	cmp	w19, 8
 	cset	w7, eq
-	cbnz	w8, .L1606
-	cbnz	w7, .L1606
+	cbnz	w8, .L1630
+	cbnz	w7, .L1630
 	cmp	w19, 7
 	mov	w1, 32
 	mov	w0, 2
 	csel	w1, w0, w1, ne
-	b	.L1566
-.L1606:
+	b	.L1590
+.L1630:
 	mov	w1, 16
-.L1566:
+.L1590:
 	adrp	x0, .LANCHOR4
 	mov	x9, 0
 	add	x0, x0, :lo12:.LANCHOR4
-	ldr	x0, [x0,1184]
-.L1567:
+	ldr	x0, [x0,1208]
+.L1591:
 	ldr	w10, [x24,2048]
 	strb	w10, [x0,x9]
 	add	x9, x9, 1
 	cmp	w1, w9, uxtb
-	bhi	.L1567
-	cbz	w7, .L1568
+	bhi	.L1591
+	cbz	w7, .L1592
 	mov	w1, 0
-.L1570:
+.L1594:
 	ldrb	w9, [x0]
 	cmp	w9, 50
-	beq	.L1569
+	beq	.L1593
 	ldrb	w9, [x0,1]
 	cmp	w9, 5
-	beq	.L1569
+	beq	.L1593
 	add	w1, w1, 1
 	add	x0, x0, 4
 	uxtb	w1, w1
 	cmp	w1, 8
-	bne	.L1570
-	b	.L1571
-.L1569:
+	bne	.L1594
+	b	.L1595
+.L1593:
 	cmp	w1, 7
-	bne	.L1572
-.L1571:
-	adrp	x0, .LC135
+	bne	.L1596
+.L1595:
+	adrp	x0, .LC139
 	mov	w1, 0
-	add	x0, x0, :lo12:.LC135
+	add	x0, x0, :lo12:.LC139
 	bl	printk
-.L1573:
-	b	.L1573
-.L1568:
+.L1597:
+	b	.L1597
+.L1592:
 	cmp	w19, 7
-	bne	.L1574
+	bne	.L1598
 	mov	w1, w7
-.L1576:
+.L1600:
 	ldrb	w9, [x0]
 	cmp	w9, 12
-	beq	.L1575
+	beq	.L1599
 	ldrb	w9, [x0,1]
 	cmp	w9, 10
-	beq	.L1575
+	beq	.L1599
 	add	w1, w1, 1
 	add	x0, x0, 4
 	uxtb	w1, w1
 	cmp	w1, 8
-	bne	.L1576
-	b	.L1577
-.L1575:
+	bne	.L1600
+	b	.L1601
+.L1599:
 	cmp	w1, 7
-	bne	.L1572
-.L1577:
-	adrp	x0, .LC135
+	bne	.L1596
+.L1601:
+	adrp	x0, .LC139
 	mov	w1, 0
-	add	x0, x0, :lo12:.LC135
+	add	x0, x0, :lo12:.LC139
 	bl	printk
-.L1578:
-	b	.L1578
-.L1574:
+.L1602:
+	b	.L1602
+.L1598:
 	cmp	w19, 6
-	bne	.L1572
+	bne	.L1596
 	mov	x1, 0
-.L1579:
+.L1603:
 	ldrb	w9, [x0,x1]
 	cmp	w9, 12
-	beq	.L1572
+	beq	.L1596
 	add	x9, x0, x1
 	ldrb	w9, [x9,8]
 	cmp	w9, 4
-	beq	.L1572
+	beq	.L1596
 	add	x1, x1, 1
 	cmp	x1, 8
-	bne	.L1579
-	adrp	x0, .LC135
+	bne	.L1603
+	adrp	x0, .LC139
 	mov	w1, 0
-	add	x0, x0, :lo12:.LC135
+	add	x0, x0, :lo12:.LC139
 	bl	printk
-.L1581:
-	b	.L1581
-.L1572:
+.L1605:
+	b	.L1605
+.L1596:
 	add	x0, x26, :lo12:.LANCHOR4
-	ldr	x10, [x0,1184]
+	ldr	x10, [x0,1208]
 	mov	x0, 0
-.L1582:
+.L1606:
 	ldr	w1, [x29,128]
 	cmp	w1, w0
-	ble	.L1651
+	ble	.L1675
 	ldr	w1, [x24,2048]
 	strb	w1, [x10,x0]
 	add	x0, x0, 1
-	b	.L1582
-.L1651:
+	b	.L1606
+.L1675:
 	add	x0, x26, :lo12:.LANCHOR4
 	mov	w11, w23
 	mov	w9, 8
-	ldr	x12, [x0,1184]
-.L1585:
+	ldr	x12, [x0,1208]
+.L1609:
 	mov	w0, 0
-.L1584:
+.L1608:
 	add	w1, w0, w11
 	add	w0, w0, 1
 	sbfiz	x1, x1, 1, 32
@@ -10237,93 +10431,93 @@ hynix_get_read_retry_default:
 	ldrh	w13, [x12,x1]
 	mvn	w13, w13
 	strh	w13, [x12,x1]
-	bne	.L1584
+	bne	.L1608
 	ldr	w0, [x29,124]
 	subs	w9, w9, #1
 	add	w11, w11, w0
-	bne	.L1585
+	bne	.L1609
 	mov	x9, 0
 	mov	w17, 1
-.L1586:
+.L1610:
 	mov	w1, 0
 	mov	w11, w1
-.L1590:
+.L1614:
 	lsl	w13, w17, w11
 	mov	w15, w9
 	mov	w0, 16
 	mov	w14, 0
-.L1588:
+.L1612:
 	ldrh	w16, [x12,w15,sxtw 1]
 	add	w15, w15, w23
 	and	w16, w16, w13
 	cmp	w16, w13
 	csinc	w14, w14, w14, ne
 	subs	w0, w0, #1
-	bne	.L1588
+	bne	.L1612
 	cmp	w14, 8
-	bls	.L1589
+	bls	.L1613
 	orr	w1, w1, w13
 	uxth	w1, w1
-.L1589:
+.L1613:
 	add	w11, w11, 1
 	cmp	w11, 16
-	bne	.L1590
+	bne	.L1614
 	strh	w1, [x12,x9,lsl 1]
 	add	x9, x9, 1
 	cmp	w23, w9
-	bgt	.L1586
+	bgt	.L1610
 	add	x1, x26, :lo12:.LANCHOR4
 	mov	x9, 0
 	mov	w11, w9
-	ldr	x1, [x1,1184]
-.L1593:
+	ldr	x1, [x1,1208]
+.L1617:
 	ldr	w12, [x1,x9]
 	add	x9, x9, 4
 	cmp	w12, wzr
 	csinc	w11, w11, w11, ne
 	cmp	x9, 32
-	bne	.L1593
+	bne	.L1617
 	cmp	w11, 7
-	ble	.L1594
-	adrp	x0, .LC136
+	ble	.L1618
+	adrp	x0, .LC140
 	mov	w2, 1
-	add	x0, x0, :lo12:.LC136
+	add	x0, x0, :lo12:.LC140
 	mov	w3, 1024
 	bl	rknand_print_hex
-	adrp	x0, .LC135
+	adrp	x0, .LC139
 	mov	w1, 0
-	add	x0, x0, :lo12:.LC135
+	add	x0, x0, :lo12:.LC139
 	bl	printk
-.L1595:
-	b	.L1595
-.L1594:
+.L1619:
+	b	.L1619
+.L1618:
 	cmp	w19, 6
 	mov	w9, 4
-	beq	.L1596
+	beq	.L1620
 	cmp	w19, 7
 	mov	w9, 10
-	beq	.L1596
+	beq	.L1620
 	cmp	w7, wzr
 	mov	w9, 5
 	mov	w1, 8
 	csel	w9, w1, w9, eq
-.L1596:
+.L1620:
 	mov	w11, 0
-.L1597:
+.L1621:
 	mov	x1, 0
-.L1598:
+.L1622:
 	add	w12, w0, w1
 	ldrb	w13, [x10,x1]
 	add	x1, x1, 1
 	cmp	w28, w1, uxtb
 	strb	w13, [x21,w12,sxtw]
-	bhi	.L1598
+	bhi	.L1622
 	add	w11, w11, 1
 	ldr	x1, [x29,112]
 	cmp	w11, w27
 	add	w0, w0, w9
 	add	x10, x10, x1
-	blt	.L1597
+	blt	.L1621
 	mov	w21, 255
 	str	w21, [x24,2056]
 	str	x7, [x29,96]
@@ -10331,7 +10525,7 @@ hynix_get_read_retry_default:
 	bl	nandc_wait_flash_ready
 	ldr	x8, [x29,104]
 	ldr	x7, [x29,96]
-	cbz	w8, .L1600
+	cbz	w8, .L1624
 	mov	w0, 54
 	str	w0, [x24,2056]
 	ldrb	w0, [x25,128]
@@ -10346,17 +10540,17 @@ hynix_get_read_retry_default:
 	str	w21, [x24,2052]
 	str	w21, [x24,2052]
 	str	w21, [x24,2052]
-	b	.L1650
-.L1600:
+	b	.L1674
+.L1624:
 	mov	w0, 190
-	cbnz	w7, .L1650
+	cbnz	w7, .L1674
 	mov	w0, 56
-.L1650:
+.L1674:
 	str	w0, [x24,2056]
 	add	w20, w20, 1
 	bl	nandc_wait_flash_ready
 	uxtb	w20, w20
-	b	.L1558
+	b	.L1582
 	.size	hynix_get_read_retry_default, .-hynix_get_read_retry_default
 	.align	2
 	.global	flash_get_read_retry_tbl
@@ -10369,9 +10563,9 @@ flash_get_read_retry_tbl:
 	sub	w1, w0, #1
 	uxtb	w1, w1
 	cmp	w1, 7
-	bhi	.L1652
+	bhi	.L1676
 	bl	hynix_get_read_retry_default
-.L1652:
+.L1676:
 	ldp	x29, x30, [sp], 16
 	ret
 	.size	flash_get_read_retry_tbl, .-flash_get_read_retry_tbl
@@ -10391,54 +10585,54 @@ nandc_xfer_done:
 	adrp	x0, .LANCHOR4
 	add	x1, x0, :lo12:.LANCHOR4
 	mov	x23, x0
-	strb	wzr, [x1,1192]
+	strb	wzr, [x1,1216]
 	ldrb	w1, [x20,516]
 	cmp	w1, 9
-	bne	.L1655
+	bne	.L1679
 	ldr	x24, [x20,536]
 	ldr	w0, [x24,16]
 	str	w0, [x29,64]
 	ldr	w20, [x24,48]
 	ubfx	x20, x20, 1, 1
-	cbnz	w20, .L1675
-	adrp	x21, .LC140
-	adrp	x23, .LC139
-	add	x21, x21, :lo12:.LC140
-	add	x23, x23, :lo12:.LC139
-	b	.L1657
-.L1675:
-	adrp	x21, .LC138
-	adrp	x22, .LC139
+	cbnz	w20, .L1699
+	adrp	x21, .LC144
+	adrp	x23, .LC143
+	add	x21, x21, :lo12:.LC144
+	add	x23, x23, :lo12:.LC143
+	b	.L1681
+.L1699:
+	adrp	x21, .LC142
+	adrp	x22, .LC143
 	mov	w20, 0
-	add	x21, x21, :lo12:.LC138
-	add	x22, x22, :lo12:.LC139
-.L1656:
+	add	x21, x21, :lo12:.LC142
+	add	x22, x22, :lo12:.LC143
+.L1680:
 	ldr	w2, [x24,64]
 	ldr	w1, [x29,64]
 	ubfx	x2, x2, 16, 6
 	ubfx	x1, x1, 22, 6
 	cmp	w2, w1
-	bge	.L1659
+	bge	.L1683
 	add	x0, x19, :lo12:.LANCHOR0
 	ldr	x0, [x0,536]
 	ldr	w0, [x0]
 	str	w0, [x29,72]
 	ldr	w0, [x29,72]
-	tbz	x0, 13, .L1658
+	tbz	x0, 13, .L1682
 	ldr	w0, [x29,72]
-	tbz	x0, 17, .L1658
+	tbz	x0, 17, .L1682
 	ldr	w1, [x29,72]
-	adrp	x0, .LC137
-	add	x0, x0, :lo12:.LC137
+	adrp	x0, .LC141
+	add	x0, x0, :lo12:.LC141
 	ubfx	x1, x1, 17, 1
 	bl	printk
-	b	.L1659
-.L1658:
+	b	.L1683
+.L1682:
 	ldr	w0, [x29,64]
 	add	w20, w20, 1
 	ubfx	x0, x0, 22, 6
 	cmp	w20, w0, lsl 12
-	bne	.L1656
+	bne	.L1680
 	ldr	w2, [x24,64]
 	mov	w1, w20
 	ldr	w3, [x29,64]
@@ -10453,15 +10647,15 @@ nandc_xfer_done:
 	ldr	x1, [x1,536]
 	bl	rknand_print_hex
 	ldr	w0, [x29,72]
-	tbz	x0, 13, .L1656
+	tbz	x0, 13, .L1680
 	add	x0, x23, :lo12:.LANCHOR4
 	mov	w1, 1
-	strb	w1, [x0,1192]
-.L1659:
+	strb	w1, [x0,1216]
+.L1683:
 	add	x20, x19, :lo12:.LANCHOR0
 	add	x20, x20, 680
 	ldr	w0, [x20,32]
-	cbz	w0, .L1663
+	cbz	w0, .L1687
 	ldr	w1, [x29,64]
 	mov	w2, 0
 	ldr	w0, [x20,24]
@@ -10472,15 +10666,15 @@ nandc_xfer_done:
 	ldr	w0, [x20,28]
 	ubfx	x1, x1, 22, 6
 	lsl	w1, w1, 2
-	b	.L1703
-.L1665:
+	b	.L1727
+.L1689:
 	add	x22, x19, :lo12:.LANCHOR0
 	add	w20, w20, 1
 	ldr	x0, [x22,536]
 	ldr	w0, [x0,16]
 	str	w0, [x29,64]
 	and	w0, w20, 16777215
-	cbnz	w0, .L1657
+	cbnz	w0, .L1681
 	ldr	w2, [x29,64]
 	mov	w1, w20
 	ldr	w3, [x24,64]
@@ -10492,13 +10686,13 @@ nandc_xfer_done:
 	mov	w2, 4
 	mov	w3, 64
 	bl	rknand_print_hex
-.L1657:
+.L1681:
 	ldr	w0, [x29,64]
-	tbz	x0, 20, .L1665
+	tbz	x0, 20, .L1689
 	add	x20, x19, :lo12:.LANCHOR0
 	add	x20, x20, 680
 	ldr	w0, [x20,32]
-	cbz	w0, .L1663
+	cbz	w0, .L1687
 	ldr	w1, [x29,64]
 	mov	w2, 1
 	ldr	w0, [x20,24]
@@ -10509,49 +10703,49 @@ nandc_xfer_done:
 	ldr	w0, [x20,28]
 	ubfx	x1, x1, 22, 6
 	lsl	w1, w1, 2
-	b	.L1702
-.L1655:
+	b	.L1726
+.L1679:
 	ldr	x23, [x20,536]
 	ldr	w0, [x23,8]
 	str	w0, [x29,64]
 	ldr	w20, [x23,16]
 	ubfx	x20, x20, 1, 1
-	cbnz	w20, .L1676
-	adrp	x21, .LC140
-	adrp	x24, .LC139
-	add	x21, x21, :lo12:.LC140
-	add	x24, x24, :lo12:.LC139
-	b	.L1668
-.L1676:
-	adrp	x21, .LC138
-	adrp	x22, .LC139
+	cbnz	w20, .L1700
+	adrp	x21, .LC144
+	adrp	x24, .LC143
+	add	x21, x21, :lo12:.LC144
+	add	x24, x24, :lo12:.LC143
+	b	.L1692
+.L1700:
+	adrp	x21, .LC142
+	adrp	x22, .LC143
 	mov	w20, 0
-	add	x21, x21, :lo12:.LC138
-	add	x22, x22, :lo12:.LC139
-.L1667:
+	add	x21, x21, :lo12:.LC142
+	add	x22, x22, :lo12:.LC143
+.L1691:
 	ldr	w2, [x23,28]
 	ldr	w1, [x29,64]
 	ubfx	x2, x2, 16, 5
 	ubfx	x1, x1, 22, 6
 	cmp	w2, w1
-	bge	.L1670
+	bge	.L1694
 	add	x0, x19, :lo12:.LANCHOR0
 	ldr	x0, [x0,536]
 	ldr	w0, [x0]
 	str	w0, [x29,72]
 	ldr	w0, [x29,72]
-	tbz	x0, 13, .L1669
+	tbz	x0, 13, .L1693
 	ldr	w0, [x29,72]
-	tbz	x0, 17, .L1669
+	tbz	x0, 17, .L1693
 	ldr	w1, [x29,72]
-	adrp	x0, .LC141
-	add	x0, x0, :lo12:.LC141
+	adrp	x0, .LC145
+	add	x0, x0, :lo12:.LC145
 	bl	printk
-	b	.L1670
-.L1669:
+	b	.L1694
+.L1693:
 	add	w20, w20, 1
 	and	w0, w20, 16777215
-	cbnz	w0, .L1667
+	cbnz	w0, .L1691
 	ldr	w2, [x23,28]
 	mov	w1, w20
 	ldr	w3, [x29,64]
@@ -10565,12 +10759,12 @@ nandc_xfer_done:
 	mov	w3, 64
 	ldr	x1, [x1,536]
 	bl	rknand_print_hex
-	b	.L1667
-.L1670:
+	b	.L1691
+.L1694:
 	add	x20, x19, :lo12:.LANCHOR0
 	add	x20, x20, 680
 	ldr	w0, [x20,32]
-	cbz	w0, .L1663
+	cbz	w0, .L1687
 	ldr	w1, [x29,64]
 	mov	w2, 0
 	ldr	w0, [x20,24]
@@ -10581,17 +10775,17 @@ nandc_xfer_done:
 	ldr	w0, [x20,28]
 	ubfx	x1, x1, 22, 6
 	lsl	w1, w1, 7
-.L1703:
+.L1727:
 	mov	w2, 0
-	b	.L1701
-.L1674:
+	b	.L1725
+.L1698:
 	add	x22, x19, :lo12:.LANCHOR0
 	add	w20, w20, 1
 	ldr	x0, [x22,536]
 	ldr	w0, [x0,8]
 	str	w0, [x29,64]
 	and	w0, w20, 16777215
-	cbnz	w0, .L1668
+	cbnz	w0, .L1692
 	ldr	w2, [x29,64]
 	mov	w1, w20
 	ldr	w3, [x23,28]
@@ -10603,13 +10797,13 @@ nandc_xfer_done:
 	mov	w2, 4
 	mov	w3, 64
 	bl	rknand_print_hex
-.L1668:
+.L1692:
 	ldr	w0, [x29,64]
-	tbz	x0, 20, .L1674
+	tbz	x0, 20, .L1698
 	add	x20, x19, :lo12:.LANCHOR0
 	add	x20, x20, 680
 	ldr	w0, [x20,32]
-	cbz	w0, .L1663
+	cbz	w0, .L1687
 	ldr	w1, [x29,64]
 	mov	w2, 1
 	ldr	w0, [x20,24]
@@ -10620,11 +10814,11 @@ nandc_xfer_done:
 	ldr	w0, [x20,28]
 	ubfx	x1, x1, 22, 6
 	lsl	w1, w1, 7
-.L1702:
+.L1726:
 	mov	w2, 1
-.L1701:
+.L1725:
 	bl	rknand_dma_unmap_single
-.L1663:
+.L1687:
 	add	x19, x19, :lo12:.LANCHOR0
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -10653,19 +10847,19 @@ nandc_xfer:
 	bl	nandc_xfer_start
 	bl	nandc_xfer_done
 	mov	w0, 0
-	cbnz	w20, .L1734
+	cbnz	w20, .L1758
 	adrp	x19, .LANCHOR0
 	add	x2, x19, :lo12:.LANCHOR0
 	ldrb	w1, [x2,516]
 	cmp	w1, 9
-	bne	.L1706
+	bne	.L1730
 	ldr	x5, [x2,536]
 	lsr	w22, w22, 2
 	mov	w4, 1
 	mov	w3, w0
-.L1707:
+.L1731:
 	cmp	w3, w22
-	bcs	.L1743
+	bcs	.L1767
 	uxtw	x1, w3
 	add	x1, x1, 84
 	ldr	w1, [x5,x1,lsl 2]
@@ -10677,30 +10871,30 @@ nandc_xfer:
 	and	w1, w1, w2
 	and	w4, w4, w1
 	ldr	w1, [x29,72]
-	tbnz	x1, 2, .L1726
+	tbnz	x1, 2, .L1750
 	ldr	w1, [x29,72]
-	tbnz	x1, 18, .L1726
+	tbnz	x1, 18, .L1750
 	ldr	w2, [x29,72]
 	ldr	w1, [x29,72]
 	ubfx	x2, x2, 3, 7
 	ubfx	x1, x1, 19, 7
 	cmp	w2, w1
 	ldr	w1, [x29,72]
-	ble	.L1709
+	ble	.L1733
 	ubfx	x1, x1, 3, 7
-	b	.L1710
-.L1709:
+	b	.L1734
+.L1733:
 	ubfx	x1, x1, 19, 7
-.L1710:
+.L1734:
 	cmp	w0, w1
 	csel	w0, w0, w1, cs
-	b	.L1708
-.L1726:
+	b	.L1732
+.L1750:
 	mov	w0, -1
-.L1708:
+.L1732:
 	add	w3, w3, 1
-	b	.L1707
-.L1743:
+	b	.L1731
+.L1767:
 	add	x22, x19, :lo12:.LANCHOR0
 	cmp	w4, wzr
 	ldr	x1, [x22,536]
@@ -10711,30 +10905,30 @@ nandc_xfer:
 	movk	w1, 0x2, lsl 16
 	and	w1, w20, w1
 	cmp	w1, 139264
-	bne	.L1713
-	adrp	x0, .LC142
+	bne	.L1737
+	adrp	x0, .LC146
 	mov	w1, w20
-	add	x0, x0, :lo12:.LC142
+	add	x0, x0, :lo12:.LC146
 	orr	w20, w20, 131072
 	bl	printk
 	ldr	x0, [x22,536]
 	str	w20, [x0]
 	mov	w0, -1
-.L1713:
-	tbz	x20, 13, .L1714
-	adrp	x1, .LANCHOR4+1192
-	ldrb	w1, [x1,#:lo12:.LANCHOR4+1192]
-	cbz	w1, .L1714
-	adrp	x0, .LC143
+.L1737:
+	tbz	x20, 13, .L1738
+	adrp	x1, .LANCHOR4+1216
+	ldrb	w1, [x1,#:lo12:.LANCHOR4+1216]
+	cbz	w1, .L1738
+	adrp	x0, .LC147
 	mov	w1, w20
-	add	x0, x0, :lo12:.LC143
+	add	x0, x0, :lo12:.LC147
 	add	x19, x19, :lo12:.LANCHOR0
 	bl	printk
 	ldr	x0, [x19,536]
 	mov	w1, 1
 	str	w1, [x0,16]
-	b	.L1715
-.L1706:
+	b	.L1739
+.L1730:
 	ldrb	w0, [x2,724]
 	mov	w5, 128
 	lsr	w6, w22, 1
@@ -10744,10 +10938,10 @@ nandc_xfer:
 	csel	w5, w0, w5, cc
 	mov	w1, w20
 	mov	w4, w20
-.L1717:
+.L1741:
 	cmp	w4, w6
 	add	w7, w1, w5
-	bcs	.L1744
+	bcs	.L1768
 	ldr	x0, [x2,680]
 	and	x1, x1, 4294967292
 	ldr	w0, [x0,x1]
@@ -10764,24 +10958,24 @@ nandc_xfer:
 	add	w3, w3, 4
 	strb	w0, [x23,x1]
 	mov	w1, w7
-	b	.L1717
-.L1744:
+	b	.L1741
+.L1768:
 	add	x0, x19, :lo12:.LANCHOR0
 	mov	w2, 0
 	lsr	w22, w22, 2
 	ldr	x6, [x0,536]
 	mov	w0, w2
-.L1719:
+.L1743:
 	cmp	w2, w22
-	bcs	.L1745
+	bcs	.L1769
 	uxtw	x1, w2
 	add	x1, x1, 8
 	ldr	w1, [x6,x1,lsl 2]
 	str	w1, [x29,72]
 	ldr	w1, [x29,72]
-	tbnz	x1, 2, .L1729
+	tbnz	x1, 2, .L1753
 	ldr	w1, [x29,72]
-	tbnz	x1, 15, .L1729
+	tbnz	x1, 15, .L1753
 	ldr	w3, [x29,72]
 	ubfx	x5, x3, 3, 5
 	ldr	w3, [x29,72]
@@ -10794,26 +10988,26 @@ nandc_xfer:
 	orr	w1, w4, w1, lsl 5
 	cmp	w3, w1
 	ldr	w1, [x29,72]
-	bls	.L1721
+	bls	.L1745
 	ubfx	x3, x1, 3, 5
 	ldr	w1, [x29,72]
 	ubfx	x1, x1, 27, 1
-	b	.L1742
-.L1721:
+	b	.L1766
+.L1745:
 	ubfx	x3, x1, 16, 5
 	ldr	w1, [x29,72]
 	ubfx	x1, x1, 29, 1
-.L1742:
+.L1766:
 	orr	w1, w3, w1, lsl 5
 	cmp	w0, w1
 	csel	w0, w0, w1, cs
-	b	.L1720
-.L1729:
+	b	.L1744
+.L1753:
 	mov	w0, -1
-.L1720:
+.L1744:
 	add	w2, w2, 1
-	b	.L1719
-.L1745:
+	b	.L1743
+.L1769:
 	add	x19, x19, :lo12:.LANCHOR0
 	ldr	x1, [x19,536]
 	str	wzr, [x1,16]
@@ -10822,32 +11016,32 @@ nandc_xfer:
 	movk	w1, 0x2, lsl 16
 	and	w1, w20, w1
 	cmp	w1, 139264
-	bne	.L1714
-	adrp	x0, .LC144
+	bne	.L1738
+	adrp	x0, .LC148
 	mov	w1, w20
-	add	x0, x0, :lo12:.LC144
+	add	x0, x0, :lo12:.LC148
 	orr	w20, w20, 131072
 	bl	printk
 	ldr	x0, [x19,536]
 	str	w20, [x0]
-	b	.L1715
-.L1714:
+	b	.L1739
+.L1738:
 	cmn	w0, #1
-	beq	.L1734
+	beq	.L1758
 	ldr	w1, [x23]
 	cmn	w1, #1
-	bne	.L1734
+	bne	.L1758
 	ldr	w1, [x23,4]
 	cmn	w1, #1
-	bne	.L1734
+	bne	.L1758
 	ldr	w1, [x21]
 	cmn	w1, #1
 	mov	w1, 512
 	csel	w0, w0, w1, ne
-	b	.L1734
-.L1715:
+	b	.L1758
+.L1739:
 	mov	w0, -1
-.L1734:
+.L1758:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldr	x23, [sp,48]
@@ -10877,36 +11071,36 @@ flash_read_page:
 	and	w20, w1, 2097151
 	ubfx	x24, x23, 24, 2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 4, .L1747
-	adrp	x0, .LC145
+	tbz	x0, 4, .L1771
+	adrp	x0, .LC149
 	mov	w1, w21
-	add	x0, x0, :lo12:.LC145
+	add	x0, x0, :lo12:.LC149
 	mov	w2, w24
 	mov	w3, w23
 	bl	printk
-.L1747:
+.L1771:
 	bl	nandc_wait_flash_ready
 	mov	w0, w21
 	bl	nandc_cs
-	cbnz	w24, .L1748
+	cbnz	w24, .L1772
 	mov	w0, w21
 	bl	zftl_flash_enter_slc_mode
-	b	.L1749
-.L1748:
+	b	.L1773
+.L1772:
 	add	x0, x22, :lo12:.LANCHOR0
 	ldr	x0, [x0,624]
 	ldrb	w0, [x0,12]
 	cmp	w0, 3
-	bne	.L1750
+	bne	.L1774
 	sxtw	x0, w21
 	add	x0, x0, 8
 	add	x0, x19, x0, lsl 8
 	str	w24, [x0,8]
-	b	.L1749
-.L1750:
+	b	.L1773
+.L1774:
 	mov	w0, w21
 	bl	zftl_flash_exit_slc_mode
-.L1749:
+.L1773:
 	ubfiz	x5, x21, 8, 8
 	and	w23, w23, 255
 	add	x19, x19, x5
@@ -10920,19 +11114,19 @@ flash_read_page:
 	str	w0, [x19,2052]
 	mov	w0, 48
 	str	w0, [x19,2056]
-	cbz	w24, .L1751
+	cbz	w24, .L1775
 	add	x22, x22, :lo12:.LANCHOR0
 	ldr	x0, [x22,624]
 	ldrb	w0, [x0,12]
 	cmp	w0, 3
-	bne	.L1751
+	bne	.L1775
 	add	w20, w20, w20, lsl 1
 	sub	w0, w20, #1
 	add	w0, w0, w24
-	b	.L1762
-.L1751:
+	b	.L1786
+.L1775:
 	mov	w0, w20
-.L1762:
+.L1786:
 	bl	nandc_set_seed
 	bl	nandc_wait_flash_ready
 	mov	w0, 5
@@ -10989,14 +11183,14 @@ micron_read_retrial:
 	uxtb	x19, w24
 	lsl	x0, x19, 8
 	str	x0, [x29,112]
-	adrp	x0, .LC146
-	add	x0, x0, :lo12:.LC146
+	adrp	x0, .LC150
+	add	x0, x0, :lo12:.LC150
 	str	x0, [x29,104]
-.L1764:
+.L1788:
 	add	x0, x23, :lo12:.LANCHOR4
-	ldrb	w0, [x0,1208]
+	ldrb	w0, [x0,1232]
 	cmp	w20, w0
-	bcs	.L1768
+	bcs	.L1792
 	ldr	x0, [x29,112]
 	add	w27, w20, 1
 	add	x1, x22, x0
@@ -11021,7 +11215,7 @@ micron_read_retrial:
 	mov	w6, w0
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L1765
+	tbz	x0, 12, .L1789
 	ldr	x0, [x29,104]
 	mov	w4, w6
 	mov	w1, w20
@@ -11030,24 +11224,24 @@ micron_read_retrial:
 	str	x6, [x29,96]
 	bl	printk
 	ldr	x6, [x29,96]
-.L1765:
+.L1789:
 	cmn	w6, #1
-	beq	.L1766
+	beq	.L1790
 	adrp	x0, .LANCHOR4
 	cmn	w28, #1
 	add	x0, x0, :lo12:.LANCHOR4
 	csel	w28, w28, w6, ne
-	ldr	x25, [x0,1184]
-	ldr	x26, [x0,1200]
+	ldr	x25, [x0,1208]
+	ldr	x26, [x0,1224]
 	ldr	w0, [x29,124]
 	cmp	w6, w0
-	bcc	.L1773
-.L1766:
+	bcc	.L1797
+.L1790:
 	mov	w20, w27
-	b	.L1764
-.L1773:
+	b	.L1788
+.L1797:
 	mov	w28, w6
-.L1768:
+.L1792:
 	add	x19, x22, x19, lsl 8
 	mov	w0, 239
 	str	w0, [x19,2056]
@@ -11061,24 +11255,24 @@ micron_read_retrial:
 	str	wzr, [x19,2048]
 	str	wzr, [x19,2048]
 	cmp	w28, w0
-	bcc	.L1770
+	bcc	.L1794
 	cmn	w28, #1
 	mov	w0, 256
 	csel	w28, w28, w0, eq
-.L1770:
+.L1794:
 	cmn	w28, #1
-	beq	.L1774
+	beq	.L1798
 	cmp	w28, 256
-	bne	.L1771
-.L1774:
-	adrp	x0, .LC147
+	bne	.L1795
+.L1798:
+	adrp	x0, .LC151
 	mov	w1, w20
-	add	x0, x0, :lo12:.LC147
+	add	x0, x0, :lo12:.LC151
 	mov	w2, w21
 	mov	w3, w20
 	mov	w4, w28
 	bl	printk
-.L1771:
+.L1795:
 	bl	nandc_wait_flash_ready
 	mov	w0, w28
 	ldp	x19, x20, [sp,16]
@@ -11124,19 +11318,19 @@ toshiba_3d_read_retrial:
 	cmp	w1, 36
 	mov	w1, 26
 	csel	w21, w21, w1, ne
-	cbnz	w19, .L1788
+	cbnz	w19, .L1812
 	str	x0, [x29,112]
-	adrp	x0, .LC148
-	add	x0, x0, :lo12:.LC148
+	adrp	x0, .LC152
+	add	x0, x0, :lo12:.LC152
 	mov	w19, -1
 	mov	w28, 1
 	str	x0, [x29,104]
-.L1795:
+.L1819:
 	add	x0, x20, :lo12:.LANCHOR0
 	ldrb	w0, [x0,725]
 	cmp	w0, 36
 	mov	x0, x23
-	bne	.L1789
+	bne	.L1813
 	mov	w1, w28
 	mov	w2, 0
 	bl	toshiba_tlc_set_rr_para
@@ -11144,11 +11338,11 @@ toshiba_3d_read_retrial:
 	mov	w1, 93
 	add	x0, x25, x0
 	str	w1, [x0,8]
-	b	.L1790
-.L1789:
+	b	.L1814
+.L1813:
 	mov	w1, w28
 	bl	toshiba_3d_set_slc_rr_para
-.L1790:
+.L1814:
 	ldr	w4, [x29,124]
 	mov	w0, w22
 	mov	w1, w24
@@ -11158,7 +11352,7 @@ toshiba_3d_read_retrial:
 	mov	w4, w0
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 4, .L1791
+	tbz	x0, 4, .L1815
 	ldr	x0, [x29,104]
 	mov	w3, w4
 	mov	w1, w28
@@ -11166,66 +11360,66 @@ toshiba_3d_read_retrial:
 	str	x4, [x29,96]
 	bl	printk
 	ldr	x4, [x29,96]
-.L1791:
+.L1815:
 	cmn	w4, #1
-	beq	.L1792
+	beq	.L1816
 	adrp	x0, .LANCHOR4
 	cmn	w19, #1
 	add	x0, x0, :lo12:.LANCHOR4
 	csel	w19, w19, w4, ne
-	ldr	x26, [x0,1184]
-	ldr	x27, [x0,1200]
+	ldr	x26, [x0,1208]
+	ldr	x27, [x0,1224]
 	add	x0, x20, :lo12:.LANCHOR0
 	ldrb	w0, [x0,724]
 	add	w0, w0, w0, lsl 1
 	cmp	w4, w0, lsr 2
-	bcc	.L1811
-.L1792:
+	bcc	.L1835
+.L1816:
 	add	w28, w28, 1
 	cmp	w28, w21
-	bne	.L1795
-	b	.L1794
-.L1811:
+	bne	.L1819
+	b	.L1818
+.L1835:
 	mov	w21, w28
 	mov	w19, w4
-.L1794:
+.L1818:
 	add	x0, x20, :lo12:.LANCHOR0
 	ldrb	w0, [x0,725]
 	cmp	w0, 36
 	mov	x0, x23
-	bne	.L1796
+	bne	.L1820
 	mov	w1, 0
 	mov	w2, w1
-	b	.L1834
-.L1796:
+	b	.L1858
+.L1820:
 	mov	w1, 0
 	bl	toshiba_3d_set_slc_rr_para
-	b	.L1797
-.L1788:
+	b	.L1821
+.L1812:
 	mov	x28, x0
-	adrp	x0, .LC149
-	add	x0, x0, :lo12:.LC149
+	adrp	x0, .LC153
+	add	x0, x0, :lo12:.LC153
 	mov	w19, -1
 	mov	w21, 1
 	str	x0, [x29,104]
-.L1804:
+.L1828:
 	add	x0, x20, :lo12:.LANCHOR0
 	ldrb	w0, [x0,725]
 	cmp	w0, 36
 	mov	x0, x23
-	bne	.L1798
+	bne	.L1822
 	mov	w1, w21
 	mov	w2, 1
 	bl	toshiba_tlc_set_rr_para
 	add	x0, x25, x28
 	mov	w1, 93
-	b	.L1833
-.L1798:
+	b	.L1857
+.L1822:
 	mov	w1, w21
 	bl	toshiba_3d_set_tlc_rr_para
 	add	x0, x25, x28
 	mov	w1, 38
-.L1833:
+.L1857:
 	str	w1, [x0,8]
 	mov	x2, x26
 	mov	w0, w22
@@ -11236,7 +11430,7 @@ toshiba_3d_read_retrial:
 	mov	w4, w0
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 4, .L1800
+	tbz	x0, 4, .L1824
 	ldr	x0, [x29,104]
 	mov	w3, w4
 	mov	w1, w21
@@ -11244,47 +11438,47 @@ toshiba_3d_read_retrial:
 	str	x4, [x29,96]
 	bl	printk
 	ldr	x4, [x29,96]
-.L1800:
+.L1824:
 	cmn	w4, #1
-	beq	.L1801
+	beq	.L1825
 	adrp	x0, .LANCHOR4
 	cmn	w19, #1
 	add	x0, x0, :lo12:.LANCHOR4
 	csel	w19, w19, w4, ne
-	ldr	x26, [x0,1184]
-	ldr	x27, [x0,1200]
+	ldr	x26, [x0,1208]
+	ldr	x27, [x0,1224]
 	add	x0, x20, :lo12:.LANCHOR0
 	ldrb	w0, [x0,724]
 	add	w0, w0, w0, lsl 1
 	cmp	w4, w0, lsr 2
-	bcc	.L1812
-.L1801:
+	bcc	.L1836
+.L1825:
 	ldr	w0, [x29,112]
 	add	w21, w21, 1
 	cmp	w21, w0
-	bne	.L1804
-	b	.L1803
-.L1812:
+	bne	.L1828
+	b	.L1827
+.L1836:
 	mov	w19, w4
-.L1803:
+.L1827:
 	add	x0, x20, :lo12:.LANCHOR0
 	ldrb	w0, [x0,725]
 	cmp	w0, 36
 	mov	x0, x23
-	bne	.L1805
+	bne	.L1829
 	mov	w1, 0
 	mov	w2, 1
-.L1834:
+.L1858:
 	bl	toshiba_tlc_set_rr_para
-	b	.L1797
-.L1805:
+	b	.L1821
+.L1829:
 	mov	w1, 0
 	bl	toshiba_3d_set_tlc_rr_para
-.L1797:
+.L1821:
 	add	x0, x20, :lo12:.LANCHOR0
 	ldrb	w0, [x0,725]
 	cmp	w0, 36
-	bne	.L1806
+	bne	.L1830
 	ubfiz	x22, x22, 8, 8
 	mov	w0, 85
 	add	x25, x25, x22
@@ -11293,29 +11487,29 @@ toshiba_3d_read_retrial:
 	str	wzr, [x25,2052]
 	str	wzr, [x25,2048]
 	str	w0, [x25,2056]
-.L1806:
+.L1830:
 	add	x20, x20, :lo12:.LANCHOR0
 	ldrb	w0, [x20,724]
 	add	w0, w0, w0, lsl 1
 	cmp	w19, w0, lsr 2
-	bcc	.L1807
+	bcc	.L1831
 	cmn	w19, #1
 	mov	w0, 256
 	csel	w19, w19, w0, eq
-.L1807:
+.L1831:
 	cmn	w19, #1
-	beq	.L1813
+	beq	.L1837
 	cmp	w19, 256
-	bne	.L1808
-.L1813:
-	adrp	x0, .LC150
+	bne	.L1832
+.L1837:
+	adrp	x0, .LC154
 	mov	w1, w21
-	add	x0, x0, :lo12:.LC150
+	add	x0, x0, :lo12:.LC154
 	mov	w2, w24
 	mov	w3, w21
 	mov	w4, w19
 	bl	printk
-.L1808:
+.L1832:
 	bl	nandc_wait_flash_ready
 	mov	w0, w19
 	ldp	x19, x20, [sp,16]
@@ -11355,20 +11549,20 @@ toshiba_read_retrial:
 	add	x21, x22, x21, lsl 8
 	uxtb	w0, w0
 	cmp	w0, 1
-	bls	.L1836
+	bls	.L1860
 	ldrb	w0, [x1,672]
-	cbz	w0, .L1837
+	cbz	w0, .L1861
 	mov	w0, 1
 	mov	w25, 1
 	bl	nandc_set_if_mode
-.L1837:
+.L1861:
 	ubfiz	x0, x23, 8, 8
 	mov	w1, 92
 	add	x0, x22, x0
 	str	w1, [x0,2056]
 	mov	w1, 197
 	str	w1, [x0,2056]
-.L1836:
+.L1860:
 	ldr	x0, [x29,112]
 	mov	w20, 1
 	mov	w24, -1
@@ -11377,13 +11571,13 @@ toshiba_read_retrial:
 	str	x0, [x29,104]
 	ubfiz	x0, x23, 8, 8
 	str	x0, [x29,96]
-.L1838:
+.L1862:
 	adrp	x0, .LANCHOR4
 	add	x0, x0, :lo12:.LANCHOR4
-	ldrb	w0, [x0,1208]
+	ldrb	w0, [x0,1232]
 	add	w0, w0, 1
 	cmp	w20, w0
-	bcs	.L1869
+	bcs	.L1893
 	add	x0, x19, :lo12:.LANCHOR0
 	mov	w1, w20
 	ldrb	w0, [x0,725]
@@ -11391,27 +11585,27 @@ toshiba_read_retrial:
 	uxtb	w0, w0
 	cmp	w0, 1
 	mov	x0, x21
-	bhi	.L1839
+	bhi	.L1863
 	bl	sandisk_set_rr_para
-	b	.L1840
-.L1839:
+	b	.L1864
+.L1863:
 	bl	toshiba_set_rr_para
-.L1840:
+.L1864:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrb	w0, [x0,725]
 	cmp	w0, 34
-	bne	.L1841
+	bne	.L1865
 	adrp	x0, .LANCHOR4
 	add	x0, x0, :lo12:.LANCHOR4
-	ldrb	w0, [x0,1208]
+	ldrb	w0, [x0,1232]
 	sub	w0, w0, #3
 	cmp	w20, w0
-	bne	.L1841
+	bne	.L1865
 	ldr	x0, [x29,104]
 	mov	w1, 179
 	add	x0, x22, x0
 	str	w1, [x0,8]
-.L1841:
+.L1865:
 	ldr	x0, [x29,96]
 	mov	w1, 38
 	ldr	w4, [x29,120]
@@ -11426,24 +11620,24 @@ toshiba_read_retrial:
 	bl	flash_read_page
 	cmn	w0, #1
 	mov	w28, w0
-	beq	.L1844
+	beq	.L1868
 	cmn	w24, #1
 	csel	w24, w24, w0, ne
 	adrp	x0, .LANCHOR4
 	add	x0, x0, :lo12:.LANCHOR4
-	ldr	x26, [x0,1184]
-	ldr	x27, [x0,1200]
+	ldr	x26, [x0,1208]
+	ldr	x27, [x0,1224]
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrb	w0, [x0,724]
 	add	w0, w0, w0, lsl 1
 	cmp	w28, w0, lsr 2
-	bcc	.L1846
-.L1844:
+	bcc	.L1870
+.L1868:
 	add	w20, w20, 1
-	b	.L1838
-.L1869:
+	b	.L1862
+.L1893:
 	mov	w28, w24
-.L1846:
+.L1870:
 	add	x0, x19, :lo12:.LANCHOR0
 	mov	w1, 0
 	ldrb	w0, [x0,725]
@@ -11451,12 +11645,12 @@ toshiba_read_retrial:
 	uxtb	w0, w0
 	cmp	w0, 1
 	mov	x0, x21
-	bhi	.L1848
+	bhi	.L1872
 	bl	sandisk_set_rr_para
-	b	.L1849
-.L1848:
+	b	.L1873
+.L1872:
 	bl	toshiba_set_rr_para
-.L1849:
+.L1873:
 	ldr	x0, [x29,112]
 	add	x19, x19, :lo12:.LANCHOR0
 	add	x0, x0, 8
@@ -11466,29 +11660,29 @@ toshiba_read_retrial:
 	ldrb	w0, [x19,724]
 	add	w0, w0, w0, lsl 1
 	cmp	w28, w0, lsr 2
-	bcc	.L1850
+	bcc	.L1874
 	cmn	w28, #1
 	mov	w0, 256
 	csel	w28, w28, w0, eq
-.L1850:
+.L1874:
 	cmn	w28, #1
-	beq	.L1856
+	beq	.L1880
 	cmp	w28, 256
-	bne	.L1851
-.L1856:
-	adrp	x0, .LC150
+	bne	.L1875
+.L1880:
+	adrp	x0, .LC154
 	ldr	w2, [x29,124]
-	add	x0, x0, :lo12:.LC150
+	add	x0, x0, :lo12:.LC154
 	mov	w1, w20
 	mov	w3, w20
 	mov	w4, w28
 	bl	printk
-.L1851:
+.L1875:
 	bl	nandc_wait_flash_ready
-	cbz	w25, .L1853
+	cbz	w25, .L1877
 	mov	w0, 4
 	bl	nandc_set_if_mode
-.L1853:
+.L1877:
 	mov	w0, w28
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
@@ -11526,9 +11720,9 @@ hynix_read_retrial:
 	bl	nandc_wait_flash_ready
 	mov	w6, 0
 	adrp	x7, .LANCHOR4
-.L1871:
+.L1895:
 	cmp	w6, w24
-	bcs	.L1875
+	bcs	.L1899
 	add	w20, w20, 1
 	mov	w0, w22
 	str	x7, [x29,104]
@@ -11547,47 +11741,47 @@ hynix_read_retrial:
 	cmn	w0, #1
 	ldr	x6, [x29,112]
 	ldr	x7, [x29,104]
-	beq	.L1873
+	beq	.L1897
 	add	x1, x7, :lo12:.LANCHOR4
 	cmn	w19, #1
 	csel	w19, w19, w0, ne
-	ldr	x25, [x1,1184]
-	ldr	x26, [x1,1200]
+	ldr	x25, [x1,1208]
+	ldr	x26, [x1,1224]
 	add	x1, x28, :lo12:.LANCHOR0
 	ldrb	w1, [x1,724]
 	add	w1, w1, w1, lsl 1
 	cmp	w0, w1, lsr 2
-	bcc	.L1880
-.L1873:
+	bcc	.L1904
+.L1897:
 	add	w6, w6, 1
-	b	.L1871
-.L1880:
+	b	.L1895
+.L1904:
 	mov	w19, w0
-.L1875:
+.L1899:
 	add	x28, x28, :lo12:.LANCHOR0
 	add	x21, x27, x21
 	ldrb	w0, [x28,724]
 	strb	w20, [x21,8]
 	add	w0, w0, w0, lsl 1
 	cmp	w19, w0, lsr 2
-	bcc	.L1877
+	bcc	.L1901
 	cmn	w19, #1
 	mov	w0, 256
 	csel	w19, w19, w0, eq
-.L1877:
+.L1901:
 	cmn	w19, #1
-	beq	.L1881
+	beq	.L1905
 	cmp	w19, 256
-	bne	.L1878
-.L1881:
-	adrp	x0, .LC151
+	bne	.L1902
+.L1905:
+	adrp	x0, .LC155
 	mov	w1, w6
-	add	x0, x0, :lo12:.LC151
+	add	x0, x0, :lo12:.LC155
 	mov	w2, w23
 	mov	w3, w6
 	mov	w4, w19
 	bl	printk
-.L1878:
+.L1902:
 	bl	nandc_wait_flash_ready
 	mov	w0, w19
 	ldp	x19, x20, [sp,16]
@@ -11617,16 +11811,16 @@ flash_ddr_tuning_read:
 	bl	nandc_get_ddr_para
 	mov	w27, 0
 	str	w0, [x29,116]
-	adrp	x0, .LC152
+	adrp	x0, .LC156
 	str	w27, [x29,124]
-	add	x0, x0, :lo12:.LC152
+	add	x0, x0, :lo12:.LC156
 	mov	w25, w27
 	mov	w28, w27
 	mov	w19, 1024
 	mov	w26, 6
 	mov	w21, -1
 	str	x0, [x29,104]
-.L1896:
+.L1920:
 	mov	w0, w26
 	bl	nandc_set_ddr_para
 	ldr	w4, [x29,120]
@@ -11638,7 +11832,7 @@ flash_ddr_tuning_read:
 	mov	w4, w0
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 4, .L1891
+	tbz	x0, 4, .L1915
 	ldr	x0, [x29,104]
 	mov	w3, w4
 	mov	w1, w26
@@ -11646,73 +11840,73 @@ flash_ddr_tuning_read:
 	str	x4, [x29,96]
 	bl	printk
 	ldr	x4, [x29,96]
-.L1891:
+.L1915:
 	add	w0, w19, 1
 	cmp	w4, w0
-	bhi	.L1892
+	bhi	.L1916
 	adrp	x0, .LANCHOR4
 	add	x0, x0, :lo12:.LANCHOR4
-	ldr	x24, [x0,1184]
-	ldr	x23, [x0,1200]
+	ldr	x24, [x0,1208]
+	ldr	x23, [x0,1224]
 	adrp	x0, .LANCHOR0
 	add	x0, x0, :lo12:.LANCHOR0
 	ldrb	w0, [x0,724]
 	cmp	w4, w0, lsr 2
-	bcs	.L1902
+	bcs	.L1926
 	add	w28, w28, 1
 	cmp	w28, 7
-	bls	.L1902
+	bls	.L1926
 	sub	w27, w26, w28
 	mov	w19, w4
 	mov	w21, 0
-	b	.L1894
-.L1892:
+	b	.L1918
+.L1916:
 	cmp	w25, w28
-	bcs	.L1903
+	bcs	.L1927
 	sub	w0, w27, w28
 	cmp	w28, 7
 	str	w0, [x29,124]
-	bhi	.L1895
+	bhi	.L1919
 	mov	w25, w28
-	b	.L1903
-.L1902:
+	b	.L1927
+.L1926:
 	mov	w27, w26
 	mov	w19, w4
 	mov	w21, 0
-	b	.L1893
-.L1903:
+	b	.L1917
+.L1927:
 	mov	w28, 0
-.L1893:
+.L1917:
 	add	w26, w26, 2
 	cmp	w26, 50
-	bne	.L1896
-.L1894:
+	bne	.L1920
+.L1918:
 	ldr	w0, [x29,124]
 	cmp	w25, w28
 	csel	w27, w27, w0, ls
-.L1895:
-	cbz	w27, .L1897
+.L1919:
+	cbz	w27, .L1921
 	adrp	x0, .LANCHOR0+724
 	mov	w1, 3
 	ldrb	w0, [x0,#:lo12:.LANCHOR0+724]
 	udiv	w0, w0, w1
 	cmp	w19, w0
-	bcs	.L1897
-	adrp	x0, .LC153
+	bcs	.L1921
+	adrp	x0, .LC157
 	mov	w1, w27
-	add	x0, x0, :lo12:.LC153
+	add	x0, x0, :lo12:.LC157
 	bl	printk
 	mov	w0, w27
-	b	.L1912
-.L1897:
+	b	.L1936
+.L1921:
 	ldrb	w0, [x29,116]
-.L1912:
+.L1936:
 	bl	nandc_set_ddr_para
-	cbz	w21, .L1899
-	adrp	x0, .LC154
+	cbz	w21, .L1923
+	adrp	x0, .LC158
 	mov	w2, w22
 	mov	w1, w20
-	add	x0, x0, :lo12:.LC154
+	add	x0, x0, :lo12:.LC158
 	adrp	x26, .LANCHOR0
 	bl	printk
 	add	x27, x26, :lo12:.LANCHOR0
@@ -11734,33 +11928,33 @@ flash_ddr_tuning_read:
 	mov	w0, w20
 	bl	flash_read_page
 	mov	w19, w0
-	adrp	x0, .LC155
+	adrp	x0, .LC159
 	mov	w1, w20
-	add	x0, x0, :lo12:.LC155
+	add	x0, x0, :lo12:.LC159
 	mov	w2, w22
 	mov	w3, w19
 	bl	printk
 	ldrb	w0, [x27,724]
 	cmp	w19, w0
-	bhi	.L1904
+	bhi	.L1928
 	adrp	x1, .LANCHOR4
 	add	x1, x1, :lo12:.LANCHOR4
-	ldr	w0, [x1,1212]
+	ldr	w0, [x1,1236]
 	add	w0, w0, 1
-	str	w0, [x1,1212]
+	str	w0, [x1,1236]
 	cmp	w0, 100
-	bls	.L1900
+	bls	.L1924
 	strb	wzr, [x27,672]
-	b	.L1899
-.L1904:
+	b	.L1923
+.L1928:
 	mov	w19, w21
-.L1900:
+.L1924:
 	add	x26, x26, :lo12:.LANCHOR0
 	ldrb	w0, [x26,780]
 	bl	flash_set_interface_mode
 	ldrb	w0, [x26,780]
 	bl	nandc_set_if_mode
-.L1899:
+.L1923:
 	mov	w0, w19
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
@@ -11789,57 +11983,57 @@ flash_read_page_en:
 	ldrb	w0, [x0,633]
 	mov	w22, w4
 	cmp	w0, w25
-	bhi	.L1914
+	bhi	.L1938
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 398
+	mov	w2, 399
 	add	x1, x1, 136
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L1914:
+.L1938:
 	add	x0, x20, :lo12:.LANCHOR0
 	add	x1, x0, x25, sxtw
 	ldrb	w21, [x1,736]
 	ldrb	w1, [x0,633]
 	cmp	w1, w25
-	bcs	.L1915
+	bcs	.L1939
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 6, .L1941
-	adrp	x0, .LC156
+	tbz	x0, 6, .L1965
+	adrp	x0, .LC160
 	mov	w1, w21
-	add	x0, x0, :lo12:.LC156
+	add	x0, x0, :lo12:.LC160
 	mov	w2, w25
 	mov	w3, w19
 	bl	printk
-.L1941:
+.L1965:
 	mov	w0, -1
-	b	.L1940
-.L1915:
+	b	.L1964
+.L1939:
 	ubfx	x1, x19, 24, 2
-	cbnz	w1, .L1918
+	cbnz	w1, .L1942
 	adrp	x1, .LANCHOR0
 	ldrb	w1, [x1,#:lo12:.LANCHOR0]
-	cbz	w1, .L1919
+	cbz	w1, .L1943
 	ldrb	w0, [x0,1]
-	cbz	w0, .L1918
-.L1919:
+	cbz	w0, .L1942
+.L1943:
 	add	x1, x20, :lo12:.LANCHOR0
 	ldrh	w2, [x1,2]
 	udiv	w0, w19, w2
 	mul	w0, w0, w2
 	ldrb	w2, [x1,1]
 	sub	w19, w19, w0
-	cbz	w2, .L1920
+	cbz	w2, .L1944
 	add	w19, w0, w19, lsl 1
-	b	.L1918
-.L1920:
+	b	.L1942
+.L1944:
 	add	x1, x1, 4
 	ldrh	w19, [x1,w19,uxtw 1]
 	add	w19, w19, w0
-.L1918:
+.L1942:
 	mov	w0, w21
 	mov	w1, w19
 	mov	x2, x24
@@ -11847,16 +12041,16 @@ flash_read_page_en:
 	mov	w4, w22
 	bl	flash_read_page
 	cmn	w0, #1
-	bne	.L1940
+	bne	.L1964
 	add	x25, x20, :lo12:.LANCHOR0
 	ldrb	w26, [x25,720]
-	cbnz	w26, .L1922
-.L1925:
-	adrp	x0, .LANCHOR4+1216
-	ldr	x5, [x0,#:lo12:.LANCHOR4+1216]
-	cbnz	x5, .L1923
-	b	.L1924
-.L1922:
+	cbnz	w26, .L1946
+.L1949:
+	adrp	x0, .LANCHOR4+1240
+	ldr	x5, [x0,#:lo12:.LANCHOR4+1240]
+	cbnz	x5, .L1947
+	b	.L1948
+.L1946:
 	mov	w0, w21
 	mov	w1, w19
 	mov	x2, x24
@@ -11866,9 +12060,9 @@ flash_read_page_en:
 	bl	flash_read_page
 	strb	w26, [x25,720]
 	cmn	w0, #1
-	beq	.L1925
-	b	.L1940
-.L1923:
+	beq	.L1949
+	b	.L1964
+.L1947:
 	mov	w0, w21
 	mov	w1, w19
 	mov	x2, x24
@@ -11876,25 +12070,25 @@ flash_read_page_en:
 	mov	w4, w22
 	blr	x5
 	cmn	w0, #1
-	bne	.L1940
-.L1924:
+	bne	.L1964
+.L1948:
 	add	x20, x20, :lo12:.LANCHOR0
-	adrp	x0, .LC157
-	add	x0, x0, :lo12:.LC157
+	adrp	x0, .LC161
+	add	x0, x0, :lo12:.LC161
 	mov	w1, 0
 	mov	w2, w19
 	mov	w3, -1
 	ldrb	w4, [x20,720]
 	bl	printk
 	ldrb	w0, [x20,672]
-	cbz	w0, .L1941
+	cbz	w0, .L1965
 	mov	w0, w21
 	mov	w1, w19
 	mov	x2, x24
 	mov	x3, x23
 	mov	w4, w22
 	bl	flash_ddr_tuning_read
-.L1940:
+.L1964:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -11910,11 +12104,11 @@ flash_get_last_written_page:
 	add	x29, sp, 0
 	stp	x23, x24, [sp,48]
 	uxtb	w23, w0
-	adrp	x0, .LANCHOR4+1084
+	adrp	x0, .LANCHOR4+1108
 	stp	x19, x20, [sp,16]
 	adrp	x20, .LANCHOR2
 	mov	x24, x2
-	ldrh	w19, [x0,#:lo12:.LANCHOR4+1084]
+	ldrh	w19, [x0,#:lo12:.LANCHOR4+1108]
 	add	x0, x20, :lo12:.LANCHOR2
 	stp	x21, x22, [sp,32]
 	stp	x25, x26, [sp,64]
@@ -11931,12 +12125,12 @@ flash_get_last_written_page:
 	add	w1, w26, w19
 	bl	flash_read_page_en
 	cmp	w0, 512
-	bne	.L1943
+	bne	.L1967
 	mov	w28, 0
 	mov	w5, 2
-.L1944:
+.L1968:
 	cmp	w28, w19
-	bgt	.L1943
+	bgt	.L1967
 	add	w0, w28, w19
 	mov	x2, x24
 	mov	x3, x21
@@ -11948,24 +12142,24 @@ flash_get_last_written_page:
 	bl	flash_read_page_en
 	cmp	w0, 512
 	ldr	x5, [x29,104]
-	bne	.L1945
+	bne	.L1969
 	sub	w19, w20, #1
 	sxth	w19, w19
-	b	.L1944
-.L1945:
+	b	.L1968
+.L1969:
 	add	w20, w20, 1
 	sxth	w28, w20
-	b	.L1944
-.L1943:
+	b	.L1968
+.L1967:
 	ldr	w0, [x27,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L1948
-	adrp	x0, .LC158
+	tbz	x0, 12, .L1972
+	adrp	x0, .LC162
 	ldr	w3, [x21]
-	add	x0, x0, :lo12:.LC158
+	add	x0, x0, :lo12:.LC162
 	mov	w1, w22
 	mov	w2, w19
 	bl	printk
-.L1948:
+.L1972:
 	mov	w0, w19
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
@@ -11980,12 +12174,12 @@ flash_get_last_written_page:
 	.type	flash_get_last_written_page_ext, %function
 flash_get_last_written_page_ext:
 	uxth	w6, w0
-	adrp	x0, .LANCHOR0+3340
+	adrp	x0, .LANCHOR0+3264
 	stp	x29, x30, [sp, -16]!
 	mov	w5, 21
 	mov	x8, x1
 	add	x29, sp, 0
-	ldrh	w0, [x0,#:lo12:.LANCHOR0+3340]
+	ldrh	w0, [x0,#:lo12:.LANCHOR0+3264]
 	mov	x7, x2
 	mov	w4, w3
 	mov	x2, x8
@@ -12021,33 +12215,33 @@ flash_ddr_para_scan:
 	bl	flash_set_interface_mode
 	ldrb	w0, [x21,780]
 	bl	nandc_set_if_mode
-	ldr	x2, [x20,1224]
+	ldr	x2, [x20,1248]
 	mov	w1, w23
-	ldr	x3, [x20,1232]
+	ldr	x3, [x20,1256]
 	mov	w4, 4
 	mov	w0, w24
 	bl	flash_ddr_tuning_read
-	ldr	x2, [x20,1224]
+	ldr	x2, [x20,1248]
 	mov	w0, w24
-	ldr	x3, [x20,1232]
+	ldr	x3, [x20,1256]
 	mov	w1, w23
 	mov	w4, 4
 	bl	flash_read_page
 	cmn	w0, #1
-	bne	.L1954
+	bne	.L1978
 	ldrb	w0, [x21,780]
-	tbz	x0, 0, .L1954
+	tbz	x0, 0, .L1978
 	mov	w0, 1
 	bl	flash_set_interface_mode
 	mov	w0, w22
 	bl	nandc_set_if_mode
 	strb	wzr, [x21,672]
-	b	.L1955
-.L1954:
+	b	.L1979
+.L1978:
 	add	x19, x19, :lo12:.LANCHOR0
 	mov	w0, 1
 	strb	w0, [x19,672]
-.L1955:
+.L1979:
 	mov	w0, 0
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
@@ -12056,8 +12250,8 @@ flash_ddr_para_scan:
 	ret
 	.size	flash_ddr_para_scan, .-flash_ddr_para_scan
 	.align	2
-	.type	id_block_read_data.constprop.32, %function
-id_block_read_data.constprop.32:
+	.type	id_block_read_data.constprop.30, %function
+id_block_read_data.constprop.30:
 	stp	x29, x30, [sp, -240]!
 	add	x29, sp, 0
 	stp	x25, x26, [sp,64]
@@ -12093,14 +12287,14 @@ id_block_read_data.constprop.32:
 	ldr	w0, [x29,172]
 	and	w0, w0, 3
 	str	w0, [x29,168]
-	adrp	x0, .LC159
-	add	x0, x0, :lo12:.LC159
+	adrp	x0, .LC163
+	add	x0, x0, :lo12:.LC163
 	str	x0, [x29,112]
-.L1960:
+.L1984:
 	cmp	w22, w27
-	bcs	.L1997
+	bcs	.L2021
 	ldr	w0, [x29,168]
-	ldrb	w1, [x19,782]
+	ldrb	w1, [x19,634]
 	sub	w0, w23, w0
 	uxth	w0, w0
 	str	w0, [x29,144]
@@ -12110,15 +12304,15 @@ id_block_read_data.constprop.32:
 	udiv	w20, w20, w23
 	and	w20, w20, 65535
 	ldrh	w0, [x0,w20,sxtw 1]
-	cbnz	w1, .L1961
+	cbnz	w1, .L1985
 	mov	w20, w0
-	b	.L1962
-.L1961:
+	b	.L1986
+.L1985:
 	ldrb	w1, [x19,1]
 	lsl	w0, w20, 1
 	cmp	w1, wzr
 	csel	w20, w0, w20, ne
-.L1962:
+.L1986:
 	ldr	w1, [x29,160]
 	ldr	w0, [x29,164]
 	ldrb	w28, [x19,632]
@@ -12133,7 +12327,7 @@ id_block_read_data.constprop.32:
 	str	w0, [x29,132]
 	mov	w0, w28
 	bl	nandc_bch_sel
-.L1963:
+.L1987:
 	mov	w0, 0
 	mov	w1, w24
 	mov	x2, x21
@@ -12142,16 +12336,16 @@ id_block_read_data.constprop.32:
 	bl	flash_read_page
 	cmn	w0, #1
 	mov	w20, w0
-	bne	.L1970
+	bne	.L1994
 	ldrb	w6, [x19,720]
-	cbnz	w6, .L1965
-.L1968:
+	cbnz	w6, .L1989
+.L1992:
 	adrp	x0, .LANCHOR4
 	add	x0, x0, :lo12:.LANCHOR4
-	ldr	x6, [x0,1216]
-	cbnz	x6, .L1966
-	b	.L1967
-.L1965:
+	ldr	x6, [x0,1240]
+	cbnz	x6, .L1990
+	b	.L1991
+.L1989:
 	mov	w0, 0
 	mov	w1, w24
 	mov	x2, x21
@@ -12163,9 +12357,9 @@ id_block_read_data.constprop.32:
 	cmn	w0, #1
 	ldr	x6, [x29,104]
 	strb	w6, [x19,720]
-	beq	.L1968
-	b	.L1996
-.L1966:
+	beq	.L1992
+	b	.L2020
+.L1990:
 	mov	w0, 0
 	mov	w1, w24
 	mov	x2, x21
@@ -12173,28 +12367,28 @@ id_block_read_data.constprop.32:
 	mov	w4, w23
 	blr	x6
 	cmn	w0, #1
-	bne	.L1996
-.L1967:
+	bne	.L2020
+.L1991:
 	ldrb	w0, [x19,672]
-	cbz	w0, .L1970
+	cbz	w0, .L1994
 	mov	w0, 0
 	mov	w1, w24
 	mov	x2, x21
 	add	x3, x29, 176
 	mov	w4, w23
 	bl	flash_ddr_tuning_read
-.L1996:
+.L2020:
 	mov	w20, w0
-.L1970:
+.L1994:
 	cmn	w20, #1
-	bne	.L1971
+	bne	.L1995
 	cmp	w28, 16
-	beq	.L1971
+	beq	.L1995
 	mov	w0, 16
 	mov	w28, 16
 	bl	nandc_bch_sel
-	b	.L1963
-.L1971:
+	b	.L1987
+.L1995:
 	ldr	w0, [x29,132]
 	bl	nandc_bch_sel
 	cmn	w20, #1
@@ -12205,18 +12399,18 @@ id_block_read_data.constprop.32:
 	cmp	w0, w26
 	cset	w0, eq
 	tst	w1, w0
-	beq	.L1973
-	cbnz	w25, .L1973
+	beq	.L1997
+	cbnz	w25, .L1997
 	ldr	w1, [x21]
 	mov	w0, 18766
 	movk	w0, 0x464e, lsl 16
 	cmp	w1, w0
-	bne	.L1973
+	bne	.L1997
 	ldr	w0, [x29,144]
 	ldrb	w23, [x21,17]
 	add	w27, w27, w0
-	b	.L1974
-.L1973:
+	b	.L1998
+.L1997:
 	ldr	x0, [x29,144]
 	mov	w2, w22
 	ldr	w1, [x29,140]
@@ -12227,12 +12421,12 @@ id_block_read_data.constprop.32:
 	ldr	x0, [x29,112]
 	bl	printk
 	str	wzr, [x29,168]
-.L1974:
+.L1998:
 	ldr	w0, [x29,144]
 	add	w22, w0, w22
 	uxth	w22, w22
-	b	.L1960
-.L1997:
+	b	.L1984
+.L2021:
 	ldr	x0, [x29,120]
 	ldrb	w1, [x29,136]
 	add	x0, x0, :lo12:.LANCHOR0
@@ -12245,7 +12439,7 @@ id_block_read_data.constprop.32:
 	ldp	x27, x28, [sp,80]
 	ldp	x29, x30, [sp], 240
 	ret
-	.size	id_block_read_data.constprop.32, .-id_block_read_data.constprop.32
+	.size	id_block_read_data.constprop.30, .-id_block_read_data.constprop.30
 	.align	2
 	.global	flash_complete_plane_page_read
 	.type	flash_complete_plane_page_read, %function
@@ -12265,27 +12459,27 @@ flash_complete_plane_page_read:
 	mov	x23, x2
 	ldrb	w0, [x0,633]
 	cmp	w0, w22
-	bhi	.L1999
+	bhi	.L2023
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 886
+	mov	w2, 887
 	add	x1, x1, 160
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L1999:
+.L2023:
 	add	x0, x21, :lo12:.LANCHOR0
 	add	x22, x0, x22, sxtw
 	ldrb	w22, [x22,736]
 	ldr	x25, [x0,536]
 	mov	w0, w22
 	bl	nandc_cs
-	cbnz	w20, .L2000
+	cbnz	w20, .L2024
 	mov	w0, w19
 	bl	slc_phy_page_address_calc
 	mov	w19, w0
-.L2000:
+.L2024:
 	add	x3, x21, :lo12:.LANCHOR0
 	uxtb	x5, w22
 	and	w2, w19, 255
@@ -12293,26 +12487,26 @@ flash_complete_plane_page_read:
 	ldrb	w0, [x3,656]
 	cmp	w0, 1
 	lsr	w0, w19, 16
-	bne	.L2001
+	bne	.L2025
 	add	x5, x25, x5, lsl 8
 	mov	w3, 6
-	b	.L2014
-.L2001:
+	b	.L2038
+.L2025:
 	ldr	x3, [x3,624]
 	add	x5, x25, x5, lsl 8
 	ldrb	w3, [x3,12]
 	cmp	w3, 3
-	bne	.L2003
+	bne	.L2027
 	mov	w3, 5
-.L2014:
+.L2038:
 	str	w3, [x5,2056]
 	str	wzr, [x5,2052]
 	str	wzr, [x5,2052]
 	str	w2, [x5,2052]
 	str	w1, [x5,2052]
 	str	w0, [x5,2052]
-	b	.L2012
-.L2003:
+	b	.L2036
+.L2027:
 	str	wzr, [x5,2056]
 	str	wzr, [x5,2052]
 	str	wzr, [x5,2052]
@@ -12323,22 +12517,22 @@ flash_complete_plane_page_read:
 	str	w0, [x5,2056]
 	str	wzr, [x5,2052]
 	str	wzr, [x5,2052]
-.L2012:
+.L2036:
 	mov	w0, 224
 	str	w0, [x5,2056]
-	cbz	w20, .L2004
+	cbz	w20, .L2028
 	add	x21, x21, :lo12:.LANCHOR0
 	ldr	x0, [x21,624]
 	ldrb	w0, [x0,12]
 	cmp	w0, 3
-	bne	.L2004
+	bne	.L2028
 	sub	w20, w20, #1
 	add	w0, w19, w19, lsl 1
 	add	w0, w20, w0
-	b	.L2013
-.L2004:
+	b	.L2037
+.L2028:
 	mov	w0, w19
-.L2013:
+.L2037:
 	bl	nandc_set_seed
 	adrp	x2, .LANCHOR2+17
 	mov	x3, x24
@@ -12379,27 +12573,27 @@ flash_complete_page_read:
 	mov	x26, x2
 	ubfx	x22, x24, 24, 2
 	cmp	w0, w21
-	bhi	.L2016
+	bhi	.L2040
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 1008
+	mov	w2, 1009
 	add	x1, x1, 192
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L2016:
+.L2040:
 	add	x0, x19, :lo12:.LANCHOR0
 	add	x21, x0, x21, sxtw
 	ldrb	w23, [x21,736]
 	ldr	x21, [x0,536]
 	mov	w0, w23
 	bl	nandc_cs
-	cbnz	w22, .L2017
+	cbnz	w22, .L2041
 	mov	w0, w20
 	bl	slc_phy_page_address_calc
 	mov	w20, w0
-.L2017:
+.L2041:
 	ubfiz	x0, x23, 8, 8
 	add	x5, x21, x0
 	mov	w0, 5
@@ -12414,19 +12608,19 @@ flash_complete_page_read:
 	str	w0, [x5,2052]
 	mov	w0, 224
 	str	w0, [x5,2056]
-	cbz	w22, .L2018
+	cbz	w22, .L2042
 	add	x0, x19, :lo12:.LANCHOR0
 	ldr	x0, [x0,624]
 	ldrb	w0, [x0,12]
 	cmp	w0, 3
-	bne	.L2018
+	bne	.L2042
 	sub	w0, w22, #1
 	add	w1, w20, w20, lsl 1
 	add	w0, w0, w1
-	b	.L2050
-.L2018:
+	b	.L2074
+.L2042:
 	mov	w0, w20
-.L2050:
+.L2074:
 	adrp	x21, .LANCHOR2
 	bl	nandc_set_seed
 	add	x27, x21, :lo12:.LANCHOR2
@@ -12438,10 +12632,10 @@ flash_complete_page_read:
 	ldrb	w2, [x27,9]
 	bl	nandc_xfer
 	cmn	w0, #1
-	bne	.L2020
+	bne	.L2044
 	add	x28, x19, :lo12:.LANCHOR0
 	ldrb	w5, [x28,720]
-	cbz	w5, .L2021
+	cbz	w5, .L2045
 	ldrb	w4, [x27,9]
 	mov	w0, w23
 	orr	w1, w20, w22, lsl 24
@@ -12452,15 +12646,15 @@ flash_complete_page_read:
 	bl	flash_read_page
 	ldr	x5, [x29,104]
 	strb	w5, [x28,720]
-	cbnz	w22, .L2022
-.L2029:
+	cbnz	w22, .L2046
+.L2053:
 	ldrb	w2, [x19,#:lo12:.LANCHOR0]
 	add	x1, x19, :lo12:.LANCHOR0
-	cbz	w2, .L2022
+	cbz	w2, .L2046
 	ldrb	w1, [x1,724]
 	add	w1, w1, w1, lsl 1
 	cmp	w0, w1, lsr 2
-	blt	.L2022
+	blt	.L2046
 	add	x21, x21, :lo12:.LANCHOR2
 	ldrb	w1, [x21,27]
 	sub	w1, w1, #4
@@ -12468,28 +12662,28 @@ flash_complete_page_read:
 	cmp	w1, 4
 	mov	w1, 256
 	csel	w0, w0, w1, hi
-	b	.L2037
-.L2022:
+	b	.L2061
+.L2046:
 	cmn	w0, #1
-	bne	.L2037
-.L2030:
-	adrp	x0, .LANCHOR4+1216
-	ldr	x5, [x0,#:lo12:.LANCHOR4+1216]
-	cbnz	x5, .L2025
-.L2028:
+	bne	.L2061
+.L2054:
+	adrp	x0, .LANCHOR4+1240
+	ldr	x5, [x0,#:lo12:.LANCHOR4+1240]
+	cbnz	x5, .L2049
+.L2052:
 	add	x19, x19, :lo12:.LANCHOR0
-	adrp	x0, .LC160
-	add	x0, x0, :lo12:.LC160
+	adrp	x0, .LC164
+	add	x0, x0, :lo12:.LC164
 	mov	w1, 0
 	mov	w2, w24
 	mov	w3, -1
 	ldrb	w4, [x19,720]
 	bl	printk
 	ldrb	w0, [x19,672]
-	cbnz	w0, .L2026
+	cbnz	w0, .L2050
 	mov	w0, -1
-	b	.L2037
-.L2025:
+	b	.L2061
+.L2049:
 	add	x4, x21, :lo12:.LANCHOR2
 	mov	w0, w23
 	orr	w1, w20, w22, lsl 24
@@ -12498,9 +12692,9 @@ flash_complete_page_read:
 	ldrb	w4, [x4,17]
 	blr	x5
 	cmn	w0, #1
-	bne	.L2037
-	b	.L2028
-.L2026:
+	bne	.L2061
+	b	.L2052
+.L2050:
 	add	x21, x21, :lo12:.LANCHOR2
 	mov	w0, w23
 	orr	w1, w20, w22, lsl 24
@@ -12508,14 +12702,14 @@ flash_complete_page_read:
 	mov	x3, x26
 	ldrb	w4, [x21,17]
 	bl	flash_ddr_tuning_read
-	b	.L2037
-.L2020:
-	cbz	w22, .L2029
-	b	.L2037
-.L2021:
-	cbz	w22, .L2029
-	b	.L2030
-.L2037:
+	b	.L2061
+.L2044:
+	cbz	w22, .L2053
+	b	.L2061
+.L2045:
+	cbz	w22, .L2053
+	b	.L2054
+.L2061:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -12536,164 +12730,161 @@ queue_wait_first_req_completed:
 	stp	x23, x24, [sp,48]
 	stp	x25, x26, [sp,64]
 	stp	x27, x28, [sp,80]
-	ldrb	w21, [x0,2835]
-	cmp	w21, 255
-	beq	.L2135
+	ldrb	w22, [x0,2835]
+	cmp	w22, 255
+	beq	.L2169
 	add	x0, x0, 784
-	mov	w1, 0
-	add	x0, x0, x21, lsl 6
+	mov	w20, 0
+	add	x0, x0, x22, lsl 6
 	ldrb	w2, [x0,58]
-	ldr	w20, [x0,40]
-	sub	w3, w2, #1
-	cmp	w3, 10
-	bhi	.L2053
-	adrp	x0, .L2055
-	add	x0, x0, :lo12:.L2055
-	ldrh	w0, [x0,w3,uxtw #1]
-	adr	x1, .Lrtx2055
+	ldr	w24, [x0,40]
+	sub	w0, w2, #1
+	cmp	w0, 10
+	bhi	.L2077
+	adrp	x1, .L2079
+	add	x1, x1, :lo12:.L2079
+	ldrh	w0, [x1,w0,uxtw #1]
+	adr	x1, .Lrtx2079
 	add	x0, x1, w0, sxth #2
 	br	x0
-.Lrtx2055:
+.Lrtx2079:
 	.section	.rodata
 	.align	0
 	.align	2
-.L2055:
-	.2byte	(.L2054 - .Lrtx2055) / 4
-	.2byte	(.L2056 - .Lrtx2055) / 4
-	.2byte	(.L2057 - .Lrtx2055) / 4
-	.2byte	(.L2057 - .Lrtx2055) / 4
-	.2byte	(.L2057 - .Lrtx2055) / 4
-	.2byte	(.L2057 - .Lrtx2055) / 4
-	.2byte	(.L2058 - .Lrtx2055) / 4
-	.2byte	(.L2059 - .Lrtx2055) / 4
-	.2byte	(.L2060 - .Lrtx2055) / 4
-	.2byte	(.L2057 - .Lrtx2055) / 4
-	.2byte	(.L2060 - .Lrtx2055) / 4
+.L2079:
+	.2byte	(.L2078 - .Lrtx2079) / 4
+	.2byte	(.L2080 - .Lrtx2079) / 4
+	.2byte	(.L2081 - .Lrtx2079) / 4
+	.2byte	(.L2081 - .Lrtx2079) / 4
+	.2byte	(.L2081 - .Lrtx2079) / 4
+	.2byte	(.L2081 - .Lrtx2079) / 4
+	.2byte	(.L2082 - .Lrtx2079) / 4
+	.2byte	(.L2083 - .Lrtx2079) / 4
+	.2byte	(.L2084 - .Lrtx2079) / 4
+	.2byte	(.L2081 - .Lrtx2079) / 4
+	.2byte	(.L2084 - .Lrtx2079) / 4
 	.text
-.L2054:
-	mov	w0, w20
+.L2078:
+	mov	w0, w24
 	mov	w1, 64
 	bl	flash_wait_device_ready
-	tbz	x0, 6, .L2135
+	tbz	x0, 6, .L2169
 	add	x3, x19, :lo12:.LANCHOR0
-	add	x0, x3, 784
-	add	x0, x0, x21, lsl 6
-	ldr	x2, [x0,16]
-	ldr	x1, [x0,8]
-	cbz	x2, .L2062
-	ldrb	w4, [x0,56]
-	ldrb	w0, [x3,2832]
-	cmp	w4, w0
-	csel	x1, x1, x2, ne
-.L2062:
+	add	x2, x3, 784
+	add	x2, x2, x22, lsl 6
+	ldr	x0, [x2,16]
+	ldr	x1, [x2,8]
+	cbz	x0, .L2086
+	ldrb	w4, [x2,56]
+	ldrb	w2, [x3,2832]
+	cmp	w4, w2
+	csel	x1, x1, x0, ne
+.L2086:
 	add	x19, x19, :lo12:.LANCHOR0
-	mov	w0, w20
+	mov	w0, w24
 	add	x19, x19, 784
-	add	x19, x19, x21, lsl 6
+	add	x19, x19, x22, lsl 6
 	ldr	x2, [x19,24]
 	bl	flash_complete_page_read
 	str	w0, [x19,52]
 	mov	w0, 13
 	strb	w0, [x19,58]
-	ldrb	w0, [x19,2]
-	orr	w0, w0, 8
-	strb	w0, [x19,2]
-	b	.L2135
-.L2056:
-	mov	w0, w20
+	b	.L2170
+.L2080:
 	mov	w1, 64
+	mov	w0, w24
 	bl	flash_wait_device_ready
-	add	x2, x19, :lo12:.LANCHOR0
-	lsl	x4, x21, 6
-	add	x3, x2, 784
-	add	x1, x3, x4
-	ldrb	w20, [x3,x4]
-	tbz	x0, 6, .L2135
+	add	x1, x19, :lo12:.LANCHOR0
+	lsl	x2, x22, 6
+	add	x3, x1, 784
+	add	x4, x3, x2
+	ldrb	w20, [x3,x2]
+	tbz	x0, 6, .L2169
 	add	x3, x3, x20, lsl 6
-	ldr	x0, [x1,16]
-	ldr	x27, [x1,8]
-	ldr	x23, [x3,8]
-	cbz	x0, .L2063
-	ldrb	w3, [x1,56]
-	ldrb	w1, [x2,2832]
-	cmp	w3, w1
+	ldr	x0, [x4,16]
+	ldr	x27, [x4,8]
+	ldr	x24, [x3,8]
+	cbz	x0, .L2087
+	ldrb	w2, [x4,56]
+	ldrb	w1, [x1,2832]
+	cmp	w2, w1
 	csel	x27, x27, x0, ne
-.L2063:
+.L2087:
 	add	x2, x19, :lo12:.LANCHOR0
 	add	x0, x2, 784
 	add	x0, x0, x20, lsl 6
 	ldr	x1, [x0,16]
-	cbz	x1, .L2064
+	cbz	x1, .L2088
 	ldrb	w3, [x0,56]
 	ldrb	w0, [x2,2832]
 	cmp	w3, w0
-	csel	x23, x23, x1, ne
-.L2064:
-	add	x24, x19, :lo12:.LANCHOR0
+	csel	x24, x24, x1, ne
+.L2088:
+	add	x21, x19, :lo12:.LANCHOR0
 	mov	x1, x27
-	add	x24, x24, 784
-	add	x26, x24, x21, lsl 6
-	add	x24, x24, x20, lsl 6
+	add	x21, x21, 784
+	add	x26, x21, x22, lsl 6
+	add	x21, x21, x20, lsl 6
 	add	x28, x26, 32
 	add	x26, x26, 16
 	ldr	x2, [x26,8]
 	ldr	w0, [x26,24]
 	bl	flash_complete_plane_page_read
-	mov	w22, w0
-	ldr	x2, [x24,24]
-	mov	x1, x23
-	ldr	w0, [x24,40]
+	mov	w23, w0
+	ldr	x2, [x21,24]
+	mov	x1, x24
+	ldr	w0, [x21,40]
 	bl	flash_complete_plane_page_read
 	mov	w25, w0
-	cmn	w22, #1
-	beq	.L2065
+	cmn	w23, #1
+	beq	.L2089
 	ldr	w0, [x28,4]
 	cmn	w0, #1
-	beq	.L2066
+	beq	.L2090
 	ldr	x1, [x26,8]
 	ldr	w1, [x1,4]
 	cmp	w0, w1
-	beq	.L2066
-.L2065:
+	beq	.L2090
+.L2089:
 	add	x4, x19, :lo12:.LANCHOR0
 	mov	x2, x27
-	add	x24, x4, 784
-	add	x24, x24, x21, lsl 6
+	add	x21, x4, 784
+	add	x21, x21, x22, lsl 6
 	ldrb	w4, [x4,2832]
-	add	x26, x24, 32
-	add	x24, x24, 16
-	ldr	w1, [x24,24]
-	ldr	x3, [x24,8]
-	ubfx	x0, x1, 21, 3
+	add	x26, x21, 32
+	add	x21, x21, 16
+	ldr	w1, [x21,24]
+	ldr	x3, [x21,8]
+	ubfx	x0, x1, 21, 3
 	and	w1, w1, -14680065
 	bl	flash_read_page_en
-	mov	w22, w0
+	mov	w23, w0
 	ldr	w2, [x26,4]
 	cmn	w2, #1
-	beq	.L2067
-	ldr	x3, [x24,8]
+	beq	.L2091
+	ldr	x3, [x21,8]
 	ldr	w4, [x3,4]
 	cmp	w2, w4
-	beq	.L2067
+	beq	.L2091
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 6, .L2067
-	adrp	x0, .LC161
+	tbz	x0, 6, .L2091
+	adrp	x0, .LC165
 	ldr	w1, [x26,8]
 	ldr	w3, [x3]
-	add	x0, x0, :lo12:.LC161
+	add	x0, x0, :lo12:.LC165
 	bl	printk
-.L2067:
+.L2091:
 	add	x0, x19, :lo12:.LANCHOR0
 	add	x0, x0, 784
-	add	x0, x0, x21, lsl 6
+	add	x0, x0, x22, lsl 6
 	ldr	w1, [x0,36]
 	cmn	w1, #1
-	beq	.L2066
+	beq	.L2090
 	ldr	x0, [x0,24]
 	ldr	w0, [x0,4]
 	cmp	w1, w0
-	beq	.L2066
+	beq	.L2090
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
@@ -12702,65 +12893,65 @@ queue_wait_first_req_completed:
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L2066:
+.L2090:
 	add	x3, x19, :lo12:.LANCHOR0
 	mov	w1, 13
 	add	x3, x3, 784
 	cmn	w25, #1
-	add	x21, x3, x21, lsl 6
-	ldrb	w0, [x21,2]
-	str	w22, [x21,52]
+	add	x22, x3, x22, lsl 6
+	ldrb	w0, [x22,2]
+	str	w23, [x22,52]
 	orr	w0, w0, 8
-	strb	w1, [x21,58]
-	strb	w0, [x21,2]
-	beq	.L2068
+	strb	w1, [x22,58]
+	strb	w0, [x22,2]
+	beq	.L2092
 	add	x3, x3, x20, lsl 6
 	ldr	w0, [x3,36]
 	cmn	w0, #1
-	beq	.L2070
+	beq	.L2094
 	ldr	x1, [x3,24]
 	ldr	w1, [x1,4]
 	cmp	w0, w1
-	beq	.L2070
-.L2068:
+	beq	.L2094
+.L2092:
 	add	x4, x19, :lo12:.LANCHOR0
-	mov	x2, x23
+	mov	x2, x24
 	add	x21, x4, 784
 	add	x21, x21, x20, lsl 6
 	ldrb	w4, [x4,2832]
-	add	x24, x21, 32
+	add	x22, x21, 32
 	add	x21, x21, 16
 	ldr	w1, [x21,24]
 	ldr	x3, [x21,8]
 	ubfx	x0, x1, 21, 3
 	and	w1, w1, -14680065
 	bl	flash_read_page_en
-	ldr	w2, [x24,4]
+	ldr	w2, [x22,4]
 	cmn	w2, #1
-	beq	.L2072
+	beq	.L2096
 	ldr	x3, [x21,8]
 	ldr	w4, [x3,4]
 	cmp	w2, w4
-	beq	.L2072
+	beq	.L2096
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 6, .L2072
-	adrp	x0, .LC161
-	ldr	w1, [x24,8]
+	tbz	x0, 6, .L2096
+	adrp	x0, .LC165
+	ldr	w1, [x22,8]
 	ldr	w3, [x3]
-	add	x0, x0, :lo12:.LC161
+	add	x0, x0, :lo12:.LC165
 	bl	printk
-.L2072:
+.L2096:
 	add	x0, x19, :lo12:.LANCHOR0
 	add	x0, x0, 784
 	add	x0, x0, x20, lsl 6
 	ldr	w1, [x0,36]
 	cmn	w1, #1
-	beq	.L2070
+	beq	.L2094
 	ldr	x0, [x0,24]
 	ldr	w0, [x0,4]
 	cmp	w1, w0
-	beq	.L2070
+	beq	.L2094
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
@@ -12769,143 +12960,226 @@ queue_wait_first_req_completed:
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L2070:
+.L2094:
 	add	x19, x19, :lo12:.LANCHOR0
 	mov	w1, 13
 	add	x19, x19, 784
-	add	x20, x19, x20, lsl 6
-	ldrb	w0, [x20,2]
-	str	w22, [x20,52]
+	add	x19, x19, x20, lsl 6
+	str	w23, [x19,52]
+	strb	w1, [x19,58]
+.L2170:
+	ldrb	w0, [x19,2]
 	orr	w0, w0, 8
-	strb	w1, [x20,58]
-	strb	w0, [x20,2]
-	b	.L2135
-.L2057:
+	strb	w0, [x19,2]
+	b	.L2169
+.L2081:
 	bl	nandc_iqr_wait_flash_ready
-	mov	w0, w20
+	mov	w0, w24
 	mov	w1, 64
 	bl	flash_wait_device_ready
-	mov	w20, w0
-	tbz	x20, 6, .L2135
-	mov	w1, 5
+	mov	w21, w0
+	tbz	x21, 6, .L2169
+	mov	w20, 5
+	ands	w20, w21, w20
+	beq	.L2097
 	add	x19, x19, :lo12:.LANCHOR0
-	ands	w1, w20, w1
-	beq	.L2073
-	add	x19, x19, 784
 	mov	w0, 12
-	add	x19, x19, x21, lsl 6
-	mov	w2, w20
+	add	x19, x19, 784
+	mov	w2, w21
+	add	x19, x19, x22, lsl 6
 	mov	w4, 12
+	mov	w20, w21
 	strb	w0, [x19,58]
-	adrp	x0, .LC162
+	adrp	x0, .LC166
 	ldrb	w1, [x19,1]
-	add	x0, x0, :lo12:.LC162
+	add	x0, x0, :lo12:.LC166
 	ldr	w3, [x19,40]
 	bl	printk
 	mov	w0, -1
 	str	w0, [x19,52]
-	b	.L2136
-.L2073:
-	add	x19, x19, x21, lsl 6
-	b	.L2080
-.L2060:
-	add	x22, x19, :lo12:.LANCHOR0
-	mov	w0, 3
-	cmp	w2, 11
-	mov	w1, 10
-	add	x22, x22, 784
-	csel	w1, w0, w1, ne
-	ubfx	x3, x20, 21, 3
-	add	x0, x22, x21, lsl 6
-.L2075:
-	ldrb	w23, [x0]
-	cmp	w23, 255
-	beq	.L2137
-	add	x0, x22, x23, lsl 6
-	ldrb	w2, [x0,58]
+	b	.L2077
+.L2097:
+	add	x4, x19, :lo12:.LANCHOR0
+	mov	w1, 13
+	add	x23, x4, 784
+	add	x23, x23, x22, lsl 6
+	strb	w1, [x23,58]
+	ldr	x1, [x4,2864]
+	str	w20, [x23,52]
+	ldr	w2, [x1,156]
+	mov	w1, 20041
+	movk	w1, 0x444b, lsl 16
 	cmp	w2, w1
-	bne	.L2075
-	ldr	w2, [x0,40]
-	ubfx	x2, x2, 21, 3
+	bne	.L2169
+	ldrh	w0, [x23,50]
+	cbnz	w0, .L2169
+	adrp	x21, .LANCHOR4
+	ldr	w1, [x23,40]
+	add	x21, x21, :lo12:.LANCHOR4
+	ldrb	w4, [x4,2832]
+	ubfx	x0, x1, 21, 3
+	and	w1, w1, -14680065
+	ldr	x3, [x21,1256]
+	ldr	x2, [x21,1248]
+	bl	flash_read_page_en
+	cmn	w0, #1
+	mov	w3, w0
+	beq	.L2098
+	ldr	x1, [x23,24]
+	ldr	x0, [x21,1256]
+	ldr	w1, [x1]
+	ldr	w0, [x0]
+	cmp	w1, w0
+	beq	.L2169
+.L2098:
+	add	x4, x19, :lo12:.LANCHOR0
+	adrp	x0, .LC167
+	add	x19, x4, 784
+	add	x0, x0, :lo12:.LC167
+	add	x19, x19, x22, lsl 6
+	ldrb	w4, [x4,720]
+	ldrb	w1, [x19,1]
+	ldr	w2, [x19,40]
+	bl	printk
+	mov	w0, -1
+	str	w0, [x19,52]
+	b	.L2077
+.L2084:
+	add	x3, x19, :lo12:.LANCHOR0
+	cmp	w2, 11
+	mov	w1, 3
+	mov	w2, 10
+	add	x21, x3, 784
+	csel	w2, w1, w2, ne
+	ubfx	x0, x24, 21, 3
+	add	x1, x21, x22, lsl 6
+	mov	x25, x3
+.L2100:
+	ldrb	w1, [x1]
+	cmp	w1, 255
+	beq	.L2171
+	sxtw	x23, w1
+	add	x1, x21, x23, lsl 6
+	ldrb	w3, [x1,58]
 	cmp	w3, w2
-	bne	.L2075
+	bne	.L2100
+	ldr	w3, [x1,40]
+	ubfx	x3, x3, 21, 3
+	cmp	w0, w3
+	bne	.L2100
 	bl	nandc_iqr_wait_flash_ready
-	mov	w0, w20
+	mov	w0, w24
 	mov	w1, 64
 	bl	flash_wait_device_ready
 	mov	w20, w0
-	and	w0, w0, 64
-	tbz	x20, 6, .L2083
-	ands	w0, w20, 15
-	add	x22, x22, x21, lsl 6
-	beq	.L2078
-	adrp	x0, .LC163
-	ldrb	w1, [x22,1]
-	ldr	w3, [x22,40]
-	add	x0, x0, :lo12:.LC163
+	tbz	x20, 6, .L2168
+	ands	w1, w20, 15
+	beq	.L2104
+	add	x21, x21, x22, lsl 6
+	adrp	x0, .LC168
+	add	x0, x0, :lo12:.LC168
 	mov	w2, w20
 	mov	w4, 12
+	ldrb	w1, [x21,1]
+	ldr	w3, [x21,40]
 	bl	printk
 	mov	w0, 12
-	strb	w0, [x22,58]
+	strb	w0, [x21,58]
 	mov	w0, -1
-	str	w0, [x22,52]
-.L2077:
-	add	x19, x19, :lo12:.LANCHOR0
-	add	x19, x19, 784
-	add	x21, x19, x21, lsl 6
-	add	x23, x19, x23, lsl 6
-	ldrb	w0, [x21,58]
-	strb	w0, [x23,58]
-	ldr	w0, [x21,52]
-	str	w0, [x23,52]
-.L2136:
-	mov	w1, w20
-	b	.L2053
-.L2078:
-	mov	w1, 13
-	str	w0, [x22,52]
-	strb	w1, [x22,58]
-.L2083:
-	mov	w20, w0
+	str	w0, [x21,52]
+	b	.L2103
+.L2104:
+	add	x20, x21, x22, lsl 6
+	mov	w2, 13
+	str	w1, [x20,52]
+	ldr	x1, [x25,2864]
+	strb	w2, [x20,58]
+	ldr	w2, [x1,156]
+	mov	w1, 20041
+	movk	w1, 0x444b, lsl 16
+	cmp	w2, w1
+	bne	.L2168
+	ldrh	w0, [x20,50]
+	cbnz	w0, .L2168
+	adrp	x21, .LANCHOR4
+	ldr	w1, [x20,40]
+	add	x21, x21, :lo12:.LANCHOR4
+	ldrb	w4, [x25,2832]
+	ubfx	x0, x1, 21, 3
+	and	w1, w1, -14680065
+	ldr	x3, [x21,1256]
+	ldr	x2, [x21,1248]
+	bl	flash_read_page_en
+	cmn	w0, #1
+	mov	w3, w0
+	beq	.L2106
+	ldr	x1, [x20,24]
+	ldr	x0, [x21,1256]
+	ldr	w1, [x1]
+	ldr	w0, [x0]
+	cmp	w1, w0
+	beq	.L2168
+.L2106:
+	add	x4, x19, :lo12:.LANCHOR0
+	adrp	x0, .LC169
+	add	x20, x4, 784
+	add	x0, x0, :lo12:.LC169
+	add	x20, x20, x22, lsl 6
+	ldrb	w4, [x4,720]
+	ldrb	w1, [x20,1]
+	ldr	w2, [x20,40]
+	bl	printk
+	mov	w0, -1
+	str	w0, [x20,52]
+.L2168:
+	mov	w20, 0
+.L2103:
+	add	x1, x19, :lo12:.LANCHOR0
+	add	x1, x1, 784
+	add	x19, x1, x22, lsl 6
+	add	x1, x1, x23, lsl 6
+	ldrb	w0, [x19,58]
+	strb	w0, [x1,58]
+	ldr	w0, [x19,52]
+	str	w0, [x1,52]
 	b	.L2077
-.L2137:
-	mov	w1, -1
-	b	.L2053
-.L2058:
+.L2171:
+	mov	w20, -1
+	b	.L2077
+.L2082:
 	mov	w1, 32
-	mov	w0, w20
+	mov	w0, w24
 	bl	flash_wait_device_ready
-	tbz	x0, 5, .L2135
-	ands	w1, w0, 15
+	tbz	x0, 5, .L2169
+	ands	w20, w0, 15
 	add	x19, x19, :lo12:.LANCHOR0
-	add	x19, x19, x21, lsl 6
-	beq	.L2080
+	add	x19, x19, x22, lsl 6
+	beq	.L2108
 	mov	w1, 12
+	mov	w20, w0
 	strb	w1, [x19,842]
 	mov	w1, -1
 	str	w1, [x19,836]
-	mov	w1, w0
-	b	.L2053
-.L2080:
+	b	.L2077
+.L2108:
 	mov	w0, 13
-	str	w1, [x19,836]
+	str	w20, [x19,836]
 	strb	w0, [x19,842]
-	b	.L2053
-.L2059:
+	b	.L2077
+.L2083:
 	mov	w1, 64
-	mov	w0, w20
+	mov	w0, w24
 	bl	flash_wait_device_ready
-	tbz	x0, 6, .L2135
+	tbz	x0, 6, .L2169
 	add	x19, x19, :lo12:.LANCHOR0
-	add	x19, x19, x21, lsl 6
+	add	x19, x19, x22, lsl 6
 	str	w0, [x19,836]
 	mov	w0, 7
 	strb	w0, [x19,842]
-.L2135:
-	mov	w1, 0
-.L2053:
-	mov	w0, w1
+.L2169:
+	mov	w20, 0
+.L2077:
+	mov	w0, w20
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -12922,15 +13196,15 @@ sblk_wait_write_queue_completed:
 	add	x29, sp, 0
 	str	x19, [sp,16]
 	adrp	x19, .LANCHOR0
-.L2139:
+.L2173:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrb	w0, [x0,2835]
 	cmp	w0, 255
-	beq	.L2141
+	beq	.L2175
 	bl	queue_wait_first_req_completed
 	bl	queue_remove_completed_req
-	b	.L2139
-.L2141:
+	b	.L2173
+.L2175:
 	ldr	x19, [sp,16]
 	ldp	x29, x30, [sp], 32
 	ret
@@ -13004,48 +13278,48 @@ sblk_read_page:
 	mov	w20, w21
 	add	x27, x22, 784
 	add	x23, x23, 256
-.L2145:
-	cbz	w20, .L2168
+.L2179:
+	cbz	w20, .L2202
 	ldrb	w28, [x19]
 	ldr	w26, [x19,40]
-.L2146:
+.L2180:
 	mov	w0, w26
 	mov	w1, 0
 	bl	queue_lun_state
-	cbz	w0, .L2169
+	cbz	w0, .L2203
 	bl	queue_wait_first_req_completed
 	bl	queue_remove_completed_req
-	b	.L2146
-.L2169:
+	b	.L2180
+.L2203:
 	cmp	w20, 1
-	beq	.L2152
-	adrp	x0, .LANCHOR4+1240
-	ldrb	w0, [x0,#:lo12:.LANCHOR4+1240]
-	cbz	w0, .L2152
+	beq	.L2186
+	adrp	x0, .LANCHOR4+1264
+	ldrb	w0, [x0,#:lo12:.LANCHOR4+1264]
+	cbz	w0, .L2186
 	ldrb	w0, [x19]
 	ubfx	x3, x26, 21, 3
 	cmp	w0, 255
-	bne	.L2151
+	bne	.L2185
 	adrp	x0, .LC0
 	mov	x1, x23
-	mov	w2, 652
+	mov	w2, 661
 	add	x0, x0, :lo12:.LC0
 	str	x3, [x29,120]
 	bl	printk
 	bl	dump_stack
 	ldr	x3, [x29,120]
-.L2151:
+.L2185:
 	ldrb	w24, [x19]
 	lsl	x24, x24, 6
 	add	x2, x27, x24
 	ldr	w1, [x2,40]
 	ubfx	x0, x1, 21, 3
 	cmp	w3, w0
-	bne	.L2152
-	ldrh	w0, [x22,3348]
+	bne	.L2186
+	ldrh	w0, [x22,3362]
 	add	w26, w0, w26
 	cmp	w1, w26
-	bne	.L2152
+	bne	.L2186
 	ldr	w0, [x19,40]
 	add	x26, x22, 2835
 	str	x2, [x29,104]
@@ -13071,36 +13345,36 @@ sblk_read_page:
 	strb	wzr, [x2,59]
 	strb	w3, [x27,x24]
 	bl	buf_add_tail
-	b	.L2150
-.L2152:
+	b	.L2184
+.L2186:
 	mov	x0, x19
 	bl	queue_read_cmd
-.L2150:
+.L2184:
 	subs	w20, w20, #1
-	beq	.L2168
+	beq	.L2202
 	sbfiz	x19, x28, 6, 32
 	add	x19, x27, x19
-	b	.L2145
-.L2168:
+	b	.L2179
+.L2202:
 	adrp	x19, .LANCHOR0
 	add	x19, x19, :lo12:.LANCHOR0
 	add	x19, x19, 784
-.L2156:
-	cbz	w21, .L2170
+.L2190:
+	cbz	w21, .L2204
 	ldrb	w0, [x25,58]
 	cmp	w0, 13
-	bne	.L2157
+	bne	.L2191
 	ldrb	w0, [x25]
 	sub	w21, w21, #1
 	cmp	w0, 255
-	beq	.L2157
+	beq	.L2191
 	sbfiz	x25, x0, 6, 32
 	add	x25, x19, x25
-.L2157:
+.L2191:
 	bl	queue_wait_first_req_completed
 	bl	queue_remove_completed_req
-	b	.L2156
-.L2170:
+	b	.L2190
+.L2204:
 	mov	w0, w21
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
@@ -13111,511 +13385,176 @@ sblk_read_page:
 	ret
 	.size	sblk_read_page, .-sblk_read_page
 	.align	2
-	.global	flash_prog_page
-	.type	flash_prog_page, %function
-flash_prog_page:
-	stp	x29, x30, [sp, -96]!
+	.global	flash_start_tlc_page_prog
+	.type	flash_start_tlc_page_prog, %function
+flash_start_tlc_page_prog:
+	stp	x29, x30, [sp, -80]!
 	add	x29, sp, 0
-	stp	x21, x22, [sp,32]
-	uxtb	x22, w0
-	adrp	x21, .LANCHOR2
-	adrp	x0, .LANCHOR0+536
-	str	x27, [sp,80]
 	stp	x19, x20, [sp,16]
-	stp	x23, x24, [sp,48]
-	ldr	x19, [x0,#:lo12:.LANCHOR0+536]
-	mov	x20, x22
-	ldr	w0, [x21,#:lo12:.LANCHOR2]
-	add	x22, x22, 8
+	mov	w20, w4
+	adrp	x4, .LANCHOR0
 	stp	x25, x26, [sp,64]
-	mov	w23, w1
-	mov	x25, x3
-	mov	x26, x2
-	mov	w3, w4
-	add	x22, x19, x22, lsl 8
-	and	w24, w1, 2097151
-	ubfx	x27, x23, 24, 2
-	tbz	x0, 4, .L2172
-	adrp	x0, .LC164
-	mov	w2, w27
-	add	x0, x0, :lo12:.LC164
+	uxtb	w25, w0
+	add	x0, x4, :lo12:.LANCHOR0
+	stp	x21, x22, [sp,32]
+	stp	x23, x24, [sp,48]
+	uxtb	w26, w3
+	uxtb	w21, w1
+	ldrb	w0, [x0,633]
+	uxtb	w22, w2
+	mov	x24, x5
+	mov	x23, x6
+	cmp	w0, w26
+	mov	x19, x4
+	bhi	.L2206
+	adrp	x1, .LANCHOR3
+	adrp	x0, .LC0
+	add	x1, x1, :lo12:.LANCHOR3
+	mov	w2, 727
+	add	x1, x1, 272
+	add	x0, x0, :lo12:.LC0
 	bl	printk
-.L2172:
-	bl	nandc_wait_flash_ready
-	mov	w0, w20
-	bl	hynix_reconfig_rr_para
-	mov	w0, w20
+	bl	dump_stack
+.L2206:
+	add	x4, x19, :lo12:.LANCHOR0
+	add	x26, x4, x26, sxtw
+	ldrb	w26, [x26,736]
+	mov	w0, w26
+	ldr	x19, [x4,536]
 	bl	nandc_cs
-	mov	w0, w20
-	cbnz	w27, .L2173
-	bl	zftl_flash_enter_slc_mode
-	b	.L2174
-.L2173:
-	bl	zftl_flash_exit_slc_mode
-.L2174:
-	ubfiz	x4, x20, 8, 8
+	cbz	w25, .L2207
+	sxtw	x1, w26
+	add	x1, x1, 8
+	add	x1, x19, x1, lsl 8
+	str	w25, [x1,8]
+.L2207:
+	ubfiz	x7, x26, 8, 8
 	mov	w0, 128
-	add	x19, x19, x4
-	add	x21, x21, :lo12:.LANCHOR2
+	add	x19, x19, x7
+	str	w21, [x19,2056]
 	str	w0, [x19,2056]
-	and	w0, w23, 255
+	and	w0, w20, 255
 	str	wzr, [x19,2052]
 	str	wzr, [x19,2052]
 	str	w0, [x19,2052]
-	lsr	w0, w24, 8
+	lsr	w0, w20, 8
 	str	w0, [x19,2052]
-	lsr	w0, w24, 16
+	lsr	w0, w20, 16
+	add	w20, w20, w20, lsl 1
 	str	w0, [x19,2052]
-	mov	w0, w24
+	sub	w0, w20, #1
+	add	w0, w0, w21
 	bl	nandc_set_seed
-	ldrb	w1, [x21,17]
-	mov	x2, x26
-	mov	x3, x25
+	adrp	x1, .LANCHOR2+17
+	mov	x2, x24
+	mov	x3, x23
 	mov	w0, 1
+	ldrb	w1, [x1,#:lo12:.LANCHOR2+17]
 	bl	nandc_xfer_start
 	bl	nandc_xfer_done
-	mov	w0, 16
-	str	w0, [x19,2056]
-	bl	nandc_iqr_wait_flash_ready
-	bl	nandc_wait_flash_ready
-	mov	x0, x22
-	bl	flash_read_status
-	mov	w21, w0
-	mov	w0, w20
-	and	w19, w21, 4
+	str	w22, [x19,2056]
+	mov	w0, w26
 	bl	nandc_de_cs
-	tbz	x21, 2, .L2175
-	adrp	x0, .LC165
-	mov	w1, w23
-	add	x0, x0, :lo12:.LC165
-	mov	w2, w19
-	bl	printk
-.L2175:
-	mov	w0, w19
-	ldr	x27, [sp,80]
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
 	ldp	x25, x26, [sp,64]
-	ldp	x29, x30, [sp], 96
+	ldp	x29, x30, [sp], 80
 	ret
-	.size	flash_prog_page, .-flash_prog_page
+	.size	flash_start_tlc_page_prog, .-flash_start_tlc_page_prog
 	.align	2
-	.global	flash_test_blk
-	.type	flash_test_blk, %function
-flash_test_blk:
+	.type	queue_tlc_prog_cmd, %function
+queue_tlc_prog_cmd:
 	stp	x29, x30, [sp, -48]!
-	mov	w2, 32
+	mov	w1, 1
+	mov	w2, 26
 	add	x29, sp, 0
 	stp	x19, x20, [sp,16]
-	adrp	x19, .LANCHOR4
-	uxth	w20, w1
-	add	x19, x19, :lo12:.LANCHOR4
-	mov	w1, 165
-	stp	x21, x22, [sp,32]
-	uxtb	w22, w0
-	ldr	x0, [x19,1184]
-	bl	ftl_memset
-	ldr	x0, [x19,1200]
-	mov	w1, 90
-	mov	w2, 8
-	bl	ftl_memset
-	adrp	x0, .LANCHOR0+2
-	ldrh	w0, [x0,#:lo12:.LANCHOR0+2]
-	mul	w20, w20, w0
-	mov	w0, w22
-	mov	w1, w20
-	bl	flash_erase_block
-	cmn	w0, #1
-	bne	.L2183
-.L2185:
-	mov	w19, -1
-	b	.L2184
-.L2183:
-	adrp	x21, .LANCHOR2
-	ldr	x2, [x19,1184]
-	add	x21, x21, :lo12:.LANCHOR2
-	ldr	x3, [x19,1200]
-	mov	w0, w22
-	mov	w1, w20
-	add	x21, x21, 8
-	ldrb	w4, [x21,9]
-	bl	flash_prog_page
-	cmn	w0, #1
-	beq	.L2185
-	ldr	x2, [x19,1184]
-	mov	w0, w22
-	ldr	x3, [x19,1200]
-	mov	w1, w20
-	ldrb	w4, [x21,9]
-	bl	flash_read_page
-	cmn	w0, #1
-	beq	.L2185
-	ldr	x0, [x19,1184]
-	ldr	w1, [x0]
-	mov	w0, 42405
-	bfi	w0, w0, 16, 16
-	cmp	w1, w0
-	bne	.L2185
-	ldr	x0, [x19,1200]
-	ldr	w1, [x0]
-	mov	w0, 23130
-	bfi	w0, w0, 16, 16
-	cmp	w1, w0
-	csetm	w19, ne
-.L2184:
-	mov	w1, w20
-	mov	w0, w22
-	bl	flash_erase_block
-	mov	w0, w19
+	str	x21, [sp,32]
+	mov	x19, x0
+	ldr	x6, [x0]
+	ldr	w20, [x6,40]
+	ldr	x5, [x6,8]
+	and	w21, w20, 2097151
+	ldrb	w0, [x6,60]
+	ubfx	x20, x20, 21, 3
+	ldr	x6, [x6,24]
+	mov	w3, w20
+	mov	w4, w21
+	bl	flash_start_tlc_page_prog
+	bl	nandc_iqr_wait_flash_ready
+	bl	nandc_wait_flash_ready
+	ldr	x6, [x19,8]
+	mov	w3, w20
+	ldr	x0, [x19]
+	mov	w4, w21
+	mov	w1, 2
+	mov	w2, 26
+	ldr	x5, [x6,8]
+	ldrb	w0, [x0,60]
+	ldr	x6, [x6,24]
+	bl	flash_start_tlc_page_prog
+	bl	nandc_iqr_wait_flash_ready
+	bl	nandc_wait_flash_ready
+	ldr	x6, [x19,16]
+	mov	w3, w20
+	ldr	x0, [x19]
+	mov	w4, w21
+	mov	w2, 16
+	mov	w1, 3
+	ldr	x5, [x6,8]
+	ldrb	w0, [x0,60]
+	ldr	x6, [x6,24]
+	bl	flash_start_tlc_page_prog
+	ldr	x1, [x19]
+	mov	w0, 4
+	strb	w0, [x1,58]
+	mov	w0, 1
+	strb	w0, [x1,59]
+	mov	w0, -1
+	strb	w0, [x1]
+	adrp	x0, .LANCHOR0
+	add	x0, x0, :lo12:.LANCHOR0
+	add	x0, x0, 2835
+	bl	buf_add_tail
+	ldr	x21, [sp,32]
 	ldp	x19, x20, [sp,16]
-	ldp	x21, x22, [sp,32]
 	ldp	x29, x30, [sp], 48
 	ret
-	.size	flash_test_blk, .-flash_test_blk
+	.size	queue_tlc_prog_cmd, .-queue_tlc_prog_cmd
 	.align	2
-	.global	flash_dual_page_prog
-	.type	flash_dual_page_prog, %function
-flash_dual_page_prog:
-	stp	x29, x30, [sp, -112]!
+	.global	sblk_tlc_prog_one_page
+	.type	sblk_tlc_prog_one_page, %function
+sblk_tlc_prog_one_page:
+	stp	x29, x30, [sp, -48]!
 	add	x29, sp, 0
-	stp	x21, x22, [sp,32]
-	uxtb	x21, w0
-	adrp	x0, .LANCHOR0+536
-	stp	x23, x24, [sp,48]
-	stp	x27, x28, [sp,80]
-	ldr	x23, [x0,#:lo12:.LANCHOR0+536]
-	adrp	x0, .LANCHOR2
-	mov	x28, x2
-	str	x0, [x29,104]
 	stp	x19, x20, [sp,16]
-	ldr	w2, [x0,#:lo12:.LANCHOR2]
-	mov	x20, x21
-	stp	x25, x26, [sp,64]
-	add	x21, x21, 8
-	mov	w22, w1
-	mov	x27, x3
-	mov	x26, x4
-	mov	x25, x5
-	mov	w3, w6
-	add	x21, x23, x21, lsl 8
-	and	w19, w1, 2097151
-	ubfx	x24, x22, 24, 2
-	tbz	x2, 4, .L2193
-	adrp	x0, .LC164
-	mov	w2, w24
-	add	x0, x0, :lo12:.LC164
-	bl	printk
-.L2193:
-	bl	nandc_wait_flash_ready
-	mov	w0, w20
-	bl	nandc_cs
-	mov	w0, w20
-	cbnz	w24, .L2194
-	bl	zftl_flash_enter_slc_mode
-	b	.L2195
-.L2194:
-	bl	zftl_flash_exit_slc_mode
-.L2195:
-	ubfiz	x0, x20, 8, 8
-	mov	w4, 128
-	add	x23, x23, x0
-	and	w0, w22, 255
-	str	x4, [x29,96]
-	str	w4, [x23,2056]
-	str	wzr, [x23,2052]
-	str	wzr, [x23,2052]
-	str	w0, [x23,2052]
-	lsr	w0, w19, 8
-	str	w0, [x23,2052]
-	lsr	w0, w19, 16
-	str	w0, [x23,2052]
-	mov	w0, w19
-	bl	nandc_set_seed
-	ldr	x0, [x29,104]
-	mov	x3, x27
-	mov	x2, x28
-	mov	w27, 16
-	add	x24, x0, :lo12:.LANCHOR2
-	mov	w0, 1
-	ldrb	w1, [x24,17]
-	bl	nandc_xfer_start
-	bl	nandc_xfer_done
-	str	w27, [x23,2056]
-	bl	nandc_iqr_wait_flash_ready
-	bl	nandc_wait_flash_ready
-	ldr	x4, [x29,96]
-	add	w0, w19, 1
-	str	w4, [x23,2056]
-	and	w1, w0, 255
-	str	wzr, [x23,2052]
-	str	wzr, [x23,2052]
-	str	w1, [x23,2052]
-	lsr	w1, w0, 8
-	str	w1, [x23,2052]
-	lsr	w1, w0, 16
-	str	w1, [x23,2052]
-	bl	nandc_set_seed
-	ldrb	w1, [x24,17]
-	mov	x2, x26
-	mov	x3, x25
-	mov	w0, 1
-	bl	nandc_xfer_start
-	bl	nandc_xfer_done
-	str	w27, [x23,2056]
-	bl	nandc_iqr_wait_flash_ready
-	bl	nandc_wait_flash_ready
-	mov	x0, x21
-	bl	flash_read_status
-	mov	w21, w0
-	mov	w0, w20
-	and	w19, w21, 4
-	bl	nandc_de_cs
-	tbz	x21, 2, .L2196
-	adrp	x0, .LANCHOR2
-	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2196
-	adrp	x0, .LC165
-	mov	w1, w22
-	add	x0, x0, :lo12:.LC165
-	mov	w2, w19
-	bl	printk
-.L2196:
+	str	x21, [sp,32]
+	mov	x20, x0
+	ldr	x0, [x0]
+	ldr	w21, [x0,40]
+.L2213:
+	mov	w0, w21
+	mov	w1, 1
+	bl	queue_lun_state
+	mov	w19, w0
+	cbz	w0, .L2215
+	bl	queue_wait_first_req_completed
+	bl	queue_remove_completed_req
+	b	.L2213
+.L2215:
+	mov	x0, x20
+	bl	queue_tlc_prog_cmd
+	ldr	x21, [sp,32]
 	mov	w0, w19
 	ldp	x19, x20, [sp,16]
-	ldp	x21, x22, [sp,32]
-	ldp	x23, x24, [sp,48]
-	ldp	x25, x26, [sp,64]
-	ldp	x27, x28, [sp,80]
-	ldp	x29, x30, [sp], 112
+	ldp	x29, x30, [sp], 48
 	ret
-	.size	flash_dual_page_prog, .-flash_dual_page_prog
-	.section	.text.unlikely
+	.size	sblk_tlc_prog_one_page, .-sblk_tlc_prog_one_page
 	.align	2
-	.type	fw_flash_page_prog.constprop.31, %function
-fw_flash_page_prog.constprop.31:
-	stp	x29, x30, [sp, -64]!
-	adrp	x4, .LANCHOR0
-	add	x29, sp, 0
-	add	x4, x4, :lo12:.LANCHOR0
-	stp	x21, x22, [sp,32]
-	stp	x19, x20, [sp,16]
-	mov	x21, x1
-	str	x2, [x29,56]
-	ldr	x1, [x4,624]
-	ldrb	w22, [x4,724]
-	ldrb	w19, [x1,9]
-	udiv	w19, w0, w19
-	ldrb	w0, [x4,632]
-	bl	nandc_bch_sel
-	adrp	x0, .LANCHOR2+15
-	ldr	x3, [x29,56]
-	ldrb	w0, [x0,#:lo12:.LANCHOR2+15]
-	cmp	w0, 9
-	bne	.L2207
-	adrp	x20, .LANCHOR4
-	mov	w1, 255
-	add	x20, x20, :lo12:.LANCHOR4
-	mov	w2, 16384
-	ldr	x0, [x20,1184]
-	bl	ftl_memset
-	ldr	x4, [x20,1184]
-	mov	w1, w19
-	ldr	x3, [x29,56]
-	mov	x2, x21
-	mov	x5, x4
-	mov	w6, 4
-	mov	w0, 0
-	bl	flash_dual_page_prog
-	b	.L2209
-.L2207:
-	mov	w0, 0
-	mov	w1, w19
-	mov	x2, x21
-	mov	w4, 4
-	bl	flash_prog_page
-.L2209:
-	mov	w19, w0
-	mov	w0, w22
-	bl	nandc_bch_sel
-	mov	w0, w19
-	ldp	x19, x20, [sp,16]
-	ldp	x21, x22, [sp,32]
-	ldp	x29, x30, [sp], 64
-	ret
-	.size	fw_flash_page_prog.constprop.31, .-fw_flash_page_prog.constprop.31
-	.text
-	.align	2
-	.global	flash_start_tlc_page_prog
-	.type	flash_start_tlc_page_prog, %function
-flash_start_tlc_page_prog:
-	stp	x29, x30, [sp, -80]!
-	add	x29, sp, 0
-	stp	x19, x20, [sp,16]
-	mov	w20, w4
-	adrp	x4, .LANCHOR0
-	stp	x25, x26, [sp,64]
-	uxtb	w25, w0
-	add	x0, x4, :lo12:.LANCHOR0
-	stp	x21, x22, [sp,32]
-	stp	x23, x24, [sp,48]
-	uxtb	w26, w3
-	uxtb	w21, w1
-	ldrb	w0, [x0,633]
-	uxtb	w22, w2
-	mov	x24, x5
-	mov	x23, x6
-	cmp	w0, w26
-	mov	x19, x4
-	bhi	.L2211
-	adrp	x1, .LANCHOR3
-	adrp	x0, .LC0
-	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 726
-	add	x1, x1, 272
-	add	x0, x0, :lo12:.LC0
-	bl	printk
-	bl	dump_stack
-.L2211:
-	add	x4, x19, :lo12:.LANCHOR0
-	add	x26, x4, x26, sxtw
-	ldrb	w26, [x26,736]
-	mov	w0, w26
-	ldr	x19, [x4,536]
-	bl	nandc_cs
-	cbz	w25, .L2212
-	sxtw	x1, w26
-	add	x1, x1, 8
-	add	x1, x19, x1, lsl 8
-	str	w25, [x1,8]
-.L2212:
-	ubfiz	x7, x26, 8, 8
-	mov	w0, 128
-	add	x19, x19, x7
-	str	w21, [x19,2056]
-	str	w0, [x19,2056]
-	and	w0, w20, 255
-	str	wzr, [x19,2052]
-	str	wzr, [x19,2052]
-	str	w0, [x19,2052]
-	lsr	w0, w20, 8
-	str	w0, [x19,2052]
-	lsr	w0, w20, 16
-	add	w20, w20, w20, lsl 1
-	str	w0, [x19,2052]
-	sub	w0, w20, #1
-	add	w0, w0, w21
-	bl	nandc_set_seed
-	adrp	x1, .LANCHOR2+17
-	mov	x2, x24
-	mov	x3, x23
-	mov	w0, 1
-	ldrb	w1, [x1,#:lo12:.LANCHOR2+17]
-	bl	nandc_xfer_start
-	bl	nandc_xfer_done
-	str	w22, [x19,2056]
-	mov	w0, w26
-	bl	nandc_de_cs
-	ldp	x19, x20, [sp,16]
-	ldp	x21, x22, [sp,32]
-	ldp	x23, x24, [sp,48]
-	ldp	x25, x26, [sp,64]
-	ldp	x29, x30, [sp], 80
-	ret
-	.size	flash_start_tlc_page_prog, .-flash_start_tlc_page_prog
-	.align	2
-	.type	queue_tlc_prog_cmd, %function
-queue_tlc_prog_cmd:
-	stp	x29, x30, [sp, -48]!
-	mov	w1, 1
-	mov	w2, 26
-	add	x29, sp, 0
-	stp	x19, x20, [sp,16]
-	str	x21, [sp,32]
-	mov	x19, x0
-	ldr	x6, [x0]
-	ldr	w20, [x6,40]
-	ldr	x5, [x6,8]
-	and	w21, w20, 2097151
-	ldrb	w0, [x6,60]
-	ubfx	x20, x20, 21, 3
-	ldr	x6, [x6,24]
-	mov	w3, w20
-	mov	w4, w21
-	bl	flash_start_tlc_page_prog
-	bl	nandc_iqr_wait_flash_ready
-	bl	nandc_wait_flash_ready
-	ldr	x6, [x19,8]
-	mov	w3, w20
-	ldr	x0, [x19]
-	mov	w4, w21
-	mov	w1, 2
-	mov	w2, 26
-	ldr	x5, [x6,8]
-	ldrb	w0, [x0,60]
-	ldr	x6, [x6,24]
-	bl	flash_start_tlc_page_prog
-	bl	nandc_iqr_wait_flash_ready
-	bl	nandc_wait_flash_ready
-	ldr	x6, [x19,16]
-	mov	w3, w20
-	ldr	x0, [x19]
-	mov	w4, w21
-	mov	w2, 16
-	mov	w1, 3
-	ldr	x5, [x6,8]
-	ldrb	w0, [x0,60]
-	ldr	x6, [x6,24]
-	bl	flash_start_tlc_page_prog
-	ldr	x1, [x19]
-	mov	w0, 4
-	strb	w0, [x1,58]
-	mov	w0, 1
-	strb	w0, [x1,59]
-	mov	w0, -1
-	strb	w0, [x1]
-	adrp	x0, .LANCHOR0
-	add	x0, x0, :lo12:.LANCHOR0
-	add	x0, x0, 2835
-	bl	buf_add_tail
-	ldr	x21, [sp,32]
-	ldp	x19, x20, [sp,16]
-	ldp	x29, x30, [sp], 48
-	ret
-	.size	queue_tlc_prog_cmd, .-queue_tlc_prog_cmd
-	.align	2
-	.global	sblk_tlc_prog_one_page
-	.type	sblk_tlc_prog_one_page, %function
-sblk_tlc_prog_one_page:
-	stp	x29, x30, [sp, -48]!
-	add	x29, sp, 0
-	stp	x19, x20, [sp,16]
-	str	x21, [sp,32]
-	mov	x20, x0
-	ldr	x0, [x0]
-	ldr	w21, [x0,40]
-.L2218:
-	mov	w0, w21
-	mov	w1, 1
-	bl	queue_lun_state
-	mov	w19, w0
-	cbz	w0, .L2220
-	bl	queue_wait_first_req_completed
-	bl	queue_remove_completed_req
-	b	.L2218
-.L2220:
-	mov	x0, x20
-	bl	queue_tlc_prog_cmd
-	ldr	x21, [sp,32]
-	mov	w0, w19
-	ldp	x19, x20, [sp,16]
-	ldp	x29, x30, [sp], 48
-	ret
-	.size	sblk_tlc_prog_one_page, .-sblk_tlc_prog_one_page
-	.align	2
-	.global	sblk_xlc_prog_pages
-	.type	sblk_xlc_prog_pages, %function
-sblk_xlc_prog_pages:
+	.global	sblk_xlc_prog_pages
+	.type	sblk_xlc_prog_pages, %function
+sblk_xlc_prog_pages:
 	stp	x29, x30, [sp, -64]!
 	add	x29, sp, 0
 	stp	x19, x20, [sp,16]
@@ -13626,17 +13565,17 @@ sblk_xlc_prog_pages:
 	ldr	x0, [x0]
 	mov	w24, w2
 	ldr	w20, [x0,40]
-.L2222:
+.L2217:
 	mov	w0, w20
 	mov	w1, 1
 	bl	queue_lun_state
-	cbz	w0, .L2226
+	cbz	w0, .L2221
 	bl	queue_wait_first_req_completed
 	bl	queue_remove_completed_req
-	b	.L2222
-.L2226:
+	b	.L2217
+.L2221:
 	cmp	w24, 2
-	bne	.L2224
+	bne	.L2219
 	ldr	x6, [x19]
 	mov	w1, 1
 	ldr	x0, [x22]
@@ -13720,11 +13659,11 @@ sblk_xlc_prog_pages:
 	add	x0, x0, :lo12:.LANCHOR0
 	add	x0, x0, 2835
 	bl	buf_add_tail
-	b	.L2225
-.L2224:
+	b	.L2220
+.L2219:
 	mov	x0, x19
 	bl	queue_tlc_prog_cmd
-.L2225:
+.L2220:
 	mov	w0, 0
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
@@ -13742,8 +13681,8 @@ sblk_3d_tlc_dump_prog:
 	str	x21, [sp,32]
 	mov	x19, x0
 	ldr	w2, [x0,40]
-	adrp	x0, .LC166
-	add	x0, x0, :lo12:.LC166
+	adrp	x0, .LC170
+	add	x0, x0, :lo12:.LC170
 	and	w20, w2, 2097151
 	mov	w3, w2
 	mov	w1, w20
@@ -13806,16 +13745,16 @@ flash_start_3d_mlc_page_prog:
 	mov	x24, x4
 	mov	x19, x5
 	cmp	w0, w20
-	bhi	.L2229
+	bhi	.L2224
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 756
+	mov	w2, 757
 	add	x1, x1, 304
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L2229:
+.L2224:
 	add	x5, x19, :lo12:.LANCHOR0
 	add	x20, x5, x20, sxtw
 	ldrb	w20, [x20,736]
@@ -13861,16 +13800,16 @@ sblk_3d_mlc_prog_pages:
 	mov	x20, x0
 	ldr	x0, [x0]
 	ldr	w19, [x0,40]
-.L2231:
+.L2226:
 	mov	w0, w19
 	mov	w1, 1
 	bl	queue_lun_state
 	mov	w21, w0
-	cbz	w0, .L2233
+	cbz	w0, .L2228
 	bl	queue_wait_first_req_completed
 	bl	queue_remove_completed_req
-	b	.L2231
-.L2233:
+	b	.L2226
+.L2228:
 	ldr	x0, [x20]
 	ldr	w19, [x0,40]
 	and	w22, w19, 2097151
@@ -13926,9 +13865,9 @@ sblk_mlc_dump_prog:
 	mov	w0, w19
 	bl	zftl_flash_exit_slc_mode
 	ldr	w2, [x20,40]
-	adrp	x0, .LC167
+	adrp	x0, .LC171
 	mov	w1, w21
-	add	x0, x0, :lo12:.LC167
+	add	x0, x0, :lo12:.LC171
 	add	w3, w2, 1
 	bl	printk
 	ldr	x3, [x20,8]
@@ -13980,50 +13919,50 @@ flash_start_page_prog:
 	and	w20, w1, 2097151
 	ubfx	x23, x1, 24, 2
 	cmp	w0, w24
-	bhi	.L2236
+	bhi	.L2231
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 803
+	mov	w2, 804
 	add	x1, x1, 336
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L2236:
+.L2231:
 	add	x28, x22, :lo12:.LANCHOR0
 	add	x0, x28, x24, sxtw
 	ldrb	w21, [x0,736]
 	ldr	x19, [x28,536]
 	bl	nandc_rdy_status
-	cbnz	w0, .L2237
+	cbnz	w0, .L2232
 	ldrb	w0, [x28,633]
 	cmp	w0, 1
-	bne	.L2238
+	bne	.L2233
 	bl	nandc_wait_flash_ready
-	b	.L2237
-.L2238:
+	b	.L2232
+.L2233:
 	mov	w0, w24
 	mov	w1, w20
 	mov	w2, 64
 	bl	flash_wait_device_ready_raw
-.L2237:
+.L2232:
 	mov	w0, w21
 	bl	hynix_reconfig_rr_para
 	mov	w0, w21
 	bl	nandc_cs
-	cbnz	w23, .L2239
+	cbnz	w23, .L2234
 	mov	w0, w20
 	bl	slc_phy_page_address_calc
 	mov	w20, w0
 	ldrb	w0, [x22,#:lo12:.LANCHOR0]
-	cbz	w0, .L2240
+	cbz	w0, .L2235
 	mov	w0, w21
 	bl	zftl_flash_enter_slc_mode
-	b	.L2240
-.L2239:
+	b	.L2235
+.L2234:
 	mov	w0, w21
 	bl	zftl_flash_exit_slc_mode
-.L2240:
+.L2235:
 	ubfiz	x4, x21, 8, 8
 	mov	w0, 128
 	add	x19, x19, x4
@@ -14073,28 +14012,28 @@ queue_prog_cmd:
 	add	x1, x0, :lo12:.LANCHOR0
 	ldrb	w2, [x1,2835]
 	cmp	w2, 255
-	beq	.L2245
+	beq	.L2240
 	ubfx	x4, x4, 21, 3
 	add	x1, x1, 784
-.L2247:
+.L2242:
 	add	x3, x1, x2, lsl 6
 	ldr	w5, [x3,40]
 	ubfx	x5, x5, 21, 3
 	cmp	w4, w5
-	bne	.L2246
+	bne	.L2241
 	ldrb	w5, [x3,58]
 	add	x3, x3, 48
 	cmp	w5, 7
-	bne	.L2246
+	bne	.L2241
 	mov	w1, 3
 	strb	w1, [x3,10]
-	b	.L2245
-.L2246:
+	b	.L2240
+.L2241:
 	lsl	x2, x2, 6
 	ldrb	w2, [x1,x2]
 	cmp	w2, 255
-	bne	.L2247
-.L2245:
+	bne	.L2242
+.L2240:
 	mov	w1, 3
 	strb	w1, [x19,58]
 	mov	w1, 1
@@ -14123,66 +14062,66 @@ sblk_prog_page:
 	mov	x19, x0
 	uxtb	w20, w1
 	ldrh	w0, [x0,50]
-	cbz	w0, .L2253
+	cbz	w0, .L2248
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 8, .L2253
-	adrp	x0, .LC168
+	tbz	x0, 8, .L2248
+	adrp	x0, .LC172
 	ldr	w1, [x19,40]
-	add	x0, x0, :lo12:.LC168
+	add	x0, x0, :lo12:.LC172
 	mov	w2, w20
 	bl	printk
-.L2253:
+.L2248:
 	adrp	x24, .LANCHOR0
 	adrp	x25, .LC0
 	add	x23, x24, :lo12:.LANCHOR0
 	mov	w21, 0
 	add	x27, x23, 784
 	add	x25, x25, :lo12:.LC0
-.L2254:
-	cbz	w20, .L2284
+.L2249:
+	cbz	w20, .L2279
 	ldrb	w26, [x19]
 	ldr	w22, [x19,40]
-.L2255:
+.L2250:
 	mov	w0, w22
 	mov	w1, 1
 	bl	queue_lun_state
-	cbz	w0, .L2285
+	cbz	w0, .L2280
 	bl	queue_wait_first_req_completed
 	bl	queue_remove_completed_req
-	b	.L2255
-.L2285:
+	b	.L2250
+.L2280:
 	cmp	w20, 1
-	beq	.L2257
+	beq	.L2252
 	add	x0, x24, :lo12:.LANCHOR0
 	ldrb	w0, [x0,781]
-	cbnz	w0, .L2258
-.L2257:
+	cbnz	w0, .L2253
+.L2252:
 	mov	x0, x19
 	bl	queue_prog_cmd
-	b	.L2259
-.L2258:
+	b	.L2254
+.L2253:
 	ldrb	w0, [x19]
 	ubfx	x28, x22, 21, 3
 	cmp	w0, 255
-	bne	.L2260
+	bne	.L2255
 	adrp	x1, .LANCHOR3
-	mov	w2, 574
+	mov	w2, 583
 	add	x1, x1, :lo12:.LANCHOR3
 	mov	x0, x25
 	add	x1, x1, 360
 	bl	printk
 	bl	dump_stack
-.L2260:
+.L2255:
 	ldrb	w0, [x19]
 	add	x0, x27, x0, lsl 6
 	ldr	w4, [x0,40]
 	ubfx	x0, x4, 21, 3
 	cmp	w28, w0
-	bne	.L2261
-	ldrh	w3, [x23,3340]
+	bne	.L2256
+	ldrh	w3, [x23,3264]
 	mov	w1, 21
-	ldrb	w6, [x23,3338]
+	ldrb	w6, [x23,3266]
 	mov	w28, 1
 	sub	w1, w1, w3
 	lsr	w0, w22, w3
@@ -14200,13 +14139,13 @@ sblk_prog_page:
 	and	w0, w1, w5
 	cmp	w0, w3
 	uxth	w2, w2
-	beq	.L2261
+	beq	.L2256
 	and	w22, w2, w22
 	and	w2, w2, w4
 	cmp	w22, w2
-	bne	.L2261
+	bne	.L2256
 	cmp	w21, w6
-	beq	.L2261
+	beq	.L2256
 	ldr	w1, [x19,40]
 	mov	w0, 17
 	ldr	x2, [x19,8]
@@ -14221,81 +14160,416 @@ sblk_prog_page:
 	strb	w0, [x19]
 	add	x0, x23, 2835
 	bl	buf_add_tail
-	b	.L2259
-.L2261:
+	b	.L2254
+.L2256:
 	mov	x0, x19
 	mov	w21, 0
 	bl	queue_prog_cmd
-.L2259:
+.L2254:
 	subs	w20, w20, #1
-	beq	.L2284
+	beq	.L2279
 	add	x19, x24, :lo12:.LANCHOR0
 	sbfiz	x26, x26, 6, 32
 	add	x19, x19, 784
 	add	x19, x19, x26
-	b	.L2254
-.L2284:
+	b	.L2249
+.L2279:
 	mov	w0, 0
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
 	ldp	x25, x26, [sp,64]
 	ldp	x27, x28, [sp,80]
-	ldp	x29, x30, [sp], 96
+	ldp	x29, x30, [sp], 96
+	ret
+	.size	sblk_prog_page, .-sblk_prog_page
+	.align	2
+	.global	ftl_flush
+	.type	ftl_flush, %function
+ftl_flush:
+	stp	x29, x30, [sp, -32]!
+	adrp	x2, .LANCHOR0
+	add	x29, sp, 0
+	add	x0, x2, :lo12:.LANCHOR0
+	stp	x19, x20, [sp,16]
+	mov	x19, x2
+	adrp	x20, .LANCHOR4
+	ldrb	w1, [x0,2857]
+	cbz	w1, .L2282
+	add	x2, x20, :lo12:.LANCHOR4
+	add	x0, x0, 784
+	ldrb	w2, [x2,1265]
+	add	x0, x0, x2, lsl 6
+	bl	sblk_prog_page
+.L2282:
+	add	x2, x19, :lo12:.LANCHOR0
+	add	x20, x20, :lo12:.LANCHOR4
+	mov	w0, -1
+	strb	wzr, [x2,2857]
+	strb	w0, [x20,1265]
+	bl	sblk_wait_write_queue_completed
+	bl	ftl_write_completed
+	mov	w0, -1
+	bl	ftl_vpn_decrement
+	ldp	x19, x20, [sp,16]
+	ldp	x29, x30, [sp], 32
+	ret
+	.size	ftl_flush, .-ftl_flush
+	.align	2
+	.global	zftl_cache_flush
+	.type	zftl_cache_flush, %function
+zftl_cache_flush:
+	adrp	x0, .LANCHOR0+2857
+	stp	x29, x30, [sp, -16]!
+	add	x29, sp, 0
+	ldrb	w0, [x0,#:lo12:.LANCHOR0+2857]
+	cbz	w0, .L2286
+	bl	timer_get_time
+	adrp	x1, .LANCHOR4+1268
+	ldr	w1, [x1,#:lo12:.LANCHOR4+1268]
+	add	w1, w1, 100
+	cmp	w0, w1
+	bls	.L2286
+	bl	ftl_flush
+.L2286:
+	ldp	x29, x30, [sp], 16
+	ret
+	.size	zftl_cache_flush, .-zftl_cache_flush
+	.align	2
+	.global	flash_prog_page
+	.type	flash_prog_page, %function
+flash_prog_page:
+	stp	x29, x30, [sp, -96]!
+	add	x29, sp, 0
+	stp	x21, x22, [sp,32]
+	uxtb	x22, w0
+	adrp	x21, .LANCHOR2
+	adrp	x0, .LANCHOR0+536
+	str	x27, [sp,80]
+	stp	x19, x20, [sp,16]
+	stp	x23, x24, [sp,48]
+	ldr	x19, [x0,#:lo12:.LANCHOR0+536]
+	mov	x20, x22
+	ldr	w0, [x21,#:lo12:.LANCHOR2]
+	add	x22, x22, 8
+	stp	x25, x26, [sp,64]
+	mov	w23, w1
+	mov	x25, x3
+	mov	x26, x2
+	mov	w3, w4
+	add	x22, x19, x22, lsl 8
+	and	w24, w1, 2097151
+	ubfx	x27, x23, 24, 2
+	tbz	x0, 4, .L2291
+	adrp	x0, .LC173
+	mov	w2, w27
+	add	x0, x0, :lo12:.LC173
+	bl	printk
+.L2291:
+	bl	nandc_wait_flash_ready
+	mov	w0, w20
+	bl	hynix_reconfig_rr_para
+	mov	w0, w20
+	bl	nandc_cs
+	mov	w0, w20
+	cbnz	w27, .L2292
+	bl	zftl_flash_enter_slc_mode
+	b	.L2293
+.L2292:
+	bl	zftl_flash_exit_slc_mode
+.L2293:
+	ubfiz	x4, x20, 8, 8
+	mov	w0, 128
+	add	x19, x19, x4
+	add	x21, x21, :lo12:.LANCHOR2
+	str	w0, [x19,2056]
+	and	w0, w23, 255
+	str	wzr, [x19,2052]
+	str	wzr, [x19,2052]
+	str	w0, [x19,2052]
+	lsr	w0, w24, 8
+	str	w0, [x19,2052]
+	lsr	w0, w24, 16
+	str	w0, [x19,2052]
+	mov	w0, w24
+	bl	nandc_set_seed
+	ldrb	w1, [x21,17]
+	mov	x2, x26
+	mov	x3, x25
+	mov	w0, 1
+	bl	nandc_xfer_start
+	bl	nandc_xfer_done
+	mov	w0, 16
+	str	w0, [x19,2056]
+	bl	nandc_iqr_wait_flash_ready
+	bl	nandc_wait_flash_ready
+	mov	x0, x22
+	bl	flash_read_status
+	mov	w21, w0
+	mov	w0, w20
+	and	w19, w21, 4
+	bl	nandc_de_cs
+	tbz	x21, 2, .L2294
+	adrp	x0, .LC174
+	mov	w1, w23
+	add	x0, x0, :lo12:.LC174
+	mov	w2, w19
+	bl	printk
+.L2294:
+	mov	w0, w19
+	ldr	x27, [sp,80]
+	ldp	x19, x20, [sp,16]
+	ldp	x21, x22, [sp,32]
+	ldp	x23, x24, [sp,48]
+	ldp	x25, x26, [sp,64]
+	ldp	x29, x30, [sp], 96
+	ret
+	.size	flash_prog_page, .-flash_prog_page
+	.align	2
+	.global	flash_test_blk
+	.type	flash_test_blk, %function
+flash_test_blk:
+	stp	x29, x30, [sp, -48]!
+	mov	w2, 32
+	add	x29, sp, 0
+	stp	x19, x20, [sp,16]
+	adrp	x19, .LANCHOR4
+	uxth	w20, w1
+	add	x19, x19, :lo12:.LANCHOR4
+	mov	w1, 165
+	stp	x21, x22, [sp,32]
+	uxtb	w22, w0
+	ldr	x0, [x19,1208]
+	bl	ftl_memset
+	ldr	x0, [x19,1224]
+	mov	w1, 90
+	mov	w2, 8
+	bl	ftl_memset
+	adrp	x0, .LANCHOR0+2
+	ldrh	w0, [x0,#:lo12:.LANCHOR0+2]
+	mul	w20, w20, w0
+	mov	w0, w22
+	mov	w1, w20
+	bl	flash_erase_block
+	cmn	w0, #1
+	bne	.L2302
+.L2304:
+	mov	w19, -1
+	b	.L2303
+.L2302:
+	adrp	x21, .LANCHOR2
+	ldr	x2, [x19,1208]
+	add	x21, x21, :lo12:.LANCHOR2
+	ldr	x3, [x19,1224]
+	mov	w0, w22
+	mov	w1, w20
+	add	x21, x21, 8
+	ldrb	w4, [x21,9]
+	bl	flash_prog_page
+	cmn	w0, #1
+	beq	.L2304
+	ldr	x2, [x19,1208]
+	mov	w0, w22
+	ldr	x3, [x19,1224]
+	mov	w1, w20
+	ldrb	w4, [x21,9]
+	bl	flash_read_page
+	cmn	w0, #1
+	beq	.L2304
+	ldr	x0, [x19,1208]
+	ldr	w1, [x0]
+	mov	w0, 42405
+	bfi	w0, w0, 16, 16
+	cmp	w1, w0
+	bne	.L2304
+	ldr	x0, [x19,1224]
+	ldr	w1, [x0]
+	mov	w0, 23130
+	bfi	w0, w0, 16, 16
+	cmp	w1, w0
+	csetm	w19, ne
+.L2303:
+	mov	w1, w20
+	mov	w0, w22
+	bl	flash_erase_block
+	mov	w0, w19
+	ldp	x19, x20, [sp,16]
+	ldp	x21, x22, [sp,32]
+	ldp	x29, x30, [sp], 48
+	ret
+	.size	flash_test_blk, .-flash_test_blk
+	.align	2
+	.global	flash_dual_page_prog
+	.type	flash_dual_page_prog, %function
+flash_dual_page_prog:
+	stp	x29, x30, [sp, -112]!
+	add	x29, sp, 0
+	stp	x21, x22, [sp,32]
+	uxtb	x21, w0
+	adrp	x0, .LANCHOR0+536
+	stp	x23, x24, [sp,48]
+	stp	x27, x28, [sp,80]
+	ldr	x23, [x0,#:lo12:.LANCHOR0+536]
+	adrp	x0, .LANCHOR2
+	mov	x28, x2
+	str	x0, [x29,104]
+	stp	x19, x20, [sp,16]
+	ldr	w2, [x0,#:lo12:.LANCHOR2]
+	mov	x20, x21
+	stp	x25, x26, [sp,64]
+	add	x21, x21, 8
+	mov	w22, w1
+	mov	x27, x3
+	mov	x26, x4
+	mov	x25, x5
+	mov	w3, w6
+	add	x21, x23, x21, lsl 8
+	and	w19, w1, 2097151
+	ubfx	x24, x22, 24, 2
+	tbz	x2, 4, .L2312
+	adrp	x0, .LC173
+	mov	w2, w24
+	add	x0, x0, :lo12:.LC173
+	bl	printk
+.L2312:
+	bl	nandc_wait_flash_ready
+	mov	w0, w20
+	bl	nandc_cs
+	mov	w0, w20
+	cbnz	w24, .L2313
+	bl	zftl_flash_enter_slc_mode
+	b	.L2314
+.L2313:
+	bl	zftl_flash_exit_slc_mode
+.L2314:
+	ubfiz	x0, x20, 8, 8
+	mov	w4, 128
+	add	x23, x23, x0
+	and	w0, w22, 255
+	str	x4, [x29,96]
+	str	w4, [x23,2056]
+	str	wzr, [x23,2052]
+	str	wzr, [x23,2052]
+	str	w0, [x23,2052]
+	lsr	w0, w19, 8
+	str	w0, [x23,2052]
+	lsr	w0, w19, 16
+	str	w0, [x23,2052]
+	mov	w0, w19
+	bl	nandc_set_seed
+	ldr	x0, [x29,104]
+	mov	x3, x27
+	mov	x2, x28
+	mov	w27, 16
+	add	x24, x0, :lo12:.LANCHOR2
+	mov	w0, 1
+	ldrb	w1, [x24,17]
+	bl	nandc_xfer_start
+	bl	nandc_xfer_done
+	str	w27, [x23,2056]
+	bl	nandc_iqr_wait_flash_ready
+	bl	nandc_wait_flash_ready
+	ldr	x4, [x29,96]
+	add	w0, w19, 1
+	str	w4, [x23,2056]
+	and	w1, w0, 255
+	str	wzr, [x23,2052]
+	str	wzr, [x23,2052]
+	str	w1, [x23,2052]
+	lsr	w1, w0, 8
+	str	w1, [x23,2052]
+	lsr	w1, w0, 16
+	str	w1, [x23,2052]
+	bl	nandc_set_seed
+	ldrb	w1, [x24,17]
+	mov	x2, x26
+	mov	x3, x25
+	mov	w0, 1
+	bl	nandc_xfer_start
+	bl	nandc_xfer_done
+	str	w27, [x23,2056]
+	bl	nandc_iqr_wait_flash_ready
+	bl	nandc_wait_flash_ready
+	mov	x0, x21
+	bl	flash_read_status
+	mov	w21, w0
+	mov	w0, w20
+	and	w19, w21, 4
+	bl	nandc_de_cs
+	tbz	x21, 2, .L2315
+	adrp	x0, .LANCHOR2
+	ldr	w0, [x0,#:lo12:.LANCHOR2]
+	tbz	x0, 12, .L2315
+	adrp	x0, .LC174
+	mov	w1, w22
+	add	x0, x0, :lo12:.LC174
+	mov	w2, w19
+	bl	printk
+.L2315:
+	mov	w0, w19
+	ldp	x19, x20, [sp,16]
+	ldp	x21, x22, [sp,32]
+	ldp	x23, x24, [sp,48]
+	ldp	x25, x26, [sp,64]
+	ldp	x27, x28, [sp,80]
+	ldp	x29, x30, [sp], 112
 	ret
-	.size	sblk_prog_page, .-sblk_prog_page
+	.size	flash_dual_page_prog, .-flash_dual_page_prog
+	.section	.text.unlikely
 	.align	2
-	.global	ftl_flush
-	.type	ftl_flush, %function
-ftl_flush:
-	stp	x29, x30, [sp, -32]!
-	adrp	x2, .LANCHOR0
+	.type	fw_flash_page_prog.constprop.29, %function
+fw_flash_page_prog.constprop.29:
+	stp	x29, x30, [sp, -64]!
+	adrp	x4, .LANCHOR0
 	add	x29, sp, 0
-	add	x0, x2, :lo12:.LANCHOR0
+	add	x4, x4, :lo12:.LANCHOR0
+	stp	x21, x22, [sp,32]
 	stp	x19, x20, [sp,16]
-	mov	x19, x2
+	mov	x21, x1
+	str	x2, [x29,56]
+	ldr	x1, [x4,624]
+	ldrb	w22, [x4,724]
+	ldrb	w19, [x1,9]
+	udiv	w19, w0, w19
+	ldrb	w0, [x4,632]
+	bl	nandc_bch_sel
+	adrp	x0, .LANCHOR2+15
+	ldr	x3, [x29,56]
+	ldrb	w0, [x0,#:lo12:.LANCHOR2+15]
+	cmp	w0, 9
+	bne	.L2326
 	adrp	x20, .LANCHOR4
-	ldrb	w1, [x0,2857]
-	cbz	w1, .L2287
-	add	x2, x20, :lo12:.LANCHOR4
-	add	x0, x0, 784
-	ldrb	w2, [x2,1241]
-	add	x0, x0, x2, lsl 6
-	bl	sblk_prog_page
-.L2287:
-	add	x2, x19, :lo12:.LANCHOR0
+	mov	w1, 255
 	add	x20, x20, :lo12:.LANCHOR4
-	mov	w0, -1
-	strb	wzr, [x2,2857]
-	strb	w0, [x20,1241]
-	bl	sblk_wait_write_queue_completed
-	bl	ftl_write_completed
-	mov	w0, -1
-	bl	ftl_vpn_decrement
+	mov	w2, 16384
+	ldr	x0, [x20,1208]
+	bl	ftl_memset
+	ldr	x4, [x20,1208]
+	mov	w1, w19
+	ldr	x3, [x29,56]
+	mov	x2, x21
+	mov	x5, x4
+	mov	w6, 4
+	mov	w0, 0
+	bl	flash_dual_page_prog
+	b	.L2328
+.L2326:
+	mov	w0, 0
+	mov	w1, w19
+	mov	x2, x21
+	mov	w4, 4
+	bl	flash_prog_page
+.L2328:
+	mov	w19, w0
+	mov	w0, w22
+	bl	nandc_bch_sel
+	mov	w0, w19
 	ldp	x19, x20, [sp,16]
-	ldp	x29, x30, [sp], 32
-	ret
-	.size	ftl_flush, .-ftl_flush
-	.align	2
-	.global	zftl_cache_flush
-	.type	zftl_cache_flush, %function
-zftl_cache_flush:
-	adrp	x0, .LANCHOR0+2857
-	stp	x29, x30, [sp, -16]!
-	add	x29, sp, 0
-	ldrb	w0, [x0,#:lo12:.LANCHOR0+2857]
-	cbz	w0, .L2291
-	bl	timer_get_time
-	adrp	x1, .LANCHOR4+1244
-	ldr	w1, [x1,#:lo12:.LANCHOR4+1244]
-	add	w1, w1, 100
-	cmp	w0, w1
-	bls	.L2291
-	bl	ftl_flush
-.L2291:
-	ldp	x29, x30, [sp], 16
+	ldp	x21, x22, [sp,32]
+	ldp	x29, x30, [sp], 64
 	ret
-	.size	zftl_cache_flush, .-zftl_cache_flush
+	.size	fw_flash_page_prog.constprop.29, .-fw_flash_page_prog.constprop.29
+	.text
 	.align	2
 	.global	flash_prog_page_en
 	.type	flash_prog_page_en, %function
@@ -14319,58 +14593,58 @@ flash_prog_page_en:
 	ubfx	x25, x20, 24, 2
 	cmp	w1, w24
 	mov	x23, x0
-	bhi	.L2296
+	bhi	.L2330
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 546
+	mov	w2, 547
 	add	x1, x1, 376
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L2296:
+.L2330:
 	add	x0, x23, :lo12:.LANCHOR0
 	mov	w19, w20
 	add	x1, x0, x24, sxtw
 	ldrb	w26, [x1,736]
-	cbnz	w25, .L2297
+	cbnz	w25, .L2331
 	adrp	x1, .LANCHOR0
 	ldrb	w1, [x1,#:lo12:.LANCHOR0]
-	cbz	w1, .L2298
+	cbz	w1, .L2332
 	ldrb	w0, [x0,1]
-	cbz	w0, .L2297
-.L2298:
+	cbz	w0, .L2331
+.L2332:
 	add	x0, x23, :lo12:.LANCHOR0
 	ldrh	w19, [x0,2]
 	ldrb	w2, [x0,1]
 	udiv	w1, w20, w19
 	mul	w19, w1, w19
 	sub	w1, w20, w19
-	cbz	w2, .L2299
+	cbz	w2, .L2333
 	add	w19, w19, w1, lsl 1
-	b	.L2297
-.L2299:
+	b	.L2331
+.L2333:
 	add	x0, x0, 4
 	ldrh	w0, [x0,w1,uxtw 1]
 	add	w19, w0, w19
-.L2297:
-	adrp	x25, .LC169
-	adrp	x23, .LC170
-	adrp	x0, .LC171
-	add	x25, x25, :lo12:.LC169
-	add	x0, x0, :lo12:.LC171
-	add	x23, x23, :lo12:.LC170
+.L2331:
+	adrp	x25, .LC175
+	adrp	x23, .LC176
+	adrp	x0, .LC177
+	add	x25, x25, :lo12:.LC175
+	add	x0, x0, :lo12:.LC177
+	add	x23, x23, :lo12:.LC176
 	str	x0, [x29,120]
-.L2303:
+.L2337:
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 4, .L2300
+	tbz	x0, 4, .L2334
 	mov	x0, x25
 	mov	w1, w26
 	mov	w2, w20
 	mov	w3, w19
 	bl	printk
-.L2300:
+.L2334:
 	mov	w0, w26
 	mov	w1, w19
 	mov	x2, x22
@@ -14378,7 +14652,7 @@ flash_prog_page_en:
 	mov	w4, w27
 	bl	flash_prog_page
 	mov	w6, w0
-	cbz	w28, .L2301
+	cbz	w28, .L2335
 	adrp	x5, .LANCHOR4
 	mov	w4, w27
 	add	x7, x5, :lo12:.LANCHOR4
@@ -14386,29 +14660,29 @@ flash_prog_page_en:
 	mov	w1, w20
 	str	x5, [x29,104]
 	str	x6, [x29,96]
-	ldr	x2, [x7,1224]
-	ldr	x3, [x7,1232]
+	ldr	x2, [x7,1248]
+	ldr	x3, [x7,1256]
 	str	x7, [x29,112]
 	bl	flash_read_page_en
 	cmp	w0, 512
 	cset	w4, eq
 	ldr	x5, [x29,104]
-	cbnz	w4, .L2302
+	cbnz	w4, .L2336
 	cmn	w0, #1
-	beq	.L2302
+	beq	.L2336
 	ldr	x7, [x29,112]
 	ldr	w1, [x22]
 	ldr	x6, [x29,96]
-	ldr	x0, [x7,1224]
+	ldr	x0, [x7,1248]
 	ldr	w0, [x0]
 	cmp	w1, w0
-	bne	.L2302
-	ldr	x0, [x7,1232]
+	bne	.L2336
+	ldr	x0, [x7,1256]
 	ldr	w1, [x21]
 	ldr	w0, [x0]
 	cmp	w1, w0
-	beq	.L2301
-.L2302:
+	beq	.L2335
+.L2336:
 	mov	w2, 4
 	mov	x0, x23
 	mov	w3, w2
@@ -14423,42 +14697,42 @@ flash_prog_page_en:
 	bl	rknand_print_hex
 	ldr	x5, [x29,112]
 	mov	w2, 4
-	adrp	x0, .LC172
+	adrp	x0, .LC178
 	mov	w3, w2
 	add	x5, x5, :lo12:.LANCHOR4
-	add	x0, x0, :lo12:.LC172
+	add	x0, x0, :lo12:.LC178
 	str	x5, [x29,112]
-	ldr	x1, [x5,1232]
+	ldr	x1, [x5,1256]
 	bl	rknand_print_hex
 	ldr	x5, [x29,112]
 	mov	w2, 4
-	adrp	x0, .LC173
+	adrp	x0, .LC179
 	mov	w3, w2
-	add	x0, x0, :lo12:.LC173
-	ldr	x1, [x5,1224]
+	add	x0, x0, :lo12:.LC179
+	ldr	x1, [x5,1248]
 	bl	rknand_print_hex
 	ldr	x4, [x29,104]
-	cbnz	w4, .L2303
-.L2305:
-	adrp	x0, .LC174
+	cbnz	w4, .L2337
+.L2339:
+	adrp	x0, .LC180
 	mov	w1, w20
-	add	x0, x0, :lo12:.LC174
+	add	x0, x0, :lo12:.LC180
 	bl	printk
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 577
+	mov	w2, 578
 	add	x1, x1, 376
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
 	mov	w0, -1
-	b	.L2304
-.L2301:
+	b	.L2338
+.L2335:
 	cmn	w6, #1
 	mov	w0, w6
-	beq	.L2305
-.L2304:
+	beq	.L2339
+.L2338:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -14489,20 +14763,20 @@ ftl_prog_page:
 	bl	flash_prog_page_en
 	cmn	w0, #1
 	mov	w19, w0
-	bne	.L2323
+	bne	.L2357
 	adrp	x2, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x2, :lo12:.LANCHOR3
 	add	x0, x0, :lo12:.LC0
 	add	x1, x1, 400
-	mov	w2, 2203
+	mov	w2, 2231
 	bl	printk
 	bl	dump_stack
-	adrp	x0, .LC174
+	adrp	x0, .LC180
 	mov	w1, w20
-	add	x0, x0, :lo12:.LC174
+	add	x0, x0, :lo12:.LC180
 	bl	printk
-.L2323:
+.L2357:
 	mov	w0, w19
 	ldp	x19, x20, [sp,16]
 	ldp	x29, x30, [sp], 64
@@ -14527,20 +14801,20 @@ ftl_info_flush:
 	adrp	x23, .LANCHOR3
 	add	x19, x22, :lo12:.LANCHOR4
 	ldrb	w2, [x0,2832]
-	adrp	x24, .LC175
+	adrp	x24, .LC181
 	add	x23, x23, :lo12:.LANCHOR3
 	add	x0, x19, 1280
 	lsl	w2, w2, 1
 	mov	w25, 0
-	add	x24, x24, :lo12:.LC175
+	add	x24, x24, :lo12:.LC181
 	add	x23, x23, 416
 	bl	ftl_memset
-.L2325:
+.L2359:
 	add	x0, x21, :lo12:.LANCHOR0
 	ldrb	w27, [x19,1536]
 	ldrh	w20, [x19,1538]
 	ldr	x2, [x0,2864]
-	ldrh	w28, [x0,3348]
+	ldrh	w28, [x0,3362]
 	ldr	w1, [x2,4]
 	add	w1, w1, 1
 	str	w1, [x2,4]
@@ -14550,29 +14824,29 @@ ftl_info_flush:
 	str	w0, [x19,1284]
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2326
+	tbz	x0, 12, .L2360
 	ldr	w3, [x3,4]
 	mov	x0, x24
 	mov	w1, w27
 	mov	w2, w20
 	bl	printk
-.L2326:
+.L2360:
 	add	x1, x21, :lo12:.LANCHOR0
 	ldrh	w0, [x19,1538]
-	ldrh	w1, [x1,3300]
+	ldrh	w1, [x1,3324]
 	cmp	w1, w0
-	bhi	.L2327
+	bhi	.L2361
 	adrp	x20, .LC0
 	add	x20, x20, :lo12:.LC0
-.L2332:
+.L2366:
 	ldrb	w1, [x19,1537]
 	add	w1, w1, 1
 	uxtb	w1, w1
 	strb	w1, [x19,1537]
 	cmp	w1, 7
-	bls	.L2328
+	bls	.L2362
 	mov	x1, 0
-.L2331:
+.L2365:
 	add	x0, x21, :lo12:.LANCHOR0
 	uxth	w25, w1
 	ldr	x2, [x0,728]
@@ -14582,24 +14856,24 @@ ftl_info_flush:
 	add	w0, w2, 127
 	uxtb	w0, w0
 	cmp	w0, 125
-	bhi	.L2329
+	bhi	.L2363
 	mov	x1, x23
-	mov	w2, 742
+	mov	w2, 748
 	mov	x0, x20
 	bl	printk
 	bl	dump_stack
-	b	.L2330
-.L2329:
+	b	.L2364
+.L2363:
 	cmp	w2, 255
-	bne	.L2330
+	bne	.L2364
 	add	x1, x1, 1
 	cmp	x1, 8
-	bne	.L2331
+	bne	.L2365
 	mov	w25, w1
-.L2330:
+.L2364:
 	strb	w25, [x19,1537]
 	mov	w25, 1
-.L2328:
+.L2362:
 	add	x27, x21, :lo12:.LANCHOR0
 	ldrb	w1, [x19,1537]
 	ldr	x0, [x27,728]
@@ -14607,8 +14881,8 @@ ftl_info_flush:
 	ldrb	w2, [x1,40]
 	strb	w2, [x19,1536]
 	cmp	w2, 255
-	beq	.L2332
-	ldrh	w20, [x27,3348]
+	beq	.L2366
+	ldrh	w20, [x27,3362]
 	mov	w0, 0
 	mul	w20, w2, w20
 	mov	w1, w20
@@ -14622,13 +14896,13 @@ ftl_info_flush:
 	bl	ftl_prog_page
 	mov	w0, 1
 	strh	w0, [x19,1538]
-	b	.L2333
-.L2327:
+	b	.L2367
+.L2361:
 	madd	w20, w27, w28, w20
-	cbnz	w0, .L2333
+	cbnz	w0, .L2367
 	mov	w1, w20
 	bl	flash_erase_block
-.L2333:
+.L2367:
 	add	x4, x21, :lo12:.LANCHOR0
 	mov	w1, w20
 	mov	w0, 0
@@ -14641,31 +14915,31 @@ ftl_info_flush:
 	adrp	x0, .LANCHOR5
 	add	w1, w1, 1
 	strh	w1, [x19,1538]
-	beq	.L2334
+	beq	.L2368
 	add	x1, x0, :lo12:.LANCHOR5
 	ldrb	w1, [x1,576]
-	cbz	w1, .L2335
-.L2334:
+	cbz	w1, .L2369
+.L2368:
 	add	x0, x0, :lo12:.LANCHOR5
 	strb	wzr, [x0,576]
-	b	.L2325
-.L2335:
-	cbnz	w25, .L2336
-.L2344:
+	b	.L2359
+.L2369:
+	cbnz	w25, .L2370
+.L2378:
 	add	x22, x22, :lo12:.LANCHOR4
 	ldrb	w0, [x22,1536]
 	cmp	w0, 255
-	bne	.L2338
+	bne	.L2372
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 778
+	mov	w2, 784
 	add	x1, x1, 416
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-	b	.L2338
-.L2336:
+	b	.L2372
+.L2370:
 	ldrb	w19, [x19,1537]
 	adrp	x20, .LANCHOR3
 	adrp	x23, .LC0
@@ -14673,9 +14947,9 @@ ftl_info_flush:
 	add	w19, w19, 1
 	add	x23, x23, :lo12:.LC0
 	add	x20, x20, 416
-.L2339:
+.L2373:
 	cmp	w19, 7
-	bhi	.L2344
+	bhi	.L2378
 	add	x0, x21, :lo12:.LANCHOR0
 	ldr	x1, [x0,728]
 	add	w0, w19, 8
@@ -14684,27 +14958,27 @@ ftl_info_flush:
 	add	w0, w24, 127
 	uxtb	w0, w0
 	cmp	w0, 125
-	bhi	.L2340
+	bhi	.L2374
 	mov	x1, x20
-	mov	w2, 771
+	mov	w2, 777
 	mov	x0, x23
 	bl	printk
 	bl	dump_stack
-	b	.L2341
-.L2340:
+	b	.L2375
+.L2374:
 	cmp	w24, 255
-	beq	.L2342
-.L2341:
+	beq	.L2376
+.L2375:
 	add	x0, x21, :lo12:.LANCHOR0
-	ldrh	w1, [x0,3348]
+	ldrh	w1, [x0,3362]
 	mov	w0, 0
 	mul	w1, w24, w1
 	bl	flash_erase_block
-.L2342:
+.L2376:
 	add	w19, w19, 1
 	uxth	w19, w19
-	b	.L2339
-.L2338:
+	b	.L2373
+.L2372:
 	mov	w0, 0
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
@@ -14723,34 +14997,34 @@ ftl_info_blk_init:
 	mov	w2, 16384
 	add	x29, sp, 0
 	stp	x19, x20, [sp,16]
-	adrp	x19, .LANCHOR0
-	adrp	x20, .LANCHOR5
+	adrp	x20, .LANCHOR0
+	adrp	x19, .LANCHOR5
 	stp	x23, x24, [sp,48]
-	add	x23, x19, :lo12:.LANCHOR0
-	add	x20, x20, :lo12:.LANCHOR5
+	add	x23, x20, :lo12:.LANCHOR0
+	add	x19, x19, :lo12:.LANCHOR5
 	stp	x21, x22, [sp,32]
 	stp	x25, x26, [sp,64]
 	stp	x27, x28, [sp,80]
 	adrp	x21, .LANCHOR4
-	strb	w0, [x20,576]
+	strb	w0, [x19,576]
 	ldrh	w1, [x23,576]
 	add	x22, x21, :lo12:.LANCHOR4
 	add	x24, x22, 1600
-	strb	w0, [x20,578]
+	strb	w0, [x19,578]
 	mov	x0, x24
-	strb	wzr, [x20,577]
+	strb	wzr, [x19,577]
 	add	x1, x24, x1, lsl 2
 	str	x1, [x23,2864]
 	mov	w1, 0
 	str	x24, [x23,584]
-	adrp	x26, .LC176
+	adrp	x26, .LC182
 	adrp	x27, .LANCHOR2
 	bl	ftl_memset
-	add	x26, x26, :lo12:.LC176
-	add	x0, x20, 640
+	add	x26, x26, :lo12:.LC182
+	add	x0, x19, 640
 	mov	w1, 0
 	mov	w2, 16384
-	mov	w20, 7
+	mov	w19, 7
 	bl	ftl_memset
 	strb	wzr, [x22,1537]
 	ldr	x0, [x23,728]
@@ -14758,16 +15032,16 @@ ftl_info_blk_init:
 	strh	wzr, [x22,1538]
 	ldrb	w0, [x0,40]
 	strb	w0, [x22,1536]
-.L2362:
-	add	x5, x19, :lo12:.LANCHOR0
-	add	w0, w20, 8
-	sxth	w25, w20
+.L2396:
+	add	x5, x20, :lo12:.LANCHOR0
+	add	w0, w19, 8
+	sxth	w25, w19
 	ldr	x1, [x5,728]
 	add	x0, x1, x0, sxtw
 	ldrb	w1, [x0,32]
 	cmp	w1, 255
-	beq	.L2358
-	ldrh	w22, [x5,3348]
+	beq	.L2392
+	ldrh	w22, [x5,3362]
 	mov	w0, 0
 	ldrb	w4, [x5,2832]
 	mov	x2, x24
@@ -14779,7 +15053,7 @@ ftl_info_blk_init:
 	cmn	w0, #1
 	mov	w28, w0
 	ldr	x5, [x29,104]
-	bne	.L2359
+	bne	.L2393
 	ldrb	w4, [x5,2832]
 	mov	w0, 0
 	add	w1, w22, 1
@@ -14787,111 +15061,120 @@ ftl_info_blk_init:
 	mov	x3, x23
 	bl	ftl_read_page
 	mov	w28, w0
-.L2359:
+.L2393:
 	ldr	w0, [x27,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2360
-	add	x0, x19, :lo12:.LANCHOR0
-	mov	w1, w20
+	tbz	x0, 12, .L2394
+	add	x0, x20, :lo12:.LANCHOR0
+	mov	w1, w19
 	mov	w2, w28
 	mov	w3, 672
 	ldr	x4, [x0,2864]
 	mov	x0, x26
 	ldr	w4, [x4]
 	bl	printk
-.L2360:
+.L2394:
 	cmn	w28, #1
-	beq	.L2358
-	add	x0, x19, :lo12:.LANCHOR0
+	beq	.L2392
+	add	x0, x20, :lo12:.LANCHOR0
 	ldr	x0, [x0,2864]
 	ldr	w1, [x0]
 	mov	w0, 21574
 	movk	w0, 0x494c, lsl 16
 	cmp	w1, w0
-	beq	.L2370
-.L2358:
-	sub	w20, w20, #1
-	cmn	w20, #1
-	bne	.L2362
+	beq	.L2405
+.L2392:
+	sub	w19, w19, #1
+	cmn	w19, #1
+	bne	.L2396
 	mov	w25, 0
-	b	.L2361
-.L2370:
-	mov	w20, w25
-.L2361:
-	adrp	x0, .LANCHOR2
-	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2363
-	add	x0, x19, :lo12:.LANCHOR0
-	mov	w1, w20
+	b	.L2395
+.L2405:
+	mov	w19, w25
+.L2395:
+	adrp	x23, .LANCHOR2
+	ldr	w0, [x23,#:lo12:.LANCHOR2]
+	tbz	x0, 12, .L2397
+	add	x0, x20, :lo12:.LANCHOR0
+	mov	w1, w19
 	mov	w2, 4800
 	ldr	x3, [x0,2864]
-	adrp	x0, .LC177
-	add	x0, x0, :lo12:.LC177
+	adrp	x0, .LC183
+	add	x0, x0, :lo12:.LC183
 	ldr	w3, [x3]
 	bl	printk
-.L2363:
-	cmn	w20, #1
-	bne	.L2364
+.L2397:
+	cmn	w19, #1
+	bne	.L2398
 	add	x0, x21, :lo12:.LANCHOR4
 	mov	w1, 0
-	add	x19, x19, :lo12:.LANCHOR0
+	add	x20, x20, :lo12:.LANCHOR0
 	add	x0, x0, 1600
 	mov	w2, 16384
 	bl	ftl_memset
-	ldr	x1, [x19,2864]
+	ldr	x1, [x20,2864]
 	mov	w0, 21574
 	movk	w0, 0x494c, lsl 16
 	str	w0, [x1]
-	mov	w0, 20
+	mov	w0, 22
 	movk	w0, 0x6, lsl 16
-	ldr	x1, [x19,2864]
+	ldr	x1, [x20,2864]
 	str	w0, [x1,12]
-	mov	w0, w20
-	b	.L2365
-.L2364:
-	add	x26, x19, :lo12:.LANCHOR0
-	add	x23, x21, :lo12:.LANCHOR4
+	b	.L2422
+.L2398:
+	add	x27, x20, :lo12:.LANCHOR0
+	add	x24, x21, :lo12:.LANCHOR4
 	add	w0, w25, 8
-	add	x24, x23, 1600
-	mov	x2, x24
+	add	x26, x24, 1280
+	mov	x3, x26
 	mov	w4, 4
-	ldr	x1, [x26,728]
+	ldr	x1, [x27,728]
 	add	x0, x1, x0, sxtw
-	strb	w25, [x23,1537]
-	add	x25, x23, 1280
+	strb	w25, [x24,1537]
+	add	x25, x24, 1600
 	ldrb	w1, [x0,32]
-	mov	x3, x25
+	mov	x2, x25
 	mov	w0, 0
-	strb	w1, [x23,1536]
+	strb	w1, [x24,1536]
 	bl	flash_get_last_written_page
 	sxth	w22, w0
 	add	w0, w0, 1
-	uxth	w20, w0
-	ldrb	w0, [x23,1536]
-	ldrh	w23, [x26,3348]
-	mul	w23, w0, w23
-.L2366:
-	tbnz	w22, #31, .L2369
-	add	x26, x19, :lo12:.LANCHOR0
+	uxth	w19, w0
+	ldrb	w0, [x24,1536]
+	ldrh	w24, [x27,3362]
+	mul	w24, w0, w24
+	b	.L2400
+.L2422:
+	mov	w0, w19
+	b	.L2399
+.L2403:
+	add	x27, x20, :lo12:.LANCHOR0
 	mov	w0, 0
-	add	w1, w22, w23
-	mov	x2, x24
-	mov	x3, x25
-	ldrb	w4, [x26,2832]
+	add	w1, w22, w24
+	mov	x2, x25
+	mov	x3, x26
+	ldrb	w4, [x27,2832]
 	bl	ftl_read_page
 	cmn	w0, #1
-	beq	.L2367
-	ldr	x0, [x26,2864]
+	bne	.L2423
+.L2401:
+	sub	w22, w22, #1
+	sxth	w22, w22
+.L2400:
+	tbz	w22, #31, .L2403
+	b	.L2404
+.L2423:
+	ldr	x0, [x27,2864]
 	ldr	w1, [x0]
 	mov	w0, 21574
 	movk	w0, 0x494c, lsl 16
 	cmp	w1, w0
-	bne	.L2367
-.L2369:
+	bne	.L2401
+.L2404:
 	add	x21, x21, :lo12:.LANCHOR4
-	add	x19, x19, :lo12:.LANCHOR0
-	strh	w20, [x21,1538]
+	add	x20, x20, :lo12:.LANCHOR0
+	strh	w19, [x21,1538]
 	bl	ftl_tmp_into_update
-	ldr	x1, [x19,2864]
+	ldr	x1, [x20,2864]
 	ldr	w0, [x1,64]
 	add	w0, w0, 1
 	str	w0, [x1,64]
@@ -14899,13 +15182,16 @@ ftl_info_blk_init:
 	bl	ftl_info_flush
 	mov	w0, 0
 	bl	ftl_info_flush
+	ldr	w0, [x23,#:lo12:.LANCHOR2]
+	and	w19, w0, 16384
+	tbz	x0, 14, .L2422
+	ldr	x1, [x20,2864]
+	adrp	x0, .LC184
+	add	x0, x0, :lo12:.LC184
+	ldr	w1, [x1,156]
+	bl	printk
 	mov	w0, 0
-	b	.L2365
-.L2367:
-	sub	w22, w22, #1
-	sxth	w22, w22
-	b	.L2366
-.L2365:
+.L2399:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -14932,17 +15218,17 @@ ftl_ext_info_flush:
 	ldr	x1, [x1,608]
 	ldr	w3, [x1,520]
 	cmp	w0, w3
-	bls	.L2388
+	bls	.L2425
 	ldr	w2, [x1,12]
 	sub	w2, w2, w3
 	add	w2, w2, w0
 	str	w2, [x1,12]
-	b	.L2401
-.L2388:
-	bcs	.L2389
-.L2401:
+	b	.L2438
+.L2425:
+	bcs	.L2426
+.L2438:
 	str	w0, [x1,520]
-.L2389:
+.L2426:
 	adrp	x23, .LANCHOR3
 	adrp	x19, .LANCHOR4
 	add	x23, x23, :lo12:.LANCHOR3
@@ -14951,40 +15237,40 @@ ftl_ext_info_flush:
 	add	x23, x23, 432
 	add	x19, x19, 1280
 	bl	ftl_total_vpn_update
-.L2390:
+.L2427:
 	adrp	x24, .LANCHOR5
 	add	x24, x24, :lo12:.LANCHOR5
 	add	x25, x24, 640
-.L2393:
+.L2430:
 	add	x2, x22, :lo12:.LANCHOR0
 	ldr	x0, [x2,2864]
 	ldr	w1, [x0,56]
 	add	w1, w1, 1
 	str	w1, [x0,56]
 	ldrh	w1, [x0,140]
-	ldrh	w0, [x2,3300]
+	ldrh	w0, [x2,3324]
 	cmp	w1, w0
-	bcc	.L2391
+	bcc	.L2428
 	bl	ftl_ext_alloc_new_blk
-.L2391:
+.L2428:
 	add	x0, x22, :lo12:.LANCHOR0
 	ldr	x0, [x0,2864]
 	ldrh	w1, [x0,130]
 	mov	w0, 65535
 	cmp	w1, w0
-	bne	.L2392
+	bne	.L2429
 	adrp	x0, .LC0
 	mov	x1, x23
-	mov	w2, 1798
+	mov	w2, 1819
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L2392:
+.L2429:
 	add	x21, x22, :lo12:.LANCHOR0
 	mov	w0, 21
 	mov	w1, 1
 	ldr	x2, [x21,2864]
-	ldrh	w20, [x21,3340]
+	ldrh	w20, [x21,3264]
 	ldrh	w3, [x2,130]
 	sub	w20, w0, w20
 	ldrh	w0, [x2,140]
@@ -14993,7 +15279,7 @@ ftl_ext_info_flush:
 	sub	w20, w20, #1
 	ldrb	w2, [x21,2832]
 	and	w3, w20, w3
-	ldrh	w20, [x21,3348]
+	ldrh	w20, [x21,3362]
 	mov	w1, 0
 	lsl	w2, w2, 1
 	madd	w20, w3, w20, w0
@@ -15016,17 +15302,17 @@ ftl_ext_info_flush:
 	uxth	w1, w1
 	strh	w1, [x2,140]
 	cmp	w1, 1
-	beq	.L2393
+	beq	.L2430
 	cmn	w0, #1
-	beq	.L2394
+	beq	.L2431
 	ldrb	w0, [x24,578]
-	cbz	w0, .L2395
-.L2394:
+	cbz	w0, .L2432
+.L2431:
 	adrp	x0, .LANCHOR5
 	add	x0, x0, :lo12:.LANCHOR5
 	strb	wzr, [x0,578]
-	b	.L2390
-.L2395:
+	b	.L2427
+.L2432:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -15053,10 +15339,10 @@ ftl_ext_info_init:
 	add	x2, x20, :lo12:.LANCHOR5
 	ldr	x0, [x26,2864]
 	add	x3, x21, :lo12:.LANCHOR4
-	ldrh	w22, [x26,3340]
+	ldrh	w22, [x26,3264]
 	add	x2, x2, 640
 	add	x3, x3, 1280
-	strh	wzr, [x26,3880]
+	strh	wzr, [x26,3896]
 	ldrh	w1, [x0,130]
 	mov	w0, 21
 	sub	w22, w0, w22
@@ -15073,60 +15359,60 @@ ftl_ext_info_init:
 	adrp	x0, .LANCHOR2
 	mov	w23, w24
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2403
+	tbz	x0, 12, .L2440
 	ldr	x5, [x26,2864]
 	adrp	x1, .LANCHOR3
-	adrp	x0, .LC178
+	adrp	x0, .LC185
 	add	x1, x1, :lo12:.LANCHOR3
-	add	x0, x0, :lo12:.LC178
+	add	x0, x0, :lo12:.LC185
 	add	x1, x1, 456
 	ldrh	w5, [x5,130]
-	mov	w2, 1842
+	mov	w2, 1863
 	mov	w3, w24
 	uxth	w4, w27
 	bl	printk
-.L2403:
+.L2440:
 	add	x20, x20, :lo12:.LANCHOR5
 	add	x21, x21, :lo12:.LANCHOR4
 	mov	w26, w24
 	add	x20, x20, 640
 	add	x21, x21, 1280
-.L2404:
-	tbnz	w26, #31, .L2409
+.L2441:
+	tbnz	w26, #31, .L2446
 	add	x27, x19, :lo12:.LANCHOR0
 	mov	w0, w25
 	mov	x2, x20
 	mov	x3, x21
-	ldrh	w1, [x27,3348]
+	ldrh	w1, [x27,3362]
 	ldrb	w4, [x27,2832]
 	madd	w1, w22, w1, w26
 	bl	flash_read_page_en
 	cmp	w0, 512
-	beq	.L2405
+	beq	.L2442
 	cmn	w0, #1
-	beq	.L2405
+	beq	.L2442
 	ldr	x0, [x27,608]
 	ldr	w1, [x0]
 	mov	w0, 20038
 	movk	w0, 0x4549, lsl 16
 	cmp	w1, w0
-	bne	.L2405
-.L2409:
+	bne	.L2442
+.L2446:
 	bl	zftl_sblk_list_init
 	add	x0, x19, :lo12:.LANCHOR0
 	ldr	x0, [x0,2864]
 	ldrh	w1, [x0,140]
 	cmp	w1, w24
-	bgt	.L2407
+	bgt	.L2444
 	add	w23, w23, 1
 	strh	w23, [x0,140]
 	bl	ftl_ext_info_flush
-	b	.L2407
-.L2405:
+	b	.L2444
+.L2442:
 	sub	w26, w26, #1
 	sxth	w26, w26
-	b	.L2404
-.L2407:
+	b	.L2441
+.L2444:
 	add	x19, x19, :lo12:.LANCHOR0
 	ldr	x20, [x19,608]
 	bl	timer_get_time
@@ -15136,15 +15422,19 @@ ftl_ext_info_init:
 	ldr	x20, [x19,608]
 	bl	timer_get_time
 	str	w0, [x20,604]
-	ldr	x1, [x19,608]
-	mov	w0, -1
-	strh	w0, [x19,3224]
-	strh	w0, [x1,584]
-	strh	w0, [x1,586]
-	strh	w0, [x1,588]
-	strh	w0, [x1,590]
+	ldr	x0, [x19,608]
+	mov	w1, -1
+	strh	w1, [x0,584]
+	strh	w1, [x0,586]
+	strh	w1, [x0,588]
+	strh	w1, [x0,590]
+	mov	w1, 65535
+	str	wzr, [x0,608]
+	str	w1, [x0,560]
+	mov	w1, -1
+	str	w1, [x0,564]
 	mov	w0, 0
-	str	wzr, [x1,608]
+	strh	w1, [x19,3240]
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -15186,14 +15476,14 @@ ftl_write_last_log_page:
 	add	x19, x19, :lo12:.LANCHOR0
 	ldrh	w24, [x0,12]
 	cmp	w1, 1
-	ldr	x22, [x19,3864]
-	bne	.L2421
+	ldr	x22, [x19,3880]
+	bne	.L2458
 	mov	x20, x0
 	bl	ftl_get_new_free_page
 	cmn	w0, #1
 	mov	w23, w0
 	mov	w21, 0
-	beq	.L2421
+	beq	.L2458
 	ldrh	w0, [x20]
 	add	x22, x22, x24, uxth 2
 	bl	ftl_vpn_decrement
@@ -15204,8 +15494,8 @@ ftl_write_last_log_page:
 	add	x2, x1, 3968
 	str	x2, [x29,72]
 	str	w0, [x1,3968]
-	ldrb	w0, [x19,3276]
-	ldrh	w1, [x19,3300]
+	ldrb	w0, [x19,3300]
+	ldrh	w1, [x19,3324]
 	mul	w1, w1, w0
 	mov	x0, x22
 	lsl	w1, w1, 2
@@ -15218,7 +15508,7 @@ ftl_write_last_log_page:
 	str	w21, [x2,8]
 	str	w21, [x2,12]
 	bl	ftl_prog_ppa_page
-.L2421:
+.L2458:
 	mov	w0, w21
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
@@ -15241,34 +15531,34 @@ ftl_open_sblk_recovery:
 	stp	x19, x20, [sp,16]
 	stp	x23, x24, [sp,48]
 	stp	x27, x28, [sp,80]
-	tbz	x0, 12, .L2426
-	adrp	x0, .LC179
+	tbz	x0, 12, .L2463
+	adrp	x0, .LC186
 	ldrh	w1, [x25,2]
-	add	x0, x0, :lo12:.LC179
+	add	x0, x0, :lo12:.LC186
 	bl	printk
-.L2426:
+.L2463:
 	ldr	w0, [x21,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2427
-	adrp	x0, .LC180
+	tbz	x0, 12, .L2464
+	adrp	x0, .LC187
 	ldrb	w1, [x25,5]
-	add	x0, x0, :lo12:.LC180
+	add	x0, x0, :lo12:.LC187
 	bl	printk
-.L2427:
+.L2464:
 	ldr	w0, [x21,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2428
-	adrp	x0, .LC181
+	tbz	x0, 12, .L2465
+	adrp	x0, .LC188
 	ldrh	w1, [x25]
-	add	x0, x0, :lo12:.LC181
+	add	x0, x0, :lo12:.LC188
 	bl	printk
-.L2428:
+.L2465:
 	ldr	w0, [x21,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2429
-	adrp	x0, .LC182
+	tbz	x0, 12, .L2466
+	adrp	x0, .LC189
 	ldrh	w1, [x25,16]
 	ldrh	w2, [x25,18]
-	add	x0, x0, :lo12:.LC182
+	add	x0, x0, :lo12:.LC189
 	bl	printk
-.L2429:
+.L2466:
 	ldrh	w0, [x25,10]
 	adrp	x19, .LANCHOR0
 	strh	w0, [x25,14]
@@ -15276,7 +15566,7 @@ ftl_open_sblk_recovery:
 	ldrh	w1, [x25]
 	ldrh	w0, [x0,576]
 	cmp	w1, w0
-	bcs	.L2425
+	bcs	.L2462
 	mov	w0, 1
 	add	x20, x29, 144
 	adrp	x24, .LANCHOR4
@@ -15296,24 +15586,24 @@ ftl_open_sblk_recovery:
 	str	wzr, [x29,136]
 	add	x0, x0, 480
 	str	x0, [x29,112]
-.L2431:
+.L2468:
 	add	x0, x19, :lo12:.LANCHOR0
-	ldrh	w0, [x0,3300]
+	ldrh	w0, [x0,3324]
 	cmp	w0, w23
-	bls	.L2434
+	bls	.L2471
 	ldrb	w22, [x25,5]
-.L2432:
+.L2469:
 	ldrb	w0, [x25,9]
 	cmp	w0, w22
-	bls	.L2542
+	bls	.L2579
 	add	x0, x25, x22, sxtw 1
 	ldrh	w0, [x0,16]
 	mov	w1, 65535
 	cmp	w0, w1
-	beq	.L2433
+	beq	.L2470
 	add	x3, x19, :lo12:.LANCHOR0
 	ldr	x2, [x27,24]
-	ldrh	w1, [x3,3348]
+	ldrh	w1, [x3,3362]
 	ldrb	w3, [x3,2832]
 	madd	w0, w0, w1, w23
 	ldr	x1, [x27,8]
@@ -15321,21 +15611,21 @@ ftl_open_sblk_recovery:
 	bl	ftl_read_ppa_page
 	cmp	w0, 512
 	mov	w28, w0
-	beq	.L2434
+	beq	.L2471
 	cmn	w0, #1
-	beq	.L2435
+	beq	.L2472
 	ldr	x0, [x27,24]
 	ldr	w1, [x0]
 	cmn	w1, #1
-	bne	.L2435
+	bne	.L2472
 	ldr	w0, [x0,4]
 	cmn	w0, #1
-	bne	.L2435
+	bne	.L2472
 	ldr	x0, [x27,8]
 	ldr	w0, [x0]
 	cmn	w0, #1
-	beq	.L2434
-.L2435:
+	beq	.L2471
+.L2472:
 	adrp	x0, .LANCHOR5+577
 	mov	w1, 1
 	strb	w1, [x0,#:lo12:.LANCHOR5+577]
@@ -15343,60 +15633,60 @@ ftl_open_sblk_recovery:
 	ldrh	w1, [x25,10]
 	madd	w0, w23, w0, w22
 	cmp	w1, w0
-	beq	.L2436
+	beq	.L2473
 	adrp	x0, .LC0
 	ldr	x1, [x29,112]
-	mov	w2, 1399
+	mov	w2, 1412
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L2436:
+.L2473:
 	ldrh	w0, [x25,10]
 	ldrh	w1, [x25,6]
 	ldrb	w2, [x25,9]
 	add	w1, w1, w0
 	add	x0, x19, :lo12:.LANCHOR0
-	ldrh	w0, [x0,3300]
+	ldrh	w0, [x0,3324]
 	mul	w0, w0, w2
 	cmp	w1, w0
-	beq	.L2437
+	beq	.L2474
 	adrp	x0, .LC0
 	ldr	x1, [x29,112]
-	mov	w2, 1400
+	mov	w2, 1413
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L2437:
+.L2474:
 	cmn	w28, #1
-	beq	.L2441
+	beq	.L2478
 	ldr	x0, [x27,24]
 	ldr	w0, [x0,4]
 	cmn	w0, #1
-	beq	.L2441
+	beq	.L2478
 	bl	lpa_hash_get_ppa
 	ldr	x1, [x29,120]
-	cbz	x1, .L2439
+	cbz	x1, .L2476
 	ldr	x3, [x27,24]
 	ldr	w1, [x3,8]
 	cmp	w0, w1
-	beq	.L2439
+	beq	.L2476
 	cmn	w0, #1
-	beq	.L2439
+	beq	.L2476
 	add	x28, x19, :lo12:.LANCHOR0
 	mov	w4, 21
 	mov	w26, 1
-	ldrh	w1, [x28,3340]
+	ldrh	w1, [x28,3264]
 	lsr	w2, w0, w1
 	sub	w1, w4, w1
 	lsl	w1, w26, w1
 	sub	w1, w1, #1
 	and	w1, w2, w1
-	ldrb	w2, [x28,3338]
+	ldrb	w2, [x28,3266]
 	udiv	w1, w1, w2
 	ldr	x2, [x29,120]
 	ldrh	w2, [x2]
 	cmp	w2, w1, uxth
-	bne	.L2439
+	bne	.L2476
 	ldr	w7, [x3]
 	mov	x2, x24
 	ldr	x1, [x27,8]
@@ -15408,36 +15698,36 @@ ftl_open_sblk_recovery:
 	ldr	x7, [x29,136]
 	ldr	x4, [x29,104]
 	cmp	w0, w7
-	bcc	.L2439
+	bcc	.L2476
 	ldr	x0, [x27,24]
 	ldr	w1, [x0,8]
 	cmn	w1, #1
-	beq	.L2441
-	ldrh	w0, [x28,3340]
+	beq	.L2478
+	ldrh	w0, [x28,3264]
 	sub	w4, w4, w0
 	lsr	w1, w1, w0
 	lsl	w26, w26, w4
-	ldrb	w0, [x28,3338]
+	ldrb	w0, [x28,3266]
 	sub	w26, w26, #1
 	and	w1, w26, w1
 	udiv	w0, w1, w0
 	bl	ftl_vpn_decrement
-	b	.L2441
-.L2439:
+	b	.L2478
+.L2476:
 	ldr	x2, [x27,24]
 	add	x1, x19, :lo12:.LANCHOR0
 	ldr	w3, [x2,4]
 	ldr	w0, [x1,2840]
 	cmp	w3, w0
-	bcs	.L2441
+	bcs	.L2478
 	ldrb	w0, [x25,9]
-	ldrh	w4, [x1,3300]
+	ldrh	w4, [x1,3324]
 	ldrh	w3, [x25,10]
 	mul	w0, w0, w4
 	sub	w0, w0, #1
 	cmp	w3, w0
-	blt	.L2543
-.L2441:
+	blt	.L2580
+.L2478:
 	ldrh	w0, [x25,6]
 	mov	w26, 4
 	sub	w0, w0, #1
@@ -15447,111 +15737,111 @@ ftl_open_sblk_recovery:
 	strh	w0, [x25,10]
 	mov	w0, 1
 	str	w0, [x29,136]
-.L2433:
+.L2470:
 	add	w22, w22, 1
 	uxth	w22, w22
-	b	.L2432
-.L2542:
+	b	.L2469
+.L2579:
 	add	w23, w23, 1
 	strb	wzr, [x25,5]
 	uxth	w23, w23
-	b	.L2431
-.L2434:
+	b	.L2468
+.L2471:
 	add	x2, x19, :lo12:.LANCHOR0
 	ldrh	w0, [x25,10]
 	ldrh	w1, [x25,6]
 	strh	w23, [x25,2]
 	add	w1, w1, w0
-	ldrh	w2, [x2,3300]
+	ldrh	w2, [x2,3324]
 	ldrb	w0, [x25,9]
 	strb	w22, [x25,5]
 	mul	w0, w0, w2
 	cmp	w1, w0
-	beq	.L2445
+	beq	.L2482
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 1480
+	mov	w2, 1493
 	add	x1, x1, 480
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L2445:
+.L2482:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrh	w3, [x25,10]
-	ldr	x4, [x0,3864]
+	ldr	x4, [x0,3880]
 	mov	w0, 0
 	mov	w2, w0
-.L2446:
+.L2483:
 	cmp	w2, w3
-	bcs	.L2544
+	bcs	.L2581
 	ldrh	w1, [x25,12]
 	add	w1, w2, w1
 	ldr	w1, [x4,x1,lsl 2]
 	cmn	w1, #1
-	beq	.L2447
+	beq	.L2484
 	add	w1, w0, 1
 	uxth	w0, w1
-.L2447:
+.L2484:
 	add	w2, w2, 1
-	b	.L2446
-.L2544:
+	b	.L2483
+.L2581:
 	add	x2, x19, :lo12:.LANCHOR0
 	ldrb	w1, [x25,9]
 	sub	w0, w0, w3
-	ldrh	w22, [x2,3300]
+	ldrh	w22, [x2,3324]
 	madd	w0, w1, w22, w0
 	uxth	w22, w0
 	ldr	w0, [x21,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2449
+	tbz	x0, 12, .L2486
 	ldrh	w1, [x25]
-	adrp	x0, .LC183
+	adrp	x0, .LC190
 	ldr	x4, [x2,600]
-	add	x0, x0, :lo12:.LC183
+	add	x0, x0, :lo12:.LC190
 	ubfiz	x3, x1, 1, 16
 	mov	w2, w22
 	ldrh	w3, [x4,x3]
 	bl	printk
-.L2449:
+.L2486:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrh	w1, [x25]
 	ldr	x0, [x0,600]
 	strh	w22, [x0,x1,lsl 1]
 	ldr	w0, [x21,#:lo12:.LANCHOR2]
-	tbz	x0, 14, .L2450
-	adrp	x0, .LC184
+	tbz	x0, 14, .L2487
+	adrp	x0, .LC191
 	ldr	w1, [x29,144]
 	ldr	w2, [x29,148]
-	add	x0, x0, :lo12:.LC184
+	add	x0, x0, :lo12:.LC191
 	ldr	w3, [x29,152]
 	ldr	w4, [x29,156]
 	bl	printk
-.L2450:
+.L2487:
 	add	x0, x19, :lo12:.LANCHOR0
 	mov	w1, 0
-	adrp	x24, .LC185
+	adrp	x24, .LC192
 	mov	x23, 0
-	add	x24, x24, :lo12:.LC185
+	add	x24, x24, :lo12:.LC192
 	ldrb	w2, [x0,2832]
 	ldr	x0, [x27,8]
 	lsl	w2, w2, 9
 	bl	ftl_memset
-	adrp	x0, .LC186
-	add	x28, x0, :lo12:.LC186
-	adrp	x0, .LC187
-	add	x0, x0, :lo12:.LC187
+	adrp	x0, .LC193
+	add	x28, x0, :lo12:.LC193
+	adrp	x0, .LC194
+	add	x0, x0, :lo12:.LC194
 	str	x0, [x29,120]
-.L2451:
+.L2488:
 	add	x22, x19, :lo12:.LANCHOR0
 	str	w23, [x29,132]
-	ldrb	w0, [x22,3276]
+	ldrb	w0, [x22,3300]
 	mul	w0, w26, w0
 	cmp	w23, w0
-	bcs	.L2545
+	bcs	.L2582
 	ldr	w0, [x20,x23,lsl 2]
 	cmn	w0, #1
-	bne	.L2452
-.L2456:
+	bne	.L2489
+.L2493:
 	add	x1, x19, :lo12:.LANCHOR0
 	ldr	x0, [x27,24]
 	mov	w22, -1
@@ -15566,8 +15856,8 @@ ftl_open_sblk_recovery:
 	str	wzr, [x0,12]
 	ldr	x0, [x27,8]
 	str	wzr, [x0]
-	b	.L2453
-.L2452:
+	b	.L2490
+.L2489:
 	ldrb	w3, [x22,2832]
 	ldr	x1, [x27,8]
 	ldr	x2, [x27,24]
@@ -15578,7 +15868,7 @@ ftl_open_sblk_recovery:
 	bl	lpa_hash_get_ppa
 	mov	w4, w0
 	ldr	w0, [x21,#:lo12:.LANCHOR2]
-	tbz	x0, 14, .L2454
+	tbz	x0, 14, .L2491
 	ldr	x3, [x27,24]
 	mov	w1, w4
 	ldr	w2, [x20,x23,lsl 2]
@@ -15587,7 +15877,7 @@ ftl_open_sblk_recovery:
 	ldr	w3, [x3,4]
 	bl	printk
 	ldr	x4, [x29,112]
-.L2454:
+.L2491:
 	ldr	w0, [x20,x23,lsl 2]
 	ldr	x2, [x27,24]
 	cmp	w4, w0
@@ -15604,19 +15894,19 @@ ftl_open_sblk_recovery:
 	str	w4, [x0,8]
 	ldr	x0, [x27,24]
 	str	w1, [x0,12]
-	beq	.L2456
-.L2453:
+	beq	.L2493
+.L2490:
 	ldr	w0, [x29,136]
-	cbz	w0, .L2458
-.L2541:
+	cbz	w0, .L2495
+.L2578:
 	ldrh	w0, [x25,6]
 	cmp	w0, 1
-	bls	.L2458
+	bls	.L2495
 	mov	x0, x25
 	bl	ftl_get_new_free_page
 	mov	w4, w0
 	ldr	w0, [x21,#:lo12:.LANCHOR2]
-	tbz	x0, 14, .L2460
+	tbz	x0, 14, .L2497
 	ldr	x2, [x27,24]
 	mov	w1, w4
 	mov	x0, x28
@@ -15624,16 +15914,16 @@ ftl_open_sblk_recovery:
 	ldr	w2, [x2,4]
 	bl	printk
 	ldr	x4, [x29,112]
-.L2460:
+.L2497:
 	add	x3, x19, :lo12:.LANCHOR0
 	ldr	w1, [x29,132]
 	ldrh	w0, [x25,6]
-	ldrb	w2, [x3,3276]
+	ldrb	w2, [x3,3300]
 	mul	w2, w26, w2
 	add	w2, w2, 1
 	sub	w2, w2, w1
 	cmp	w0, w2
-	bls	.L2458
+	bls	.L2495
 	ldr	x1, [x27,8]
 	mov	w0, w4
 	ldr	x2, [x27,24]
@@ -15647,10 +15937,10 @@ ftl_open_sblk_recovery:
 	cmn	w22, #1
 	cset	w1, ne
 	cmn	w2, #1
-	beq	.L2461
-	cbz	w1, .L2458
+	beq	.L2498
+	cbz	w1, .L2495
 	ldr	w0, [x21,#:lo12:.LANCHOR2]
-	tbz	x0, 14, .L2462
+	tbz	x0, 14, .L2499
 	ldr	x2, [x27,24]
 	ldrh	w0, [x25,12]
 	ldrh	w3, [x25,10]
@@ -15660,7 +15950,7 @@ ftl_open_sblk_recovery:
 	ldr	x0, [x29,120]
 	sub	w3, w3, #1
 	bl	printk
-.L2462:
+.L2499:
 	ldr	x1, [x27,24]
 	ldrh	w0, [x25,12]
 	ldrh	w2, [x25,10]
@@ -15669,48 +15959,48 @@ ftl_open_sblk_recovery:
 	ldr	w1, [x1,8]
 	sub	w2, w2, #1
 	bl	lpa_hash_update_ppa
-	b	.L2458
-.L2461:
-	cbnz	w1, .L2541
-.L2458:
+	b	.L2495
+.L2498:
+	cbnz	w1, .L2578
+.L2495:
 	add	x23, x23, 1
-	b	.L2451
-.L2545:
+	b	.L2488
+.L2582:
 	mov	x0, x27
-	bl	buf_free
-	ldrh	w1, [x22,3300]
+	bl	zbuf_free
+	ldrh	w1, [x22,3324]
 	ldrh	w0, [x25,12]
 	ldrb	w2, [x25,9]
 	madd	w0, w1, w2, w0
 	mov	x1, -4
 	add	x0, x1, x0, sxtw 2
-	ldr	x1, [x22,3864]
+	ldr	x1, [x22,3880]
 	ldr	w0, [x1,x0]
 	cmn	w0, #1
-	beq	.L2466
+	beq	.L2503
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 1554
+	mov	w2, 1567
 	add	x1, x1, 480
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L2466:
+.L2503:
 	ldrh	w0, [x25,6]
 	cmp	w0, 1
-	bne	.L2425
+	bne	.L2462
 	mov	x0, x25
 	bl	ftl_write_last_log_page
-	b	.L2425
-.L2543:
+	b	.L2462
+.L2580:
 	ldr	x0, [x1,2864]
 	ldr	w2, [x2]
 	ldr	w1, [x0,8]
 	cmp	w2, w1
-	bls	.L2442
+	bls	.L2479
 	str	w2, [x0,8]
-.L2442:
+.L2479:
 	ldr	x1, [x27,24]
 	ldrh	w0, [x25,10]
 	ldrh	w2, [x25,12]
@@ -15726,8 +16016,8 @@ ftl_open_sblk_recovery:
 	str	w0, [x20,8]
 	ldr	w0, [x29,132]
 	str	w0, [x20,12]
-	b	.L2441
-.L2425:
+	b	.L2478
+.L2462:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -15755,7 +16045,7 @@ pm_write_page:
 	adrp	x25, .LANCHOR0
 	add	x23, x23, :lo12:.LC0
 	add	x22, x22, 504
-.L2547:
+.L2584:
 	add	x2, x25, :lo12:.LANCHOR0
 	adrp	x19, .LANCHOR0
 	ldr	x0, [x2,2864]
@@ -15763,36 +16053,36 @@ pm_write_page:
 	ldrh	w3, [x0,696]
 	add	w1, w1, 1
 	str	w1, [x0,48]
-	ldrh	w1, [x2,3300]
+	ldrh	w1, [x2,3324]
 	cmp	w3, w1
-	bcs	.L2548
+	bcs	.L2585
 	ldrh	w1, [x0,692]
 	mov	w0, 65535
 	cmp	w1, w0
-	bne	.L2549
-.L2548:
+	bne	.L2586
+.L2585:
 	bl	pm_alloc_new_blk
 	mov	w0, 0
 	bl	ftl_info_flush
-.L2549:
+.L2586:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldr	x0, [x0,2864]
 	ldrh	w1, [x0,692]
 	mov	w0, 65535
 	cmp	w1, w0
-	bne	.L2550
+	bne	.L2587
 	mov	x1, x22
 	mov	w2, 230
 	mov	x0, x23
 	bl	printk
 	bl	dump_stack
-.L2550:
+.L2587:
 	add	x19, x19, :lo12:.LANCHOR0
 	adrp	x20, .LANCHOR7
 	add	x27, x20, :lo12:.LANCHOR7
 	mov	w2, 64
 	ldr	x1, [x19,2864]
-	ldrh	w26, [x19,3348]
+	ldrh	w26, [x19,3362]
 	ldrh	w0, [x1,692]
 	ldrh	w1, [x1,696]
 	madd	w26, w0, w26, w1
@@ -15818,28 +16108,28 @@ pm_write_page:
 	uxth	w2, w2
 	strh	w2, [x1,696]
 	cmp	w2, 1
-	beq	.L2551
+	beq	.L2588
 	ldrb	w2, [x27,-120]
-	cbz	w2, .L2552
-.L2551:
+	cbz	w2, .L2589
+.L2588:
 	add	x20, x20, :lo12:.LANCHOR7
 	strb	wzr, [x20,-120]
-	b	.L2547
-.L2552:
+	b	.L2584
+.L2589:
 	cmn	w0, #1
-	bne	.L2554
-	adrp	x0, .LC188
+	bne	.L2591
+	adrp	x0, .LC195
 	mov	w1, w26
-	add	x0, x0, :lo12:.LC188
+	add	x0, x0, :lo12:.LC195
 	bl	printk
-	b	.L2547
-.L2554:
+	b	.L2584
+.L2591:
 	ldrh	w0, [x1,698]
 	cmp	w21, w0
-	bcs	.L2555
+	bcs	.L2592
 	add	x21, x1, x21, uxtw 2
 	str	w26, [x21,704]
-.L2555:
+.L2592:
 	mov	w0, 0
 	ldr	x27, [sp,80]
 	ldp	x19, x20, [sp,16]
@@ -15866,12 +16156,12 @@ ftl_dump_write_open_sblk:
 	stp	x27, x28, [sp,128]
 	ldrh	w1, [x0,576]
 	cmp	w1, w23
-	bls	.L2559
-	ldrb	w1, [x0,3272]
-	cbnz	w1, .L2561
-	ldrb	w0, [x0,3258]
-	cbz	w0, .L2559
-.L2561:
+	bls	.L2596
+	ldrb	w1, [x0,3296]
+	cbnz	w1, .L2598
+	ldrb	w0, [x0,3282]
+	cbz	w0, .L2596
+.L2598:
 	add	x1, x22, :lo12:.LANCHOR0
 	ubfiz	x19, x23, 2, 16
 	mov	w27, 1
@@ -15880,15 +16170,15 @@ ftl_dump_write_open_sblk:
 	ldrb	w0, [x0,2]
 	and	w0, w0, 224
 	cmp	w0, 160
-	bne	.L2562
-	ldrb	w27, [x1,3257]
-.L2562:
+	bne	.L2599
+	ldrb	w27, [x1,3281]
+.L2599:
 	add	x24, x29, 128
 	mov	w0, w23
 	add	x1, x24, 16
 	strh	w23, [x29,128]
 	mov	w21, 0
-	adrp	x25, .LC190
+	adrp	x25, .LC197
 	bl	ftl_get_blk_list_in_sblk
 	uxtb	w0, w0
 	add	x1, x22, :lo12:.LANCHOR0
@@ -15897,8 +16187,8 @@ ftl_dump_write_open_sblk:
 	mov	w20, w21
 	strb	wzr, [x29,133]
 	mov	w26, w21
-	ldrh	w2, [x1,3300]
-	add	x25, x25, :lo12:.LC190
+	ldrh	w2, [x1,3324]
+	add	x25, x25, :lo12:.LC197
 	strh	wzr, [x29,138]
 	mul	w0, w0, w2
 	strh	w0, [x29,134]
@@ -15906,57 +16196,57 @@ ftl_dump_write_open_sblk:
 	add	x1, x0, x19
 	ldrh	w4, [x0,x19]
 	ldr	w5, [x0,x19]
-	adrp	x0, .LC189
+	adrp	x0, .LC196
 	ldrb	w3, [x1,2]
 	and	w4, w4, 2047
 	mov	w1, w23
 	ubfx	x5, x5, 11, 8
 	ubfx	x2, x3, 5, 3
-	add	x0, x0, :lo12:.LC189
+	add	x0, x0, :lo12:.LC196
 	ubfx	x3, x3, 3, 2
 	bl	printk
 	mov	w0, 1
 	bl	buf_alloc
 	mov	x19, x0
 	mov	w8, 65535
-.L2563:
+.L2600:
 	add	x0, x22, :lo12:.LANCHOR0
-	ldrh	w0, [x0,3300]
+	ldrh	w0, [x0,3324]
 	cmp	w0, w20
-	bls	.L2584
+	bls	.L2621
 	lsl	w28, w20, 1
 	mov	w26, 0
 	sub	w28, w28, #1
-.L2573:
+.L2610:
 	ldrb	w0, [x24,9]
 	cmp	w0, w26
-	bls	.L2588
+	bls	.L2625
 	mov	w21, 1
 	sxtw	x9, w26
-.L2572:
+.L2609:
 	cmp	w21, w27
-	bhi	.L2589
+	bhi	.L2626
 	add	x0, x9, 8
 	ldrh	w5, [x24,x0,lsl 1]
 	cmp	w5, w8
-	beq	.L2565
+	beq	.L2602
 	add	x0, x22, :lo12:.LANCHOR0
 	cmp	w27, 3
-	ldrh	w2, [x0,3348]
+	ldrh	w2, [x0,3362]
 	mul	w2, w5, w2
-	bne	.L2566
+	bne	.L2603
 	add	w2, w2, w20
 	orr	w3, w2, w21, lsl 24
-	b	.L2567
-.L2566:
+	b	.L2604
+.L2603:
 	cmp	w27, 2
 	add	w3, w2, w20
-	bne	.L2567
-	ldrb	w3, [x0,3257]
+	bne	.L2604
+	ldrb	w3, [x0,3281]
 	add	w2, w2, w28
 	add	w2, w2, w21
 	orr	w3, w2, w3, lsl 24
-.L2567:
+.L2604:
 	str	w3, [x19,40]
 	mov	w1, 1
 	mov	x0, x19
@@ -15993,32 +16283,32 @@ ftl_dump_write_open_sblk:
 	ldr	x9, [x29,104]
 	cmp	w10, 512
 	ldr	x8, [x29,96]
-	beq	.L2584
-.L2565:
+	beq	.L2621
+.L2602:
 	add	w21, w21, 1
 	uxth	w21, w21
-	b	.L2572
-.L2589:
+	b	.L2609
+.L2626:
 	add	w26, w26, 1
 	uxth	w26, w26
-	b	.L2573
-.L2588:
+	b	.L2610
+.L2625:
 	add	w20, w20, 1
 	uxth	w20, w20
-	b	.L2563
-.L2584:
-.L2569:
-	adrp	x0, .LC191
+	b	.L2600
+.L2621:
+.L2606:
+	adrp	x0, .LC198
 	mov	w4, w21
 	mov	w2, w20
 	mov	w3, w26
 	mov	w1, w23
 	mov	w25, w20
-	add	x0, x0, :lo12:.LC191
+	add	x0, x0, :lo12:.LC198
 	add	x20, x22, :lo12:.LANCHOR0
-	adrp	x21, .LC192
+	adrp	x21, .LC199
 	bl	printk
-	add	x21, x21, :lo12:.LC192
+	add	x21, x21, :lo12:.LC199
 	ldrb	w2, [x20,2832]
 	mov	w1, 0
 	ldr	x0, [x19,8]
@@ -16029,26 +16319,26 @@ ftl_dump_write_open_sblk:
 	ldr	x0, [x19,24]
 	lsl	w2, w2, 1
 	bl	ftl_memset
-.L2574:
+.L2611:
 	add	x0, x22, :lo12:.LANCHOR0
-	ldrh	w0, [x0,3300]
+	ldrh	w0, [x0,3324]
 	cmp	w0, w25
-	bls	.L2579
+	bls	.L2616
 	lsl	w26, w25, 1
 	mov	w20, 0
-.L2580:
+.L2617:
 	ldrb	w0, [x24,9]
 	cmp	w0, w20
-	bls	.L2590
+	bls	.L2627
 	mov	w1, w25
 	mov	x0, x21
 	mov	w2, w20
 	bl	printk
 	add	x4, x22, :lo12:.LANCHOR0
 	sxtw	x3, w20
-	ldrb	w5, [x4,3272]
-	ldrh	w1, [x4,3348]
-	cbz	w5, .L2575
+	ldrb	w5, [x4,3296]
+	ldrh	w1, [x4,3362]
+	cbz	w5, .L2612
 	add	x3, x3, 8
 	ldrh	w0, [x24,x3,lsl 1]
 	mul	w1, w0, w1
@@ -16056,21 +16346,21 @@ ftl_dump_write_open_sblk:
 	orr	w1, w1, w25
 	str	w1, [x19,40]
 	bl	sblk_3d_tlc_dump_prog
-	b	.L2576
-.L2575:
+	b	.L2613
+.L2612:
 	add	x3, x3, 8
-	ldrb	w0, [x4,3257]
+	ldrb	w0, [x4,3281]
 	cmp	w0, 2
 	ldrh	w0, [x24,x3,lsl 1]
 	mul	w1, w0, w1
-	bne	.L2577
+	bne	.L2614
 	orr	w1, w1, w26
 	mov	x0, x19
 	orr	w1, w1, 33554432
 	str	w1, [x19,40]
 	bl	sblk_mlc_dump_prog
-	b	.L2576
-.L2577:
+	b	.L2613
+.L2614:
 	orr	w1, w1, w25
 	ldr	x2, [x19,8]
 	ldr	x3, [x19,24]
@@ -16079,22 +16369,22 @@ ftl_dump_write_open_sblk:
 	str	w1, [x19,40]
 	and	w1, w1, -14680065
 	bl	flash_prog_page_en
-.L2576:
+.L2613:
 	add	w20, w20, 1
 	uxth	w20, w20
-	b	.L2580
-.L2590:
+	b	.L2617
+.L2627:
 	add	w25, w25, 1
 	uxth	w25, w25
-	b	.L2574
-.L2579:
+	b	.L2611
+.L2616:
 	mov	x0, x19
-	bl	buf_free
-	adrp	x0, .LC193
+	bl	zbuf_free
+	adrp	x0, .LC200
 	mov	w1, w23
-	add	x0, x0, :lo12:.LC193
+	add	x0, x0, :lo12:.LC200
 	bl	printk
-.L2559:
+.L2596:
 	sub	sp, x29, #48
 	ldp	x19, x20, [sp,64]
 	ldp	x21, x22, [sp,80]
@@ -16118,32 +16408,32 @@ flash_info_flush:
 	stp	x23, x24, [sp,48]
 	stp	x25, x26, [sp,64]
 	stp	x27, x28, [sp,80]
-	tbz	x0, 12, .L2592
+	tbz	x0, 12, .L2629
 	adrp	x2, .LANCHOR3
-	adrp	x0, .LC130
+	adrp	x0, .LC134
 	add	x2, x2, :lo12:.LANCHOR3
-	add	x0, x0, :lo12:.LC130
+	add	x0, x0, :lo12:.LC134
 	mov	w1, 324
 	add	x2, x2, 520
 	bl	printk
-.L2592:
+.L2629:
 	adrp	x22, .LANCHOR7
 	adrp	x23, .LANCHOR0
 	add	x0, x22, :lo12:.LANCHOR7
 	mov	w1, 0
 	mov	w2, 64
 	add	x19, x23, :lo12:.LANCHOR0
-	adrp	x24, .LC195
-	adrp	x25, .LC196
+	adrp	x24, .LC202
+	adrp	x25, .LC203
 	ldr	x0, [x0,-112]
 	mov	w26, 0
-	add	x24, x24, :lo12:.LC195
+	add	x24, x24, :lo12:.LC202
 	adrp	x27, .LANCHOR4
-	add	x25, x25, :lo12:.LC196
+	add	x25, x25, :lo12:.LC203
 	bl	ftl_memset
 	ldr	x1, [x19,728]
-	adrp	x0, .LC194
-	add	x0, x0, :lo12:.LC194
+	adrp	x0, .LC201
+	add	x0, x0, :lo12:.LC201
 	mov	w2, 4
 	mov	w3, 16
 	bl	rknand_print_hex
@@ -16152,7 +16442,7 @@ flash_info_flush:
 	ldr	w1, [x19,8]
 	bl	js_hash
 	str	w0, [x19,12]
-.L2593:
+.L2630:
 	add	x21, x22, :lo12:.LANCHOR7
 	add	x28, x23, :lo12:.LANCHOR0
 	mov	x0, x24
@@ -16166,10 +16456,10 @@ flash_info_flush:
 	add	x1, x27, :lo12:.LANCHOR4
 	ldrh	w0, [x21,-102]
 	ldr	x3, [x29,104]
-	ldrh	w1, [x1,1084]
+	ldrh	w1, [x1,1108]
 	sub	w1, w1, #1
 	cmp	w0, w1
-	blt	.L2594
+	blt	.L2631
 	ldr	x1, [x28,728]
 	strh	wzr, [x21,-102]
 	ldr	w0, [x1,4]
@@ -16191,14 +16481,14 @@ flash_info_flush:
 	mov	w0, 0
 	ldrh	w19, [x28,2]
 	mul	w19, w1, w19
-	b	.L2602
-.L2594:
+	b	.L2639
+.L2631:
 	madd	w19, w20, w3, w19
-	cbnz	w0, .L2595
-.L2602:
+	cbnz	w0, .L2632
+.L2639:
 	mov	w1, w19
 	bl	flash_erase_block
-.L2595:
+.L2632:
 	add	x2, x23, :lo12:.LANCHOR0
 	add	x20, x22, :lo12:.LANCHOR7
 	mov	w4, 4
@@ -16220,16 +16510,16 @@ flash_info_flush:
 	ldrh	w1, [x20,-102]
 	add	w1, w1, 1
 	strh	w1, [x20,-102]
-	bne	.L2596
+	bne	.L2633
 	mov	x0, x25
 	mov	w1, w19
 	bl	printk
-	b	.L2593
-.L2596:
-	cbnz	w26, .L2603
+	b	.L2630
+.L2633:
+	cbnz	w26, .L2640
 	mov	w26, 1
-	b	.L2593
-.L2603:
+	b	.L2630
+.L2640:
 	mov	w0, 0
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
@@ -16252,21 +16542,21 @@ flash_info_blk_init:
 	stp	x23, x24, [sp,48]
 	str	x25, [sp,64]
 	adrp	x20, .LANCHOR0
-	tbz	x0, 12, .L2605
+	tbz	x0, 12, .L2642
 	add	x4, x20, :lo12:.LANCHOR0
 	adrp	x2, .LANCHOR3
-	adrp	x0, .LC197
+	adrp	x0, .LC204
 	add	x2, x2, :lo12:.LANCHOR3
-	add	x0, x0, :lo12:.LC197
+	add	x0, x0, :lo12:.LC204
 	mov	w1, 50
 	ldr	x4, [x4,728]
 	add	x2, x2, 544
 	mov	w3, 2048
 	bl	printk
-.L2605:
+.L2642:
 	mov	w23, 4
 	adrp	x24, .LANCHOR7
-.L2608:
+.L2645:
 	add	x19, x20, :lo12:.LANCHOR0
 	add	x21, x24, :lo12:.LANCHOR7
 	mov	w0, 0
@@ -16278,21 +16568,21 @@ flash_info_blk_init:
 	mul	w1, w23, w1
 	bl	flash_read_page_en
 	cmn	w0, #1
-	beq	.L2606
+	beq	.L2643
 	ldr	x2, [x19,728]
 	mov	w0, 21321
 	movk	w0, 0x5359, lsl 16
 	ldr	w1, [x2]
 	cmp	w1, w0
-	beq	.L2607
-.L2606:
+	beq	.L2644
+.L2643:
 	add	w23, w23, 1
 	cmp	w23, 16
-	bne	.L2608
-.L2633:
+	bne	.L2645
+.L2670:
 	mov	w0, -1
-	b	.L2632
-.L2607:
+	b	.L2669
+.L2644:
 	ldrb	w1, [x2,36]
 	mov	w4, 4
 	ldrh	w3, [x19,2]
@@ -16305,16 +16595,16 @@ flash_info_blk_init:
 	mov	w21, 0
 	bl	flash_read_page_en
 	cmn	w0, #1
-	beq	.L2610
+	beq	.L2647
 	ldr	x0, [x19,728]
 	mov	w1, 21321
 	movk	w1, 0x5359, lsl 16
 	mov	w21, 0
 	ldr	w2, [x0]
 	cmp	w2, w1
-	bne	.L2610
+	bne	.L2647
 	ldr	w21, [x0,4]
-.L2610:
+.L2647:
 	add	x19, x22, :lo12:.LANCHOR7
 	add	x23, x20, :lo12:.LANCHOR0
 	mov	w0, 0
@@ -16326,21 +16616,21 @@ flash_info_blk_init:
 	ldr	x2, [x23,728]
 	bl	flash_read_page_en
 	cmn	w0, #1
-	beq	.L2611
+	beq	.L2648
 	ldr	x0, [x23,728]
 	mov	w1, 21321
 	movk	w1, 0x5359, lsl 16
 	ldr	w2, [x0]
 	cmp	w2, w1
-	bne	.L2611
+	bne	.L2648
 	ldr	w1, [x0,4]
 	cmp	w21, w1
-	bcs	.L2611
+	bcs	.L2648
 	ldrb	w1, [x0,37]
 	ldrb	w0, [x0,36]
 	strb	w1, [x19,-104]
 	strb	w0, [x19,-103]
-.L2611:
+.L2648:
 	add	x19, x22, :lo12:.LANCHOR7
 	add	x21, x20, :lo12:.LANCHOR0
 	mov	w0, 0
@@ -16356,10 +16646,10 @@ flash_info_blk_init:
 	mov	w21, 0
 	strh	w0, [x19,-102]
 	mul	w23, w1, w23
-.L2612:
+.L2649:
 	sub	w19, w24, w21
 	sxth	w19, w19
-	tbnz	w19, #31, .L2634
+	tbnz	w19, #31, .L2671
 	add	x25, x20, :lo12:.LANCHOR0
 	add	x3, x22, :lo12:.LANCHOR7
 	mov	w0, 0
@@ -16369,33 +16659,33 @@ flash_info_blk_init:
 	ldr	x3, [x3,-112]
 	bl	flash_read_page_en
 	cmn	w0, #1
-	beq	.L2613
+	beq	.L2650
 	ldr	x0, [x25,728]
 	ldr	w1, [x0]
 	mov	w0, 21321
 	movk	w0, 0x5359, lsl 16
 	cmp	w1, w0
-	beq	.L2614
-.L2613:
+	beq	.L2651
+.L2650:
 	add	w21, w21, 1
-	b	.L2612
-.L2634:
+	b	.L2649
+.L2671:
 	cmn	w19, #1
-	bne	.L2614
+	bne	.L2651
 	add	x20, x20, :lo12:.LANCHOR0
-	adrp	x0, .LC198
-	add	x0, x0, :lo12:.LC198
+	adrp	x0, .LC205
+	add	x0, x0, :lo12:.LC205
 	ldr	x1, [x20,728]
 	ldr	w1, [x1]
 	bl	printk
-	b	.L2633
-.L2614:
+	b	.L2670
+.L2651:
 	cmp	w21, 1
 	mov	w0, 0
-	bls	.L2632
+	bls	.L2669
 	bl	flash_info_flush
 	mov	w0, 0
-.L2632:
+.L2669:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -16416,22 +16706,22 @@ nand_flash_init:
 	stp	x23, x24, [sp,48]
 	ldr	w0, [x20,#:lo12:.LANCHOR2]
 	str	x25, [sp,64]
-	tbz	x0, 12, .L2636
+	tbz	x0, 12, .L2673
 	adrp	x2, .LANCHOR3
-	adrp	x0, .LC130
+	adrp	x0, .LC134
 	add	x2, x2, :lo12:.LANCHOR3
-	add	x0, x0, :lo12:.LC130
-	mov	w1, 2459
+	add	x0, x0, :lo12:.LC134
+	mov	w1, 2491
 	add	x2, x2, 568
 	bl	printk
-.L2636:
+.L2673:
 	adrp	x21, .LANCHOR4
 	mov	x0, x19
 	add	x23, x21, :lo12:.LANCHOR4
 	adrp	x19, .LANCHOR0
 	add	x22, x19, :lo12:.LANCHOR0
 	mov	w25, 44
-	str	wzr, [x23,1212]
+	str	wzr, [x23,1236]
 	bl	nandc_init
 	add	x1, x20, :lo12:.LANCHOR2
 	mov	w0, 1
@@ -16444,78 +16734,78 @@ nand_flash_init:
 	add	x22, x22, 748
 	bl	ftl_memset
 	mov	x24, x22
-	add	x0, x23, 1088
+	add	x0, x23, 1112
 	mov	w1, 0
 	mov	w2, 32
 	mov	w23, 0
 	bl	ftl_memset
-.L2642:
+.L2679:
 	mov	w0, w23
 	mov	x1, x22
 	bl	flash_read_id
-	cbnz	w23, .L2637
+	cbnz	w23, .L2674
 	ldrb	w0, [x24]
 	sub	w0, w0, #1
 	uxtb	w0, w0
 	cmp	w0, 253
-	bls	.L2638
-.L2640:
+	bls	.L2675
+.L2677:
 	mov	w22, -2
-	b	.L2712
-.L2638:
+	b	.L2749
+.L2675:
 	ldrb	w0, [x24,1]
 	cmp	w0, 255
-	beq	.L2640
-.L2637:
+	beq	.L2677
+.L2674:
 	ldrb	w0, [x22]
 	cmp	w0, 181
-	bne	.L2641
+	bne	.L2678
 	strb	w25, [x22]
-.L2641:
+.L2678:
 	add	w23, w23, 1
 	add	x22, x22, 8
 	uxtb	w23, w23
 	cmp	w23, 4
-	bne	.L2642
+	bne	.L2679
 	add	x23, x20, :lo12:.LANCHOR2
 	add	x24, x19, :lo12:.LANCHOR0
 	add	x23, x23, 440
 	mov	w22, 0
 	add	x24, x24, 748
-.L2645:
+.L2682:
 	ldrb	w2, [x23]
 	add	x0, x23, 1
 	mov	x1, x24
 	bl	flash_mem_cmp8
-	cbnz	w0, .L2643
+	cbnz	w0, .L2680
 	add	x1, x20, :lo12:.LANCHOR2
 	ubfiz	x22, x22, 5, 32
 	add	x0, x1, 440
 	adds	x22, x0, x22
-	beq	.L2640
+	beq	.L2677
 	ldrb	w3, [x22,22]
 	mov	x0, 0
-	b	.L2647
-.L2643:
+	b	.L2684
+.L2680:
 	add	w22, w22, 1
 	add	x23, x23, 32
-	cmp	w22, 38
-	bne	.L2645
-	b	.L2640
-.L2647:
+	cmp	w22, 39
+	bne	.L2682
+	b	.L2677
+.L2684:
 	add	x4, x1, x0, lsl 5
 	mov	w2, w0
-	ldrb	w4, [x4,1656]
+	ldrb	w4, [x4,1688]
 	cmp	w4, w3
-	beq	.L2646
+	beq	.L2683
 	add	x0, x0, 1
 	cmp	x0, 4
-	bne	.L2647
+	bne	.L2684
 	mov	w2, w0
-.L2646:
+.L2683:
 	add	x23, x20, :lo12:.LANCHOR2
 	add	x24, x19, :lo12:.LANCHOR0
-	add	x1, x23, 1656
+	add	x1, x23, 1688
 	ubfiz	x2, x2, 5, 32
 	add	x1, x1, x2
 	add	x0, x24, 640
@@ -16528,51 +16818,51 @@ nand_flash_init:
 	bl	ftl_memcpy
 	ldrb	w0, [x24,516]
 	cmp	w0, 8
-	bhi	.L2648
+	bhi	.L2685
 	ldrb	w1, [x23,20]
 	cmp	w1, 60
-	bls	.L2649
+	bls	.L2686
 	mov	w1, 60
 	strb	w1, [x23,20]
-.L2649:
+.L2686:
 	cmp	w0, 8
-	bne	.L2648
+	bne	.L2685
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrb	w0, [x0,748]
 	cmp	w0, 137
-	beq	.L2678
+	beq	.L2715
 	cmp	w0, 44
-	beq	.L2678
-.L2648:
+	beq	.L2715
+.L2685:
 	ldr	w0, [x20,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2651
+	tbz	x0, 12, .L2688
 	adrp	x2, .LANCHOR3
-	adrp	x0, .LC130
+	adrp	x0, .LC134
 	add	x2, x2, :lo12:.LANCHOR3
-	add	x0, x0, :lo12:.LC130
-	mov	w1, 2484
+	add	x0, x0, :lo12:.LC134
+	mov	w1, 2516
 	add	x2, x2, 568
 	bl	printk
-.L2651:
+.L2688:
 	add	x24, x21, :lo12:.LANCHOR4
 	mov	w0, 16384
 	add	x22, x19, :lo12:.LANCHOR0
 	adrp	x23, .LANCHOR7
 	bl	ftl_malloc
 	add	x25, x20, :lo12:.LANCHOR2
-	str	x0, [x24,1224]
+	str	x0, [x24,1248]
 	mov	w0, 16384
 	bl	ftl_malloc
-	str	x0, [x24,1184]
+	str	x0, [x24,1208]
 	mov	w0, 2048
 	bl	ftl_malloc
 	str	x0, [x22,728]
 	mov	w0, 64
 	bl	ftl_malloc
-	str	x0, [x24,1232]
+	str	x0, [x24,1256]
 	mov	w0, 64
 	bl	ftl_malloc
-	str	x0, [x24,1200]
+	str	x0, [x24,1224]
 	mov	w0, 64
 	bl	ftl_malloc
 	add	x1, x23, :lo12:.LANCHOR7
@@ -16583,81 +16873,81 @@ nand_flash_init:
 	bl	flash_lsb_page_tbl_build
 	ldrb	w0, [x25,28]
 	bl	nandc_bch_sel
-	str	xzr, [x24,1216]
+	str	xzr, [x24,1240]
 	ldr	x1, [x22,624]
 	ldrh	w0, [x1,16]
 	ldrb	w1, [x1,28]
 	ubfx	x2, x0, 8, 3
 	strb	w2, [x22,780]
 	ubfx	x2, x0, 3, 1
-	strb	w2, [x24,1240]
+	strb	w2, [x24,1264]
 	ubfx	x2, x0, 4, 1
 	strb	w2, [x22,781]
 	ubfx	x2, x0, 12, 1
-	strb	w2, [x22,3272]
+	strb	w2, [x22,3296]
 	ubfx	x2, x0, 13, 1
-	strb	w2, [x22,3258]
+	strb	w2, [x22,3282]
 	ubfx	x2, x0, 14, 1
 	lsr	w0, w0, 15
-	strb	w0, [x22,3259]
+	strb	w0, [x22,3283]
 	mov	w0, 60
 	strb	w0, [x22,632]
 	ldrb	w0, [x22,516]
 	strb	w2, [x22,1]
 	strb	w1, [x19,#:lo12:.LANCHOR0]
 	cmp	w0, 9
-	bne	.L2652
+	bne	.L2689
 	mov	w0, 70
 	strb	w0, [x22,632]
-.L2652:
+.L2689:
 	add	x0, x19, :lo12:.LANCHOR0
-	strb	w1, [x0,782]
+	strb	w1, [x0,634]
 	add	x1, x20, :lo12:.LANCHOR2
 	ldrb	w1, [x1,15]
 	cmp	w1, 9
-	bne	.L2653
-	strb	wzr, [x0,782]
-.L2653:
+	bne	.L2690
+	strb	wzr, [x0,634]
+.L2690:
 	add	x1, x20, :lo12:.LANCHOR2
 	add	x2, x19, :lo12:.LANCHOR0
 	add	x1, x1, 8
 	ldrb	w0, [x1,19]
 	ldrh	w1, [x1,16]
 	strb	w0, [x2,725]
-	tbz	x1, 6, .L2655
+	tbz	x1, 6, .L2692
 	sub	w1, w0, #17
 	cmp	w0, 21
 	cset	w2, eq
 	uxtb	w1, w1
 	cmp	w1, 2
-	bls	.L2679
-	cbz	w2, .L2656
-.L2679:
+	bls	.L2716
+	cbz	w2, .L2693
+.L2716:
 	add	x0, x21, :lo12:.LANCHOR4
 	adrp	x1, micron_read_retrial
 	add	x1, x1, :lo12:micron_read_retrial
-	str	x1, [x0,1216]
+	str	x1, [x0,1240]
 	mov	w1, 15
-	cbz	w2, .L2714
+	cbz	w2, .L2751
 	mov	w1, 4
-	b	.L2714
-.L2656:
+	b	.L2751
+.L2693:
 	sub	w1, w0, #65
 	uxtb	w1, w1
 	cmp	w1, 1
-	bls	.L2680
+	bls	.L2717
 	cmp	w0, 33
-	bne	.L2660
-.L2680:
+	bne	.L2697
+.L2717:
 	add	x0, x21, :lo12:.LANCHOR4
 	adrp	x1, toshiba_read_retrial
 	add	x1, x1, :lo12:toshiba_read_retrial
 	mov	w2, 4
-	str	x1, [x0,1216]
+	str	x1, [x0,1240]
 	add	x1, x19, :lo12:.LANCHOR0
 	strb	w2, [x1,726]
-	b	.L2716
-.L2660:
+	b	.L2753
+.L2697:
 	sub	w1, w0, #67
 	uxtb	w1, w1
 	cmp	w1, 1
@@ -16665,109 +16955,109 @@ nand_flash_init:
 	cset	w2, ls
 	uxtb	w1, w1
 	cmp	w1, 1
-	bls	.L2681
-	cbz	w2, .L2662
-.L2681:
+	bls	.L2718
+	cbz	w2, .L2699
+.L2718:
 	add	x3, x21, :lo12:.LANCHOR4
 	adrp	x1, toshiba_read_retrial
 	add	x1, x1, :lo12:toshiba_read_retrial
 	cmp	w0, 35
-	str	x1, [x3,1216]
-	beq	.L2664
+	str	x1, [x3,1240]
+	beq	.L2701
 	cmp	w0, 68
-	beq	.L2664
+	beq	.L2701
 	mov	w0, 7
-	strb	w0, [x3,1208]
-	b	.L2665
-.L2664:
+	strb	w0, [x3,1232]
+	b	.L2702
+.L2701:
 	add	x0, x21, :lo12:.LANCHOR4
 	mov	w1, 17
-	strb	w1, [x0,1208]
-.L2665:
+	strb	w1, [x0,1232]
+.L2702:
 	add	x0, x19, :lo12:.LANCHOR0
 	mov	w1, 4
-	cbnz	w2, .L2715
+	cbnz	w2, .L2752
 	mov	w1, 5
-.L2715:
+.L2752:
 	strb	w1, [x0,726]
-	b	.L2655
-.L2662:
+	b	.L2692
+.L2699:
 	sub	w0, w0, #36
 	uxtb	w0, w0
 	cmp	w0, 1
-	bhi	.L2655
+	bhi	.L2692
 	add	x0, x21, :lo12:.LANCHOR4
 	adrp	x1, toshiba_3d_read_retrial
 	add	x1, x1, :lo12:toshiba_3d_read_retrial
-	str	x1, [x0,1216]
-.L2716:
+	str	x1, [x0,1240]
+.L2753:
 	mov	w1, 7
-.L2714:
-	strb	w1, [x0,1208]
-.L2655:
+.L2751:
+	strb	w1, [x0,1232]
+.L2692:
 	ldr	w0, [x20,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2667
+	tbz	x0, 12, .L2704
 	adrp	x2, .LANCHOR3
-	adrp	x0, .LC130
+	adrp	x0, .LC134
 	add	x2, x2, :lo12:.LANCHOR3
-	add	x0, x0, :lo12:.LC130
-	mov	w1, 2537
+	add	x0, x0, :lo12:.LC134
+	mov	w1, 2574
 	add	x2, x2, 568
 	bl	printk
-.L2667:
+.L2704:
 	add	x0, x19, :lo12:.LANCHOR0
 	strb	wzr, [x0,672]
 	ldrb	w0, [x0,780]
-	tbz	x0, 0, .L2668
+	tbz	x0, 0, .L2705
 	mov	w0, 4
 	bl	nandc_set_if_mode
 	mov	w0, 1
 	bl	flash_set_interface_mode
 	mov	w0, 1
-	b	.L2717
-.L2668:
+	b	.L2754
+.L2705:
 	mov	w0, 4
-.L2717:
+.L2754:
 	bl	nandc_set_if_mode
 	bl	flash_info_blk_init
 	cmn	w0, #1
 	mov	w22, w0
-	bne	.L2670
+	bne	.L2707
 	ldr	w0, [x20,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2671
+	tbz	x0, 12, .L2708
 	adrp	x2, .LANCHOR3
-	adrp	x0, .LC130
+	adrp	x0, .LC134
 	add	x2, x2, :lo12:.LANCHOR3
-	add	x0, x0, :lo12:.LC130
-	mov	w1, 2568
+	add	x0, x0, :lo12:.LC134
+	mov	w1, 2606
 	add	x2, x2, 568
 	bl	printk
-.L2671:
+.L2708:
 	add	x19, x19, :lo12:.LANCHOR0
 	mov	w1, 17
 	ldr	x0, [x19,728]
 	strb	w1, [x0,32]
 	mov	w0, 0
 	bl	zftl_flash_exit_slc_mode
-	b	.L2712
-.L2670:
+	b	.L2749
+.L2707:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrb	w0, [x0,725]
 	sub	w0, w0, #1
 	uxtb	w0, w0
 	cmp	w0, 7
-	bhi	.L2672
+	bhi	.L2709
 	add	x21, x21, :lo12:.LANCHOR4
 	adrp	x0, hynix_read_retrial
 	add	x0, x0, :lo12:hynix_read_retrial
-	str	x0, [x21,1216]
-.L2672:
+	str	x0, [x21,1240]
+.L2709:
 	add	x19, x19, :lo12:.LANCHOR0
 	ldrb	w0, [x19,780]
-	tbz	x0, 2, .L2674
+	tbz	x0, 2, .L2711
 	ldr	x0, [x19,728]
 	ldrb	w0, [x0,19]
-	cbz	w0, .L2674
+	cbz	w0, .L2711
 	add	x23, x23, :lo12:.LANCHOR7
 	ldrh	w1, [x19,2]
 	mov	w0, 0
@@ -16775,33 +17065,33 @@ nand_flash_init:
 	mul	w1, w2, w1
 	bl	flash_ddr_para_scan
 	ldrb	w0, [x19,672]
-	cbnz	w0, .L2674
+	cbnz	w0, .L2711
 	ldr	x1, [x19,728]
 	strb	w0, [x1,19]
 	bl	flash_info_flush
-.L2674:
+.L2711:
 	ldr	w0, [x20,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2676
+	tbz	x0, 12, .L2713
 	adrp	x2, .LANCHOR3
-	adrp	x0, .LC130
+	adrp	x0, .LC134
 	add	x2, x2, :lo12:.LANCHOR3
-	add	x0, x0, :lo12:.LC130
-	mov	w1, 2634
+	add	x0, x0, :lo12:.LC134
+	mov	w1, 2672
 	add	x2, x2, 568
 	bl	printk
-.L2676:
+.L2713:
 	bl	nand_flash_print_info
 	mov	w22, 0
-	b	.L2712
-.L2678:
+	b	.L2749
+.L2715:
 	add	x0, x20, :lo12:.LANCHOR2
 	add	x0, x0, 8
 	ldrb	w1, [x0,28]
 	cmp	w1, 3
-	bne	.L2648
+	bne	.L2685
 	strb	wzr, [x0,28]
-	b	.L2648
-.L2712:
+	b	.L2685
+.L2749:
 	mov	w0, w22
 	ldr	x25, [sp,64]
 	ldp	x19, x20, [sp,16]
@@ -16817,42 +17107,39 @@ ftl_sysblk_dump:
 	sub	sp, sp, #144
 	stp	x29, x30, [sp,48]
 	add	x29, sp, 48
-	stp	x25, x26, [sp,112]
-	uxth	w25, w0
+	stp	x23, x24, [sp,96]
+	uxth	w24, w0
 	mov	w0, 1
 	stp	x19, x20, [sp,64]
-	stp	x23, x24, [sp,96]
-	stp	x27, x28, [sp,128]
 	stp	x21, x22, [sp,80]
+	stp	x25, x26, [sp,112]
+	str	x27, [sp,128]
+	mov	w21, 0
 	bl	buf_alloc
-	ldr	x24, [x0,8]
-	mov	w20, 0
-	adrp	x22, .LC190
-	adrp	x23, .LC199
-	mov	x27, x0
-	mov	w19, w20
-	adrp	x28, .LANCHOR0
-	add	x22, x22, :lo12:.LC190
-	add	x23, x23, :lo12:.LC199
-	add	x24, x24, 704
-.L2719:
-	add	x3, x28, :lo12:.LANCHOR0
-	ldrh	w1, [x3,3300]
-	cmp	w1, w19
-	bls	.L2731
-	ldrh	w21, [x3,3348]
-	ldr	x1, [x27,8]
-	ldr	x2, [x27,24]
-	madd	w21, w25, w21, w19
+	adrp	x23, .LC197
+	ldr	x26, [x0,8]
+	mov	x20, x0
+	mov	w19, w21
+	adrp	x27, .LANCHOR0
+	add	x23, x23, :lo12:.LC197
+.L2756:
+	add	x3, x27, :lo12:.LANCHOR0
+	ldrh	w0, [x3,3324]
+	cmp	w0, w19
+	bls	.L2768
+	ldrh	w22, [x3,3362]
+	ldr	x1, [x20,8]
+	ldr	x2, [x20,24]
+	madd	w22, w24, w22, w19
 	ldrb	w3, [x3,2832]
-	mov	w0, w21
+	mov	w0, w22
 	bl	ftl_read_ppa_page
-	mov	w26, w0
-	ldr	x7, [x27,8]
-	mov	w1, w25
-	ldr	x2, [x27,24]
-	mov	w3, w21
-	mov	w4, w26
+	mov	w25, w0
+	ldr	x7, [x20,8]
+	mov	w1, w24
+	ldr	x2, [x20,24]
+	mov	w3, w22
+	mov	w4, w25
 	ldr	w0, [x7,12]
 	str	w0, [sp]
 	ldr	w0, [x2]
@@ -16864,46 +17151,47 @@ ftl_sysblk_dump:
 	ldr	w0, [x2,12]
 	mov	w2, w19
 	str	w0, [sp,32]
-	mov	x0, x22
+	mov	x0, x23
 	ldr	w5, [x7]
 	ldr	w6, [x7,4]
 	ldr	w7, [x7,8]
 	bl	printk
-	mov	x0, x23
-	mov	x1, x24
+	cmp	w25, 512
+	beq	.L2761
+	cmn	w25, #1
+	bne	.L2757
+.L2761:
+	mov	w21, 1
+.L2757:
+	add	w19, w19, 1
+	uxth	w19, w19
+	b	.L2756
+.L2768:
+	adrp	x0, .LC206
+	add	x1, x26, 704
+	add	x0, x0, :lo12:.LC206
 	mov	w2, 4
 	mov	w3, 32
 	bl	rknand_print_hex
-	cmp	w26, 512
-	beq	.L2724
-	cmn	w26, #1
-	bne	.L2720
-.L2724:
-	mov	w20, 1
-.L2720:
-	add	w19, w19, 1
-	uxth	w19, w19
-	b	.L2719
-.L2731:
-	mov	x0, x27
-	bl	buf_free
-	cbz	w20, .L2723
+	mov	x0, x20
+	bl	zbuf_free
+	cbz	w21, .L2760
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 1338
+	mov	w2, 1351
 	add	x1, x1, 584
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L2723:
+.L2760:
 	sub	sp, x29, #48
-	mov	w0, w20
+	mov	w0, w21
 	ldp	x19, x20, [sp,64]
 	ldp	x21, x22, [sp,80]
 	ldp	x23, x24, [sp,96]
 	ldp	x25, x26, [sp,112]
-	ldp	x27, x28, [sp,128]
+	ldr	x27, [sp,128]
 	ldp	x29, x30, [sp,48]
 	add	sp, sp, 144
 	ret
@@ -16913,31 +17201,31 @@ ftl_sysblk_dump:
 	.type	dump_ftl_info, %function
 dump_ftl_info:
 	stp	x29, x30, [sp, -32]!
-	adrp	x0, .LC200
+	adrp	x0, .LC207
 	add	x29, sp, 0
 	str	x19, [sp,16]
 	adrp	x19, .LANCHOR0
 	add	x19, x19, :lo12:.LANCHOR0
-	add	x0, x0, :lo12:.LC200
+	add	x0, x0, :lo12:.LC207
 	ldrb	w1, [x19,2834]
 	bl	printk
 	adrp	x3, .LANCHOR4
-	adrp	x0, .LC201
+	adrp	x0, .LC208
 	add	x3, x3, :lo12:.LANCHOR4
-	add	x0, x0, :lo12:.LC201
+	add	x0, x0, :lo12:.LC208
 	ldrb	w1, [x3,1536]
 	ldrb	w2, [x3,1537]
 	ldrh	w3, [x3,1538]
 	bl	printk
 	ldr	x2, [x19,2864]
-	adrp	x0, .LC202
-	add	x0, x0, :lo12:.LC202
+	adrp	x0, .LC209
+	add	x0, x0, :lo12:.LC209
 	ldrh	w1, [x2,130]
 	ldrh	w2, [x2,140]
 	bl	printk
 	ldr	x1, [x19,608]
-	adrp	x0, .LC203
-	add	x0, x0, :lo12:.LC203
+	adrp	x0, .LC210
+	add	x0, x0, :lo12:.LC210
 	add	x5, x1, 16
 	ldrh	w1, [x1,16]
 	ldrh	w2, [x5,2]
@@ -16946,8 +17234,8 @@ dump_ftl_info:
 	ldrh	w5, [x5,10]
 	bl	printk
 	ldr	x1, [x19,608]
-	adrp	x0, .LC204
-	add	x0, x0, :lo12:.LC204
+	adrp	x0, .LC211
+	add	x0, x0, :lo12:.LC211
 	add	x5, x1, 48
 	ldrh	w1, [x1,48]
 	ldrh	w2, [x5,2]
@@ -16956,8 +17244,8 @@ dump_ftl_info:
 	ldrh	w5, [x5,10]
 	bl	printk
 	ldr	x1, [x19,608]
-	adrp	x0, .LC205
-	add	x0, x0, :lo12:.LC205
+	adrp	x0, .LC212
+	add	x0, x0, :lo12:.LC212
 	add	x5, x1, 80
 	ldrh	w1, [x1,80]
 	ldrh	w4, [x5,6]
@@ -16965,47 +17253,47 @@ dump_ftl_info:
 	ldrb	w3, [x5,5]
 	ldrh	w5, [x5,10]
 	bl	printk
-	ldrh	w0, [x19,3300]
+	ldrh	w0, [x19,3324]
 	mov	w2, 4
-	ldrb	w3, [x19,3276]
-	ldr	x1, [x19,3864]
+	ldrb	w3, [x19,3300]
+	ldr	x1, [x19,3880]
 	mul	w3, w0, w3
-	adrp	x0, .LC206
-	add	x0, x0, :lo12:.LC206
+	adrp	x0, .LC213
+	add	x0, x0, :lo12:.LC213
 	lsl	w3, w3, 1
 	bl	rknand_print_hex
 	ldr	x1, [x19,600]
-	adrp	x0, .LC207
+	adrp	x0, .LC214
 	ldrh	w3, [x19,576]
-	add	x0, x0, :lo12:.LC207
+	add	x0, x0, :lo12:.LC214
 	mov	w2, 2
 	bl	rknand_print_hex
 	ldr	x3, [x19,2864]
-	adrp	x0, .LC199
-	add	x0, x0, :lo12:.LC199
+	adrp	x0, .LC206
+	add	x0, x0, :lo12:.LC206
 	mov	w2, 4
 	add	x1, x3, 704
 	ldrh	w3, [x3,698]
 	bl	rknand_print_hex
 	ldr	x1, [x19,584]
-	adrp	x0, .LC208
+	adrp	x0, .LC215
 	ldrh	w3, [x19,576]
-	add	x0, x0, :lo12:.LC208
+	add	x0, x0, :lo12:.LC215
 	mov	w2, 4
 	bl	rknand_print_hex
-	adrp	x0, .LC209
-	add	x1, x19, 3352
-	add	x0, x0, :lo12:.LC209
+	adrp	x0, .LC216
+	add	x1, x19, 3368
+	add	x0, x0, :lo12:.LC216
 	mov	w2, 2
 	mov	w3, 256
 	bl	rknand_print_hex
-	ldrh	w0, [x19,3300]
+	ldrh	w0, [x19,3324]
 	mov	w2, 2
-	ldrb	w3, [x19,3276]
-	ldr	x1, [x19,3872]
+	ldrb	w3, [x19,3300]
+	ldr	x1, [x19,3888]
 	mul	w3, w0, w3
-	adrp	x0, .LC210
-	add	x0, x0, :lo12:.LC210
+	adrp	x0, .LC217
+	add	x0, x0, :lo12:.LC217
 	lsl	w3, w3, 1
 	bl	rknand_print_hex
 	ldr	x19, [sp,16]
@@ -17022,8 +17310,8 @@ pm_ppa_update_check:
 	mov	w7, 1
 	stp	x29, x30, [sp, -16]!
 	add	x29, sp, 0
-	ldrh	w4, [x5,3340]
-	ldrb	w3, [x5,3338]
+	ldrh	w4, [x5,3264]
+	ldrb	w3, [x5,3266]
 	sub	w6, w6, w4
 	lsr	w4, w2, w4
 	lsl	w6, w7, w6
@@ -17036,19 +17324,19 @@ pm_ppa_update_check:
 	ubfx	x3, x3, 5, 3
 	cmp	w3, 7
 	cset	w4, eq
-	cbnz	w4, .L2737
+	cbnz	w4, .L2774
 	cmp	w3, w7
-	bne	.L2734
-.L2737:
+	bne	.L2771
+.L2774:
 	mov	w3, w2
 	mov	w2, w1
 	mov	x1, x0
-	adrp	x0, .LC211
-	add	x0, x0, :lo12:.LC211
+	adrp	x0, .LC218
+	add	x0, x0, :lo12:.LC218
 	bl	printk
 	bl	dump_ftl_info
 	mov	w4, -1
-.L2734:
+.L2771:
 	mov	w0, w4
 	ldp	x29, x30, [sp], 16
 	ret
@@ -17064,7 +17352,7 @@ load_l2p_region:
 	stp	x19, x20, [sp,16]
 	cmp	w22, 31
 	uxth	w20, w0
-	bls	.L2740
+	bls	.L2777
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
@@ -17073,17 +17361,17 @@ load_l2p_region:
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L2740:
+.L2777:
 	adrp	x21, .LANCHOR0
 	adrp	x19, .LANCHOR7
 	add	x21, x21, :lo12:.LANCHOR0
 	ldr	x0, [x21,2864]
 	ldrh	w2, [x0,698]
 	cmp	w20, w2
-	bls	.L2741
-	adrp	x0, .LC212
+	bls	.L2778
+	adrp	x0, .LC219
 	mov	w1, w20
-	add	x0, x0, :lo12:.LC212
+	add	x0, x0, :lo12:.LC219
 	add	x19, x19, :lo12:.LANCHOR7
 	bl	printk
 	mov	x0, 0
@@ -17094,35 +17382,35 @@ load_l2p_region:
 	ldr	x0, [x21,2864]
 	ldrh	w0, [x0,698]
 	cmp	w0, w20
-	bcs	.L2743
+	bcs	.L2780
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
 	add	x0, x0, :lo12:.LC0
 	add	x1, x1, 600
 	mov	w2, 35
-	b	.L2747
-.L2741:
+	b	.L2784
+.L2778:
 	add	x0, x0, x20, sxtw 2
 	sbfiz	x22, x22, 4, 32
 	ldr	w4, [x0,704]
-	add	x0, x21, 3896
+	add	x0, x21, 3920
 	add	x23, x0, x22
 	strh	w20, [x0,x22]
 	strh	wzr, [x23,2]
-	cbnz	w4, .L2744
-	adrp	x0, .LC213
+	cbnz	w4, .L2781
+	adrp	x0, .LC220
 	mov	w1, w20
 	mov	w2, w4
 	add	x19, x19, :lo12:.LANCHOR7
-	add	x0, x0, :lo12:.LC213
+	add	x0, x0, :lo12:.LC220
 	bl	printk
 	ldr	x0, [x23,8]
 	mov	w1, 255
 	ldrh	w2, [x19,-98]
 	bl	ftl_memset
-	b	.L2743
-.L2744:
+	b	.L2780
+.L2781:
 	add	x22, x19, :lo12:.LANCHOR7
 	ldrb	w3, [x21,2832]
 	ldr	x1, [x23,8]
@@ -17135,47 +17423,47 @@ load_l2p_region:
 	ldr	x4, [x29,72]
 	ldr	w2, [x0]
 	cmp	w2, w20
-	beq	.L2745
-	adrp	x0, .LC214
+	beq	.L2782
+	adrp	x0, .LC221
 	mov	w1, w20
-	add	x0, x0, :lo12:.LC214
+	add	x0, x0, :lo12:.LC221
 	bl	printk
 	ldr	x3, [x21,2864]
-	adrp	x0, .LC215
-	add	x0, x0, :lo12:.LC215
+	adrp	x0, .LC222
+	add	x0, x0, :lo12:.LC222
 	mov	w2, 4
 	add	x1, x3, 704
 	ldrh	w3, [x3,698]
 	bl	rknand_print_hex
 	ldrb	w3, [x21,2832]
-	adrp	x0, .LC216
+	adrp	x0, .LC223
 	ldr	x1, [x23,8]
-	add	x0, x0, :lo12:.LC216
+	add	x0, x0, :lo12:.LC223
 	mov	w2, 4
 	lsl	w3, w3, 7
 	bl	rknand_print_hex
-	adrp	x0, .LC217
+	adrp	x0, .LC224
 	ldr	x1, [x22,-128]
-	add	x0, x0, :lo12:.LC217
+	add	x0, x0, :lo12:.LC224
 	mov	w2, 4
 	mov	w3, 16
 	bl	rknand_print_hex
-.L2745:
+.L2782:
 	add	x19, x19, :lo12:.LANCHOR7
 	ldr	x0, [x19,-128]
 	ldr	w0, [x0]
 	cmp	w0, w20
-	beq	.L2743
+	beq	.L2780
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
 	add	x0, x0, :lo12:.LC0
 	add	x1, x1, 600
 	mov	w2, 59
-.L2747:
+.L2784:
 	bl	printk
 	bl	dump_stack
-.L2743:
+.L2780:
 	mov	w0, 0
 	ldr	x23, [sp,48]
 	ldp	x19, x20, [sp,16]
@@ -17199,22 +17487,22 @@ pm_gc:
 	add	x19, x19, :lo12:.LANCHOR4
 	ldr	x0, [x20,2864]
 	ldrh	w1, [x0,688]
-	ldrh	w0, [x19,1156]
+	ldrh	w0, [x19,1180]
 	sub	w0, w0, #1
 	cmp	w1, w0
-	blt	.L2750
+	blt	.L2787
 	bl	pm_free_sblk
 	ldr	x2, [x20,2864]
-	ldrh	w1, [x19,1156]
+	ldrh	w1, [x19,1180]
 	ldrh	w3, [x2,688]
 	sub	w1, w1, #1
 	cmp	w3, w1
-	blt	.L2750
+	blt	.L2787
 	add	x0, x2, x0, uxth 1
 	ldrh	w21, [x0,416]
 	mov	w0, 65535
 	cmp	w21, w0
-	bne	.L2752
+	bne	.L2789
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
@@ -17227,39 +17515,39 @@ pm_gc:
 	ldr	x1, [x20,2864]
 	add	x0, x1, x0, uxth 1
 	ldrh	w21, [x0,416]
-.L2752:
+.L2789:
 	bl	pm_select_ram_region
 	uxth	x20, w0
 	add	x0, x23, :lo12:.LANCHOR0
 	lsl	x1, x20, 4
-	add	x0, x0, 3896
+	add	x0, x0, 3920
 	mov	x22, x20
 	add	x19, x0, x1
 	ldrh	w0, [x0,x1]
 	mov	w1, 65535
 	cmp	w0, w1
-	beq	.L2753
+	beq	.L2790
 	ldr	x1, [x19,8]
-	cbz	x1, .L2753
+	cbz	x1, .L2790
 	ldrsh	w2, [x19,2]
-	tbz	w2, #31, .L2753
+	tbz	w2, #31, .L2790
 	bl	pm_write_page
 	ldrh	w0, [x19,2]
 	and	w0, w0, 32767
 	strh	w0, [x19,2]
-.L2753:
+.L2790:
 	add	x23, x23, :lo12:.LANCHOR0
 	mov	w19, 0
-	add	x0, x23, 3896
+	add	x0, x23, 3920
 	mov	w24, 21
 	mov	w25, 1
 	add	x20, x0, x20, lsl 4
-.L2754:
+.L2791:
 	ldr	x0, [x23,2864]
 	ldrh	w1, [x0,698]
 	cmp	w1, w19
-	bls	.L2760
-	ldrh	w1, [x23,3340]
+	bls	.L2797
+	ldrh	w1, [x23,3264]
 	add	x0, x0, x19, sxtw 2
 	ldr	w0, [x0,704]
 	lsr	w0, w0, w1
@@ -17267,10 +17555,10 @@ pm_gc:
 	lsl	w1, w25, w1
 	sub	w1, w1, #1
 	and	w1, w0, w1
-	ldrb	w0, [x23,3338]
+	ldrb	w0, [x23,3266]
 	udiv	w1, w1, w0
 	cmp	w21, w1, uxth
-	bne	.L2755
+	bne	.L2792
 	mov	w1, w22
 	mov	w0, w19
 	bl	load_l2p_region
@@ -17279,13 +17567,13 @@ pm_gc:
 	bl	pm_write_page
 	mov	w0, -1
 	strh	w0, [x20]
-.L2755:
+.L2792:
 	add	w19, w19, 1
 	uxth	w19, w19
-	b	.L2754
-.L2760:
+	b	.L2791
+.L2797:
 	bl	pm_free_sblk
-.L2750:
+.L2787:
 	mov	w0, 0
 	ldr	x25, [sp,64]
 	ldp	x19, x20, [sp,16]
@@ -17304,7 +17592,7 @@ pm_flush_id:
 	stp	x19, x20, [sp,16]
 	adrp	x19, .LANCHOR0
 	add	x19, x19, :lo12:.LANCHOR0
-	add	x1, x19, 3896
+	add	x1, x19, 3920
 	add	x20, x1, x0
 	ldrh	w0, [x1,x0]
 	ldr	x1, [x20,8]
@@ -17312,11 +17600,11 @@ pm_flush_id:
 	ldrh	w0, [x20,2]
 	and	w0, w0, 32767
 	strh	w0, [x20,2]
-	ldr	w0, [x19,3888]
-	cbz	w0, .L2762
+	ldr	w0, [x19,3912]
+	cbz	w0, .L2799
 	bl	pm_gc
-	str	wzr, [x19,3888]
-.L2762:
+	str	wzr, [x19,3912]
+.L2799:
 	mov	w0, 0
 	ldp	x19, x20, [sp,16]
 	ldp	x29, x30, [sp], 32
@@ -17332,17 +17620,17 @@ pm_flush:
 	adrp	x20, .LANCHOR0
 	mov	x19, 0
 	add	x20, x20, :lo12:.LANCHOR0
-	add	x20, x20, 3896
-.L2768:
+	add	x20, x20, 3920
+.L2805:
 	add	x1, x20, x19, lsl 4
 	uxth	w0, w19
 	ldrsh	w1, [x1,2]
-	tbz	w1, #31, .L2767
+	tbz	w1, #31, .L2804
 	bl	pm_flush_id
-.L2767:
+.L2804:
 	add	x19, x19, 1
 	cmp	x19, 32
-	bne	.L2768
+	bne	.L2805
 	mov	w0, 0
 	ldp	x19, x20, [sp,16]
 	ldp	x29, x30, [sp], 32
@@ -17393,31 +17681,31 @@ pm_init:
 	mov	w0, 1
 	strb	w0, [x22,-120]
 	mov	w0, 64
-	str	wzr, [x20,3888]
-	add	x20, x20, 3896
+	str	wzr, [x20,3912]
+	add	x20, x20, 3920
 	bl	ftl_malloc
 	mov	w24, -1
 	str	x0, [x22,-128]
 	add	x22, x20, 512
-.L2774:
+.L2811:
 	strh	w24, [x20]
 	strh	wzr, [x20,2]
-	cbz	w23, .L2773
+	cbz	w23, .L2810
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrb	w0, [x0,2832]
 	lsl	w0, w0, 9
 	bl	ftl_malloc
 	str	x0, [x20,8]
-.L2773:
+.L2810:
 	add	x20, x20, 16
 	cmp	x20, x22
-	bne	.L2774
+	bne	.L2811
 	add	x20, x19, :lo12:.LANCHOR0
 	add	x21, x21, :lo12:.LANCHOR7
 	mov	w4, 4
 	ldr	x1, [x20,2864]
 	ldr	x25, [x21,-128]
-	ldr	x23, [x20,3904]
+	ldr	x23, [x20,3928]
 	ldrb	w0, [x1,694]
 	mov	x3, x25
 	ldrh	w1, [x1,692]
@@ -17428,25 +17716,25 @@ pm_init:
 	mov	w24, w21
 	ldrh	w2, [x1,696]
 	cmp	w2, w21
-	bgt	.L2775
-	adrp	x0, .LC218
+	bgt	.L2812
+	adrp	x0, .LC225
 	ldrh	w1, [x1,692]
 	mov	w3, w21
-	add	x0, x0, :lo12:.LC218
-	adrp	x26, .LC219
+	add	x0, x0, :lo12:.LC225
+	adrp	x26, .LC226
 	add	w21, w21, 1
 	bl	printk
-	add	x26, x26, :lo12:.LC219
+	add	x26, x26, :lo12:.LC226
 	ldr	x0, [x20,2864]
 	ldrsh	w20, [x0,696]
-.L2776:
+.L2813:
 	cmp	w20, w21
-	bge	.L2789
+	bge	.L2826
 	add	x27, x19, :lo12:.LANCHOR0
 	mov	x2, x23
 	mov	x3, x25
 	ldr	x0, [x27,2864]
-	ldrh	w22, [x27,3348]
+	ldrh	w22, [x27,3362]
 	ldrb	w4, [x27,2832]
 	ldrh	w1, [x0,692]
 	ldrb	w0, [x0,694]
@@ -17464,21 +17752,21 @@ pm_init:
 	ldr	w1, [x25]
 	bl	printk
 	cmp	w28, 512
-	beq	.L2777
+	beq	.L2814
 	cmn	w28, #1
-	beq	.L2777
+	beq	.L2814
 	ldr	x1, [x27,2864]
 	ldr	w0, [x25]
 	ldrh	w2, [x1,698]
 	cmp	w0, w2
-	bcs	.L2777
+	bcs	.L2814
 	add	x0, x1, x0, uxtw 2
 	str	w22, [x0,704]
-.L2777:
+.L2814:
 	add	w20, w20, 1
 	sxth	w20, w20
-	b	.L2776
-.L2789:
+	b	.L2813
+.L2826:
 	adrp	x0, .LANCHOR5+577
 	mov	w1, 1
 	add	w24, w24, 1
@@ -17487,18 +17775,18 @@ pm_init:
 	ldr	x0, [x0,2864]
 	strh	w24, [x0,696]
 	bl	pm_free_sblk
-.L2775:
+.L2812:
 	add	x19, x19, :lo12:.LANCHOR0
 	mov	w0, -1
-	ldr	x1, [x19,3904]
+	ldr	x1, [x19,3928]
 	bl	pm_write_page
-	ldr	x1, [x19,3904]
+	ldr	x1, [x19,3928]
 	mov	w0, -1
 	bl	pm_write_page
-	ldr	x1, [x19,3904]
+	ldr	x1, [x19,3928]
 	mov	w0, -1
 	bl	pm_write_page
-	ldr	x1, [x19,3904]
+	ldr	x1, [x19,3928]
 	mov	w0, -1
 	bl	pm_write_page
 	bl	pm_free_sblk
@@ -17530,7 +17818,7 @@ pm_log2phys:
 	mov	x19, 0
 	ldrb	w4, [x3,2832]
 	ldr	w2, [x3,2840]
-	add	x3, x3, 3896
+	add	x3, x3, 3920
 	lsl	w20, w4, 7
 	lsl	w24, w4, 7
 	cmp	w0, w2
@@ -17538,87 +17826,87 @@ pm_log2phys:
 	uxth	w25, w20
 	msub	w24, w25, w24, w0
 	uxth	x24, w24
-	bcc	.L2803
-	adrp	x0, .LC220
+	bcc	.L2840
+	adrp	x0, .LC227
 	mov	w1, w5
-	add	x0, x0, :lo12:.LC220
+	add	x0, x0, :lo12:.LC227
 	bl	printk
 	mov	w0, -1
-	cbnz	w23, .L2792
+	cbnz	w23, .L2829
 	str	w0, [x22]
-	b	.L2792
-.L2807:
+	b	.L2829
+.L2844:
 	ldrh	w0, [x3]
 	cmp	w0, w25
-	beq	.L2794
-.L2793:
+	beq	.L2831
+.L2830:
 	add	w19, w19, 1
 	add	x3, x3, 16
 	uxth	x19, w19
 	cmp	w19, 32
-	beq	.L2806
-.L2803:
+	beq	.L2843
+.L2840:
 	ldr	x0, [x3,8]
-	cbnz	x0, .L2807
-	b	.L2793
-.L2806:
+	cbnz	x0, .L2844
+	b	.L2830
+.L2843:
 	bl	pm_select_ram_region
 	uxth	x19, w0
 	add	x2, x21, :lo12:.LANCHOR0
 	sbfiz	x3, x19, 4, 32
-	add	x2, x2, 3896
+	add	x2, x2, 3920
 	mov	w1, w0
 	add	x4, x2, x3
 	ldrh	w3, [x2,x3]
 	mov	w2, 65535
 	cmp	w3, w2
-	bne	.L2808
-.L2798:
+	bne	.L2845
+.L2835:
 	adrp	x0, .LANCHOR7-96
 	strb	w19, [x0,#:lo12:.LANCHOR7-96]
 	mov	w0, w25
 	bl	load_l2p_region
-.L2794:
-	cbnz	w23, .L2795
+.L2831:
+	cbnz	w23, .L2832
 	add	x0, x21, :lo12:.LANCHOR0
 	add	x0, x0, x19, lsl 4
-	ldr	x0, [x0,3904]
+	ldr	x0, [x0,3928]
 	ldr	w0, [x0,x24,lsl 2]
 	str	w0, [x22]
-	b	.L2796
-.L2795:
+	b	.L2833
+.L2832:
 	add	x0, x21, :lo12:.LANCHOR0
 	ldr	w2, [x22]
-	add	x0, x0, 3896
+	add	x0, x0, 3920
 	add	x0, x0, x19, lsl 4
 	ldr	x1, [x0,8]
 	str	w2, [x1,x24,lsl 2]
 	ldrh	w1, [x0,2]
 	orr	w1, w1, -32768
 	strh	w1, [x0,2]
-	adrp	x0, .LANCHOR4+56
-	strb	w20, [x0,#:lo12:.LANCHOR4+56]
-.L2796:
+	adrp	x0, .LANCHOR4+80
+	strb	w20, [x0,#:lo12:.LANCHOR4+80]
+.L2833:
 	add	x21, x21, :lo12:.LANCHOR0
 	mov	w2, 32767
-	add	x21, x21, 3896
+	add	x21, x21, 3920
 	mov	w0, 0
 	add	x19, x21, x19, lsl 4
 	ldrh	w1, [x19,2]
 	and	w3, w1, 32767
 	cmp	w3, w2
-	beq	.L2792
+	beq	.L2829
 	add	w1, w1, 1
 	strh	w1, [x19,2]
-	b	.L2792
-.L2808:
+	b	.L2829
+.L2845:
 	ldrsh	w2, [x4,2]
-	tbz	w2, #31, .L2798
+	tbz	w2, #31, .L2835
 	str	x1, [x29,88]
 	bl	pm_flush_id
 	ldr	x1, [x29,88]
-	b	.L2798
-.L2792:
+	b	.L2835
+.L2829:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -17642,63 +17930,61 @@ gc_recovery:
 	stp	x25, x26, [sp,96]
 	stp	x27, x28, [sp,112]
 	add	x0, x23, :lo12:.LANCHOR4
-	strb	wzr, [x24,3273]
+	strb	wzr, [x24,3297]
 	ldr	x20, [x24,608]
-	strb	wzr, [x0,1122]
-	bl	gc_init
-	ldrh	w1, [x20,80]
+	strb	wzr, [x0,1146]
 	mov	w0, 65535
+	ldrh	w1, [x20,80]
 	add	x22, x20, 80
 	cmp	w1, w0
-	ldr	x0, [x24,608]
-	beq	.L2810
-	mov	w1, -1
-	strh	w1, [x0,130]
+	beq	.L2847
+	mov	w0, -1
+	strh	w0, [x20,130]
 	mov	w0, 1
 	bl	buf_alloc
 	mov	x21, x0
 	ldrb	w0, [x22,9]
-	ldrh	w1, [x24,3348]
+	ldrh	w1, [x24,3362]
 	sub	w0, w0, #1
 	add	x0, x22, x0, sxtw 1
 	ldrh	w0, [x0,16]
 	mul	w0, w0, w1
-	ldrb	w1, [x24,3257]
+	ldrb	w1, [x24,3281]
 	str	w0, [x29,152]
 	cmp	w1, 3
-	bne	.L2811
-	ldrh	w1, [x24,3300]
+	bne	.L2848
+	ldrh	w1, [x24,3324]
 	sub	w1, w1, #1
 	add	w0, w1, w0
 	orr	w0, w0, 50331648
-	b	.L2854
-.L2811:
+	b	.L2891
+.L2848:
 	cmp	w1, 2
-	bne	.L2812
-	ldrh	w1, [x24,3300]
+	bne	.L2849
+	ldrh	w1, [x24,3324]
 	add	w0, w0, w1, lsl 1
 	sub	w0, w0, #1
 	orr	w0, w0, 33554432
-.L2854:
+.L2891:
 	str	w0, [x21,40]
-.L2812:
+.L2849:
 	mov	x0, x21
 	mov	w1, 1
 	bl	sblk_read_page
 	ldr	w0, [x21,52]
 	cmp	w0, 512
-	beq	.L2813
+	beq	.L2850
 	cmn	w0, #1
-	beq	.L2813
+	beq	.L2850
 	ldr	x0, [x21,24]
 	ldr	w1, [x0]
 	mov	w0, 15555
 	movk	w0, 0xf55f, lsl 16
 	cmp	w1, w0
-	beq	.L2814
-.L2813:
+	beq	.L2851
+.L2850:
 	mov	x0, x21
-	bl	buf_free
+	bl	zbuf_free
 	ldr	x7, [x21,24]
 	ldr	x6, [x21,8]
 	ldr	w0, [x7,4]
@@ -17707,8 +17993,8 @@ gc_recovery:
 	str	w0, [sp,8]
 	ldr	w0, [x7,12]
 	str	w0, [sp,16]
-	adrp	x0, .LC221
-	add	x0, x0, :lo12:.LC221
+	adrp	x0, .LC228
+	add	x0, x0, :lo12:.LC228
 	ldr	w3, [x6]
 	ldr	w4, [x6,4]
 	ldr	w5, [x6,8]
@@ -17717,63 +18003,63 @@ gc_recovery:
 	ldr	w6, [x6,12]
 	ldr	w7, [x7]
 	bl	printk
-	b	.L2857
-.L2814:
+	b	.L2894
+.L2851:
 	add	x24, x19, :lo12:.LANCHOR0
 	add	x25, x23, :lo12:.LANCHOR4
 	ldr	x1, [x21,8]
-	ldrh	w0, [x24,3274]
-	ldrb	w2, [x24,3276]
+	ldrh	w0, [x24,3298]
+	ldrb	w2, [x24,3300]
 	mul	w2, w0, w2
-	ldr	x0, [x25,1128]
+	ldr	x0, [x25,1152]
 	lsl	w2, w2, 2
 	bl	ftl_memcpy
-	ldrh	w0, [x24,3274]
-	ldrb	w2, [x24,3276]
+	ldrh	w0, [x24,3298]
+	ldrb	w2, [x24,3300]
 	ldr	x1, [x21,8]
 	mul	w2, w0, w2
 	add	x1, x1, x2, sxtw 2
-	ldr	x0, [x25,1136]
+	ldr	x0, [x25,1160]
 	lsl	w2, w2, 2
 	bl	ftl_memcpy
-	ldrb	w26, [x24,3257]
-	ldrh	w25, [x24,3300]
+	ldrb	w26, [x24,3281]
+	ldrh	w25, [x24,3324]
 	cmp	w26, 2
-	bne	.L2816
+	bne	.L2853
 	lsl	w25, w25, 1
 	mov	w26, 1
-.L2816:
+.L2853:
 	mov	w27, 0
-	adrp	x24, .LC222
-	add	x0, x24, :lo12:.LC222
+	adrp	x24, .LC229
+	add	x0, x24, :lo12:.LC229
 	mov	w28, w27
 	str	x0, [x29,120]
-	b	.L2817
-.L2859:
-	ldr	x0, [x0,1136]
+	b	.L2854
+.L2896:
+	ldr	x0, [x0,1160]
 	ldr	w1, [x0,x12]
 	ldr	w0, [x7,8]
 	cmp	w1, w0
-	bne	.L2821
-.L2844:
+	bne	.L2858
+.L2881:
 	add	w28, w28, 1
 	add	w9, w9, 1
-.L2825:
+.L2862:
 	cmp	w9, w26
-	bhi	.L2858
+	bhi	.L2895
 	ldr	x0, [x29,136]
 	add	x1, x19, :lo12:.LANCHOR0
 	add	x0, x0, 8
-	ldrh	w2, [x1,3348]
-	ldrb	w1, [x1,3257]
+	ldrh	w2, [x1,3362]
+	ldrb	w1, [x1,3281]
 	ldrh	w0, [x22,x0,lsl 1]
 	cmp	w1, 3
 	mul	w0, w0, w2
 	str	w0, [x29,152]
-	bne	.L2818
+	bne	.L2855
 	add	w0, w0, w27
 	orr	w0, w0, w9, lsl 24
-.L2855:
+.L2892:
 	str	w0, [x21,40]
 	mov	w1, 1
 	mov	x0, x21
@@ -17783,17 +18069,17 @@ gc_recovery:
 	sbfiz	x12, x28, 2, 32
 	ldr	x7, [x21,24]
 	ldr	x9, [x29,112]
-	ldr	x1, [x0,1128]
+	ldr	x1, [x0,1152]
 	ldr	w6, [x7,4]
 	ldr	w3, [x1,x12]
 	cmp	w3, w6
-	beq	.L2859
-.L2821:
+	beq	.L2896
+.L2858:
 	add	x13, x23, :lo12:.LANCHOR4
 	ldr	w0, [x7,12]
 	str	x9, [x29,96]
 	str	x13, [x29,104]
-	ldr	x4, [x13,1136]
+	ldr	x4, [x13,1160]
 	str	w0, [sp]
 	ldr	x0, [x29,120]
 	ldr	w4, [x4,x12]
@@ -17806,13 +18092,13 @@ gc_recovery:
 	ldr	x13, [x29,104]
 	ldr	x12, [x29,112]
 	ldr	x9, [x29,96]
-	ldr	x0, [x13,1128]
+	ldr	x0, [x13,1152]
 	ldr	w0, [x0,x12]
 	cmn	w0, #1
-	beq	.L2844
+	beq	.L2881
 	mov	x0, x21
-	bl	buf_free
-.L2857:
+	bl	zbuf_free
+.L2894:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrh	w2, [x20,80]
 	mov	w21, 0
@@ -17821,74 +18107,74 @@ gc_recovery:
 	ldr	x0, [x0,608]
 	ldrh	w1, [x20,80]
 	strh	w1, [x0,130]
-	b	.L2815
-.L2824:
+	b	.L2852
+.L2861:
 	add	w27, w27, 1
-.L2817:
+.L2854:
 	cmp	w27, w25
-	beq	.L2826
+	beq	.L2863
 	sub	w0, w27, #1
 	mov	w24, 0
 	str	w0, [x29,132]
-.L2827:
+.L2864:
 	ldrb	w0, [x22,9]
 	cmp	w24, w0
-	bge	.L2824
+	bge	.L2861
 	sxtw	x0, w24
 	mov	w9, 1
 	str	x0, [x29,136]
-	b	.L2825
-.L2818:
+	b	.L2862
+.L2855:
 	cmp	w1, 2
-	bne	.L2820
+	bne	.L2857
 	ldr	w1, [x29,132]
 	add	w0, w0, w1
 	add	w0, w0, w9
 	orr	w0, w0, 33554432
-	b	.L2855
-.L2820:
+	b	.L2892
+.L2857:
 	add	w0, w0, w27
-	b	.L2855
-.L2858:
+	b	.L2892
+.L2895:
 	add	w24, w24, 1
-	b	.L2827
-.L2826:
+	b	.L2864
+.L2863:
 	mov	x0, x21
 	mov	w21, 0
 	mov	w28, w21
-	bl	buf_free
+	bl	zbuf_free
 	str	w21, [x29,136]
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrb	w1, [x22,9]
 	ldrh	w3, [x20,80]
 	ldr	x2, [x0,600]
-	ldrh	w0, [x0,3274]
+	ldrh	w0, [x0,3298]
 	mul	w0, w1, w0
 	strh	w0, [x2,x3,lsl 1]
-.L2828:
+.L2865:
 	cmp	w28, w25
-	beq	.L2839
+	beq	.L2876
 	sub	w0, w28, #1
 	mov	w24, 0
 	str	w0, [x29,104]
-.L2840:
+.L2877:
 	ldrb	w0, [x22,9]
 	cmp	w24, w0
-	bge	.L2837
+	bge	.L2874
 	sxtw	x0, w24
 	mov	w27, 1
 	str	x0, [x29,112]
-.L2838:
+.L2875:
 	cmp	w27, w26
-	bhi	.L2860
+	bhi	.L2897
 	add	x1, x23, :lo12:.LANCHOR4
 	ldr	w0, [x29,136]
 	sbfiz	x0, x0, 2, 32
-	ldr	x2, [x1,1128]
+	ldr	x2, [x1,1152]
 	ldr	w5, [x2,x0]
 	cmn	w5, #1
-	beq	.L2829
-	ldr	x1, [x1,1136]
+	beq	.L2866
+	ldr	x1, [x1,1160]
 	str	x5, [x29,120]
 	ldr	w0, [x1,x0]
 	str	w0, [x29,132]
@@ -17897,42 +18183,42 @@ gc_recovery:
 	str	w0, [x29,156]
 	cmn	w0, #1
 	ldr	x5, [x29,120]
-	bne	.L2830
+	bne	.L2867
 	mov	w0, w5
 	add	x1, x29, 156
 	mov	w2, 0
 	bl	pm_log2phys
 	ldr	x5, [x29,120]
-.L2830:
+.L2867:
 	ldr	x0, [x29,112]
 	add	x0, x0, 8
 	ldrh	w1, [x22,x0,lsl 1]
 	add	x0, x19, :lo12:.LANCHOR0
-	ldrh	w2, [x0,3348]
-	ldrb	w0, [x0,3257]
+	ldrh	w2, [x0,3362]
+	ldrb	w0, [x0,3281]
 	cmp	w0, 3
 	mul	w1, w1, w2
-	bne	.L2831
+	bne	.L2868
 	add	w1, w1, w28
 	orr	w1, w1, w27, lsl 24
-	b	.L2856
-.L2831:
+	b	.L2893
+.L2868:
 	cmp	w0, 2
-	bne	.L2833
+	bne	.L2870
 	ldr	w0, [x29,104]
 	add	w1, w1, w0
 	add	w1, w1, w27
 	orr	w1, w1, 33554432
-	b	.L2856
-.L2833:
+	b	.L2893
+.L2870:
 	add	w1, w1, w28
-.L2856:
+.L2893:
 	add	x0, x19, :lo12:.LANCHOR0
 	str	w1, [x29,152]
 	ldr	w2, [x29,132]
 	mov	w3, 21
-	ldrh	w1, [x0,3340]
-	ldrb	w0, [x0,3338]
+	ldrh	w1, [x0,3264]
+	ldrb	w0, [x0,3266]
 	lsr	w2, w2, w1
 	sub	w1, w3, w1
 	mov	w3, 1
@@ -17945,7 +18231,7 @@ gc_recovery:
 	str	w0, [x29,120]
 	ldr	w0, [x29,156]
 	cmp	w0, w1
-	bne	.L2834
+	bne	.L2871
 	mov	w0, w5
 	add	x1, x29, 152
 	mov	w2, w3
@@ -17953,12 +18239,12 @@ gc_recovery:
 	bl	pm_log2phys
 	ldrh	w0, [x29,120]
 	bl	ftl_vpn_decrement
-	b	.L2835
-.L2834:
+	b	.L2872
+.L2871:
 	ldr	w1, [x29,152]
 	cmp	w0, w1
 	csinc	w21, w21, w21, ne
-.L2835:
+.L2872:
 	ldr	w0, [x29,136]
 	add	x2, x19, :lo12:.LANCHOR0
 	add	w0, w0, 1
@@ -17968,35 +18254,35 @@ gc_recovery:
 	add	x1, x1, x0, lsl 2
 	ldrb	w1, [x1,2]
 	ands	w1, w1, 224
-	bne	.L2829
+	bne	.L2866
 	lsl	x0, x0, 1
 	ldr	x2, [x2,600]
 	ldrh	w5, [x2,x0]
-	cbz	w5, .L2829
+	cbz	w5, .L2866
 	strh	w1, [x2,x0]
-.L2829:
+.L2866:
 	add	w27, w27, 1
-	b	.L2838
-.L2860:
+	b	.L2875
+.L2897:
 	add	w24, w24, 1
-	b	.L2840
-.L2837:
+	b	.L2877
+.L2874:
 	add	w28, w28, 1
-	b	.L2828
-.L2839:
+	b	.L2865
+.L2876:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrh	w1, [x20,80]
 	ldr	x0, [x0,600]
 	strh	w21, [x0,x1,lsl 1]
 	ldrh	w0, [x20,80]
 	bl	zftl_insert_data_list
-.L2815:
+.L2852:
 	ldrh	w0, [x20,80]
 	bl	ftl_dump_write_open_sblk
 	ldrh	w1, [x20,80]
-	adrp	x0, .LC223
+	adrp	x0, .LC230
 	mov	w2, w21
-	add	x0, x0, :lo12:.LC223
+	add	x0, x0, :lo12:.LC230
 	bl	printk
 	mov	w0, -1
 	strh	w0, [x20,80]
@@ -18007,9 +18293,9 @@ gc_recovery:
 	ldr	x0, [x0,608]
 	ldrh	w0, [x0,130]
 	cmp	w0, w1
-	beq	.L2841
+	beq	.L2878
 	bl	ftl_free_sblk
-.L2841:
+.L2878:
 	add	x19, x19, :lo12:.LANCHOR0
 	mov	w0, -1
 	ldr	x1, [x19,2864]
@@ -18018,15 +18304,15 @@ gc_recovery:
 	strh	w0, [x1,130]
 	mov	w0, 0
 	bl	ftl_info_flush
-	b	.L2809
-.L2810:
-	ldrh	w0, [x0,130]
+	b	.L2846
+.L2847:
+	ldrh	w0, [x20,130]
 	cmp	w0, w1
-	beq	.L2809
+	beq	.L2846
 	ldr	x1, [x24,2864]
 	ldrh	w1, [x1,126]
 	cmp	w1, w0
-	bne	.L2843
+	bne	.L2880
 	bl	pm_flush
 	ldr	x0, [x24,608]
 	ldrh	w0, [x0,130]
@@ -18036,12 +18322,12 @@ gc_recovery:
 	strh	w1, [x0,126]
 	mov	w0, 0
 	bl	ftl_info_flush
-.L2843:
+.L2880:
 	add	x19, x19, :lo12:.LANCHOR0
 	mov	w1, -1
 	ldr	x0, [x19,608]
 	strh	w1, [x0,130]
-.L2809:
+.L2846:
 	sub	sp, x29, #32
 	ldp	x19, x20, [sp,48]
 	ldp	x21, x22, [sp,64]
@@ -18069,8 +18355,8 @@ zftl_init:
 	stp	x23, x24, [sp,48]
 	add	x23, x21, :lo12:.LANCHOR7
 	strb	w0, [x20,2888]
-	strb	w0, [x20,3885]
-	strb	w0, [x1,1241]
+	strb	w0, [x20,3907]
+	strb	w0, [x1,1265]
 	mov	w0, -1
 	adrp	x1, .LC2
 	str	w0, [x23,-92]
@@ -18078,15 +18364,15 @@ zftl_init:
 	add	x1, x1, :lo12:.LC2
 	add	x0, x0, :lo12:.LC1
 	strb	wzr, [x20,2856]
-	strb	wzr, [x20,3886]
+	strb	wzr, [x20,3908]
 	strb	wzr, [x20,2857]
 	bl	printk
 	adrp	x11, .LANCHOR2
 	ldrb	w6, [x20,633]
 	add	x1, x11, :lo12:.LANCHOR2
-	strb	w6, [x20,3350]
+	strb	w6, [x20,3364]
 	ldrh	w4, [x20,2]
-	strh	w4, [x20,3348]
+	strh	w4, [x20,3362]
 	ldrb	w2, [x1,21]
 	ldrb	w8, [x1,20]
 	ldrh	w3, [x1,18]
@@ -18095,42 +18381,42 @@ zftl_init:
 	ldrh	w7, [x1,22]
 	mov	w1, 0
 	sdiv	w9, w3, w8
-	strb	w2, [x20,3338]
-	strb	w8, [x20,3257]
+	strb	w2, [x20,3266]
+	strb	w8, [x20,3281]
 	uxtb	w6, w6
 	strb	w0, [x20,2832]
 	ubfiz	w10, w0, 9, 7
-	strh	w3, [x20,3274]
+	strh	w3, [x20,3298]
 	mov	w2, 1
-	strh	w9, [x20,3300]
-	strb	w6, [x20,3276]
+	strh	w9, [x20,3324]
+	strb	w6, [x20,3300]
 	strh	w7, [x20,576]
 	mov	x20, x11
 	strh	w10, [x23,-98]
-.L2862:
+.L2899:
 	cmp	w2, w4
-	bhi	.L2928
+	bhi	.L2965
 	add	w1, w1, 1
 	lsl	w2, w2, 1
 	uxth	w1, w1
-	b	.L2862
-.L2928:
+	b	.L2899
+.L2965:
 	mul	w3, w0, w3
 	add	x2, x19, :lo12:.LANCHOR0
 	sub	w1, w1, #1
 	mul	w5, w3, w7
-	strh	w1, [x2,3340]
+	strh	w1, [x2,3264]
 	mov	w1, 1
 	lsr	w4, w5, 21
 	mov	w2, 0
-.L2864:
+.L2901:
 	cmp	w1, w4
-	bhi	.L2929
+	bhi	.L2966
 	add	w2, w2, 1
 	lsl	w1, w1, 1
 	uxth	w2, w2
-	b	.L2864
-.L2929:
+	b	.L2901
+.L2966:
 	mov	w1, 57344
 	mov	w4, 1
 	movk	w1, 0x1c, lsl 16
@@ -18155,145 +18441,145 @@ zftl_init:
 	add	x2, x22, :lo12:.LANCHOR4
 	udiv	w5, w5, w3
 	add	w5, w5, 8
-	strh	w5, [x4,3308]
+	strh	w5, [x4,3332]
 	udiv	w0, w0, w10
 	strh	w0, [x11,-84]
 	ubfiz	w0, w0, 4, 16
 	sdiv	w0, w0, w9
-	strh	w0, [x2,1156]
+	strh	w0, [x2,1180]
 	add	w0, w7, w7, lsl 1
 	asr	w0, w0, 2
-	strh	w0, [x4,3344]
+	strh	w0, [x4,3902]
 	lsr	w0, w7, 4
-	strh	w0, [x4,3306]
+	strh	w0, [x4,3330]
 	cmp	w0, 79
-	bhi	.L2866
+	bhi	.L2903
 	mov	w0, 80
-	strh	w0, [x4,3306]
-.L2866:
+	strh	w0, [x4,3330]
+.L2903:
 	add	x0, x19, :lo12:.LANCHOR0
 	mov	w2, 2000
 	mov	w3, 256
 	cmp	w8, 2
-	strh	w2, [x0,3346]
+	strh	w2, [x0,3904]
 	mov	w2, 50
-	strh	w2, [x0,3342]
+	strh	w2, [x0,3900]
 	add	x2, x22, :lo12:.LANCHOR4
-	strh	w3, [x2,1152]
+	strh	w3, [x2,1176]
 	mov	w3, 48
-	strh	w3, [x2,1154]
+	strh	w3, [x2,1178]
 	mov	w2, 32
 	strh	w2, [x0,592]
-	beq	.L2867
-	ldrb	w0, [x0,3272]
-	cbz	w0, .L2868
-.L2867:
+	beq	.L2904
+	ldrb	w0, [x0,3296]
+	cbz	w0, .L2905
+.L2904:
 	add	x0, x19, :lo12:.LANCHOR0
 	mov	w2, 150
 	mov	w3, 64
-	strh	w2, [x0,3342]
+	strh	w2, [x0,3900]
 	add	x2, x22, :lo12:.LANCHOR4
-	strh	w3, [x2,1154]
+	strh	w3, [x2,1178]
 	mov	w3, 12
 	strh	w3, [x0,592]
 	ldrb	w3, [x19,#:lo12:.LANCHOR0]
-	cbnz	w3, .L2868
+	cbnz	w3, .L2905
 	mov	w3, 4
 	strh	w3, [x0,592]
 	mov	w3, 600
-	strh	w3, [x0,3346]
+	strh	w3, [x0,3904]
 	mov	w0, 128
-	strh	w0, [x2,1152]
-.L2868:
+	strh	w0, [x2,1176]
+.L2905:
 	ldr	w0, [x20,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2870
-	adrp	x0, .LC224
-	add	x0, x0, :lo12:.LC224
+	tbz	x0, 12, .L2907
+	adrp	x0, .LC231
+	add	x0, x0, :lo12:.LC231
 	bl	printk
-.L2870:
+.L2907:
 	ldr	w0, [x20,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2871
+	tbz	x0, 12, .L2908
 	add	x1, x19, :lo12:.LANCHOR0
-	adrp	x0, .LC225
-	add	x0, x0, :lo12:.LC225
+	adrp	x0, .LC232
+	add	x0, x0, :lo12:.LC232
 	ldr	w1, [x1,2836]
 	bl	printk
-.L2871:
+.L2908:
 	ldr	w0, [x20,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2872
+	tbz	x0, 12, .L2909
 	add	x1, x19, :lo12:.LANCHOR0
-	adrp	x0, .LC226
-	add	x0, x0, :lo12:.LC226
+	adrp	x0, .LC233
+	add	x0, x0, :lo12:.LC233
 	ldr	w1, [x1,2840]
 	bl	printk
-.L2872:
+.L2909:
 	ldr	w0, [x20,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2873
+	tbz	x0, 12, .L2910
 	add	x1, x21, :lo12:.LANCHOR7
-	adrp	x0, .LC227
-	add	x0, x0, :lo12:.LC227
+	adrp	x0, .LC234
+	add	x0, x0, :lo12:.LC234
 	ldr	w1, [x1,-88]
 	bl	printk
-.L2873:
+.L2910:
 	ldr	w0, [x20,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2874
+	tbz	x0, 12, .L2911
 	add	x1, x21, :lo12:.LANCHOR7
-	adrp	x0, .LC228
-	add	x0, x0, :lo12:.LC228
+	adrp	x0, .LC235
+	add	x0, x0, :lo12:.LC235
 	ldrh	w1, [x1,-84]
 	bl	printk
-.L2874:
+.L2911:
 	ldr	w0, [x20,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2875
+	tbz	x0, 12, .L2912
 	add	x1, x21, :lo12:.LANCHOR7
-	adrp	x0, .LC229
-	add	x0, x0, :lo12:.LC229
+	adrp	x0, .LC236
+	add	x0, x0, :lo12:.LC236
 	ldrh	w1, [x1,-98]
 	bl	printk
-.L2875:
+.L2912:
 	ldr	w0, [x20,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2876
+	tbz	x0, 12, .L2913
 	add	x22, x22, :lo12:.LANCHOR4
-	adrp	x0, .LC230
-	add	x0, x0, :lo12:.LC230
-	ldrh	w1, [x22,1156]
+	adrp	x0, .LC237
+	add	x0, x0, :lo12:.LC237
+	ldrh	w1, [x22,1180]
 	bl	printk
-.L2876:
+.L2913:
 	ldr	w0, [x20,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2877
+	tbz	x0, 12, .L2914
 	add	x1, x19, :lo12:.LANCHOR0
-	adrp	x0, .LC231
-	add	x0, x0, :lo12:.LC231
-	ldrh	w1, [x1,3306]
+	adrp	x0, .LC238
+	add	x0, x0, :lo12:.LC238
+	ldrh	w1, [x1,3330]
 	bl	printk
-.L2877:
+.L2914:
 	ldr	w0, [x20,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L2878
+	tbz	x0, 12, .L2915
 	add	x1, x19, :lo12:.LANCHOR0
-	adrp	x0, .LC232
-	add	x0, x0, :lo12:.LC232
-	ldrh	w1, [x1,3308]
+	adrp	x0, .LC239
+	add	x0, x0, :lo12:.LC239
+	ldrh	w1, [x1,3332]
 	bl	printk
-.L2878:
+.L2915:
 	add	x22, x19, :lo12:.LANCHOR0
-	bl	buf_init
+	bl	zbuf_init
 	mov	w0, 6
 	adrp	x23, .LANCHOR5
 	ldrh	w1, [x22,576]
 	mul	w0, w1, w0
 	bl	ftl_malloc
 	str	x0, [x22,528]
-	ldrb	w1, [x22,3276]
-	ldrh	w0, [x22,3300]
+	ldrb	w1, [x22,3300]
+	ldrh	w0, [x22,3324]
 	mul	w0, w0, w1
 	lsl	w0, w0, 2
 	bl	ftl_malloc
-	str	x0, [x22,3872]
-	ldrb	w1, [x22,3276]
+	str	x0, [x22,3888]
+	ldrb	w1, [x22,3300]
 	add	x2, x23, :lo12:.LANCHOR5
-	ldrh	w0, [x22,3300]
+	ldrh	w0, [x22,3324]
 	add	x2, x2, 640
-	str	x2, [x22,3864]
+	str	x2, [x22,3880]
 	mul	w1, w0, w1
 	ldrh	w0, [x22,576]
 	lsl	w1, w1, 1
@@ -18303,15 +18589,15 @@ zftl_init:
 	ldr	w0, [x20,#:lo12:.LANCHOR2]
 	add	x1, x2, x1, sxtw 2
 	str	x1, [x22,608]
-	tbz	x0, 12, .L2879
-	adrp	x0, .LC233
-	add	x0, x0, :lo12:.LC233
+	tbz	x0, 12, .L2916
+	adrp	x0, .LC240
+	add	x0, x0, :lo12:.LC240
 	bl	printk
-.L2879:
+.L2916:
 	add	x2, x19, :lo12:.LANCHOR0
 	add	x3, x21, :lo12:.LANCHOR7
-	ldrh	w0, [x2,3300]
-	ldrb	w22, [x2,3276]
+	ldrh	w0, [x2,3324]
+	ldrb	w22, [x2,3300]
 	ldrh	w1, [x2,576]
 	ldrh	w24, [x3,-84]
 	mul	w22, w0, w22
@@ -18322,32 +18608,33 @@ zftl_init:
 	add	w24, w24, 704
 	lsl	w22, w22, 1
 	add	w22, w22, 632
-	tbz	x0, 12, .L2880
-	adrp	x0, .LC234
+	tbz	x0, 12, .L2917
+	adrp	x0, .LC241
 	ldrh	w3, [x3,-98]
-	add	x0, x0, :lo12:.LC234
+	add	x0, x0, :lo12:.LC241
 	mov	w1, w22
 	mov	w2, w24
 	bl	printk
-.L2880:
+.L2917:
 	add	x21, x21, :lo12:.LANCHOR7
 	ldrh	w0, [x21,-98]
 	cmp	w22, w0
-	bhi	.L2882
+	bhi	.L2919
 	cmp	w24, w0
-	bls	.L2881
-.L2882:
-.L2883:
-	b	.L2883
-.L2881:
+	bls	.L2918
+.L2919:
+.L2920:
+	b	.L2920
+.L2918:
 	bl	sblk_init
 	bl	ftl_info_blk_init
 	cmn	w0, #1
-	beq	.L2884
+	beq	.L2921
 	bl	ftl_ext_info_init
 	add	x19, x19, :lo12:.LANCHOR0
-	mov	w0, 1
+	bl	gc_init
 	add	x23, x23, :lo12:.LANCHOR5
+	mov	w0, 1
 	bl	pm_init
 	bl	lpa_rebuild_hash
 	ldr	x0, [x19,608]
@@ -18376,18 +18663,18 @@ zftl_init:
 	mov	w0, 1
 	bl	ftl_total_vpn_update
 	ldrb	w0, [x23,577]
-	cbz	w0, .L2885
+	cbz	w0, .L2922
 	ldr	x1, [x19,2864]
 	ldr	w0, [x1,68]
 	add	w0, w0, 1
 	str	w0, [x1,68]
-.L2885:
+.L2922:
 	bl	ftl_ext_info_flush
 	mov	w0, 0
 	bl	ftl_info_flush
 	bl	print_ftl_debug_info
 	mov	w0, 0
-.L2884:
+.L2921:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -18408,26 +18695,26 @@ rk_ftl_init:
 	add	x19, x21, :lo12:.LANCHOR4
 	adrp	x20, .LANCHOR7
 	add	x20, x20, :lo12:.LANCHOR7
-	str	x0, [x19,1160]
+	str	x0, [x19,1184]
 	mov	w0, 136
 	strb	wzr, [x20,-82]
 	bl	ftl_malloc
-	str	x0, [x19,1168]
-	cbnz	x0, .L2931
-.L2933:
+	str	x0, [x19,1192]
+	cbnz	x0, .L2968
+.L2970:
 	mov	w0, -1
-	b	.L2932
-.L2931:
+	b	.L2969
+.L2968:
 	mov	w0, 2048
 	bl	ftl_malloc
 	str	x0, [x20,-80]
 	mov	x1, x20
-	add	x0, x19, 1176
-	str	xzr, [x19,1176]
+	add	x0, x19, 1200
+	str	xzr, [x19,1200]
 	str	xzr, [x1,-72]!
 	bl	rknand_get_reg_addr
-	ldr	x0, [x19,1176]
-	cbz	x0, .L2933
+	ldr	x0, [x19,1200]
+	cbz	x0, .L2970
 	bl	rk_nandc_irq_init
 	mov	w1, 0
 	ldr	x0, [x20,-80]
@@ -18435,7 +18722,7 @@ rk_ftl_init:
 	mov	w3, 2048
 	bl	flash_sram_load_store
 	bl	rknand_flash_cs_init
-	ldr	x0, [x19,1168]
+	ldr	x0, [x19,1192]
 	adrp	x1, zftl_deinit
 	add	x1, x1, :lo12:zftl_deinit
 	str	x1, [x0,80]
@@ -18484,18 +18771,18 @@ rk_ftl_init:
 	adrp	x1, zftl_discard
 	add	x1, x1, :lo12:zftl_discard
 	str	x1, [x0,56]
-	ldr	x0, [x19,1176]
+	ldr	x0, [x19,1200]
 	bl	nand_flash_init
 	mov	w22, w0
-	cbnz	w0, .L2934
+	cbnz	w0, .L2971
 	bl	zftl_init
 	mov	w19, w0
 	bl	zftl_proc_debug_init
 	mov	w0, 1
 	strb	w0, [x20,-82]
-	b	.L2935
-.L2934:
-	ldr	x1, [x19,1168]
+	b	.L2972
+.L2971:
+	ldr	x1, [x19,1192]
 	adrp	x2, ftl_read_flash_info
 	add	x2, x2, :lo12:ftl_read_flash_info
 	adrp	x0, ftl_deinit
@@ -18542,14 +18829,14 @@ rk_ftl_init:
 	str	x0, [x1,72]
 	str	x2, [x1,104]
 	adrp	x2, ftl_discard
-	ldr	x0, [x19,1176]
+	ldr	x0, [x19,1200]
 	add	x2, x2, :lo12:ftl_discard
 	str	x2, [x1,56]
 	bl	FlashInit
 	mov	w19, w0
 	cmn	w22, #2
 	adrp	x22, .LANCHOR2
-	bne	.L2936
+	bne	.L2973
 	add	x20, x22, :lo12:.LANCHOR2
 	adrp	x1, gNandParaInfo
 	add	x20, x20, 8
@@ -18561,22 +18848,22 @@ rk_ftl_init:
 	bl	flash_lsb_page_tbl_build
 	ldrh	w0, [x20,10]
 	strh	w0, [x20,26]
-.L2936:
+.L2973:
 	adrp	x0, g_nandc_version_data
 	ldr	w1, [x0,#:lo12:g_nandc_version_data]
 	mov	w0, 12336
 	movk	w0, 0x5638, lsl 16
 	cmp	w1, w0
 	adrp	x0, .LANCHOR0
-	bne	.L2937
+	bne	.L2974
 	adrp	x1, gFlashSlcMode
 	ldrb	w1, [x1,#:lo12:gFlashSlcMode]
-	cbnz	w1, .L2938
-.L2937:
+	cbnz	w1, .L2975
+.L2974:
 	add	x1, x0, :lo12:.LANCHOR0
 	strb	wzr, [x0,#:lo12:.LANCHOR0]
-	strb	wzr, [x1,782]
-.L2938:
+	strb	wzr, [x1,634]
+.L2975:
 	adrp	x2, gNandFlashIDBEccBits
 	add	x1, x0, :lo12:.LANCHOR0
 	add	x22, x22, :lo12:.LANCHOR2
@@ -18585,33 +18872,33 @@ rk_ftl_init:
 	strb	w2, [x1,632]
 	adrp	x2, gNandFlashEccBits
 	ldrh	w3, [x22,18]
-	str	xzr, [x21,1216]
+	str	xzr, [x21,1240]
 	ldrb	w2, [x2,#:lo12:gNandFlashEccBits]
 	strb	w2, [x1,724]
 	mov	w2, 1
 	mov	w1, 0
-.L2939:
+.L2976:
 	cmp	w2, w3
-	bhi	.L2944
+	bhi	.L2981
 	add	w1, w1, 1
 	lsl	w2, w2, 1
 	uxth	w1, w1
-	b	.L2939
-.L2944:
+	b	.L2976
+.L2981:
 	add	x0, x0, :lo12:.LANCHOR0
 	sub	w1, w1, #1
 	strb	wzr, [x0,672]
-	strh	w1, [x0,3340]
-	cbnz	w19, .L2935
+	strh	w1, [x0,3264]
+	cbnz	w19, .L2972
 	bl	FtlInit
 	mov	w19, w0
-.L2935:
-	adrp	x0, .LC235
+.L2972:
+	adrp	x0, .LC242
 	mov	w1, w19
-	add	x0, x0, :lo12:.LC235
+	add	x0, x0, :lo12:.LC242
 	bl	printk
 	mov	w0, w19
-.L2932:
+.L2969:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x29, x30, [sp], 48
@@ -18632,19 +18919,19 @@ gc_update_l2p_map_new:
 	stp	x27, x28, [sp,80]
 	adrp	x22, .LANCHOR2
 	ldr	x20, [x0,608]
-	ldrh	w24, [x0,3274]
+	ldrh	w24, [x0,3298]
 	add	x0, x20, 80
 	str	x0, [x29,128]
 	ldrb	w0, [x0,9]
 	mul	w24, w24, w0
 	bl	timer_get_time
 	ldr	w0, [x22,#:lo12:.LANCHOR2]
-	tbz	x0, 8, .L2946
-	adrp	x0, .LC236
+	tbz	x0, 8, .L2983
+	adrp	x0, .LC243
 	ldrh	w1, [x20,80]
-	add	x0, x0, :lo12:.LC236
+	add	x0, x0, :lo12:.LC243
 	bl	printk
-.L2946:
+.L2983:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrh	w1, [x20,80]
 	sub	w2, w24, #1
@@ -18653,21 +18940,21 @@ gc_update_l2p_map_new:
 	adrp	x27, .LANCHOR4
 	ldr	x0, [x0,600]
 	strh	w2, [x0,x1,lsl 1]
-	adrp	x0, .LC238
-	add	x0, x0, :lo12:.LC238
+	adrp	x0, .LC245
+	add	x0, x0, :lo12:.LC245
 	str	x0, [x29,120]
-	adrp	x0, .LC237
-	add	x0, x0, :lo12:.LC237
+	adrp	x0, .LC244
+	add	x0, x0, :lo12:.LC244
 	str	x0, [x29,112]
-.L2947:
+.L2984:
 	cmp	w23, w24
-	beq	.L2979
+	beq	.L3016
 	adrp	x0, .LANCHOR4
 	add	x0, x0, :lo12:.LANCHOR4
-	ldr	x0, [x0,1128]
+	ldr	x0, [x0,1152]
 	ldr	w2, [x0,w23,sxtw 2]
 	cmn	w2, #1
-	beq	.L2948
+	beq	.L2985
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrb	w0, [x0,2832]
 	lsl	w0, w0, 7
@@ -18675,28 +18962,28 @@ gc_update_l2p_map_new:
 	and	w0, w0, 65535
 	str	w0, [x29,140]
 	ldr	w0, [x22,#:lo12:.LANCHOR2]
-	tbz	x0, 8, .L2949
+	tbz	x0, 8, .L2986
 	ldr	x0, [x29,112]
 	mov	w3, w23
 	ldr	w1, [x29,140]
 	bl	printk
-.L2949:
+.L2986:
 	mov	w25, w23
-.L2955:
+.L2992:
 	add	x1, x27, :lo12:.LANCHOR4
 	sbfiz	x26, x25, 2, 32
-	ldr	x0, [x1,1128]
+	ldr	x0, [x1,1152]
 	ldr	w4, [x0,x26]
 	cmn	w4, #1
-	beq	.L2950
+	beq	.L2987
 	add	x0, x19, :lo12:.LANCHOR0
 	ldr	w2, [x29,140]
 	ldrb	w0, [x0,2832]
 	lsl	w0, w0, 7
 	udiv	w0, w4, w0
 	cmp	w2, w0, uxth
-	bne	.L2950
-	ldr	x0, [x1,1136]
+	bne	.L2987
+	ldr	x0, [x1,1160]
 	str	x4, [x29,104]
 	ldr	w28, [x0,x26]
 	mov	w0, w4
@@ -18704,90 +18991,90 @@ gc_update_l2p_map_new:
 	str	w0, [x29,156]
 	cmn	w0, #1
 	ldr	x4, [x29,104]
-	bne	.L2951
+	bne	.L2988
 	mov	w0, w4
 	add	x1, x29, 156
 	mov	w2, 0
 	bl	pm_log2phys
 	ldr	x4, [x29,104]
-.L2951:
+.L2988:
 	ldr	w3, [x29,156]
 	cmp	w3, w28
-	bne	.L2952
+	bne	.L2989
 	add	x0, x27, :lo12:.LANCHOR4
 	add	x1, x29, 152
 	mov	w2, 1
 	add	w21, w21, 1
-	ldr	x0, [x0,1144]
+	ldr	x0, [x0,1168]
 	ldr	w0, [x0,x26]
 	str	w0, [x29,152]
 	mov	w0, w4
 	bl	pm_log2phys
 	add	x2, x19, :lo12:.LANCHOR0
 	mov	w0, 21
-	ldrh	w1, [x2,3340]
+	ldrh	w1, [x2,3264]
 	sub	w3, w0, w1
 	mov	w0, 1
 	lsl	w0, w0, w3
 	lsr	w28, w28, w1
 	sub	w0, w0, #1
 	and	w28, w0, w28
-	ldrb	w0, [x2,3338]
+	ldrb	w0, [x2,3266]
 	udiv	w0, w28, w0
-	b	.L2978
-.L2952:
+	b	.L3015
+.L2989:
 	ldr	w0, [x22,#:lo12:.LANCHOR2]
-	tbz	x0, 8, .L2954
+	tbz	x0, 8, .L2991
 	ldr	x0, [x29,120]
 	mov	w1, w4
 	mov	w2, w28
 	bl	printk
-.L2954:
+.L2991:
 	ldr	x0, [x29,128]
 	ldrh	w0, [x0]
-.L2978:
+.L3015:
 	bl	ftl_vpn_decrement
 	add	x0, x27, :lo12:.LANCHOR4
 	mov	w1, -1
-	ldr	x0, [x0,1128]
+	ldr	x0, [x0,1152]
 	str	w1, [x0,x26]
 	bl	timer_get_time
-.L2950:
+.L2987:
 	add	w25, w25, 1
 	cmp	w25, w24
-	bne	.L2955
-.L2948:
+	bne	.L2992
+.L2985:
 	add	w23, w23, 1
-	b	.L2947
-.L2979:
+	b	.L2984
+.L3016:
 	ldr	w0, [x22,#:lo12:.LANCHOR2]
-	tbz	x0, 8, .L2957
+	tbz	x0, 8, .L2994
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrh	w3, [x20,80]
 	ldr	x1, [x0,608]
 	ldr	x2, [x0,600]
-	adrp	x0, .LC239
-	add	x0, x0, :lo12:.LC239
+	adrp	x0, .LC246
+	add	x0, x0, :lo12:.LC246
 	ldrh	w1, [x1,80]
 	ldrh	w2, [x2,x3,lsl 1]
 	mov	w3, w21
 	bl	printk
-.L2957:
+.L2994:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrh	w1, [x20,80]
 	ldr	x0, [x0,600]
 	ldrh	w0, [x0,x1,lsl 1]
 	cmp	w0, w21
-	beq	.L2958
+	beq	.L2995
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 569
+	mov	w2, 616
 	add	x1, x1, 624
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L2958:
+.L2995:
 	add	x19, x19, :lo12:.LANCHOR0
 	ldrh	w1, [x20,80]
 	ldr	x0, [x19,600]
@@ -18811,129 +19098,131 @@ gc_scan_src_blk_one_page:
 	add	x29, sp, 0
 	stp	x19, x20, [sp,16]
 	adrp	x19, .LANCHOR0
+	str	x23, [sp,48]
 	add	x2, x19, :lo12:.LANCHOR0
 	add	x1, x2, 2896
 	stp	x21, x22, [sp,32]
-	stp	x23, x24, [sp,48]
 	ldrb	w0, [x1,4]
 	add	x3, x1, x0, sxtw 1
-	ldrb	w6, [x2,3276]
+	ldrb	w6, [x2,3300]
 	ldrh	w22, [x3,40]
 	mov	w3, 0
 	ldrh	w2, [x1,2]
 	mov	w4, w3
-.L2981:
+.L3018:
 	cmp	w22, w5
-	bne	.L3007
+	bne	.L3044
 	add	w0, w0, 1
 	uxtb	w0, w0
 	cmp	w0, w6
-	bne	.L2982
+	bne	.L3019
 	add	w2, w2, 1
 	mov	w0, 0
 	mov	w4, 1
 	uxth	w2, w2
-.L2982:
+.L3019:
 	add	x3, x1, x0, sxtw 1
 	ldrh	w22, [x3,40]
 	mov	w3, 1
-	b	.L2981
-.L3007:
-	cbz	w4, .L2984
+	b	.L3018
+.L3044:
+	cbz	w4, .L3021
 	add	x1, x19, :lo12:.LANCHOR0
 	strh	w2, [x1,2898]
-.L2984:
-	cbz	w3, .L2985
+.L3021:
+	cbz	w3, .L3022
 	add	x1, x19, :lo12:.LANCHOR0
 	strb	w0, [x1,2900]
-.L2985:
+.L3022:
 	mov	w0, 1
 	mov	w23, 1
 	add	x19, x19, :lo12:.LANCHOR0
 	bl	buf_alloc
 	mov	x21, x0
-.L2986:
+.L3023:
 	add	x20, x19, 2896
 	ldrb	w1, [x20,6]
 	cmp	w23, w1
-	bgt	.L3008
-	ldrh	w0, [x19,3348]
+	bgt	.L3045
+	ldrh	w0, [x19,3362]
 	cmp	w1, 3
 	mul	w0, w22, w0
-	bne	.L2987
+	bne	.L3024
 	ldrh	w1, [x20,2]
 	add	w0, w0, w1
 	orr	w0, w0, w23, lsl 24
-	b	.L3006
-.L2987:
+	b	.L3043
+.L3024:
 	cmp	w1, 2
 	ldrh	w1, [x20,2]
-	bne	.L2989
+	bne	.L3026
 	add	w0, w0, w1, lsl 1
-	ldrb	w1, [x19,3257]
+	ldrb	w1, [x19,3281]
 	sub	w0, w0, #1
 	add	w0, w0, w23
 	orr	w0, w0, w1, lsl 24
-	b	.L3006
-.L2989:
+	b	.L3043
+.L3026:
 	add	w0, w0, w1
-.L3006:
+.L3043:
 	str	w0, [x21,40]
 	mov	w1, 1
 	mov	x0, x21
-	ldr	w24, [x21,40]
 	bl	sblk_read_page
 	ldr	w0, [x21,52]
 	cmp	w0, 512
-	beq	.L2992
+	beq	.L3029
 	cmn	w0, #1
-	beq	.L2992
+	beq	.L3029
 	ldr	x0, [x21,24]
 	ldr	w20, [x0,4]
 	mov	w0, w20
 	bl	lpa_hash_get_ppa
 	str	w0, [x29,76]
 	cmn	w0, #1
-	bne	.L2993
+	bne	.L3030
+	ldr	w0, [x19,2840]
+	cmp	w20, w0
+	bcs	.L3030
 	mov	w0, w20
 	add	x1, x29, 76
 	mov	w2, 0
 	bl	pm_log2phys
-.L2993:
+.L3030:
 	ldr	w1, [x21,40]
 	ldr	w0, [x29,76]
 	cmp	w1, w0
-	bne	.L2992
-	ldrh	w2, [x19,2920]
-	ldr	x1, [x19,3248]
-	str	w24, [x1,x2,lsl 2]
+	bne	.L3029
+	ldrh	w3, [x19,2920]
+	ldr	x2, [x19,3272]
+	str	w1, [x2,x3,lsl 2]
 	ldrh	w1, [x19,2920]
 	add	w1, w1, 1
 	strh	w1, [x19,2920]
-.L2992:
+.L3029:
 	ldrh	w0, [x19,2922]
 	add	w23, w23, 1
 	add	w0, w0, 1
 	strh	w0, [x19,2922]
-	b	.L2986
-.L3008:
+	b	.L3023
+.L3045:
 	mov	x0, x21
-	bl	buf_free
+	bl	zbuf_free
 	ldrb	w0, [x20,4]
-	ldrb	w1, [x19,3276]
+	ldrb	w1, [x19,3300]
 	add	w0, w0, 1
 	uxtb	w0, w0
 	strb	w0, [x20,4]
 	cmp	w1, w0
-	bne	.L2980
+	bne	.L3017
 	ldrh	w0, [x20,2]
 	strb	wzr, [x20,4]
 	add	w0, w0, 1
 	strh	w0, [x20,2]
-.L2980:
+.L3017:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
-	ldp	x23, x24, [sp,48]
+	ldr	x23, [sp,48]
 	ldp	x29, x30, [sp], 80
 	ret
 	.size	gc_scan_src_blk_one_page, .-gc_scan_src_blk_one_page
@@ -18952,32 +19241,32 @@ gc_scan_src_blk:
 	ldrh	w1, [x0,2896]
 	mov	w0, 65535
 	cmp	w1, w0
-	bne	.L3010
+	bne	.L3047
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 1004
+	mov	w2, 1051
 	add	x1, x1, 648
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L3010:
+.L3047:
 	add	x2, x19, :lo12:.LANCHOR0
 	mov	w3, 65535
 	mov	w0, 0
 	ldrh	w1, [x2,2896]
 	cmp	w1, w3
-	beq	.L3011
+	beq	.L3048
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 8, .L3012
+	tbz	x0, 8, .L3049
 	ubfiz	x3, x1, 1, 16
 	ldr	x2, [x2,600]
-	adrp	x0, .LC240
-	add	x0, x0, :lo12:.LC240
+	adrp	x0, .LC247
+	add	x0, x0, :lo12:.LC247
 	ldrh	w2, [x2,x3]
 	bl	printk
-.L3012:
+.L3049:
 	add	x20, x19, :lo12:.LANCHOR0
 	bl	timer_get_time
 	add	x21, x20, 2896
@@ -18986,97 +19275,97 @@ gc_scan_src_blk:
 	bl	ftl_get_blk_list_in_sblk
 	uxtb	w1, w0
 	strb	w1, [x21,5]
-	cbnz	w1, .L3013
+	cbnz	w1, .L3050
 	mov	w0, -1
 	strh	w0, [x20,2896]
-	b	.L3039
-.L3013:
+	b	.L3076
+.L3050:
 	ldrh	w3, [x20,2896]
 	ldr	x2, [x20,584]
 	add	x2, x2, x3, lsl 2
 	ldrb	w2, [x2,2]
 	tst	w2, 192
 	and	w4, w2, 224
-	beq	.L3014
+	beq	.L3051
 	cmp	w4, 224
-	beq	.L3014
+	beq	.L3051
 	ldr	x2, [x20,608]
 	ldrh	w5, [x2,16]
 	cmp	w5, w3
-	beq	.L3014
+	beq	.L3051
 	ldrh	w5, [x2,48]
 	cmp	w5, w3
-	beq	.L3014
+	beq	.L3051
 	ldrh	w2, [x2,80]
 	cmp	w2, w3
-	bne	.L3015
-.L3014:
-	cbnz	w4, .L3016
+	bne	.L3052
+.L3051:
+	cbnz	w4, .L3053
 	add	x0, x19, :lo12:.LANCHOR0
 	ldr	x0, [x0,600]
 	ldrh	w0, [x0,x3,lsl 1]
-	cbz	w0, .L3017
+	cbz	w0, .L3054
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 1024
+	mov	w2, 1071
 	add	x1, x1, 648
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L3017:
+.L3054:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrh	w1, [x0,2896]
 	ldr	x0, [x0,600]
 	strh	wzr, [x0,x1,lsl 1]
-.L3016:
+.L3053:
 	add	x19, x19, :lo12:.LANCHOR0
 	mov	w0, -1
 	strh	wzr, [x19,2920]
 	strh	w0, [x19,2896]
-.L3039:
+.L3076:
 	mov	w0, 0
-	b	.L3011
-.L3015:
+	b	.L3048
+.L3052:
 	and	w0, w0, 255
 	sub	w0, w0, #1
 	add	x0, x21, x0, sxtw 1
 	ldrh	w20, [x0,40]
 	mov	w0, 65535
 	cmp	w20, w0
-	bne	.L3018
+	bne	.L3055
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 1032
+	mov	w2, 1079
 	add	x1, x1, 648
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L3018:
+.L3055:
 	add	x2, x19, :lo12:.LANCHOR0
 	mov	w25, 1
 	ldrh	w3, [x2,2896]
 	ldr	x4, [x2,584]
-	ldrh	w0, [x2,3300]
+	ldrh	w0, [x2,3324]
 	add	x3, x4, x3, lsl 2
-	ldrh	w1, [x2,3348]
+	ldrh	w1, [x2,3362]
 	sub	w0, w0, #1
 	ldrb	w3, [x3,2]
 	uxth	w0, w0
 	mul	w1, w20, w1
 	and	w3, w3, 224
 	cmp	w3, 160
-	bne	.L3019
-	ldrb	w3, [x2,3257]
+	bne	.L3056
+	ldrb	w3, [x2,3281]
 	cmp	w3, 2
 	uxth	w25, w3
 	orr	w1, w1, w3, lsl 24
-	bne	.L3019
-	ldrh	w0, [x2,3274]
+	bne	.L3056
+	ldrh	w0, [x2,3298]
 	sub	w0, w0, #1
 	uxth	w0, w0
-.L3019:
+.L3056:
 	add	x20, x19, :lo12:.LANCHOR0
 	orr	w23, w0, w1
 	mov	w0, 1
@@ -19090,64 +19379,64 @@ gc_scan_src_blk:
 	str	w23, [x0,40]
 	mov	x21, x0
 	bl	sblk_read_page
-	ldrh	w0, [x20,3274]
+	ldrh	w0, [x20,3298]
 	mov	w1, 255
-	ldrb	w2, [x20,3276]
+	ldrb	w2, [x20,3300]
 	mul	w2, w0, w2
-	ldr	x0, [x20,3248]
+	ldr	x0, [x20,3272]
 	lsl	w2, w2, 2
 	bl	ftl_memset
 	strh	wzr, [x20,2920]
 	ldr	w0, [x21,52]
 	cmp	w0, 512
-	beq	.L3040
+	beq	.L3077
 	cmn	w0, #1
-	beq	.L3040
+	beq	.L3077
 	ldr	x0, [x21,24]
 	ldr	w1, [x0]
 	mov	w0, 15555
 	movk	w0, 0xf55f, lsl 16
 	cmp	w1, w0
-	beq	.L3022
+	beq	.L3059
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 1065
+	mov	w2, 1112
 	add	x1, x1, 648
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L3040:
+.L3077:
 	mov	x0, x21
-	bl	buf_free
+	bl	zbuf_free
 	mov	w0, -1
-	b	.L3011
-.L3022:
-	ldrb	w0, [x20,3276]
+	b	.L3048
+.L3059:
+	ldrb	w0, [x20,3300]
 	mov	x26, 0
-	ldrh	w22, [x20,3300]
+	ldrh	w22, [x20,3324]
 	mov	w24, 21
 	ldr	x23, [x21,8]
 	mul	w22, w0, w22
 	mul	w22, w25, w22
 	mov	w25, 1
 	uxth	w22, w22
-.L3023:
+.L3060:
 	cmp	w22, w26
-	ble	.L3041
+	ble	.L3078
 	ldr	w0, [x23,x26,lsl 2]
 	cmn	w0, #1
-	beq	.L3025
+	beq	.L3062
 	bl	lpa_hash_get_ppa
 	str	w0, [x29,92]
 	cmn	w0, #1
-	bne	.L3026
+	bne	.L3063
 	ldr	w0, [x23,x26,lsl 2]
 	add	x1, x29, 92
 	mov	w2, 0
 	bl	pm_log2phys
-.L3026:
-	ldrh	w1, [x20,3340]
+.L3063:
+	ldrh	w1, [x20,3264]
 	ldr	w2, [x29,92]
 	sub	w0, w24, w1
 	ldrh	w3, [x20,2896]
@@ -19155,23 +19444,23 @@ gc_scan_src_blk:
 	lsr	w1, w2, w1
 	sub	w0, w0, #1
 	and	w1, w0, w1
-	ldrb	w0, [x20,3338]
+	ldrb	w0, [x20,3266]
 	udiv	w1, w1, w0
 	cmp	w1, w3
-	bne	.L3025
+	bne	.L3062
 	ldrh	w3, [x20,2920]
-	ldr	x1, [x20,3248]
+	ldr	x1, [x20,3272]
 	str	w2, [x1,x3,lsl 2]
 	ldrh	w1, [x20,2920]
 	add	w1, w1, 1
 	strh	w1, [x20,2920]
-.L3025:
+.L3062:
 	bl	timer_get_time
 	add	x26, x26, 1
-	b	.L3023
-.L3041:
+	b	.L3060
+.L3078:
 	mov	x0, x21
-	bl	buf_free
+	bl	zbuf_free
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrh	w1, [x0,2896]
 	ldr	x3, [x0,600]
@@ -19179,11 +19468,11 @@ gc_scan_src_blk:
 	ldrh	w2, [x3,x2]
 	ldrh	w3, [x0,2920]
 	cmp	w2, w3
-	beq	.L3029
-	adrp	x0, .LC241
-	add	x0, x0, :lo12:.LC241
+	beq	.L3066
+	adrp	x0, .LC248
+	add	x0, x0, :lo12:.LC248
 	bl	printk
-.L3029:
+.L3066:
 	add	x19, x19, :lo12:.LANCHOR0
 	ldrh	w2, [x19,2896]
 	ldr	x1, [x19,600]
@@ -19191,7 +19480,7 @@ gc_scan_src_blk:
 	strh	w3, [x1,x2,lsl 1]
 	strh	wzr, [x19,2924]
 	ldrh	w0, [x19,2920]
-.L3011:
+.L3048:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -19213,14 +19502,14 @@ gc_scan_static_data:
 	ldr	x0, [x3,608]
 	ldr	w1, [x0,544]
 	cmn	w1, #1
-	beq	.L3043
+	beq	.L3080
 	adrp	x21, .LANCHOR3
 	adrp	x22, .LC0
 	add	x21, x21, :lo12:.LANCHOR3
 	mov	w20, 11
 	add	x22, x22, :lo12:.LC0
 	add	x21, x21, 664
-.L3044:
+.L3081:
 	add	x24, x19, :lo12:.LANCHOR0
 	add	x1, x29, 76
 	mov	w2, 0
@@ -19229,7 +19518,7 @@ gc_scan_static_data:
 	bl	pm_log2phys
 	ldr	w0, [x29,76]
 	cmn	w0, #1
-	beq	.L3045
+	beq	.L3082
 	mov	w0, 1
 	bl	buf_alloc
 	mov	x23, x0
@@ -19239,8 +19528,8 @@ gc_scan_static_data:
 	bl	sblk_read_page
 	ldr	w0, [x23,52]
 	cmp	w0, 256
-	bne	.L3046
-	ldrh	w0, [x24,3340]
+	bne	.L3083
+	ldrh	w0, [x24,3264]
 	mov	w2, 21
 	mov	w1, 1
 	ldr	w3, [x29,76]
@@ -19248,28 +19537,28 @@ gc_scan_static_data:
 	lsl	w2, w1, w2
 	lsr	w3, w3, w0
 	sub	w2, w2, #1
-	ldrb	w0, [x24,3338]
+	ldrb	w0, [x24,3266]
 	and	w2, w2, w3
 	udiv	w0, w2, w0
 	mov	w2, 0
 	bl	gc_add_sblk
-.L3046:
+.L3083:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldr	x1, [x23,24]
 	ldr	x0, [x0,608]
 	ldr	w1, [x1,4]
 	ldr	w0, [x0,544]
 	cmp	w1, w0
-	beq	.L3047
+	beq	.L3084
 	mov	x1, x21
-	mov	w2, 1504
+	mov	w2, 1551
 	mov	x0, x22
 	bl	printk
 	bl	dump_stack
-.L3047:
+.L3084:
 	mov	x0, x23
-	bl	buf_free
-.L3045:
+	bl	zbuf_free
+.L3082:
 	add	x2, x19, :lo12:.LANCHOR0
 	ldr	x1, [x2,608]
 	ldr	w2, [x2,2840]
@@ -19277,7 +19566,7 @@ gc_scan_static_data:
 	add	w0, w0, 1
 	str	w0, [x1,544]
 	cmp	w0, w2
-	bcc	.L3048
+	bcc	.L3085
 	mov	w0, -1
 	str	w0, [x1,544]
 	ldr	w0, [x1,548]
@@ -19288,37 +19577,37 @@ gc_scan_static_data:
 	bl	ftl_ext_info_flush
 	mov	w0, 0
 	bl	ftl_info_flush
-	b	.L3042
-.L3048:
+	b	.L3079
+.L3085:
 	ldr	w0, [x29,76]
 	cmn	w0, #1
-	bne	.L3042
+	bne	.L3079
 	sub	w20, w20, #1
 	uxth	w20, w20
-	cbnz	w20, .L3044
-	b	.L3042
-.L3043:
+	cbnz	w20, .L3081
+	b	.L3079
+.L3080:
 	ldr	w1, [x0,536]
 	ldr	w2, [x0,12]
 	add	w1, w1, 12959744
 	add	w1, w1, 256
 	cmp	w2, w1
-	bhi	.L3053
+	bhi	.L3090
 	ldr	x3, [x3,2864]
 	ldr	w1, [x0,540]
 	ldr	w3, [x3,44]
 	add	w1, w1, 4096
 	add	w1, w1, 904
 	cmp	w3, w1
-	bls	.L3042
-.L3053:
+	bls	.L3079
+.L3090:
 	add	x19, x19, :lo12:.LANCHOR0
 	ldr	x1, [x19,2864]
 	ldr	w1, [x1,44]
 	str	w1, [x0,540]
 	str	w2, [x0,536]
 	str	wzr, [x0,544]
-.L3042:
+.L3079:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -19342,45 +19631,45 @@ gc_block_vpn_scan:
 	ldrh	w0, [x20,576]
 	ldr	w1, [x1,608]
 	cmp	w1, w0
-	bcs	.L3058
+	bcs	.L3095
 	bl	timer_get_time
 	ldr	x21, [x20,608]
 	ldr	w1, [x21,604]
 	add	w1, w1, 28672
 	add	w1, w1, 1328
 	cmp	w0, w1
-	bls	.L3058
+	bls	.L3095
 	bl	timer_get_time
 	str	w0, [x21,604]
 	ldr	x0, [x20,608]
 	ldrh	w2, [x20,576]
 	ldr	w1, [x0,600]
 	cmp	w1, w2
-	bcs	.L3062
+	bcs	.L3099
 	ldr	x2, [x20,2864]
 	ldrh	w2, [x2,134]
 	cmp	w1, w2
-	bcs	.L3063
-.L3062:
+	bcs	.L3100
+.L3099:
 	add	x1, x19, :lo12:.LANCHOR0
 	ldr	x1, [x1,2864]
 	ldrh	w1, [x1,134]
 	str	w1, [x0,600]
-.L3063:
+.L3100:
 	ldr	w25, [x0,600]
 	mov	w0, 65535
 	uxth	w20, w25
 	cmp	w20, w0
-	bne	.L3064
+	bne	.L3101
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 1799
+	mov	w2, 1846
 	add	x1, x1, 688
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L3064:
+.L3101:
 	add	x21, x19, :lo12:.LANCHOR0
 	ldr	x0, [x21,608]
 	ldr	w1, [x0,600]
@@ -19393,47 +19682,47 @@ gc_block_vpn_scan:
 	mov	w0, w20
 	bl	ftl_get_blk_list_in_sblk
 	uxth	w1, w0
-	cbz	w1, .L3058
+	cbz	w1, .L3095
 	uxtw	x22, w20
 	ldr	x24, [x21,584]
 	add	x24, x24, x22, lsl 2
 	ldrb	w1, [x24,2]
 	tst	w1, 192
 	and	w2, w1, 224
-	beq	.L3065
+	beq	.L3102
 	cmp	w2, 224
-	beq	.L3065
+	beq	.L3102
 	ldr	x1, [x21,608]
 	ldrh	w3, [x1,16]
 	cmp	w3, w20
-	beq	.L3065
+	beq	.L3102
 	ldrh	w3, [x1,48]
 	cmp	w3, w20
-	beq	.L3065
+	beq	.L3102
 	ldrh	w1, [x1,80]
 	cmp	w1, w20
-	bne	.L3066
-.L3065:
-	cbnz	w2, .L3058
+	bne	.L3103
+.L3102:
+	cbnz	w2, .L3095
 	add	x0, x19, :lo12:.LANCHOR0
 	lsl	x22, x22, 1
 	ldr	x0, [x0,600]
 	ldrh	w0, [x0,x22]
-	cbz	w0, .L3067
+	cbz	w0, .L3104
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 1815
+	mov	w2, 1862
 	add	x1, x1, 688
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L3067:
+.L3104:
 	add	x19, x19, :lo12:.LANCHOR0
 	ldr	x0, [x19,600]
 	strh	wzr, [x0,x22]
-	b	.L3058
-.L3066:
+	b	.L3095
+.L3103:
 	and	w0, w0, 65535
 	add	x1, x29, 144
 	sub	w0, w0, #1
@@ -19441,36 +19730,36 @@ gc_block_vpn_scan:
 	ldrh	w21, [x0,-16]
 	mov	w0, 65535
 	cmp	w21, w0
-	bne	.L3069
+	bne	.L3106
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 1821
+	mov	w2, 1868
 	add	x1, x1, 688
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L3069:
+.L3106:
 	add	x2, x19, :lo12:.LANCHOR0
 	ldrb	w3, [x24,2]
 	mov	w26, 1
 	and	w3, w3, 224
-	ldrh	w0, [x2,3300]
+	ldrh	w0, [x2,3324]
 	cmp	w3, 160
-	ldrh	w1, [x2,3348]
+	ldrh	w1, [x2,3362]
 	sub	w0, w0, #1
 	mul	w1, w21, w1
 	uxth	w0, w0
-	bne	.L3070
-	ldrb	w3, [x2,3257]
+	bne	.L3107
+	ldrb	w3, [x2,3281]
 	cmp	w3, 2
 	uxth	w26, w3
 	orr	w1, w1, w3, lsl 24
-	bne	.L3070
-	ldrh	w0, [x2,3274]
+	bne	.L3107
+	ldrh	w0, [x2,3298]
 	sub	w0, w0, #1
 	uxth	w0, w0
-.L3070:
+.L3107:
 	orr	w21, w0, w1
 	mov	w0, 1
 	bl	buf_alloc
@@ -19479,42 +19768,42 @@ gc_block_vpn_scan:
 	add	x21, x19, :lo12:.LANCHOR0
 	mov	x23, x0
 	bl	sblk_read_page
-	ldrh	w0, [x21,3274]
+	ldrh	w0, [x21,3298]
 	mov	w1, 255
-	ldrb	w2, [x21,3276]
+	ldrb	w2, [x21,3300]
 	mul	w2, w0, w2
-	ldr	x0, [x21,3248]
+	ldr	x0, [x21,3272]
 	lsl	w2, w2, 2
 	bl	ftl_memset
 	ldr	w0, [x23,52]
 	cmp	w0, 512
-	beq	.L3082
+	beq	.L3119
 	cmn	w0, #1
 	cset	w2, eq
-	cbz	w2, .L3071
-.L3082:
+	cbz	w2, .L3108
+.L3119:
 	mov	w0, w20
 	mov	w1, 1
 	mov	w2, 0
-	b	.L3095
-.L3071:
+	b	.L3132
+.L3108:
 	ldr	x0, [x23,24]
 	ldr	w1, [x0]
 	mov	w0, 15555
 	movk	w0, 0xf55f, lsl 16
 	cmp	w1, w0
-	beq	.L3073
+	beq	.L3110
 	mov	w0, w20
 	mov	w1, 1
-.L3095:
+.L3132:
 	bl	gc_add_sblk
 	mov	x0, x23
-	bl	buf_free
-	b	.L3058
-.L3073:
-	ldrb	w0, [x21,3276]
+	bl	zbuf_free
+	b	.L3095
+.L3110:
+	ldrb	w0, [x21,3300]
 	mov	x27, 0
-	ldrh	w1, [x21,3300]
+	ldrh	w1, [x21,3324]
 	and	w28, w25, 65535
 	mov	w21, w27
 	mul	w0, w0, w1
@@ -19522,68 +19811,68 @@ gc_block_vpn_scan:
 	uxth	w0, w26
 	ldr	x26, [x23,8]
 	str	w0, [x29,108]
-.L3074:
+.L3111:
 	ldr	w0, [x29,108]
 	cmp	w0, w27
-	ble	.L3096
+	ble	.L3133
 	ldr	w0, [x26,x27,lsl 2]
 	cmn	w0, #1
-	beq	.L3075
+	beq	.L3112
 	bl	lpa_hash_get_ppa
 	str	w0, [x29,124]
 	cmn	w0, #1
-	bne	.L3076
+	bne	.L3113
 	ldr	w0, [x26,x27,lsl 2]
 	add	x1, x29, 124
 	mov	w2, 0
 	bl	pm_log2phys
-.L3076:
+.L3113:
 	add	x4, x19, :lo12:.LANCHOR0
 	mov	w1, 21
-	ldrh	w0, [x4,3340]
+	ldrh	w0, [x4,3264]
 	sub	w2, w1, w0
 	mov	w1, 1
 	lsl	w2, w1, w2
 	ldr	w1, [x29,124]
 	sub	w2, w2, #1
 	lsr	w0, w1, w0
-	ldrb	w1, [x4,3338]
+	ldrb	w1, [x4,3266]
 	and	w0, w2, w0
 	udiv	w0, w0, w1
 	cmp	w0, w28
-	bne	.L3075
+	bne	.L3112
 	add	w21, w21, 1
 	uxth	w21, w21
-.L3075:
+.L3112:
 	add	x27, x27, 1
-	b	.L3074
-.L3096:
+	b	.L3111
+.L3133:
 	mov	x0, x23
-	bl	buf_free
+	bl	zbuf_free
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 8, .L3078
+	tbz	x0, 8, .L3115
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrb	w4, [x24,2]
 	uxth	w1, w25
 	mov	w3, w21
 	ubfx	x4, x4, 5, 3
 	ldr	x2, [x0,600]
-	adrp	x0, .LC242
-	add	x0, x0, :lo12:.LC242
+	adrp	x0, .LC249
+	add	x0, x0, :lo12:.LC249
 	ldrh	w2, [x2,x22,lsl 1]
 	bl	printk
-.L3078:
+.L3115:
 	add	x19, x19, :lo12:.LANCHOR0
 	cmp	w21, 31
 	ldr	x0, [x19,600]
 	strh	w21, [x0,x22,lsl 1]
-	bhi	.L3058
+	bhi	.L3095
 	mov	w0, w20
 	mov	w1, 1
 	mov	w2, 0
 	bl	gc_add_sblk
-.L3058:
+.L3095:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -19615,9 +19904,9 @@ ftl_sblk_dump:
 	add	x1, x0, x25
 	ldrh	w4, [x0,x25]
 	ldr	w5, [x0,x25]
-	adrp	x0, .LC243
+	adrp	x0, .LC250
 	ldrb	w3, [x1,2]
-	add	x0, x0, :lo12:.LC243
+	add	x0, x0, :lo12:.LC250
 	mov	w1, w20
 	and	w4, w4, 2047
 	ubfx	x2, x3, 5, 3
@@ -19627,19 +19916,19 @@ ftl_sblk_dump:
 	mov	w1, 65535
 	mov	w0, 0
 	cmp	w20, w1
-	beq	.L3098
+	beq	.L3135
 	ldrh	w1, [x19,576]
 	cmp	w1, w20
-	bls	.L3098
+	bls	.L3135
 	ldr	x0, [x19,584]
 	mov	w26, 1
 	add	x0, x0, x25
 	ldrb	w0, [x0,2]
 	and	w0, w0, 224
 	cmp	w0, 160
-	bne	.L3099
-	ldrb	w26, [x19,3257]
-.L3099:
+	bne	.L3136
+	ldrb	w26, [x19,3281]
+.L3136:
 	add	x1, x29, 192
 	mov	w0, w20
 	strh	w20, [x29,176]
@@ -19652,7 +19941,7 @@ ftl_sblk_dump:
 	mov	w3, w26
 	strh	wzr, [x29,178]
 	uxtb	w4, w4
-	ldrh	w2, [x0,3300]
+	ldrh	w2, [x0,3324]
 	mov	w27, w22
 	strb	wzr, [x29,181]
 	mov	w19, w22
@@ -19660,8 +19949,8 @@ ftl_sblk_dump:
 	mul	w1, w1, w2
 	strh	w1, [x29,182]
 	ldr	x1, [x0,584]
-	adrp	x0, .LC244
-	add	x0, x0, :lo12:.LC244
+	adrp	x0, .LC251
+	add	x0, x0, :lo12:.LC251
 	add	x1, x1, x25
 	ldrb	w2, [x1,2]
 	mov	w1, w20
@@ -19670,56 +19959,56 @@ ftl_sblk_dump:
 	mov	w0, 1
 	bl	buf_alloc
 	mov	x28, x0
-	adrp	x0, .LC190
+	adrp	x0, .LC197
 	str	w22, [x29,152]
-	add	x0, x0, :lo12:.LC190
+	add	x0, x0, :lo12:.LC197
 	str	x0, [x29,120]
 	adrp	x0, .LANCHOR3
 	add	x0, x0, :lo12:.LANCHOR3
 	add	x0, x0, 712
 	str	x0, [x29,112]
-.L3100:
+.L3137:
 	add	x21, x23, :lo12:.LANCHOR0
-	ldrh	w0, [x21,3300]
+	ldrh	w0, [x21,3324]
 	cmp	w0, w19
-	bls	.L3116
+	bls	.L3153
 	lsl	w0, w19, 1
 	str	wzr, [x29,156]
 	sub	w0, w0, #1
 	str	w0, [x29,132]
-.L3117:
+.L3154:
 	ldrb	w0, [x29,185]
 	ldr	w1, [x29,156]
 	cmp	w0, w1
-	bls	.L3114
+	bls	.L3151
 	mov	w24, 1
-.L3115:
+.L3152:
 	cmp	w24, w26
 	ldr	w0, [x29,156]
-	bhi	.L3134
+	bhi	.L3171
 	add	x1, x29, 176
 	add	x0, x1, x0, sxtw 1
 	ldrh	w2, [x0,16]
 	mov	w0, 65535
 	cmp	w2, w0
-	beq	.L3101
+	beq	.L3138
 	add	x1, x23, :lo12:.LANCHOR0
 	cmp	w26, 3
-	ldrh	w0, [x1,3348]
+	ldrh	w0, [x1,3362]
 	mul	w0, w2, w0
 	add	w21, w0, w19
-	bne	.L3102
+	bne	.L3139
 	orr	w21, w21, w24, lsl 24
-	b	.L3103
-.L3102:
+	b	.L3140
+.L3139:
 	cmp	w26, 2
-	bne	.L3103
+	bne	.L3140
 	ldr	w3, [x29,132]
-	ldrb	w21, [x1,3257]
+	ldrb	w21, [x1,3281]
 	add	w0, w0, w3
 	add	w0, w0, w24
 	orr	w21, w0, w21, lsl 24
-.L3103:
+.L3140:
 	mov	w1, 1
 	str	w21, [x28,40]
 	mov	x0, x28
@@ -19751,23 +20040,23 @@ ftl_sblk_dump:
 	bl	printk
 	ldr	x9, [x29,104]
 	cmp	w9, 512
-	beq	.L3121
+	beq	.L3158
 	cmn	w9, #1
-	bne	.L3105
-.L3121:
+	bne	.L3142
+.L3158:
 	mov	w0, 1
 	str	w0, [x29,152]
-.L3105:
+.L3142:
 	add	x0, x23, :lo12:.LANCHOR0
 	ldr	x0, [x0,584]
 	add	x0, x0, x25
 	ldrb	w0, [x0,2]
 	and	w0, w0, 224
 	cmp	w0, 32
-	beq	.L3101
+	beq	.L3138
 	cmp	w0, 224
 	cset	w2, eq
-	cbnz	w2, .L3101
+	cbnz	w2, .L3138
 	ldr	x0, [x28,24]
 	str	x2, [x29,104]
 	ldr	w0, [x0,4]
@@ -19775,82 +20064,82 @@ ftl_sblk_dump:
 	str	w0, [x29,172]
 	cmn	w0, #1
 	ldr	x2, [x29,104]
-	bne	.L3107
+	bne	.L3144
 	ldr	x0, [x28,24]
 	add	x1, x29, 172
 	ldr	w0, [x0,4]
 	bl	pm_log2phys
-.L3107:
+.L3144:
 	ldr	w0, [x29,172]
 	cmp	w0, w21
-	bne	.L3108
+	bne	.L3145
 	ldr	x2, [x28,24]
 	add	w22, w22, 1
-	adrp	x0, .LC245
+	adrp	x0, .LC252
 	mov	w1, w21
-	add	x0, x0, :lo12:.LC245
+	add	x0, x0, :lo12:.LC252
 	mov	w3, w22
 	ldr	w2, [x2,4]
 	bl	printk
-.L3108:
+.L3145:
 	ldr	x0, [x29,144]
-	cbz	x0, .L3110
+	cbz	x0, .L3147
 	ubfiz	x21, x27, 2, 32
 	ldr	w2, [x0,x21]
 	ldr	x0, [x28,24]
 	ldr	w0, [x0,4]
 	cmp	w0, w2
-	beq	.L3111
+	beq	.L3148
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L3111
-	adrp	x0, .LC246
+	tbz	x0, 12, .L3148
+	adrp	x0, .LC253
 	mov	w1, w27
-	add	x0, x0, :lo12:.LC246
+	add	x0, x0, :lo12:.LC253
 	bl	printk
-.L3111:
+.L3148:
 	ldr	x0, [x29,144]
 	ldr	x1, [x28,24]
 	ldr	w0, [x0,x21]
 	ldr	w1, [x1,4]
 	cmp	w1, w0
-	beq	.L3110
+	beq	.L3147
 	cmn	w0, #1
-	beq	.L3110
+	beq	.L3147
 	adrp	x0, .LC0
 	ldr	x1, [x29,112]
-	mov	w2, 1299
+	mov	w2, 1312
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L3110:
+.L3147:
 	add	w27, w27, 1
-.L3101:
+.L3138:
 	add	w24, w24, 1
 	uxth	w24, w24
-	b	.L3115
-.L3134:
+	b	.L3152
+.L3171:
 	add	w0, w0, 1
 	uxth	w0, w0
 	str	w0, [x29,156]
-	b	.L3117
-.L3114:
+	b	.L3154
+.L3151:
 	add	w19, w19, 1
 	uxth	w19, w19
-	b	.L3100
-.L3116:
+	b	.L3137
+.L3153:
 	mov	x0, x28
-	bl	buf_free
+	bl	zbuf_free
 	ldr	x3, [x29,136]
-	adrp	x0, .LC247
+	adrp	x0, .LC254
 	ldr	x2, [x21,600]
-	add	x0, x0, :lo12:.LC247
+	add	x0, x0, :lo12:.LC254
 	mov	w1, w20
 	ldrh	w2, [x2,x3,lsl 1]
 	mov	w3, w22
 	bl	printk
 	ldr	w0, [x29,152]
-.L3098:
+.L3135:
 	sub	sp, x29, #48
 	ldp	x19, x20, [sp,64]
 	ldp	x21, x22, [sp,80]
@@ -19874,52 +20163,52 @@ zftl_read:
 	stp	x21, x22, [sp,48]
 	stp	x23, x24, [sp,64]
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	mov	w22, w1
+	mov	w21, w1
 	stp	x25, x26, [sp,80]
 	stp	x27, x28, [sp,96]
-	mov	w25, w2
-	mov	x23, x3
-	tbz	x0, 12, .L3136
-	adrp	x0, .LC248
+	mov	w24, w2
+	mov	x22, x3
+	tbz	x0, 12, .L3173
+	adrp	x0, .LC255
 	mov	w1, w19
-	add	x0, x0, :lo12:.LC248
-	mov	w2, w22
-	mov	w3, w25
+	add	x0, x0, :lo12:.LC255
+	mov	w2, w21
+	mov	w3, w24
 	bl	printk
-.L3136:
-	cbnz	w19, .L3137
+.L3173:
+	cbnz	w19, .L3174
 	adrp	x0, .LANCHOR0+520
 	mov	w19, 24576
 	ldr	w2, [x0,#:lo12:.LANCHOR0+520]
-	b	.L3138
-.L3137:
+	b	.L3175
+.L3174:
 	cmp	w19, 3
 	mov	w0, -1
-	bhi	.L3139
+	bhi	.L3176
 	lsl	w19, w19, 13
 	mov	w2, 8192
-.L3138:
-	add	w1, w22, w25
+.L3175:
+	add	w1, w21, w24
 	mov	w0, -1
 	cmp	w1, w2
-	bhi	.L3139
-	add	w22, w19, w22
+	bhi	.L3176
+	add	w21, w19, w21
 	adrp	x19, .LANCHOR0
 	add	x1, x19, :lo12:.LANCHOR0
-	add	w28, w22, w25
+	add	w27, w21, w24
 	str	wzr, [x29,140]
 	ldr	x2, [x1,2864]
 	ldr	w0, [x2,24]
-	add	w0, w0, w25
+	add	w0, w0, w24
 	str	w0, [x2,24]
 	ldrb	w0, [x1,2832]
-	sub	w1, w28, #1
-	udiv	w27, w22, w0
-	mov	w20, w27
+	sub	w1, w27, #1
+	udiv	w26, w21, w0
+	mov	w20, w26
 	udiv	w0, w1, w0
 	str	w0, [x29,136]
-	sub	w24, w0, w27
-	add	w24, w24, 1
+	sub	w23, w0, w26
+	add	w23, w23, 1
 	adrp	x0, .LC0
 	add	x0, x0, :lo12:.LC0
 	str	x0, [x29,128]
@@ -19927,292 +20216,300 @@ zftl_read:
 	add	x0, x0, :lo12:.LANCHOR3
 	add	x0, x0, 728
 	str	x0, [x29,120]
-.L3140:
-	cbz	w24, .L3200
+.L3177:
+	cbz	w23, .L3242
 	add	x0, x19, :lo12:.LANCHOR0
 	ldr	w1, [x29,136]
-	cmp	w20, w27
+	cmp	w20, w26
 	cset	w2, eq
 	cmp	w20, w1
 	ldrb	w0, [x0,2832]
-	cset	w26, eq
-	uxth	w21, w0
-	cbnz	w26, .L3170
-	cbz	w2, .L3141
-	b	.L3199
-.L3170:
-	cbz	w2, .L3143
-.L3199:
-	udiv	w26, w22, w0
-	msub	w26, w26, w0, w22
-	uxth	w0, w25
-	uxth	w26, w26
-	sub	w21, w21, w26
-	uxth	w21, w21
-	cmp	w21, w25
-	csel	w21, w0, w21, hi
-	b	.L3141
-.L3143:
-	msub	w21, w0, w20, w28
-	mov	w26, w2
-	uxtb	w21, w21
-.L3141:
+	cset	w28, eq
+	uxth	w25, w0
+	cbnz	w28, .L3208
+	cbz	w2, .L3178
+	b	.L3241
+.L3208:
+	cbz	w2, .L3180
+.L3241:
+	udiv	w28, w21, w0
+	msub	w28, w28, w0, w21
+	uxth	w0, w24
+	uxth	w28, w28
+	sub	w25, w25, w28
+	uxth	w25, w25
+	cmp	w25, w24
+	csel	w25, w0, w25, hi
+	b	.L3178
+.L3180:
+	msub	w25, w0, w20, w27
+	mov	w28, w2
+	uxtb	w25, w25
+.L3178:
 	add	x1, x19, :lo12:.LANCHOR0
 	mov	w0, 0
 	add	x1, x1, 784
-.L3146:
+.L3183:
 	ldr	w2, [x1,36]
 	cmp	w2, w20
-	bne	.L3144
+	bne	.L3181
 	ldrb	w2, [x1,2]
-	tbz	x2, 3, .L3144
+	tbz	x2, 3, .L3181
 	add	x2, x19, :lo12:.LANCHOR0
 	ubfiz	x1, x0, 6, 32
 	add	x0, x2, x1
-	ubfiz	x26, x26, 9, 16
-	lsl	w2, w21, 9
-	ubfiz	x21, x21, 9, 16
+	ubfiz	x28, x28, 9, 16
+	lsl	w2, w25, 9
+	ubfiz	x25, x25, 9, 16
 	ldr	x1, [x0,792]
-	mov	x0, x23
-	add	x23, x23, x21
-	add	x1, x1, x26
+	mov	x0, x22
+	add	x22, x22, x25
+	add	x1, x1, x28
 	bl	ftl_memcpy
-	b	.L3145
-.L3144:
+	b	.L3182
+.L3181:
 	add	w0, w0, 1
 	add	x1, x1, 64
 	cmp	w0, 32
-	bne	.L3146
+	bne	.L3183
 	mov	w0, w20
 	bl	lpa_hash_get_ppa
 	str	w0, [x29,156]
 	cmn	w0, #1
-	bne	.L3147
+	bne	.L3184
 	mov	w0, w20
 	add	x1, x29, 156
 	mov	w2, 0
 	bl	pm_log2phys
-.L3147:
+.L3184:
 	ldr	w0, [x29,156]
 	cmn	w0, #1
-	bne	.L3148
-	mov	w21, 0
-.L3149:
+	bne	.L3185
+	mov	w25, 0
+.L3186:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrb	w0, [x0,2832]
-	cmp	w21, w0
-	bcs	.L3145
-	madd	w0, w20, w0, w21
-	cmp	w0, w22
-	bcc	.L3150
-	cmp	w0, w28
-	bcs	.L3150
-	mov	x0, x23
+	cmp	w25, w0
+	bcs	.L3182
+	madd	w0, w20, w0, w25
+	cmp	w0, w21
+	bcc	.L3187
+	cmp	w0, w27
+	bcs	.L3187
+	mov	x0, x22
 	mov	w1, 0
 	mov	w2, 512
-	add	x23, x23, 512
+	add	x22, x22, 512
 	bl	ftl_memset
-.L3150:
-	add	w21, w21, 1
-	b	.L3149
-.L3148:
+.L3187:
+	add	w25, w25, 1
+	b	.L3186
+.L3185:
 	mov	w0, 0
 	bl	buf_alloc
-	cbz	x0, .L3152
+	cbz	x0, .L3189
 	add	x2, x19, :lo12:.LANCHOR0
 	ldr	x3, [x2,2864]
 	ldr	w2, [x3,40]
 	add	w2, w2, 1
 	str	w2, [x3,40]
 	ldr	w2, [x29,156]
-	strb	w21, [x0,56]
-	ubfiz	x21, x21, 9, 16
-	str	x23, [x0,16]
-	add	x23, x23, x21
+	strb	w25, [x0,56]
+	ubfiz	x25, x25, 9, 16
+	str	x22, [x0,16]
+	add	x22, x22, x25
 	str	w2, [x0,40]
 	str	w2, [x0,44]
 	str	w20, [x0,36]
-	strb	w26, [x0,57]
+	strb	w28, [x0,57]
 	bl	zftl_add_read_buf
-.L3145:
+.L3182:
 	add	w20, w20, 1
-	sub	w24, w24, #1
-.L3152:
-	cbz	w24, .L3171
+	sub	w23, w23, #1
+.L3189:
+	cbz	w23, .L3209
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrb	w0, [x0,2834]
 	cmp	w0, 2
-	bhi	.L3140
-.L3171:
+	bhi	.L3177
+.L3209:
 	add	x2, x19, :lo12:.LANCHOR0
-	ldrb	w1, [x2,3886]
-	cbz	w1, .L3140
+	ldrb	w1, [x2,3908]
+	cbz	w1, .L3177
 	add	x0, x2, 784
-	ldrb	w2, [x2,3885]
+	ldrb	w2, [x2,3907]
 	add	x0, x0, x2, lsl 6
 	bl	sblk_read_page
-.L3155:
+.L3192:
 	add	x0, x19, :lo12:.LANCHOR0
-	ldrb	w1, [x0,3886]
-	cbz	w1, .L3201
-	ldrb	w0, [x0,3885]
+	ldrb	w1, [x0,3908]
+	cbz	w1, .L3243
+	ldrb	w0, [x0,3907]
 	cmp	w0, 255
-	bne	.L3156
+	bne	.L3193
 	ldr	x1, [x29,120]
-	mov	w2, 1070
+	mov	w2, 1080
 	ldr	x0, [x29,128]
 	bl	printk
 	bl	dump_stack
-.L3156:
+.L3193:
 	add	x5, x19, :lo12:.LANCHOR0
 	add	x1, x5, 784
-	ldrb	w21, [x5,3885]
-	lsl	x0, x21, 6
-	add	x26, x1, x0
+	ldrb	w28, [x5,3907]
+	lsl	x0, x28, 6
+	add	x25, x1, x0
 	ldrb	w0, [x1,x0]
-	ldr	w8, [x26,52]
-	strb	w0, [x5,3885]
-	cmn	w8, #1
-	bne	.L3157
+	ldr	w6, [x25,52]
+	strb	w0, [x5,3907]
+	cmn	w6, #1
+	bne	.L3194
 	ldr	x1, [x5,608]
-	str	w8, [x29,140]
+	str	w6, [x29,140]
 	ldr	w0, [x1,552]
 	add	w0, w0, 1
 	str	w0, [x1,552]
-	b	.L3158
-.L3157:
-	cmp	w8, 256
-	bne	.L3158
-	ldrh	w0, [x5,3340]
+	b	.L3195
+.L3194:
+	cmp	w6, 256
+	bne	.L3195
+	ldrh	w0, [x5,3264]
 	mov	w1, 21
-	mov	w6, 1
-	ldr	w3, [x26,40]
+	mov	w7, 1
+	ldr	w3, [x25,40]
 	sub	w4, w1, w0
-	ldr	w2, [x26,36]
-	lsl	w4, w6, w4
+	ldr	w2, [x25,36]
+	lsl	w4, w7, w4
 	lsr	w0, w3, w0
 	sub	w4, w4, #1
-	str	x8, [x29,96]
+	str	x6, [x29,96]
 	and	w0, w4, w0
-	ldrb	w4, [x5,3338]
-	str	x6, [x29,104]
+	ldrb	w4, [x5,3266]
+	str	x7, [x29,104]
 	udiv	w4, w0, w4
-	adrp	x0, .LC249
-	add	x0, x0, :lo12:.LC249
+	adrp	x0, .LC256
+	add	x0, x0, :lo12:.LC256
 	str	x4, [x29,112]
 	uxth	w1, w4
 	bl	printk
 	ldr	x4, [x29,112]
 	mov	w2, 0
-	ldr	x6, [x29,104]
+	ldr	x7, [x29,104]
 	mov	w0, w4
-	mov	w1, w6
+	mov	w1, w7
 	bl	gc_add_sblk
-	ldr	x8, [x29,96]
-.L3158:
-	add	x9, x19, :lo12:.LANCHOR0
-	add	x0, x9, 784
-	add	x0, x0, x21, lsl 6
-	add	x10, x0, 32
+	ldr	x6, [x29,96]
+.L3195:
+	add	x0, x19, :lo12:.LANCHOR0
+	cmn	w6, #1
+	add	x0, x0, 784
+	cset	w10, eq
+	add	x0, x0, x28, lsl 6
 	ldr	x1, [x0,24]
-	ldr	w3, [x1,4]
-	ldr	w1, [x0,36]
-	cmp	w3, w1
-	beq	.L3159
-	ldr	x3, [x9,608]
-	mov	w2, w8
-	str	x8, [x29,104]
-	str	x9, [x29,96]
-	ldr	w1, [x3,552]
-	str	x10, [x29,112]
-	add	w1, w1, 1
-	str	w1, [x3,552]
-	ldr	x7, [x0,24]
-	ldrb	w1, [x0,1]
+	ldr	w0, [x0,36]
+	ldr	w1, [x1,4]
+	cmp	w1, w0
+	bne	.L3210
+	cbz	w10, .L3196
+.L3210:
+	add	x11, x19, :lo12:.LANCHOR0
+	mov	w2, w6
+	add	x9, x11, 784
+	str	x10, [x29,96]
+	add	x9, x9, x28, lsl 6
+	str	x11, [x29,104]
+	ldr	x1, [x11,608]
+	add	x9, x9, 32
+	ldr	w0, [x1,552]
+	add	w0, w0, 1
+	str	w0, [x1,552]
+	ldr	x7, [x9,-8]
+	ldrb	w1, [x9,-31]
 	ldr	w0, [x7,12]
 	str	w0, [sp]
-	adrp	x0, .LC250
-	add	x0, x0, :lo12:.LC250
-	ldr	w3, [x10,4]
-	ldr	w4, [x10,8]
+	adrp	x0, .LC257
+	add	x0, x0, :lo12:.LC257
+	ldr	w3, [x9,4]
+	ldr	w4, [x9,8]
 	ldr	w5, [x7]
 	ldr	w6, [x7,4]
 	ldr	w7, [x7,8]
+	str	x9, [x29,112]
 	bl	printk
-	ldr	x9, [x29,96]
+	ldr	x11, [x29,104]
 	mov	w1, 21
-	ldr	x10, [x29,112]
-	ldrh	w0, [x9,3340]
+	ldr	x9, [x29,112]
+	ldrh	w0, [x11,3264]
 	sub	w2, w1, w0
 	mov	w1, 1
 	lsl	w2, w1, w2
-	ldr	w1, [x10,8]
+	ldr	w1, [x9,8]
 	sub	w2, w2, #1
 	lsr	w0, w1, w0
-	ldrb	w1, [x9,3338]
+	ldrb	w1, [x11,3266]
 	and	w0, w2, w0
 	udiv	w0, w0, w1
 	mov	x1, 0
 	bl	ftl_sblk_dump
-	ldr	x8, [x29,104]
-.L3159:
+	ldr	x10, [x29,96]
+.L3196:
 	add	x0, x19, :lo12:.LANCHOR0
 	add	x0, x0, 784
-	add	x0, x0, x21, lsl 6
+	add	x0, x0, x28, lsl 6
 	ldr	x1, [x0,24]
 	ldr	w0, [x0,36]
 	ldr	w1, [x1,4]
 	cmp	w1, w0
-	bne	.L3172
-	cmn	w8, #1
-	bne	.L3160
-.L3172:
+	bne	.L3211
+	cbz	w10, .L3198
+.L3211:
 	ldr	x1, [x29,120]
-	mov	w2, 1091
+	mov	w2, 1101
 	ldr	x0, [x29,128]
 	bl	printk
 	bl	dump_stack
-.L3160:
+.L3198:
 	add	x1, x19, :lo12:.LANCHOR0
 	add	x0, x1, 784
-	add	x21, x0, x21, lsl 6
+	add	x8, x0, x28, lsl 6
 	ldrb	w1, [x1,2832]
-	ldrb	w2, [x21,56]
+	ldrb	w2, [x8,56]
 	cmp	w1, w2
-	bls	.L3162
-	ldrb	w3, [x21,57]
+	bls	.L3200
+	ldrb	w3, [x8,57]
 	lsl	w2, w2, 9
-	ldr	x1, [x21,8]
-	ldr	x0, [x21,16]
+	ldr	x1, [x8,8]
+	ldr	x0, [x8,16]
 	add	x1, x1, x3, lsl 9
 	bl	ftl_memcpy
-	b	.L3163
-.L3162:
-	ldrb	w0, [x21,2]
+	b	.L3201
+.L3200:
+	ldrb	w0, [x8,2]
 	and	w0, w0, -9
-	strb	w0, [x21,2]
-.L3163:
-	add	x21, x19, :lo12:.LANCHOR0
-	mov	x1, x26
-	add	x0, x21, 3887
+	strb	w0, [x8,2]
+.L3201:
+	add	x2, x19, :lo12:.LANCHOR0
+	mov	x1, x25
+	add	x0, x2, 3909
+	str	x2, [x29,112]
 	bl	buf_remove_buf
-	mov	x0, x26
-	bl	buf_free
-	ldrb	w0, [x21,3886]
+	mov	x0, x25
+	bl	zbuf_free
+	ldr	x2, [x29,112]
+	ldrb	w0, [x2,3908]
 	sub	w0, w0, #1
-	strb	w0, [x21,3886]
-	b	.L3155
-.L3201:
+	strb	w0, [x2,3908]
+	b	.L3192
+.L3243:
 	mov	w2, -1
-	strb	w1, [x0,3886]
-	strb	w2, [x0,3885]
-	b	.L3140
-.L3200:
+	strb	w1, [x0,3908]
+	strb	w2, [x0,3907]
+	b	.L3177
+.L3242:
 	bl	timer_get_time
 	adrp	x1, .LANCHOR7-64
 	str	w0, [x1,#:lo12:.LANCHOR7-64]
 	ldr	w0, [x29,140]
-.L3139:
+.L3176:
 	sub	sp, x29, #16
 	ldp	x19, x20, [sp,32]
 	ldp	x21, x22, [sp,48]
@@ -20269,34 +20566,34 @@ zftl_debug_proc_write:
 	stp	x23, x24, [sp,80]
 	stp	x25, x26, [sp,96]
 	mov	x21, x2
-	bhi	.L3205
+	bhi	.L3247
 	mov	x0, x19
 	bl	rk_copy_from_user
 	mov	x22, x0
 	mov	x0, -14
-	cbnz	x22, .L3205
-	adrp	x0, .LC251
+	cbnz	x22, .L3247
+	adrp	x0, .LC258
 	mov	x1, x19
-	add	x0, x0, :lo12:.LC251
+	add	x0, x0, :lo12:.LC258
 	strb	w22, [x19,x21]
 	bl	printk
-	adrp	x0, .LC252
+	adrp	x0, .LC259
 	mov	x1, x19
-	add	x0, x0, :lo12:.LC252
+	add	x0, x0, :lo12:.LC259
 	mov	w2, 1
 	mov	w3, 16
 	bl	rknand_print_hex
 	bl	rknand_device_lock
-	adrp	x1, .LC253
+	adrp	x1, .LC260
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC253
+	add	x1, x1, :lo12:.LC260
 	mov	x2, 7
 	bl	memcmp
-	cbnz	w0, .L3206
+	cbnz	w0, .L3248
 	adrp	x23, .LANCHOR0
-	adrp	x0, .LC254
+	adrp	x0, .LC261
 	add	x19, x23, :lo12:.LANCHOR0
-	add	x0, x0, :lo12:.LC254
+	add	x0, x0, :lo12:.LC261
 	mov	w2, 4
 	adrp	x20, .LANCHOR4
 	ldr	x3, [x19,2864]
@@ -20305,19 +20602,19 @@ zftl_debug_proc_write:
 	bl	rknand_print_hex
 	add	x3, x20, :lo12:.LANCHOR4
 	ldr	x1, [x19,2864]
-	adrp	x0, .LC255
+	adrp	x0, .LC262
 	mov	w2, 2
-	add	x0, x0, :lo12:.LC255
+	add	x0, x0, :lo12:.LC262
 	add	x1, x1, 416
-	ldrh	w3, [x3,1156]
+	ldrh	w3, [x3,1180]
 	mov	w19, w22
 	mov	w22, 65535
 	bl	rknand_print_hex
-.L3207:
+.L3249:
 	add	x0, x20, :lo12:.LANCHOR4
-	ldrh	w0, [x0,1156]
+	ldrh	w0, [x0,1180]
 	cmp	w19, w0
-	bge	.L3210
+	bge	.L3252
 	mov	w0, 300
 	bl	msleep
 	add	x0, x23, :lo12:.LANCHOR0
@@ -20325,63 +20622,63 @@ zftl_debug_proc_write:
 	add	x0, x0, x19, sxtw 1
 	ldrh	w0, [x0,416]
 	cmp	w0, w22
-	beq	.L3208
+	beq	.L3250
 	mov	x1, 0
 	bl	ftl_sblk_dump
-.L3208:
+.L3250:
 	add	w19, w19, 1
-	b	.L3207
-.L3206:
-	adrp	x1, .LC256
+	b	.L3249
+.L3248:
+	adrp	x1, .LC263
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC256
+	add	x1, x1, :lo12:.LC263
 	mov	x2, 7
 	bl	memcmp
-	cbnz	w0, .L3211
+	cbnz	w0, .L3253
 	adrp	x23, .LANCHOR0
-	adrp	x0, .LC254
+	adrp	x0, .LC261
 	add	x20, x23, :lo12:.LANCHOR0
-	add	x0, x0, :lo12:.LC254
+	add	x0, x0, :lo12:.LC261
 	mov	w2, 4
 	add	x22, x29, 192
-	adrp	x24, .LC259
+	adrp	x24, .LC266
 	ldr	x3, [x20,2864]
-	add	x24, x24, :lo12:.LC259
+	add	x24, x24, :lo12:.LC266
 	add	x1, x3, 704
 	ldrh	w3, [x3,698]
 	bl	rknand_print_hex
-	adrp	x3, .LANCHOR4+1156
+	adrp	x3, .LANCHOR4+1180
 	ldr	x1, [x20,2864]
-	adrp	x0, .LC255
+	adrp	x0, .LC262
 	mov	w2, 2
-	add	x0, x0, :lo12:.LC255
+	add	x0, x0, :lo12:.LC262
 	add	x1, x1, 416
-	ldrh	w3, [x3,#:lo12:.LANCHOR4+1156]
+	ldrh	w3, [x3,#:lo12:.LANCHOR4+1180]
 	bl	rknand_print_hex
-	adrp	x0, .LC257
+	adrp	x0, .LC264
 	add	x1, x19, 7
-	add	x0, x0, :lo12:.LC257
+	add	x0, x0, :lo12:.LC264
 	str	x1, [x22,-88]!
-	add	x19, x20, 3896
+	add	x19, x20, 3920
 	mov	x20, x23
 	bl	printk
-	adrp	x23, .LC258
+	adrp	x23, .LC265
 	ldr	x0, [x29,104]
 	mov	x1, x22
 	add	x25, x19, 512
-	add	x23, x23, :lo12:.LC258
-	bl	rk_simple_strtoull.constprop.30
+	add	x23, x23, :lo12:.LC265
+	bl	rk_simple_strtoull.constprop.33
 	mov	w22, w0
 	str	w0, [x29,100]
 	uxth	w26, w0
-.L3213:
+.L3255:
 	ldrh	w1, [x19]
 	mov	x0, x23
 	ldrh	w2, [x19,2]
 	bl	printk
 	ldrh	w0, [x19]
 	cmp	w0, w26
-	bne	.L3212
+	bne	.L3254
 	add	x0, x20, :lo12:.LANCHOR0
 	ldr	x1, [x19,8]
 	mov	w2, 4
@@ -20389,10 +20686,10 @@ zftl_debug_proc_write:
 	mov	x0, x24
 	lsl	w3, w3, 7
 	bl	rknand_print_hex
-.L3212:
+.L3254:
 	add	x19, x19, 16
 	cmp	x19, x25
-	bne	.L3213
+	bne	.L3255
 	mov	w0, 300
 	add	x20, x20, :lo12:.LANCHOR0
 	bl	msleep
@@ -20415,8 +20712,8 @@ zftl_debug_proc_write:
 	str	w0, [sp,8]
 	ldr	w0, [x7,12]
 	str	w0, [sp,16]
-	adrp	x0, .LC221
-	add	x0, x0, :lo12:.LC221
+	adrp	x0, .LC228
+	add	x0, x0, :lo12:.LC228
 	ldr	w3, [x6]
 	ldr	w2, [x19,52]
 	ldr	w4, [x6,4]
@@ -20425,61 +20722,61 @@ zftl_debug_proc_write:
 	ldr	w6, [x6,12]
 	bl	printk
 	ldrb	w3, [x20,2832]
-	adrp	x0, .LC260
-	add	x0, x0, :lo12:.LC260
+	adrp	x0, .LC267
+	add	x0, x0, :lo12:.LC267
 	ldr	x1, [x19,8]
 	mov	w2, 4
 	lsl	w3, w3, 7
-	b	.L3228
-.L3211:
-	adrp	x1, .LC261
+	b	.L3270
+.L3253:
+	adrp	x1, .LC268
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC261
+	add	x1, x1, :lo12:.LC268
 	mov	x2, 7
 	bl	memcmp
-	cbnz	w0, .L3214
+	cbnz	w0, .L3256
 	bl	dump_ftl_info
-	b	.L3210
-.L3214:
-	adrp	x1, .LC262
+	b	.L3252
+.L3256:
+	adrp	x1, .LC269
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC262
+	add	x1, x1, :lo12:.LC269
 	mov	x2, 9
 	bl	memcmp
-	cbnz	w0, .L3215
+	cbnz	w0, .L3257
 	add	x1, x29, 192
 	add	x0, x19, 9
 	str	x0, [x1,-88]!
-	bl	rk_simple_strtoull.constprop.30
+	bl	rk_simple_strtoull.constprop.33
 	str	w0, [x29,100]
-	adrp	x1, .LANCHOR0+3336
-	strh	w0, [x1,#:lo12:.LANCHOR0+3336]
+	adrp	x1, .LANCHOR0+3360
+	strh	w0, [x1,#:lo12:.LANCHOR0+3360]
 	bl	dump_all_list_info
-	b	.L3210
-.L3215:
-	adrp	x1, .LC263
+	b	.L3252
+.L3257:
+	adrp	x1, .LC270
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC263
+	add	x1, x1, :lo12:.LC270
 	mov	x2, 8
 	bl	memcmp
-	cbz	w0, .L3210
-	adrp	x1, .LC264
+	cbz	w0, .L3252
+	adrp	x1, .LC271
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC264
+	add	x1, x1, :lo12:.LC271
 	mov	x2, 8
 	bl	memcmp
-	cbnz	w0, .L3217
+	cbnz	w0, .L3259
 	add	x20, x29, 192
-	adrp	x0, .LC257
+	adrp	x0, .LC264
 	add	x1, x19, 8
-	add	x0, x0, :lo12:.LC257
+	add	x0, x0, :lo12:.LC264
 	str	x1, [x20,-88]!
 	bl	printk
 	ldr	x0, [x29,104]
 	mov	x1, x20
 	adrp	x20, .LANCHOR0
 	add	x20, x20, :lo12:.LANCHOR0
-	bl	rk_simple_strtoull.constprop.30
+	bl	rk_simple_strtoull.constprop.33
 	str	w0, [x29,100]
 	mov	w0, 1
 	bl	buf_alloc
@@ -20497,8 +20794,8 @@ zftl_debug_proc_write:
 	str	w0, [sp,8]
 	ldr	w0, [x7,12]
 	str	w0, [sp,16]
-	adrp	x0, .LC221
-	add	x0, x0, :lo12:.LC221
+	adrp	x0, .LC228
+	add	x0, x0, :lo12:.LC228
 	ldr	w3, [x6]
 	ldr	w4, [x6,4]
 	ldr	w5, [x6,8]
@@ -20507,129 +20804,129 @@ zftl_debug_proc_write:
 	ldr	w7, [x7]
 	bl	printk
 	ldrb	w3, [x20,2832]
-	adrp	x0, .LC216
+	adrp	x0, .LC223
 	ldr	x1, [x19,8]
-	add	x0, x0, :lo12:.LC216
+	add	x0, x0, :lo12:.LC223
 	mov	w2, 4
 	lsl	w3, w3, 7
 	bl	rknand_print_hex
 	ldrb	w3, [x20,2832]
-	adrp	x0, .LC217
+	adrp	x0, .LC224
 	ldr	x1, [x19,24]
-	add	x0, x0, :lo12:.LC217
+	add	x0, x0, :lo12:.LC224
 	mov	w2, 4
 	lsl	w3, w3, 1
-.L3228:
+.L3270:
 	bl	rknand_print_hex
 	mov	x0, x19
-	bl	buf_free
-	b	.L3210
-.L3217:
-	adrp	x1, .LC265
+	bl	zbuf_free
+	b	.L3252
+.L3259:
+	adrp	x1, .LC272
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC265
+	add	x1, x1, :lo12:.LC272
 	mov	x2, 8
 	bl	memcmp
-	cbnz	w0, .L3218
+	cbnz	w0, .L3260
 	add	x20, x29, 192
-	adrp	x0, .LC257
+	adrp	x0, .LC264
 	add	x1, x19, 8
-	add	x0, x0, :lo12:.LC257
+	add	x0, x0, :lo12:.LC264
 	str	x1, [x20,-88]!
 	bl	printk
 	ldr	x0, [x29,104]
 	mov	x1, x20
-	bl	rk_simple_strtoull.constprop.30
+	bl	rk_simple_strtoull.constprop.33
 	str	w0, [x29,100]
 	mov	x1, x22
 	bl	ftl_sblk_dump
-	b	.L3210
-.L3218:
-	adrp	x1, .LC266
+	b	.L3252
+.L3260:
+	adrp	x1, .LC273
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC266
+	add	x1, x1, :lo12:.LC273
 	mov	x2, 10
 	bl	memcmp
-	cbnz	w0, .L3219
+	cbnz	w0, .L3261
 	add	x20, x29, 192
-	adrp	x0, .LC257
+	adrp	x0, .LC264
 	add	x1, x19, 10
-	add	x0, x0, :lo12:.LC257
+	add	x0, x0, :lo12:.LC264
 	str	x1, [x20,-88]!
 	bl	printk
 	ldr	x0, [x29,104]
 	mov	x1, x20
-	bl	rk_simple_strtoull.constprop.30
+	bl	rk_simple_strtoull.constprop.33
 	str	w0, [x29,100]
 	adrp	x1, .LANCHOR2
 	str	w0, [x1,#:lo12:.LANCHOR2]
-	b	.L3210
-.L3219:
-	adrp	x1, .LC267
+	b	.L3252
+.L3261:
+	adrp	x1, .LC274
 	mov	x2, 8
 	mov	x0, x19
-	add	x1, x1, :lo12:.LC267
+	add	x1, x1, :lo12:.LC274
 	bl	memcmp
 	mov	w2, w0
 	str	x2, [x29,88]
-	cbnz	w0, .L3220
+	cbnz	w0, .L3262
 	add	x1, x19, 8
-	adrp	x0, .LC257
+	adrp	x0, .LC264
 	add	x19, x29, 192
-	add	x0, x0, :lo12:.LC257
+	add	x0, x0, :lo12:.LC264
 	str	x1, [x19,-88]!
 	bl	printk
 	ldr	x0, [x29,104]
 	mov	x1, x19
-	bl	rk_simple_strtoull.constprop.30
+	bl	rk_simple_strtoull.constprop.33
 	mov	w19, w0
 	bl	lpa_hash_get_ppa
 	str	w0, [x29,100]
 	cmn	w0, #1
 	ldr	x2, [x29,88]
-	bne	.L3221
+	bne	.L3263
 	mov	w0, w19
 	add	x1, x29, 100
 	bl	pm_log2phys
-.L3221:
-	adrp	x0, .LC268
+.L3263:
+	adrp	x0, .LC275
 	ldr	w2, [x29,100]
 	mov	w1, w19
-	add	x0, x0, :lo12:.LC268
+	add	x0, x0, :lo12:.LC275
 	bl	printk
-	b	.L3210
-.L3220:
-	adrp	x0, .LC269
-	add	x0, x0, :lo12:.LC269
+	b	.L3252
+.L3262:
+	adrp	x0, .LC276
+	add	x0, x0, :lo12:.LC276
 	bl	printk
-	adrp	x0, .LC270
-	add	x0, x0, :lo12:.LC270
+	adrp	x0, .LC277
+	add	x0, x0, :lo12:.LC277
 	bl	printk
-	adrp	x0, .LC271
-	add	x0, x0, :lo12:.LC271
+	adrp	x0, .LC278
+	add	x0, x0, :lo12:.LC278
 	bl	printk
-	adrp	x0, .LC272
-	add	x0, x0, :lo12:.LC272
+	adrp	x0, .LC279
+	add	x0, x0, :lo12:.LC279
 	bl	printk
-	adrp	x0, .LC273
-	add	x0, x0, :lo12:.LC273
+	adrp	x0, .LC280
+	add	x0, x0, :lo12:.LC280
 	bl	printk
-	adrp	x0, .LC274
-	add	x0, x0, :lo12:.LC274
+	adrp	x0, .LC281
+	add	x0, x0, :lo12:.LC281
 	bl	printk
-	adrp	x0, .LC275
-	add	x0, x0, :lo12:.LC275
+	adrp	x0, .LC282
+	add	x0, x0, :lo12:.LC282
 	bl	printk
-	adrp	x0, .LC276
-	add	x0, x0, :lo12:.LC276
+	adrp	x0, .LC283
+	add	x0, x0, :lo12:.LC283
 	bl	printk
-	adrp	x0, .LC277
-	add	x0, x0, :lo12:.LC277
+	adrp	x0, .LC284
+	add	x0, x0, :lo12:.LC284
 	bl	printk
-.L3210:
+.L3252:
 	bl	rknand_device_unlock
 	mov	x0, x21
-.L3205:
+.L3247:
 	sub	sp, x29, #32
 	ldp	x19, x20, [sp,48]
 	ldp	x21, x22, [sp,64]
@@ -20656,118 +20953,118 @@ gc_check_data_one_wl:
 	ldr	x0, [x20,2904]
 	ldr	x23, [x20,608]
 	add	x20, x20, 2896
-	cbnz	x0, .L3230
+	cbnz	x0, .L3272
 	mov	w0, 1
 	bl	buf_alloc
 	str	x0, [x20,8]
-.L3230:
+.L3272:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldr	x20, [x0,2904]
-	cbnz	x20, .L3231
+	cbnz	x20, .L3273
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 447
+	mov	w2, 494
 	add	x1, x1, 744
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L3231:
+.L3273:
 	mov	w24, 0
 	add	x25, x23, 80
 	add	x21, x19, :lo12:.LANCHOR0
 	adrp	x27, .LANCHOR4
-.L3232:
+.L3274:
 	ldrb	w0, [x25,9]
 	cmp	w24, w0
-	bge	.L3255
+	bge	.L3297
 	mov	w22, 1
 	sxtw	x28, w24
-.L3241:
+.L3283:
 	add	x0, x21, 2896
 	ldrh	w1, [x0,20]
 	cmp	w22, w1
-	bgt	.L3256
+	bgt	.L3298
 	add	x1, x28, 8
-	ldrh	w2, [x21,3348]
+	ldrh	w2, [x21,3362]
 	ldrh	w0, [x0,16]
 	ldrh	w1, [x25,x1,lsl 1]
 	mul	w1, w1, w2
-	ldrb	w2, [x21,3257]
+	ldrb	w2, [x21,3281]
 	cmp	w2, 3
-	bne	.L3233
+	bne	.L3275
 	add	w1, w1, w0
 	orr	w1, w1, w22, lsl 24
-	b	.L3254
-.L3233:
+	b	.L3296
+.L3275:
 	cmp	w2, 2
-	bne	.L3235
+	bne	.L3277
 	sub	w0, w0, #1
 	add	w1, w0, w1
 	add	w1, w1, w22
 	orr	w1, w1, 33554432
-	b	.L3254
-.L3235:
+	b	.L3296
+.L3277:
 	add	w1, w1, w0
-.L3254:
+.L3296:
 	str	w1, [x20,40]
 	mov	x0, x20
 	mov	w1, 1
 	bl	sblk_read_page
 	ldr	w0, [x20,52]
 	cmn	w0, #1
-	beq	.L3236
+	beq	.L3278
 	add	x2, x27, :lo12:.LANCHOR4
 	ldrh	w0, [x21,2918]
 	ldr	x1, [x20,24]
 	lsl	x0, x0, 2
-	ldr	x3, [x2,1128]
+	ldr	x3, [x2,1152]
 	ldr	w4, [x3,x0]
 	ldr	w3, [x1,4]
 	cmp	w4, w3
-	bne	.L3236
-	ldr	x2, [x2,1136]
+	bne	.L3278
+	ldr	x2, [x2,1160]
 	ldr	w2, [x2,x0]
 	ldr	w0, [x1,8]
 	cmp	w2, w0
-	beq	.L3237
-.L3236:
+	beq	.L3279
+.L3278:
 	add	x26, x27, :lo12:.LANCHOR4
 	ldrh	w0, [x21,2918]
 	add	x4, x21, 2896
-	ldr	x1, [x26,1128]
+	ldr	x1, [x26,1152]
 	ldr	w0, [x1,x0,lsl 2]
 	cmn	w0, #1
-	beq	.L3237
+	beq	.L3279
 	ldrb	w5, [x25,9]
-	adrp	x0, .LC278
-	ldrh	w3, [x21,3274]
-	add	x0, x0, :lo12:.LC278
+	adrp	x0, .LC285
+	ldrh	w3, [x21,3298]
+	add	x0, x0, :lo12:.LC285
 	mov	w2, 4
 	str	x4, [x29,104]
 	mul	w3, w5, w3
 	bl	rknand_print_hex
 	ldrb	w5, [x25,9]
-	adrp	x0, .LC279
-	ldrh	w3, [x21,3274]
-	add	x0, x0, :lo12:.LC279
-	ldr	x1, [x26,1136]
+	adrp	x0, .LC286
+	ldrh	w3, [x21,3298]
+	add	x0, x0, :lo12:.LC286
+	ldr	x1, [x26,1160]
 	mov	w2, 4
 	mul	w3, w5, w3
 	bl	rknand_print_hex
 	adrp	x0, .LANCHOR2
 	ldr	x4, [x29,104]
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 10, .L3238
+	tbz	x0, 10, .L3280
 	ldr	x7, [x20,24]
 	ldrh	w4, [x4,22]
-	ldr	x5, [x26,1136]
+	ldr	x5, [x26,1160]
 	ldr	w0, [x7,12]
 	lsl	x4, x4, 2
-	ldr	x3, [x26,1128]
+	ldr	x3, [x26,1152]
 	str	w0, [sp]
-	adrp	x0, .LC280
-	add	x0, x0, :lo12:.LC280
+	adrp	x0, .LC287
+	add	x0, x0, :lo12:.LC287
 	ldr	w3, [x3,x4]
 	ldr	w6, [x7,4]
 	ldr	w4, [x5,x4]
@@ -20776,7 +21073,7 @@ gc_check_data_one_wl:
 	ldr	w2, [x20,52]
 	ldr	w7, [x7,8]
 	bl	printk
-.L3238:
+.L3280:
 	add	x19, x19, :lo12:.LANCHOR0
 	mov	x1, 0
 	ldr	x0, [x19,608]
@@ -20786,27 +21083,27 @@ gc_check_data_one_wl:
 	ldrh	w1, [x23,80]
 	strh	wzr, [x0,x1,lsl 1]
 	mov	w0, -1
-	b	.L3239
-.L3237:
+	b	.L3281
+.L3279:
 	ldrh	w0, [x21,2918]
 	add	w22, w22, 1
 	add	w0, w0, 1
 	strh	w0, [x21,2918]
-	b	.L3241
-.L3256:
+	b	.L3283
+.L3298:
 	add	w24, w24, 1
-	b	.L3232
-.L3255:
+	b	.L3274
+.L3297:
 	add	x19, x19, :lo12:.LANCHOR0
 	ldrh	w1, [x19,2912]
-	ldrb	w3, [x19,3258]
+	ldrb	w3, [x19,3282]
 	add	w0, w1, 1
 	strh	w0, [x19,2912]
 	mov	w0, 0
-	cbz	w3, .L3239
+	cbz	w3, .L3281
 	add	w1, w1, 2
 	strh	w1, [x19,2912]
-.L3239:
+.L3281:
 	sub	sp, x29, #16
 	ldp	x19, x20, [sp,32]
 	ldp	x21, x22, [sp,48]
@@ -20832,41 +21129,41 @@ ftl_update_l2p_map:
 	stp	x25, x26, [sp,64]
 	stp	x27, x28, [sp,80]
 	ldrb	w1, [x23,9]
-	ldrh	w24, [x0,3300]
+	ldrh	w24, [x0,3324]
 	ldrh	w20, [x23,12]
-	ldr	x0, [x0,3864]
+	ldr	x0, [x0,3880]
 	mul	w24, w24, w1
 	add	x20, x0, x20, lsl 2
 	add	x0, x20, x24, sxtw 2
 	ldr	w0, [x0,-4]
 	cmn	w0, #1
-	beq	.L3258
+	beq	.L3300
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 1627
+	mov	w2, 1640
 	add	x1, x1, 768
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L3258:
-	adrp	x0, .LC282
+.L3300:
+	adrp	x0, .LC289
 	mov	x28, 0
-	add	x0, x0, :lo12:.LC282
-	adrp	x27, .LC281
+	add	x0, x0, :lo12:.LC289
+	adrp	x27, .LC288
 	str	x0, [x29,120]
-	adrp	x0, .LC283
-	add	x0, x0, :lo12:.LC283
+	adrp	x0, .LC290
+	add	x0, x0, :lo12:.LC290
 	mov	w22, w28
 	str	x0, [x29,112]
-	add	x27, x27, :lo12:.LC281
-.L3259:
+	add	x27, x27, :lo12:.LC288
+.L3301:
 	cmp	w28, w24
 	mov	w25, w28
-	bge	.L3286
+	bge	.L3328
 	ldr	w2, [x20,x28,lsl 2]
 	cmn	w2, #1
-	beq	.L3260
+	beq	.L3302
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrb	w21, [x0,2832]
 	adrp	x0, .LANCHOR2
@@ -20874,24 +21171,24 @@ ftl_update_l2p_map:
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
 	udiv	w21, w2, w21
 	and	w21, w21, 65535
-	tbz	x0, 12, .L3264
+	tbz	x0, 12, .L3306
 	mov	x0, x27
 	mov	w1, w21
 	mov	w3, w28
 	bl	printk
-.L3264:
+.L3306:
 	sbfiz	x26, x25, 2, 32
 	ldr	w0, [x20,x26]
 	cmn	w0, #1
-	beq	.L3262
+	beq	.L3304
 	add	x3, x19, :lo12:.LANCHOR0
 	ldrb	w1, [x3,2832]
 	lsl	w1, w1, 7
 	udiv	w0, w0, w1
 	cmp	w21, w0, uxth
-	bne	.L3262
+	bne	.L3304
 	ldrb	w0, [x23,9]
-	ldrh	w2, [x3,3348]
+	ldrh	w2, [x3,3362]
 	str	x3, [x29,104]
 	sdiv	w1, w25, w0
 	msub	w0, w1, w0, w25
@@ -20903,13 +21200,13 @@ ftl_update_l2p_map:
 	ldr	w1, [x20,x26]
 	bl	pm_ppa_update_check
 	ldr	x3, [x29,104]
-	cbz	w0, .L3263
-	ldr	x1, [x3,3864]
+	cbz	w0, .L3305
+	ldr	x1, [x3,3880]
 	mov	w2, 4
 	ldr	x0, [x29,112]
 	mov	w3, w24
 	bl	rknand_print_hex
-.L3263:
+.L3305:
 	ldr	w0, [x20,x26]
 	add	x1, x29, 140
 	mov	w2, 1
@@ -20918,27 +21215,27 @@ ftl_update_l2p_map:
 	uxth	w22, w22
 	mov	w0, -1
 	str	w0, [x20,x26]
-.L3262:
+.L3304:
 	add	w25, w25, 1
 	cmp	w25, w24
-	bne	.L3264
-.L3260:
+	bne	.L3306
+.L3302:
 	add	x28, x28, 1
-	b	.L3259
-.L3286:
+	b	.L3301
+.L3328:
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L3266
+	tbz	x0, 12, .L3308
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrh	w1, [x23]
 	mov	w2, w22
 	ubfiz	x3, x1, 1, 16
 	ldr	x4, [x0,600]
-	adrp	x0, .LC284
-	add	x0, x0, :lo12:.LC284
+	adrp	x0, .LC291
+	add	x0, x0, :lo12:.LC291
 	ldrh	w3, [x4,x3]
 	bl	printk
-.L3266:
+.L3308:
 	add	x19, x19, :lo12:.LANCHOR0
 	ldrh	w1, [x23]
 	ldr	x0, [x19,600]
@@ -20955,34 +21252,57 @@ ftl_update_l2p_map:
 	.global	ftl_alloc_new_data_sblk
 	.type	ftl_alloc_new_data_sblk, %function
 ftl_alloc_new_data_sblk:
-	stp	x29, x30, [sp, -32]!
+	stp	x29, x30, [sp, -48]!
 	add	x29, sp, 0
-	str	x19, [sp,16]
-	mov	x19, x0
+	stp	x19, x20, [sp,16]
+	str	x21, [sp,32]
+	mov	x20, x0
+	ldrh	w21, [x0]
 	bl	ftl_update_l2p_map
 	bl	pm_flush
-	ldrh	w0, [x19]
+	ldrh	w0, [x20]
 	mov	w1, 65535
 	cmp	w0, w1
-	beq	.L3288
+	beq	.L3330
 	bl	zftl_insert_data_list
-.L3288:
-	adrp	x0, .LANCHOR0+608
+.L3330:
+	adrp	x19, .LANCHOR0
 	mov	w2, 2
+	add	x19, x19, :lo12:.LANCHOR0
 	mov	w1, 3
-	ldr	x0, [x0,#:lo12:.LANCHOR0+608]
+	ldr	x0, [x19,608]
 	add	x0, x0, 16
-	cmp	x19, x0
-	mov	x0, x19
+	cmp	x20, x0
+	mov	x0, x20
 	csel	w1, w2, w1, eq
 	bl	ftl_open_sblk_init
+	ldr	x0, [x19,608]
+	ldr	w0, [x0,560]
+	cmp	w0, w21
+	bne	.L3332
+	mov	w20, 65535
+	cmp	w21, w20
+	beq	.L3332
+	adrp	x0, .LC292
+	mov	w1, w21
+	add	x0, x0, :lo12:.LC292
+	bl	printk
+	ldr	x0, [x19,608]
+	ldr	w0, [x0,564]
+	bl	gc_mark_bad_ppa
+	ldr	x0, [x19,608]
+	mov	w1, -1
+	str	w20, [x0,560]
+	str	w1, [x0,564]
+.L3332:
 	bl	ftl_ext_info_flush
 	mov	w0, 0
 	bl	ftl_info_flush
 	bl	lpa_rebuild_hash
-	ldr	x19, [sp,16]
+	ldr	x21, [sp,32]
 	mov	w0, 0
-	ldp	x29, x30, [sp], 32
+	ldp	x19, x20, [sp,16]
+	ldp	x29, x30, [sp], 48
 	ret
 	.size	ftl_alloc_new_data_sblk, .-ftl_alloc_new_data_sblk
 	.align	2
@@ -21000,15 +21320,15 @@ ftl_write_commit:
 	add	x0, x0, :lo12:.LANCHOR4
 	str	x0, [x29,120]
 	stp	x19, x20, [sp,16]
-	add	x0, x0, 1241
+	add	x0, x0, 1265
 	str	x0, [x29,104]
 	stp	x21, x22, [sp,32]
 	stp	x25, x26, [sp,64]
 	stp	x27, x28, [sp,80]
-.L3292:
+.L3341:
 	ldrb	w0, [x24,2856]
 	adrp	x21, .LANCHOR0
-	cbz	w0, .L3294
+	cbz	w0, .L3343
 	ldrb	w1, [x24,2888]
 	sub	w0, w0, #1
 	ldr	x2, [x29,112]
@@ -21021,16 +21341,16 @@ ftl_write_commit:
 	strb	w1, [x24,2888]
 	ldr	w1, [x27,36]
 	cmp	w1, w0
-	bcc	.L3295
+	bcc	.L3344
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 501
+	mov	w2, 502
 	add	x1, x1, 792
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L3295:
+.L3344:
 	ldr	x0, [x29,128]
 	add	x1, x21, :lo12:.LANCHOR0
 	add	x4, x1, 784
@@ -21038,32 +21358,32 @@ ftl_write_commit:
 	ldr	w2, [x1,2840]
 	ldr	w23, [x0,36]
 	cmp	w23, w2
-	bcc	.L3296
+	bcc	.L3345
 	mov	x0, x27
-	bl	buf_free
+	bl	zbuf_free
 	mov	w0, -1
-	b	.L3350
-.L3296:
+	b	.L3399
+.L3345:
 	ldr	x25, [x0,8]
 	ldr	x28, [x0,24]
 	ldrb	w22, [x0,57]
 	ldrb	w20, [x0,56]
 	ldrb	w0, [x1,2857]
-	cbz	w0, .L3298
+	cbz	w0, .L3347
 	ldr	x0, [x29,120]
-	ldrb	w3, [x0,1241]
+	ldrb	w3, [x0,1265]
 	add	x3, x4, x3, lsl 6
-.L3299:
+.L3348:
 	ldrb	w5, [x3]
 	cmp	w5, 255
-	beq	.L3352
+	beq	.L3401
 	sbfiz	x3, x5, 6, 32
 	add	x3, x4, x3
-	b	.L3299
-.L3352:
+	b	.L3348
+.L3401:
 	ldr	w0, [x3,36]
 	cmp	w0, w23
-	bne	.L3298
+	bne	.L3347
 	ldr	x0, [x3,8]
 	ubfiz	x1, x22, 9, 8
 	lsl	w2, w20, 9
@@ -21071,30 +21391,30 @@ ftl_write_commit:
 	add	x1, x25, x1
 	bl	ftl_memcpy
 	mov	x0, x27
-	bl	buf_free
-	b	.L3292
-.L3298:
+	bl	zbuf_free
+	b	.L3341
+.L3347:
 	mov	w0, w23
 	bl	lpa_hash_get_ppa
 	str	w0, [x29,156]
 	cmn	w0, #1
-	bne	.L3302
+	bne	.L3351
 	mov	w0, w23
 	add	x1, x29, 156
 	mov	w2, 0
 	bl	pm_log2phys
-.L3302:
+.L3351:
 	add	x4, x21, :lo12:.LANCHOR0
 	mov	w3, 0
 	add	x4, x4, 784
 	ldr	x19, [x4,-176]
 	add	x19, x19, 16
-.L3305:
+.L3354:
 	ldr	w0, [x4,36]
 	cmp	w0, w23
-	bne	.L3303
+	bne	.L3352
 	ldrb	w5, [x4,2]
-	tbz	x5, 3, .L3303
+	tbz	x5, 3, .L3352
 	add	x0, x21, :lo12:.LANCHOR0
 	ubfiz	x3, x3, 6, 32
 	add	x0, x0, 784
@@ -21104,22 +21424,22 @@ ftl_write_commit:
 	strb	w5, [x3,2]
 	ldr	x26, [x3,8]
 	str	w0, [x29,156]
-	b	.L3304
-.L3303:
+	b	.L3353
+.L3352:
 	add	w3, w3, 1
 	add	x4, x4, 64
 	cmp	w3, 32
-	bne	.L3305
+	bne	.L3354
 	mov	x26, 0
-.L3304:
+.L3353:
 	add	x3, x21, :lo12:.LANCHOR0
 	str	wzr, [x29,136]
 	ldrb	w0, [x3,2832]
 	cmp	w20, w0
-	bcs	.L3306
+	bcs	.L3355
 	add	w20, w22, w20
-	cbz	x26, .L3307
-	cbz	w22, .L3308
+	cbz	x26, .L3356
+	cbz	w22, .L3357
 	mov	x0, x25
 	mov	x1, x26
 	lsl	w2, w22, 9
@@ -21128,28 +21448,28 @@ ftl_write_commit:
 	ldr	x3, [x29,136]
 	ldr	x19, [x3,608]
 	add	x19, x19, 48
-.L3308:
+.L3357:
 	add	x0, x21, :lo12:.LANCHOR0
 	ldrb	w2, [x0,2832]
 	cmp	w20, w2
-	bcc	.L3309
+	bcc	.L3358
 	ldr	x19, [x0,608]
 	add	x19, x19, 16
-	b	.L3351
-.L3309:
+	b	.L3400
+.L3358:
 	ubfiz	x1, x20, 9, 9
 	sub	w2, w2, w20
 	add	x0, x25, x1
 	lsl	w2, w2, 9
 	add	x1, x26, x1
 	bl	ftl_memcpy
-.L3351:
+.L3400:
 	str	wzr, [x29,136]
-	b	.L3306
-.L3307:
+	b	.L3355
+.L3356:
 	ldr	w0, [x29,156]
 	cmn	w0, #1
-	beq	.L3310
+	beq	.L3359
 	mov	w0, 1
 	bl	buf_alloc
 	mov	x26, x0
@@ -21164,11 +21484,11 @@ ftl_write_commit:
 	add	w1, w1, 1
 	str	w1, [x29,136]
 	cmp	w0, w23
-	bne	.L3311
+	bne	.L3360
 	ldr	w0, [x26,52]
 	cmn	w0, #1
-	bne	.L3312
-.L3311:
+	bne	.L3361
+.L3360:
 	add	x0, x21, :lo12:.LANCHOR0
 	ldr	w2, [x29,156]
 	mov	w3, w23
@@ -21176,99 +21496,99 @@ ftl_write_commit:
 	ldr	w0, [x1,552]
 	add	w0, w0, 1
 	str	w0, [x1,552]
-	adrp	x0, .LC285
+	adrp	x0, .LC293
 	ldrb	w1, [x26,1]
-	add	x0, x0, :lo12:.LC285
+	add	x0, x0, :lo12:.LC293
 	ldr	w4, [x26,52]
 	bl	printk
-	adrp	x0, .LC217
+	adrp	x0, .LC224
 	mov	w2, 4
 	ldr	x1, [x26,24]
-	add	x0, x0, :lo12:.LC217
+	add	x0, x0, :lo12:.LC224
 	mov	w3, w2
 	bl	rknand_print_hex
-.L3312:
+.L3361:
 	ldr	x0, [x26,24]
 	ldr	w0, [x0,4]
 	cmp	w0, w23
-	bne	.L3313
+	bne	.L3362
 	ldr	w0, [x26,52]
 	cmn	w0, #1
-	bne	.L3314
-.L3313:
+	bne	.L3363
+.L3362:
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 572
+	mov	w2, 573
 	add	x1, x1, 792
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L3314:
-	cbz	w22, .L3315
+.L3363:
+	cbz	w22, .L3364
 	ldr	w0, [x29,156]
 	lsl	w2, w22, 9
 	cmn	w0, #1
-	beq	.L3316
+	beq	.L3365
 	ldr	x1, [x26,8]
 	mov	x0, x25
 	bl	ftl_memcpy
-	b	.L3317
-.L3310:
-	cbz	w22, .L3315
+	b	.L3366
+.L3359:
+	cbz	w22, .L3364
 	lsl	w2, w22, 9
-.L3316:
+.L3365:
 	mov	x0, x25
 	mov	w1, 0
 	bl	ftl_memset
-.L3317:
+.L3366:
 	add	x0, x21, :lo12:.LANCHOR0
 	ldr	x19, [x0,608]
 	add	x19, x19, 48
-.L3315:
+.L3364:
 	add	x0, x21, :lo12:.LANCHOR0
 	ldrb	w2, [x0,2832]
 	cmp	w20, w2
-	bcc	.L3318
-	bls	.L3319
+	bcc	.L3367
+	bls	.L3368
 	ldr	x19, [x0,608]
 	add	x19, x19, 16
-	b	.L3319
-.L3318:
+	b	.L3368
+.L3367:
 	ldr	w0, [x29,156]
 	sub	w2, w2, w20
 	lsl	w2, w2, 9
 	cmn	w0, #1
 	ubfiz	x0, x20, 7, 9
-	beq	.L3320
+	beq	.L3369
 	ldr	x1, [x26,8]
 	lsl	x20, x0, 2
 	add	x0, x25, x20
 	add	x1, x1, x20
 	bl	ftl_memcpy
-	b	.L3319
-.L3320:
+	b	.L3368
+.L3369:
 	add	x0, x25, x0, lsl 2
 	mov	w1, 0
 	bl	ftl_memset
-.L3319:
-	cbz	x26, .L3306
+.L3368:
+	cbz	x26, .L3355
 	ldrb	w0, [x26,2]
 	mov	x1, x26
 	and	w0, w0, -9
 	strb	w0, [x26,2]
 	add	x0, x21, :lo12:.LANCHOR0
-	add	x0, x0, 3887
+	add	x0, x0, 3909
 	bl	buf_remove_buf
 	mov	x0, x26
-	bl	buf_free
-.L3306:
+	bl	zbuf_free
+.L3355:
 	ldrh	w0, [x19,6]
-	cbnz	w0, .L3321
+	cbnz	w0, .L3370
 	bl	ftl_flush
 	mov	x0, x19
 	bl	ftl_alloc_new_data_sblk
-.L3321:
+.L3370:
 	mov	x0, x19
 	add	x20, x21, :lo12:.LANCHOR0
 	bl	ftl_get_new_free_page
@@ -21305,14 +21625,14 @@ ftl_write_commit:
 	bl	timer_get_time
 	ldr	x1, [x29,120]
 	ldrb	w2, [x20,2857]
-	str	w0, [x1,1244]
+	str	w0, [x1,1268]
 	cmp	w2, 2
 	adrp	x0, .LANCHOR4
-	bhi	.L3322
+	bhi	.L3371
 	ldrh	w1, [x19,6]
 	cmp	w1, 1
-	bne	.L3294
-.L3322:
+	bne	.L3343
+.L3371:
 	ldrb	w1, [x19,5]
 	mov	w4, 2
 	add	x6, x21, :lo12:.LANCHOR0
@@ -21323,22 +21643,22 @@ ftl_write_commit:
 	cmp	w1, 1
 	add	x1, x0, :lo12:.LANCHOR4
 	csel	w4, w4, w2, ne
-	ldrb	w5, [x1,1241]
+	ldrb	w5, [x1,1265]
 	mov	w1, 0
 	mov	w3, w5
-.L3326:
+.L3375:
 	cmp	w1, w4
-	beq	.L3353
+	beq	.L3402
 	ubfiz	x3, x3, 6, 8
 	add	w1, w1, 1
 	ldrb	w3, [x6,x3]
-	b	.L3326
-.L3353:
+	b	.L3375
+.L3402:
 	add	x0, x0, :lo12:.LANCHOR4
 	uxtb	w1, w1
 	sub	w2, w2, w1
 	ubfiz	x5, x5, 6, 8
-	strb	w3, [x0,1241]
+	strb	w3, [x0,1265]
 	add	x0, x21, :lo12:.LANCHOR0
 	add	x0, x0, 784
 	strb	w2, [x0,2073]
@@ -21346,20 +21666,20 @@ ftl_write_commit:
 	bl	sblk_prog_page
 	ldrh	w0, [x19,6]
 	cmp	w0, 1
-	bne	.L3294
+	bne	.L3343
 	bl	sblk_wait_write_queue_completed
 	bl	ftl_write_completed
 	mov	x0, x19
 	bl	ftl_write_last_log_page
 	mov	x0, x19
 	bl	ftl_alloc_new_data_sblk
-.L3294:
+.L3343:
 	add	x21, x21, :lo12:.LANCHOR0
 	ldrb	w19, [x21,2856]
-	cbnz	w19, .L3292
+	cbnz	w19, .L3341
 	bl	ftl_write_completed
 	mov	w0, w19
-.L3350:
+.L3399:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -21382,12 +21702,12 @@ gc_do_copy_back:
 	stp	x23, x24, [sp,64]
 	stp	x25, x26, [sp,80]
 	stp	x27, x28, [sp,96]
-	ldrb	w0, [x21,3273]
+	ldrb	w0, [x21,3297]
 	ldr	x22, [x21,608]
-	cbnz	w0, .L3355
+	cbnz	w0, .L3404
 	bl	buf_alloc
 	mov	x20, x0
-	cbz	x0, .L3354
+	cbz	x0, .L3403
 	ldrh	w22, [x21,2922]
 	mov	w0, w22
 	add	w22, w22, 1
@@ -21400,60 +21720,60 @@ gc_do_copy_back:
 	bl	sblk_read_page
 	ldr	w0, [x20,52]
 	cmp	w0, 512
-	beq	.L3410
+	beq	.L3459
 	cmn	w0, #1
-	bne	.L3357
-.L3410:
+	bne	.L3406
+.L3459:
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 684
+	mov	w2, 731
 	add	x1, x1, 816
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L3357:
+.L3406:
 	ldr	x0, [x20,24]
 	ldr	w21, [x0,4]
 	mov	w0, w21
 	bl	lpa_hash_get_ppa
 	str	w0, [x29,144]
 	cmn	w0, #1
-	bne	.L3359
+	bne	.L3408
 	mov	w0, w21
 	add	x1, x29, 144
 	mov	w2, 0
 	bl	pm_log2phys
-.L3359:
+.L3408:
 	ldr	w22, [x29,144]
 	cmp	w22, w23
-	bne	.L3360
+	bne	.L3409
 	add	x1, x19, :lo12:.LANCHOR0
 	add	x0, x1, 784
 	add	x1, x1, 2832
-.L3363:
+.L3412:
 	ldr	w2, [x0,36]
 	cmp	w2, w21
-	bne	.L3361
+	bne	.L3410
 	ldrb	w2, [x0,2]
-	tbz	x2, 1, .L3361
+	tbz	x2, 1, .L3410
 	mov	x0, x20
-	bl	buf_free
+	bl	zbuf_free
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 8, .L3354
+	tbz	x0, 8, .L3403
 	add	x19, x19, :lo12:.LANCHOR0
-	adrp	x0, .LC286
+	adrp	x0, .LC294
 	mov	w1, w21
 	mov	w2, w22
-	add	x0, x0, :lo12:.LC286
+	add	x0, x0, :lo12:.LC294
 	ldrh	w3, [x19,2922]
 	bl	printk
-	b	.L3354
-.L3361:
+	b	.L3403
+.L3410:
 	add	x0, x0, 64
 	cmp	x0, x1
-	bne	.L3363
+	bne	.L3412
 	add	x23, x19, :lo12:.LANCHOR0
 	ldrb	w1, [x20,2]
 	str	w21, [x20,36]
@@ -21468,20 +21788,20 @@ gc_do_copy_back:
 	str	w0, [x20,32]
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 8, .L3364
+	tbz	x0, 8, .L3413
 	ldr	w2, [x29,144]
 	mov	w0, w21
 	str	x2, [x29,136]
 	bl	lpa_hash_get_ppa
 	mov	w3, w0
 	ldr	x2, [x29,136]
-	adrp	x0, .LC287
+	adrp	x0, .LC295
 	ldrh	w5, [x23,2922]
-	add	x0, x0, :lo12:.LC287
+	add	x0, x0, :lo12:.LC295
 	mov	w1, w21
 	mov	w4, w22
 	bl	printk
-.L3364:
+.L3413:
 	add	x19, x19, :lo12:.LANCHOR0
 	mov	x0, x20
 	bl	ftl_gc_write_buf
@@ -21493,34 +21813,34 @@ gc_do_copy_back:
 	ldrh	w0, [x19,2924]
 	add	w0, w0, 1
 	strh	w0, [x19,2924]
-	b	.L3354
-.L3360:
+	b	.L3403
+.L3409:
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 8, .L3366
+	tbz	x0, 8, .L3415
 	mov	w0, w21
 	add	x19, x19, :lo12:.LANCHOR0
 	bl	lpa_hash_get_ppa
 	mov	w3, w0
 	ldrh	w5, [x19,2922]
-	adrp	x0, .LC287
-	add	x0, x0, :lo12:.LC287
+	adrp	x0, .LC295
+	add	x0, x0, :lo12:.LC295
 	mov	w1, w21
 	mov	w2, w22
 	mov	w4, w23
 	bl	printk
-.L3366:
+.L3415:
 	mov	x0, x20
-	bl	buf_free
-	b	.L3354
-.L3355:
-	ldrb	w24, [x21,3257]
+	bl	zbuf_free
+	b	.L3403
+.L3404:
+	ldrb	w24, [x21,3281]
 	add	x0, x21, 2896
 	add	x22, x22, 80
 	cmp	w24, 3
-	bne	.L3367
-	ldrb	w1, [x21,3272]
-	cbz	w1, .L3368
+	bne	.L3416
+	ldrb	w1, [x21,3296]
+	cbz	w1, .L3417
 	ldrb	w20, [x22,9]
 	ldrh	w21, [x0,314]
 	str	w24, [x29,136]
@@ -21529,13 +21849,13 @@ gc_do_copy_back:
 	sdiv	w23, w21, w23
 	madd	w20, w23, w20, w21
 	uxth	w20, w20
-	b	.L3370
-.L3368:
+	b	.L3419
+.L3417:
 	ldrh	w20, [x0,314]
 	adrp	x0, .LANCHOR2
 	ldrb	w21, [x22,9]
 	add	x0, x0, :lo12:.LANCHOR2
-	add	x0, x0, 1784
+	add	x0, x0, 1816
 	str	w24, [x29,136]
 	sdiv	w1, w20, w21
 	msub	w20, w1, w21, w20
@@ -21547,48 +21867,48 @@ gc_do_copy_back:
 	cmp	w25, 1
 	add	w21, w21, w21, lsl 1
 	uxth	w21, w21
-	bne	.L3371
-	b	.L3370
-.L3367:
+	bne	.L3420
+	b	.L3419
+.L3416:
 	ldrb	w20, [x22,9]
-	ldrb	w1, [x21,3258]
+	ldrb	w1, [x21,3282]
 	ldrh	w21, [x0,314]
 	mov	w0, 1
 	sdiv	w23, w21, w20
 	msub	w20, w23, w20, w21
 	uxth	w20, w20
-	cbz	w1, .L3452
+	cbz	w1, .L3501
 	mov	w0, 2
-.L3452:
+.L3501:
 	str	w0, [x29,136]
-.L3370:
+.L3419:
 	mov	w25, 0
 	add	x24, x19, :lo12:.LANCHOR0
 	adrp	x3, .LANCHOR4
-.L3373:
+.L3422:
 	ldrb	w1, [x22,9]
 	ldr	w0, [x29,136]
 	mul	w0, w0, w1
 	cmp	w25, w0
-	bge	.L3407
-	ldrh	w0, [x24,3274]
+	bge	.L3456
+	ldrh	w0, [x24,3298]
 	add	w26, w21, w25
 	mul	w0, w0, w1
 	sub	w0, w0, #1
 	cmp	w26, w0
-	beq	.L3407
+	beq	.L3456
 	add	x0, x3, :lo12:.LANCHOR4
 	sbfiz	x26, x26, 2, 32
-	ldr	x1, [x0,1136]
+	ldr	x1, [x0,1160]
 	ldr	w0, [x1,x26]
 	cmn	w0, #1
-	bne	.L3374
+	bne	.L3423
 	ldrh	w27, [x24,2922]
 	ldrh	w0, [x24,2920]
 	str	x3, [x29,120]
 	str	x1, [x29,128]
 	cmp	w0, w27
-	bls	.L3354
+	bls	.L3403
 	mov	w0, w27
 	add	w27, w27, 1
 	bl	gc_get_src_ppa_from_index
@@ -21596,31 +21916,31 @@ gc_do_copy_back:
 	ldr	x1, [x29,128]
 	ldr	x3, [x29,120]
 	str	w0, [x1,x26]
-.L3374:
+.L3423:
 	add	w25, w25, 1
 	uxth	w25, w25
-	b	.L3373
-.L3407:
+	b	.L3422
+.L3456:
 	mov	w25, 1
-.L3371:
+.L3420:
 	adrp	x0, .LANCHOR2
 	str	x0, [x29,120]
 	ldr	w1, [x0,#:lo12:.LANCHOR2]
-	tbz	x1, 8, .L3376
-	adrp	x0, .LANCHOR4+1136
+	tbz	x1, 8, .L3425
+	adrp	x0, .LANCHOR4+1160
 	add	x4, x19, :lo12:.LANCHOR0
 	ubfiz	x5, x21, 2, 16
 	mov	w1, w23
 	mov	w2, w25
 	mov	w3, w20
-	ldr	x6, [x0,#:lo12:.LANCHOR4+1136]
-	adrp	x0, .LC288
+	ldr	x6, [x0,#:lo12:.LANCHOR4+1160]
+	adrp	x0, .LC296
 	ldrh	w4, [x4,3210]
-	add	x0, x0, :lo12:.LC288
+	add	x0, x0, :lo12:.LC296
 	ldr	w5, [x6,x5]
 	mov	w6, w21
 	bl	printk
-.L3376:
+.L3425:
 	adrp	x0, .LC0
 	mov	w27, 0
 	add	x0, x0, :lo12:.LC0
@@ -21629,25 +21949,25 @@ gc_do_copy_back:
 	add	x0, x0, :lo12:.LANCHOR3
 	add	x0, x0, 816
 	str	x0, [x29,104]
-.L3377:
+.L3426:
 	ldrb	w1, [x22,9]
 	ldr	w0, [x29,136]
 	mul	w0, w0, w1
 	cmp	w27, w0
-	bge	.L3456
+	bge	.L3505
 	add	w26, w21, w27
 	sxtw	x0, w26
 	str	x0, [x29,128]
 	add	x0, x19, :lo12:.LANCHOR0
 	ldr	x1, [x29,128]
-	ldr	x0, [x0,3264]
+	ldr	x0, [x0,3288]
 	ldrb	w0, [x0,x1]
 	cmp	w0, 255
-	bne	.L3378
+	bne	.L3427
 	mov	w0, 0
 	bl	buf_alloc
 	mov	x24, x0
-	cbnz	x0, .L3379
+	cbnz	x0, .L3428
 	bl	sblk_wait_write_queue_completed
 	bl	ftl_write_completed
 	bl	gc_write_completed
@@ -21655,12 +21975,12 @@ gc_do_copy_back:
 	mov	w0, w24
 	bl	buf_alloc
 	mov	x24, x0
-	cbz	x0, .L3354
-.L3379:
+	cbz	x0, .L3403
+.L3428:
 	add	x28, x19, :lo12:.LANCHOR0
 	ldr	x2, [x29,128]
 	ldrb	w1, [x24,1]
-	ldr	x0, [x28,3264]
+	ldr	x0, [x28,3288]
 	strb	w1, [x0,x2]
 	strh	w26, [x24,48]
 	ldrb	w0, [x28,2903]
@@ -21668,26 +21988,26 @@ gc_do_copy_back:
 	add	w0, w0, 1
 	strb	w0, [x28,2903]
 	ldrb	w1, [x22,9]
-	ldrh	w0, [x28,3274]
+	ldrh	w0, [x28,3298]
 	mul	w0, w0, w1
 	sub	w0, w0, #1
 	cmp	w26, w0
 	adrp	x26, .LANCHOR4
-	bne	.L3380
+	bne	.L3429
 	add	x26, x26, :lo12:.LANCHOR4
 	mov	w1, -1
-	ldr	x0, [x26,1128]
+	ldr	x0, [x26,1152]
 	str	w1, [x0,x2,lsl 2]
-	ldrh	w0, [x28,3274]
-	ldrb	w2, [x28,3276]
-	ldr	x1, [x26,1128]
+	ldrh	w0, [x28,3298]
+	ldrb	w2, [x28,3300]
+	ldr	x1, [x26,1152]
 	mul	w2, w0, w2
 	ldr	x0, [x24,8]
 	lsl	w2, w2, 2
 	bl	ftl_memcpy
-	ldrh	w0, [x28,3274]
-	ldrb	w2, [x28,3276]
-	ldr	x1, [x26,1136]
+	ldrh	w0, [x28,3298]
+	ldrb	w2, [x28,3300]
+	ldr	x1, [x26,1160]
 	mul	w2, w0, w2
 	ldr	x0, [x24,8]
 	add	x0, x0, x2, sxtw 2
@@ -21702,8 +22022,8 @@ gc_do_copy_back:
 	mov	w0, 15555
 	movk	w0, 0xf55f, lsl 16
 	str	w0, [x1]
-	ldrh	w0, [x28,3274]
-	ldrb	w1, [x28,3276]
+	ldrh	w0, [x28,3298]
+	ldrb	w1, [x28,3300]
 	ldr	x26, [x24,24]
 	mul	w1, w0, w1
 	ldr	x0, [x24,8]
@@ -21713,96 +22033,96 @@ gc_do_copy_back:
 	ldr	x1, [x28,608]
 	ldr	x0, [x24,24]
 	ldr	w1, [x1,132]
-	b	.L3453
-.L3380:
+	b	.L3502
+.L3429:
 	ldr	x0, [x29,128]
 	mov	w1, 1
 	lsl	x28, x0, 2
 	add	x0, x26, :lo12:.LANCHOR4
-	ldr	x0, [x0,1136]
+	ldr	x0, [x0,1160]
 	ldr	w0, [x0,x28]
 	str	w0, [x24,40]
 	mov	x0, x24
 	bl	sblk_read_page
 	ldr	w0, [x24,52]
 	cmp	w0, 512
-	beq	.L3381
+	beq	.L3430
 	cmn	w0, #1
-	bne	.L3382
-.L3381:
+	bne	.L3431
+.L3430:
 	add	x4, x19, :lo12:.LANCHOR0
 	mov	w2, 21
 	mov	w1, 1
-	ldrh	w0, [x4,3340]
+	ldrh	w0, [x4,3264]
 	sub	w2, w2, w0
 	lsl	w2, w1, w2
 	ldr	w1, [x24,40]
 	sub	w2, w2, #1
 	lsr	w0, w1, w0
-	ldrb	w1, [x4,3338]
+	ldrb	w1, [x4,3266]
 	and	w0, w2, w0
 	udiv	w0, w0, w1
 	mov	x1, 0
 	bl	ftl_sblk_dump
 	ldr	w0, [x24,52]
 	cmp	w0, 512
-	beq	.L3411
+	beq	.L3460
 	cmn	w0, #1
-	bne	.L3382
-.L3411:
+	bne	.L3431
+.L3460:
 	ldr	x0, [x24,24]
 	mov	w1, -1
 	str	w1, [x0,4]
-.L3382:
+.L3431:
 	ldr	w0, [x24,52]
 	cmp	w0, 512
-	beq	.L3412
+	beq	.L3461
 	cmn	w0, #1
-	bne	.L3385
-.L3412:
+	bne	.L3434
+.L3461:
 	ldr	x1, [x29,104]
-	mov	w2, 799
+	mov	w2, 846
 	ldr	x0, [x29,112]
 	bl	printk
 	bl	dump_stack
-.L3385:
+.L3434:
 	ldr	x1, [x24,24]
 	add	x0, x19, :lo12:.LANCHOR0
 	ldr	w2, [x1,4]
 	ldr	w0, [x0,2840]
 	cmp	w2, w0
-	bcc	.L3387
+	bcc	.L3436
 	mov	w0, -1
 	str	w0, [x1,4]
-.L3387:
+.L3436:
 	ldr	x0, [x24,24]
 	add	x26, x26, :lo12:.LANCHOR4
 	ldr	w1, [x0,4]
-	ldr	x0, [x26,1128]
+	ldr	x0, [x26,1152]
 	str	w1, [x0,x28]
 	ldr	x0, [x24,24]
 	ldr	w1, [x24,40]
-.L3453:
+.L3502:
 	str	w1, [x0,8]
-.L3378:
+.L3427:
 	add	x3, x19, :lo12:.LANCHOR0
 	ldr	x2, [x29,128]
 	add	x1, x3, 784
 	sxtw	x5, w27
-	ldr	x0, [x3,3264]
+	ldr	x0, [x3,3288]
 	ldrb	w4, [x0,x2]
 	add	x0, x29, 144
 	mov	w2, 2
 	add	x1, x1, x4, lsl 6
 	str	x1, [x0,w27,sxtw 3]
-	ldrb	w0, [x3,3257]
+	ldrb	w0, [x3,3281]
 	strh	w2, [x1,50]
 	cmp	w0, 3
 	strb	w25, [x1,61]
 	adrp	x2, .LANCHOR4
-	bne	.L3388
+	bne	.L3437
 	udiv	w0, w27, w0
-	ldrh	w3, [x3,3348]
+	ldrh	w3, [x3,3362]
 	add	x2, x2, :lo12:.LANCHOR4
 	add	w4, w0, w20
 	add	x4, x22, x4, sxtw 1
@@ -21813,54 +22133,54 @@ gc_do_copy_back:
 	orr	w3, w3, w23
 	sub	w0, w27, w0
 	str	w3, [x1,40]
-	ldr	x1, [x2,1144]
+	ldr	x1, [x2,1168]
 	uxth	w0, w0
 	add	w0, w0, 1
 	orr	w0, w3, w0, lsl 24
 	str	w0, [x1,x4,lsl 2]
-	b	.L3389
-.L3388:
+	b	.L3438
+.L3437:
 	cmp	w0, 2
-	bne	.L3390
-	ldrb	w6, [x3,3258]
+	bne	.L3439
+	ldrb	w6, [x3,3282]
 	add	x1, x1, 32
-	ldrh	w0, [x3,3348]
-	cbnz	w6, .L3391
+	ldrh	w0, [x3,3362]
+	cbnz	w6, .L3440
 	add	w3, w27, w20
 	add	x3, x22, x3, sxtw 1
 	ldrh	w3, [x3,16]
 	madd	w0, w3, w0, w23
-	b	.L3455
-.L3391:
+	b	.L3504
+.L3440:
 	add	w3, w20, w27, lsr 1
 	add	x3, x22, x3, sxtw 1
 	ldrh	w3, [x3,16]
 	madd	w0, w3, w0, w23
 	and	w3, w27, 1
 	add	w0, w0, w3
-.L3455:
+.L3504:
 	orr	w0, w0, 33554432
 	str	w0, [x1,8]
-.L3390:
+.L3439:
 	add	x0, x19, :lo12:.LANCHOR0
 	add	x2, x2, :lo12:.LANCHOR4
 	add	x0, x0, 784
 	add	x0, x0, x4, lsl 6
 	ldr	w3, [x0,40]
 	ldrh	w1, [x0,48]
-	ldr	x0, [x2,1144]
+	ldr	x0, [x2,1168]
 	str	w3, [x0,x1,lsl 2]
-.L3389:
+.L3438:
 	ldr	x0, [x29,120]
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 8, .L3392
+	tbz	x0, 8, .L3441
 	add	x0, x29, 144
 	ldr	x1, [x29,128]
 	mov	w2, w25
 	ldr	x5, [x0,x5,lsl 3]
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrb	w3, [x0,2902]
-	ldr	x0, [x0,3264]
+	ldr	x0, [x0,3288]
 	ldrh	w6, [x5,48]
 	ldrb	w7, [x5,1]
 	ldrb	w4, [x0,x1]
@@ -21872,64 +22192,64 @@ gc_do_copy_back:
 	ldr	x0, [x5,24]
 	ldr	w0, [x0,4]
 	str	w0, [sp,8]
-	adrp	x0, .LC289
-	add	x0, x0, :lo12:.LC289
+	adrp	x0, .LC297
+	add	x0, x0, :lo12:.LC297
 	ldr	w5, [x5,40]
 	bl	printk
-.L3392:
+.L3441:
 	add	w8, w27, 1
 	uxth	w27, w8
-	b	.L3377
-.L3456:
+	b	.L3426
+.L3505:
 	add	x3, x19, :lo12:.LANCHOR0
-	ldrb	w0, [x3,3257]
+	ldrb	w0, [x3,3281]
 	cmp	w0, 3
 	add	x0, x29, 144
-	bne	.L3394
-	ldrb	w1, [x3,3272]
-	cbz	w1, .L3395
-.L3398:
+	bne	.L3443
+	ldrb	w1, [x3,3296]
+	cbz	w1, .L3444
+.L3447:
 	ldr	x1, [x29,144]
 	strb	wzr, [x1,60]
-	b	.L3396
-.L3395:
+	b	.L3445
+.L3444:
 	cmp	w25, 1
 	mov	w2, 9
-	beq	.L3454
+	beq	.L3503
 	cmp	w25, 2
-	bne	.L3398
+	bne	.L3447
 	mov	w2, 13
-.L3454:
+.L3503:
 	ldr	x1, [x29,144]
 	strb	w2, [x1,60]
-.L3396:
+.L3445:
 	ldrb	w2, [x22,9]
 	add	x1, x0, 24
 	bl	sblk_xlc_prog_pages
-	b	.L3399
-.L3394:
-	ldrb	w2, [x3,3258]
-	cbz	w2, .L3438
-	ldrb	w3, [x3,3259]
+	b	.L3448
+.L3443:
+	ldrb	w2, [x3,3282]
+	cbz	w2, .L3487
+	ldrb	w3, [x3,3283]
 	mov	w2, 0
-	cbz	w3, .L3438
+	cbz	w3, .L3487
 	bl	sblk_3d_mlc_prog_pages
-	b	.L3399
-.L3438:
+	b	.L3448
+.L3487:
 	ldrb	w1, [x22,9]
 	ldr	w3, [x29,136]
 	mul	w1, w1, w3
 	sub	w1, w1, #1
 	cmp	w2, w1
-	bge	.L3457
+	bge	.L3506
 	ldr	x1, [x0,w2,sxtw 3]
 	add	w2, w2, 1
 	ldr	x3, [x0,w2,sxtw 3]
 	uxth	w2, w2
 	ldrb	w3, [x3,1]
 	strb	w3, [x1]
-	b	.L3438
-.L3457:
+	b	.L3487
+.L3506:
 	ldr	x0, [x0,w1,sxtw 3]
 	mov	w1, -1
 	strb	w1, [x0]
@@ -21937,20 +22257,20 @@ gc_do_copy_back:
 	ldr	x0, [x29,144]
 	mul	w1, w3, w1
 	bl	sblk_prog_page
-.L3399:
+.L3448:
 	add	x1, x19, :lo12:.LANCHOR0
 	ldrb	w2, [x22,9]
-	ldrb	w3, [x1,3272]
-	cbz	w3, .L3402
+	ldrb	w3, [x1,3296]
+	cbz	w3, .L3451
 	add	w0, w2, w2, lsl 1
-	and	w2, w0, 1023
-	b	.L3403
-.L3402:
-	ldrb	w1, [x1,3258]
+	and	w2, w0, 1023
+	b	.L3452
+.L3451:
+	ldrb	w1, [x1,3282]
 	ubfiz	w0, w2, 1, 8
 	cmp	w1, wzr
 	csel	w2, w0, w2, ne
-.L3403:
+.L3452:
 	add	x19, x19, :lo12:.LANCHOR0
 	ldr	x1, [x19,2864]
 	ldr	w0, [x1,52]
@@ -21958,18 +22278,18 @@ gc_do_copy_back:
 	str	w0, [x1,52]
 	ldrh	w1, [x19,3210]
 	add	w0, w2, w1
-	ldrh	w1, [x19,3274]
+	ldrh	w1, [x19,3298]
 	uxth	w0, w0
 	strh	w0, [x19,3210]
 	ldrb	w2, [x22,9]
 	mul	w1, w1, w2
 	cmp	w0, w1
-	blt	.L3404
+	blt	.L3453
 	ldr	x0, [x19,608]
 	strh	wzr, [x0,86]
-.L3404:
+.L3453:
 	bl	gc_write_completed
-.L3354:
+.L3403:
 	sub	sp, x29, #16
 	ldp	x19, x20, [sp,32]
 	ldp	x21, x22, [sp,48]
@@ -22002,63 +22322,63 @@ zftl_do_gc:
 	add	w20, w0, w20
 	ldrh	w21, [x1,2846]
 	uxth	w20, w20
-	bne	.L3459
+	bne	.L3508
 	adrp	x23, .LANCHOR7
 	add	x1, x23, :lo12:.LANCHOR7
 	ldr	w24, [x1,-64]
-	cbnz	w24, .L3460
+	cbnz	w24, .L3509
 	ldr	w1, [x1,-60]
-	cbz	w1, .L3459
-.L3460:
+	cbz	w1, .L3508
+.L3509:
 	add	x1, x19, :lo12:.LANCHOR0
-	ldrh	w2, [x1,3306]
+	ldrh	w2, [x1,3330]
 	cmp	w20, w2, lsr 2
-	bls	.L3459
+	bls	.L3508
 	ldrh	w1, [x1,2872]
 	cmp	w1, w20
-	bcs	.L3459
+	bcs	.L3508
 	add	w24, w24, 20
 	bl	timer_get_time
 	cmp	w24, w0
-	bcs	.L3461
+	bcs	.L3510
 	add	x0, x23, :lo12:.LANCHOR7
 	str	wzr, [x0,-64]
-.L3461:
+.L3510:
 	add	x19, x23, :lo12:.LANCHOR7
 	ldr	w20, [x19,-60]
 	bl	timer_get_time
 	add	w20, w20, 20
 	cmp	w20, w0
-	bcs	.L3648
+	bcs	.L3697
 	str	wzr, [x19,-60]
-	b	.L3648
-.L3459:
+	b	.L3697
+.L3508:
 	adrp	x23, .LANCHOR4
 	add	x1, x23, :lo12:.LANCHOR4
-	ldrb	w2, [x1,1122]
+	ldrb	w2, [x1,1146]
 	mov	w1, 16
 	cmp	w2, 6
-	bhi	.L3620
-	adrp	x1, .L3465
-	add	x1, x1, :lo12:.L3465
+	bhi	.L3669
+	adrp	x1, .L3514
+	add	x1, x1, :lo12:.L3514
 	ldrh	w1, [x1,w2,uxtw #1]
-	adr	x2, .Lrtx3465
+	adr	x2, .Lrtx3514
 	add	x1, x2, w1, sxth #2
 	br	x1
-.Lrtx3465:
+.Lrtx3514:
 	.section	.rodata
 	.align	0
 	.align	2
-.L3465:
-	.2byte	(.L3464 - .Lrtx3465) / 4
-	.2byte	(.L3466 - .Lrtx3465) / 4
-	.2byte	(.L3467 - .Lrtx3465) / 4
-	.2byte	(.L3468 - .Lrtx3465) / 4
-	.2byte	(.L3469 - .Lrtx3465) / 4
-	.2byte	(.L3576 - .Lrtx3465) / 4
-	.2byte	(.L3471 - .Lrtx3465) / 4
+.L3514:
+	.2byte	(.L3513 - .Lrtx3514) / 4
+	.2byte	(.L3515 - .Lrtx3514) / 4
+	.2byte	(.L3516 - .Lrtx3514) / 4
+	.2byte	(.L3517 - .Lrtx3514) / 4
+	.2byte	(.L3518 - .Lrtx3514) / 4
+	.2byte	(.L3625 - .Lrtx3514) / 4
+	.2byte	(.L3520 - .Lrtx3514) / 4
 	.text
-.L3464:
+.L3513:
 	add	w21, w21, w0
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrh	w2, [x22,80]
@@ -22069,167 +22389,167 @@ zftl_do_gc:
 	mov	w1, 65535
 	cmp	w2, w1
 	uxth	w25, w25
-	beq	.L3472
-	cbnz	w26, .L3473
+	beq	.L3521
+	cbnz	w26, .L3522
 	ldrh	w0, [x0,2872]
 	cmp	w20, w0, lsl 1
-	bge	.L3648
-.L3473:
+	bge	.L3697
+.L3522:
 	add	x24, x19, :lo12:.LANCHOR0
 	mov	w1, 5
-	ldrh	w0, [x24,3304]
+	ldrh	w0, [x24,3328]
 	add	w0, w0, 1
 	uxth	w0, w0
-	strh	w0, [x24,3304]
+	strh	w0, [x24,3328]
 	bl	zftl_get_gc_node
 	uxth	w2, w0
 	mov	w1, 65535
 	cmp	w2, w1
-	beq	.L3475
+	beq	.L3524
 	add	x3, x23, :lo12:.LANCHOR4
 	ubfiz	x2, x2, 1, 16
-	ldr	w1, [x3,1124]
+	ldr	w1, [x3,1148]
 	add	w1, w1, 1
-	str	w1, [x3,1124]
+	str	w1, [x3,1148]
 	ldr	x3, [x24,600]
 	ldrh	w2, [x3,x2]
-	ldrh	w3, [x24,3300]
+	ldrh	w3, [x24,3324]
 	cmp	w3, w2
-	bcs	.L3476
+	bcs	.L3525
 	ldrh	w3, [x24,576]
 	cmp	w1, w3, lsr 4
-	bls	.L3475
+	bls	.L3524
 	ldrh	w1, [x24,2874]
 	cmp	w1, w2
-	bls	.L3475
-.L3476:
+	bls	.L3524
+.L3525:
 	add	x2, x19, :lo12:.LANCHOR0
 	mov	w1, 0
-	ldrb	w2, [x2,3273]
+	ldrb	w2, [x2,3297]
 	bl	gc_add_sblk
-	cbz	w0, .L3477
+	cbz	w0, .L3526
 	add	x23, x23, :lo12:.LANCHOR4
 	mov	w0, 1
-	str	wzr, [x23,1124]
-	strb	w0, [x23,1122]
-	b	.L3648
-.L3475:
+	str	wzr, [x23,1148]
+	strb	w0, [x23,1146]
+	b	.L3697
+.L3524:
 	add	x0, x19, :lo12:.LANCHOR0
-	strh	wzr, [x0,3304]
-.L3477:
+	strh	wzr, [x0,3328]
+.L3526:
 	cmp	w21, 15
 	mov	w24, 2
-	bls	.L3478
-	cbz	w25, .L3578
+	bls	.L3527
+	cbz	w25, .L3627
 	add	x0, x19, :lo12:.LANCHOR0
 	mov	w24, 1
 	ldrh	w1, [x0,2854]
-	ldrh	w0, [x0,3308]
+	ldrh	w0, [x0,3332]
 	cmp	w1, w0
-	bls	.L3478
-.L3578:
+	bls	.L3527
+.L3627:
 	mov	w24, 2
-.L3478:
+.L3527:
 	adrp	x0, .LANCHOR2
 	ldr	w0, [x0,#:lo12:.LANCHOR2]
-	tbz	x0, 8, .L3479
+	tbz	x0, 8, .L3528
 	add	x1, x19, :lo12:.LANCHOR0
 	mov	w3, w20
 	mov	w4, w21
 	ldr	x0, [x1,608]
-	ldrb	w2, [x1,3273]
-	mov	w1, 1935
+	ldrb	w2, [x1,3297]
+	mov	w1, 1982
 	ldrh	w5, [x0,124]
 	ldrh	w6, [x0,120]
 	ldrh	w7, [x0,122]
 	ldrh	w0, [x22,80]
 	str	w0, [sp]
-	adrp	x0, .LC290
-	add	x0, x0, :lo12:.LC290
+	adrp	x0, .LC298
+	add	x0, x0, :lo12:.LC298
 	bl	printk
-.L3479:
+.L3528:
 	add	x19, x19, :lo12:.LANCHOR0
 	mov	w1, w24
 	mov	w2, 1
-	ldrb	w0, [x19,3273]
+	ldrb	w0, [x19,3297]
 	bl	gc_search_src_blk
 	cmp	w0, wzr
-	ble	.L3480
-.L3481:
+	ble	.L3529
+.L3530:
 	add	x23, x23, :lo12:.LANCHOR4
 	mov	w0, 1
-	b	.L3651
-.L3480:
-	ldrb	w0, [x19,3273]
+	b	.L3700
+.L3529:
+	ldrb	w0, [x19,3297]
 	mov	w1, 3
 	mov	w2, 1
 	bl	gc_search_src_blk
 	cmp	w0, wzr
-	bgt	.L3481
-	b	.L3648
-.L3472:
+	bgt	.L3530
+	b	.L3697
+.L3521:
 	adrp	x27, .LANCHOR2
 	ldr	w1, [x27,#:lo12:.LANCHOR2]
-	tbz	x1, 8, .L3482
-	ldrb	w2, [x0,3273]
-	adrp	x0, .LC290
+	tbz	x1, 8, .L3531
+	ldrb	w2, [x0,3297]
+	adrp	x0, .LC298
 	ldrh	w5, [x22,124]
-	add	x0, x0, :lo12:.LC290
+	add	x0, x0, :lo12:.LC298
 	ldrh	w6, [x22,120]
-	mov	w1, 1947
+	mov	w1, 1994
 	ldrh	w7, [x22,122]
 	mov	w3, w20
 	str	w26, [sp]
 	mov	w4, w21
 	bl	printk
-.L3482:
+.L3531:
 	cmp	w26, 1
-	bne	.L3483
+	bne	.L3532
 	add	x22, x19, :lo12:.LANCHOR0
 	bl	gc_scan_static_data
 	ldr	x0, [x22,608]
 	ldrh	w0, [x0,122]
-	cbz	w0, .L3484
-.L3485:
+	cbz	w0, .L3533
+.L3534:
 	add	x19, x19, :lo12:.LANCHOR0
 	mov	w0, 1
 	add	x23, x23, :lo12:.LANCHOR4
-	strb	w0, [x19,3273]
-	b	.L3651
-.L3484:
+	strb	w0, [x19,3297]
+	b	.L3700
+.L3533:
 	bl	gc_static_wearleveling
-	cbnz	w0, .L3485
+	cbnz	w0, .L3534
 	bl	gc_block_vpn_scan
-	cbz	w21, .L3579
+	cbz	w21, .L3628
 	cmp	w20, w25
-	bcs	.L3488
-	ldrh	w0, [x22,3306]
+	bcs	.L3537
+	ldrh	w0, [x22,3330]
 	cmp	w0, w20
-	bhi	.L3489
-.L3488:
+	bhi	.L3538
+.L3537:
 	add	x0, x19, :lo12:.LANCHOR0
 	add	w1, w20, w25
-	ldrh	w2, [x0,3306]
+	ldrh	w2, [x0,3330]
 	cmp	w1, w2
-	blt	.L3489
+	blt	.L3538
 	ldrh	w1, [x0,2854]
-	ldrh	w0, [x0,3308]
+	ldrh	w0, [x0,3332]
 	cmp	w1, w0
-	bcc	.L3579
-.L3489:
+	bcc	.L3628
+.L3538:
 	add	x22, x19, :lo12:.LANCHOR0
 	add	x28, x23, :lo12:.LANCHOR4
 	mov	w2, 1
-	ldr	w1, [x28,1124]
+	ldr	w1, [x28,1148]
 	ldrh	w0, [x22,576]
 	add	w1, w1, 1
-	strb	w2, [x22,3273]
-	str	w1, [x28,1124]
+	strb	w2, [x22,3297]
+	str	w1, [x28,1148]
 	cmp	w1, w0, lsr 5
-	bls	.L3491
+	bls	.L3540
 	ldrh	w0, [x22,2854]
 	cmp	w0, w21
-	bls	.L3491
+	bls	.L3540
 	mov	w1, 5
 	mov	w0, 0
 	str	x2, [x29,104]
@@ -22237,254 +22557,254 @@ zftl_do_gc:
 	uxth	w1, w0
 	mov	w0, 65535
 	cmp	w1, w0
-	beq	.L3579
+	beq	.L3628
 	ubfiz	x1, x1, 1, 16
 	ldr	x0, [x22,600]
-	ldrb	w3, [x22,3276]
+	ldrb	w3, [x22,3300]
 	mov	w24, 16
 	ldr	x2, [x29,104]
 	ldrh	w0, [x0,x1]
-	ldrh	w1, [x22,3300]
+	ldrh	w1, [x22,3324]
 	mul	w1, w1, w3
 	cmp	w0, w1
-	bgt	.L3487
-	str	wzr, [x28,1124]
+	bgt	.L3536
+	str	wzr, [x28,1148]
 	mov	w0, w2
 	mov	w1, 2
-	b	.L3641
-.L3491:
+	b	.L3690
+.L3540:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrh	w2, [x0,2854]
-	ldrh	w1, [x0,3308]
+	ldrh	w1, [x0,3332]
 	cmp	w2, w1
-	bcc	.L3494
+	bcc	.L3543
 	mov	w0, 1
 	mov	w1, 2
 	mov	w2, w0
-	b	.L3642
-.L3494:
+	b	.L3691
+.L3543:
 	ldrh	w24, [x0,2850]
-	cbnz	w24, .L3495
+	cbnz	w24, .L3544
 	ldrh	w0, [x0,2852]
 	cmp	w0, 8
-	bls	.L3487
-.L3495:
+	bls	.L3536
+.L3544:
 	mov	w0, 1
 	mov	w1, w0
-.L3641:
+.L3690:
 	mov	w2, 4
-.L3642:
+.L3691:
 	bl	gc_search_src_blk
 	uxth	w0, w0
-	cbnz	w0, .L3481
-	b	.L3579
-.L3483:
+	cbnz	w0, .L3530
+	b	.L3628
+.L3532:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrh	w0, [x0,2872]
 	cmp	w0, w20
-	bcc	.L3648
-.L3579:
+	bcc	.L3697
+.L3628:
 	mov	w24, 16
-.L3487:
+.L3536:
 	add	x22, x19, :lo12:.LANCHOR0
 	ldr	w0, [x22,2884]
-	cbz	w0, .L3496
+	cbz	w0, .L3545
 	mov	w0, 1
 	mov	w1, 5
-	strb	w0, [x22,3273]
+	strb	w0, [x22,3297]
 	mov	w0, 0
 	str	wzr, [x22,2884]
 	bl	zftl_get_gc_node
 	uxth	w1, w0
 	mov	w2, 65535
 	cmp	w1, w2
-	beq	.L3497
+	beq	.L3546
 	ubfiz	x1, x1, 1, 16
 	ldr	x2, [x22,600]
 	ldrh	w1, [x2,x1]
 	cmp	w1, 8
-	bhi	.L3497
+	bhi	.L3546
 	mov	w2, 1
 	mov	w1, 0
 	str	w2, [x22,2884]
 	bl	gc_add_sblk
-	cbnz	w0, .L3481
-.L3497:
+	cbnz	w0, .L3530
+.L3546:
 	mov	w1, 4
 	mov	w0, 0
 	bl	zftl_get_gc_node
 	uxth	w1, w0
 	mov	w2, 65535
 	cmp	w1, w2
-	beq	.L3498
+	beq	.L3547
 	add	x3, x19, :lo12:.LANCHOR0
 	ubfiz	x1, x1, 1, 16
 	ldr	x2, [x3,600]
 	ldrh	w1, [x2,x1]
 	cmp	w1, 4
-	bhi	.L3498
+	bhi	.L3547
 	mov	w2, 1
 	mov	w1, 0
 	str	w2, [x3,2884]
 	bl	gc_add_sblk
-	cbnz	w0, .L3481
-.L3498:
+	cbnz	w0, .L3530
+.L3547:
 	mov	w0, 0
 	bl	zftl_get_gc_node.part.12
 	uxth	w1, w0
 	mov	w2, 65535
 	cmp	w1, w2
-	beq	.L3496
+	beq	.L3545
 	add	x2, x19, :lo12:.LANCHOR0
 	ubfiz	x1, x1, 1, 16
 	ldr	x3, [x2,600]
 	ldrh	w1, [x3,x1]
 	cmp	w1, 4
-	bhi	.L3496
+	bhi	.L3545
 	mov	w1, 1
 	str	w1, [x2,2884]
 	mov	w2, 0
 	bl	gc_add_sblk
-	cbnz	w0, .L3481
-.L3496:
+	cbnz	w0, .L3530
+.L3545:
 	add	x22, x19, :lo12:.LANCHOR0
 	mov	w0, 1
 	ldr	x7, [x22,608]
-	strb	w0, [x22,3273]
+	strb	w0, [x22,3297]
 	ldrh	w5, [x7,124]
-	cbz	w5, .L3499
+	cbz	w5, .L3548
 	add	x23, x23, :lo12:.LANCHOR4
-	strb	wzr, [x22,3273]
-	strb	w0, [x23,1122]
+	strb	wzr, [x22,3297]
+	strb	w0, [x23,1146]
 	ldr	w0, [x27,#:lo12:.LANCHOR2]
-	tbz	x0, 8, .L3500
+	tbz	x0, 8, .L3549
 	ldrh	w6, [x7,120]
-	adrp	x0, .LC291
+	adrp	x0, .LC299
 	ldrh	w7, [x7,122]
-	mov	w1, 2037
+	mov	w1, 2084
 	mov	w2, 0
 	mov	w3, w20
 	mov	w4, w21
-	add	x0, x0, :lo12:.LC291
+	add	x0, x0, :lo12:.LC299
 	bl	printk
-	b	.L3500
-.L3499:
+	b	.L3549
+.L3548:
 	ldrh	w2, [x22,2872]
 	cmp	w20, w2
-	bcs	.L3501
-	cbz	w21, .L3502
+	bcs	.L3550
+	cbz	w21, .L3551
 	cmp	w21, 16
-	bls	.L3503
+	bls	.L3552
 	ldrh	w2, [x22,2854]
-	ldrh	w1, [x22,3308]
+	ldrh	w1, [x22,3332]
 	cmp	w2, w1
-	bhi	.L3503
+	bhi	.L3552
 	mov	w1, w0
 	mov	w2, 4
 	str	x5, [x29,104]
 	bl	gc_search_src_blk
 	uxth	w0, w0
 	ldr	x5, [x29,104]
-	cbnz	w0, .L3504
-	ldrb	w0, [x22,3273]
-	b	.L3650
-.L3504:
+	cbnz	w0, .L3553
+	ldrb	w0, [x22,3297]
+	b	.L3699
+.L3553:
 	mov	w1, 5
 	mov	w0, w5
 	bl	zftl_get_gc_node
 	uxth	w2, w0
 	mov	w1, 65535
 	cmp	w2, w1
-	beq	.L3573
+	beq	.L3622
 	add	x3, x23, :lo12:.LANCHOR4
 	ubfiz	x2, x2, 1, 16
-	ldr	w1, [x3,1124]
+	ldr	w1, [x3,1148]
 	add	w1, w1, 1
-	str	w1, [x3,1124]
+	str	w1, [x3,1148]
 	ldr	x3, [x22,600]
 	ldrh	w2, [x3,x2]
-	ldrh	w3, [x22,3300]
+	ldrh	w3, [x22,3324]
 	cmp	w3, w2
-	bcs	.L3507
+	bcs	.L3556
 	ldrh	w3, [x22,576]
 	cmp	w1, w3, lsr 4
-	bls	.L3573
+	bls	.L3622
 	ldrh	w1, [x22,2874]
 	cmp	w1, w2
-	bls	.L3573
-.L3507:
+	bls	.L3622
+.L3556:
 	add	x19, x19, :lo12:.LANCHOR0
 	mov	w1, 0
-	ldrb	w2, [x19,3273]
+	ldrb	w2, [x19,3297]
 	bl	gc_add_sblk
 	mov	w0, 1
 	str	w0, [x19,2884]
 	add	x0, x23, :lo12:.LANCHOR4
-	str	wzr, [x0,1124]
-	b	.L3573
-.L3503:
+	str	wzr, [x0,1148]
+	b	.L3622
+.L3552:
 	mov	w0, 1
 	mov	w1, 2
 	mov	w2, w0
 	bl	gc_search_src_blk
 	uxth	w0, w0
-	cbnz	w0, .L3573
+	cbnz	w0, .L3622
 	add	x19, x19, :lo12:.LANCHOR0
-.L3647:
-	ldrb	w0, [x19,3273]
+.L3696:
+	ldrb	w0, [x19,3297]
 	mov	w1, 3
 	mov	w2, 2
-.L3644:
+.L3693:
 	bl	gc_search_src_blk
 	uxth	w0, w0
-	b	.L3505
-.L3502:
+	b	.L3554
+.L3551:
 	ldr	w0, [x27,#:lo12:.LANCHOR2]
-	strb	w21, [x22,3273]
-	tbz	x0, 8, .L3509
-	adrp	x0, .LC291
+	strb	w21, [x22,3297]
+	tbz	x0, 8, .L3558
+	adrp	x0, .LC299
 	ldrh	w6, [x7,120]
 	ldrh	w7, [x7,122]
-	add	x0, x0, :lo12:.LC291
-	mov	w1, 2067
+	add	x0, x0, :lo12:.LC299
+	mov	w1, 2114
 	mov	w2, w21
 	mov	w3, w20
 	mov	w4, w21
 	mov	w5, w21
 	bl	printk
-.L3509:
+.L3558:
 	add	x19, x19, :lo12:.LANCHOR0
 	cmp	w20, 16
-	ldrb	w0, [x19,3273]
-	bls	.L3510
-.L3650:
+	ldrb	w0, [x19,3297]
+	bls	.L3559
+.L3699:
 	mov	w1, 3
 	mov	w2, 4
-	b	.L3644
-.L3510:
+	b	.L3693
+.L3559:
 	mov	w1, 1
 	mov	w2, w1
 	bl	gc_search_src_blk
 	uxth	w0, w0
-	cbnz	w0, .L3573
-	b	.L3647
-.L3501:
+	cbnz	w0, .L3622
+	b	.L3696
+.L3550:
 	cmp	w26, 1
 	mov	w1, w24
-	bne	.L3620
+	bne	.L3669
 	cmp	w20, w2, lsl 1
-	bge	.L3511
+	bge	.L3560
 	cmp	w25, w21, lsr 1
-	bcs	.L3512
+	bcs	.L3561
 	ldrh	w2, [x22,2854]
-	ldrh	w0, [x22,3308]
+	ldrh	w0, [x22,3332]
 	cmp	w2, w0
-	bcs	.L3512
-	ldrh	w0, [x22,3306]
+	bcs	.L3561
+	ldrh	w0, [x22,3330]
 	lsr	w0, w0, 2
 	strh	w0, [x22,2872]
-	b	.L3620
-.L3512:
+	b	.L3669
+.L3561:
 	mov	w1, 5
 	mov	w0, 0
 	bl	zftl_get_gc_node
@@ -22492,243 +22812,243 @@ zftl_do_gc:
 	mov	w1, 65535
 	mov	w27, w22
 	cmp	w22, w1
-	bne	.L3513
-.L3518:
+	bne	.L3562
+.L3567:
 	cmp	w21, 1
-	bhi	.L3514
-	b	.L3515
-.L3513:
+	bhi	.L3563
+	b	.L3564
+.L3562:
 	add	x26, x23, :lo12:.LANCHOR4
 	add	x2, x19, :lo12:.LANCHOR0
 	uxtw	x22, w22
-	ldr	w1, [x26,1124]
+	ldr	w1, [x26,1148]
 	ldrh	w3, [x2,576]
 	add	w1, w1, 1
-	str	w1, [x26,1124]
+	str	w1, [x26,1148]
 	cmp	w1, w3, lsr 4
-	bls	.L3516
+	bls	.L3565
 	ldr	x1, [x2,600]
-	str	wzr, [x26,1124]
+	str	wzr, [x26,1148]
 	ldrh	w3, [x1,x22,lsl 1]
 	ldrh	w1, [x2,2874]
 	cmp	w3, w1
-	bcs	.L3516
+	bcs	.L3565
 	mov	w1, 0
 	mov	w2, 1
 	bl	gc_add_sblk
-	cbz	w0, .L3516
+	cbz	w0, .L3565
 	mov	w0, 1
-	strb	w0, [x26,1122]
-	b	.L3500
-.L3516:
+	strb	w0, [x26,1146]
+	b	.L3549
+.L3565:
 	add	x1, x19, :lo12:.LANCHOR0
 	ldr	x0, [x1,600]
 	ldrh	w2, [x0,x22,lsl 1]
-	ldrh	w0, [x1,3300]
+	ldrh	w0, [x1,3324]
 	cmp	w2, w0, lsr 1
-	bhi	.L3517
+	bhi	.L3566
 	mov	w0, w27
 	mov	w1, 1
 	mov	w2, 0
 	bl	gc_add_sblk
-	b	.L3573
-.L3517:
+	b	.L3622
+.L3566:
 	ldrh	w3, [x1,2850]
 	ldrh	w0, [x1,2852]
 	add	w0, w3, w0
-	ldrh	w3, [x1,3306]
+	ldrh	w3, [x1,3330]
 	cmp	w0, w3, lsl 1
-	ble	.L3518
+	ble	.L3567
 	ldrh	w0, [x1,2874]
 	cmp	w0, w2
-	bcc	.L3515
-	b	.L3518
-.L3514:
+	bcc	.L3564
+	b	.L3567
+.L3563:
 	add	x22, x19, :lo12:.LANCHOR0
 	mov	w0, 1
 	cmp	w21, 16
-	strb	w0, [x22,3273]
-	bls	.L3519
+	strb	w0, [x22,3297]
+	bls	.L3568
 	ldrh	w2, [x22,2854]
-	ldrh	w1, [x22,3308]
+	ldrh	w1, [x22,3332]
 	cmp	w2, w1
-	bhi	.L3519
+	bhi	.L3568
 	mov	w1, w0
 	mov	w2, 4
 	bl	gc_search_src_blk
 	uxth	w0, w0
-	cbnz	w0, .L3520
-	ldrb	w0, [x22,3273]
+	cbnz	w0, .L3569
+	ldrb	w0, [x22,3297]
 	mov	w1, 3
 	mov	w2, 4
-	b	.L3643
-.L3519:
+	b	.L3692
+.L3568:
 	mov	w0, 1
 	mov	w1, 2
 	mov	w2, w0
 	bl	gc_search_src_blk
 	uxth	w0, w0
-	cbnz	w0, .L3520
+	cbnz	w0, .L3569
 	add	x0, x19, :lo12:.LANCHOR0
 	mov	w1, 3
 	mov	w2, 2
-	ldrb	w0, [x0,3273]
-.L3643:
+	ldrb	w0, [x0,3297]
+.L3692:
 	bl	gc_search_src_blk
 	uxth	w0, w0
-.L3520:
+.L3569:
 	add	x19, x19, :lo12:.LANCHOR0
 	cmp	w20, w25, lsr 1
-	ldrh	w1, [x19,3306]
-	bls	.L3645
+	ldrh	w1, [x19,3330]
+	bls	.L3694
 	lsr	w1, w1, 2
-	b	.L3646
-.L3515:
+	b	.L3695
+.L3564:
 	cmp	w20, w25
 	add	x19, x19, :lo12:.LANCHOR0
-	bcs	.L3522
+	bcs	.L3571
 	mov	w0, 4
-	strb	wzr, [x19,3273]
+	strb	wzr, [x19,3297]
 	bl	zftl_get_gc_node.part.12
 	uxth	w0, w0
 	mov	w1, 65535
 	cmp	w0, w1
-	beq	.L3522
+	beq	.L3571
 	ubfiz	x0, x0, 1, 16
 	ldr	x1, [x19,600]
-	ldrb	w2, [x19,3276]
+	ldrb	w2, [x19,3300]
 	ldrh	w1, [x1,x0]
-	ldrh	w0, [x19,3300]
+	ldrh	w0, [x19,3324]
 	mul	w0, w0, w2
 	cmp	w1, w0, lsr 1
-	bgt	.L3522
+	bgt	.L3571
 	mov	w1, 3
 	mov	w0, 0
 	mov	w2, 4
 	bl	gc_search_src_blk
 	uxth	w0, w0
-	ldrh	w1, [x19,3306]
-.L3645:
+	ldrh	w1, [x19,3330]
+.L3694:
 	lsr	w1, w1, 1
-.L3646:
+.L3695:
 	strh	w1, [x19,2872]
-	b	.L3505
-.L3522:
-	ldrh	w0, [x19,3306]
+	b	.L3554
+.L3571:
+	ldrh	w0, [x19,3330]
 	lsr	w0, w0, 2
 	strh	w0, [x19,2872]
-	b	.L3500
-.L3511:
-	ldrh	w0, [x22,3306]
+	b	.L3549
+.L3560:
+	ldrh	w0, [x22,3330]
 	mov	w24, w5
 	lsr	w0, w0, 2
 	strh	w0, [x22,2872]
-	b	.L3500
-.L3505:
+	b	.L3549
+.L3554:
 	mov	w1, w24
-	cbz	w0, .L3620
-.L3573:
+	cbz	w0, .L3669
+.L3622:
 	add	x23, x23, :lo12:.LANCHOR4
 	mov	w0, 1
-	strb	w0, [x23,1122]
-	b	.L3500
-.L3466:
+	strb	w0, [x23,1146]
+	b	.L3549
+.L3515:
 	add	x20, x19, :lo12:.LANCHOR0
 	mov	w0, 65535
 	ldrh	w1, [x20,2896]
 	cmp	w1, w0
-	bne	.L3525
+	bne	.L3574
 	bl	gc_get_src_blk
 	strh	w0, [x20,2896]
-.L3525:
+.L3574:
 	add	x0, x19, :lo12:.LANCHOR0
 	mov	w2, 65535
 	add	x1, x0, 2896
 	ldrh	w3, [x0,2896]
 	cmp	w3, w2
-	beq	.L3649
+	beq	.L3698
 	ldrh	w5, [x1,56]
 	uxtw	x4, w3
 	ldr	x2, [x0,584]
 	add	x2, x2, x4, lsl 2
-	cbz	w5, .L3528
+	cbz	w5, .L3577
 	mov	x0, 0
-.L3527:
+.L3576:
 	cmp	w5, w0, uxth
-	bls	.L3528
+	bls	.L3577
 	add	x0, x0, 1
 	add	x6, x1, x0, lsl 1
 	ldrh	w6, [x6,56]
 	cmp	w6, w3
-	bne	.L3527
-.L3533:
+	bne	.L3576
+.L3582:
 	add	x19, x19, :lo12:.LANCHOR0
 	mov	w0, -1
 	strh	w0, [x19,2896]
-	b	.L3648
-.L3528:
+	b	.L3697
+.L3577:
 	ldrb	w0, [x2,2]
 	tst	w0, 192
-	beq	.L3586
+	beq	.L3635
 	and	w0, w0, 224
 	cmp	w0, 224
-	bne	.L3530
-.L3586:
+	bne	.L3579
+.L3635:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldr	x0, [x0,600]
 	ldrh	w0, [x0,x4,lsl 1]
-	cbz	w0, .L3533
+	cbz	w0, .L3582
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 2300
+	mov	w2, 2347
 	add	x1, x1, 832
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-	b	.L3533
-.L3530:
+	b	.L3582
+.L3579:
 	add	x23, x23, :lo12:.LANCHOR4
 	mov	w0, 2
-	b	.L3651
-.L3467:
+	b	.L3700
+.L3516:
 	bl	gc_scan_src_blk
 	cmn	w0, #1
-	bne	.L3534
+	bne	.L3583
 	add	x23, x23, :lo12:.LANCHOR4
 	mov	w0, 3
-.L3651:
-	strb	w0, [x23,1122]
-	b	.L3648
-.L3534:
+.L3700:
+	strb	w0, [x23,1146]
+	b	.L3697
+.L3583:
 	add	x1, x19, :lo12:.LANCHOR0
 	mov	w3, 65535
 	ldrh	w0, [x1,2896]
 	cmp	w0, w3
-	beq	.L3481
+	beq	.L3530
 	ldrh	w3, [x1,2920]
 	add	x23, x23, :lo12:.LANCHOR4
-	cbz	w3, .L3535
+	cbz	w3, .L3584
 	mov	w0, 4
 	strh	wzr, [x1,2922]
-	strb	w0, [x23,1122]
-	b	.L3648
-.L3535:
+	strb	w0, [x23,1146]
+	b	.L3697
+.L3584:
 	ubfiz	x0, x0, 1, 16
 	ldr	x1, [x1,600]
 	mov	w2, 1
-	strb	w2, [x23,1122]
+	strb	w2, [x23,1146]
 	ldrh	w0, [x1,x0]
-	cbz	w0, .L3536
+	cbz	w0, .L3585
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 2328
+	mov	w2, 2375
 	add	x1, x1, 832
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L3536:
+.L3585:
 	add	x20, x19, :lo12:.LANCHOR0
 	add	x21, x20, 2896
 	ldrh	w0, [x20,2896]
@@ -22740,100 +23060,100 @@ zftl_do_gc:
 	add	w0, w0, 1
 	uxth	w0, w0
 	cmp	w0, 8
-	bhi	.L3537
+	bhi	.L3586
 	strh	w0, [x21,30]
-	b	.L3533
-.L3537:
+	b	.L3582
+.L3586:
 	strh	wzr, [x21,30]
 	bl	ftl_flush
 	bl	pm_flush
 	bl	ftl_ext_info_flush
 	mov	w0, 0
 	bl	ftl_info_flush
-	b	.L3533
-.L3468:
+	b	.L3582
+.L3517:
 	add	x21, x19, :lo12:.LANCHOR0
-.L3621:
+.L3670:
 	bl	gc_scan_src_blk_one_page
 	ldrh	w2, [x21,2898]
 	add	x0, x21, 2896
-	ldrh	w1, [x21,3300]
+	ldrh	w1, [x21,3324]
 	cmp	w2, w1
-	bcs	.L3539
+	bcs	.L3588
 	cmp	w20, 7
-	bls	.L3621
-	b	.L3648
-.L3539:
+	bls	.L3670
+	b	.L3697
+.L3588:
 	ldrh	w3, [x0,24]
 	adrp	x2, .LANCHOR2
-	cbz	w3, .L3540
+	cbz	w3, .L3589
 	add	x23, x23, :lo12:.LANCHOR4
 	mov	w1, 4
 	strh	wzr, [x0,26]
-	strb	w1, [x23,1122]
+	strb	w1, [x23,1146]
 	ldr	w1, [x2,#:lo12:.LANCHOR2]
-	tbz	x1, 8, .L3541
+	tbz	x1, 8, .L3590
 	ldrh	w1, [x0]
-	adrp	x0, .LC292
+	adrp	x0, .LC300
 	ldr	x4, [x21,600]
-	add	x0, x0, :lo12:.LC292
+	add	x0, x0, :lo12:.LC300
 	ubfiz	x2, x1, 1, 16
 	ldrh	w2, [x4,x2]
 	bl	printk
-.L3541:
+.L3590:
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrh	w2, [x0,2896]
 	ldr	x1, [x0,600]
 	ldrh	w0, [x0,2920]
 	ldrh	w1, [x1,x2,lsl 1]
 	cmp	w1, w0
-	beq	.L3542
+	beq	.L3591
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 2362
+	mov	w2, 2409
 	add	x1, x1, 832
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L3542:
+.L3591:
 	add	x19, x19, :lo12:.LANCHOR0
 	ldrh	w1, [x19,2896]
 	ldr	x0, [x19,600]
 	ldrh	w2, [x19,2920]
 	strh	w2, [x0,x1,lsl 1]
-	b	.L3648
-.L3540:
+	b	.L3697
+.L3589:
 	add	x23, x23, :lo12:.LANCHOR4
 	ldrh	w1, [x0]
 	mov	w0, 1
 	ldr	x20, [x21,584]
 	add	x20, x20, x1, uxth 2
-	strb	w0, [x23,1122]
+	strb	w0, [x23,1146]
 	ldr	w0, [x2,#:lo12:.LANCHOR2]
-	tbz	x0, 8, .L3543
+	tbz	x0, 8, .L3592
 	ldrb	w2, [x20,2]
-	adrp	x0, .LC293
-	add	x0, x0, :lo12:.LC293
+	adrp	x0, .LC301
+	add	x0, x0, :lo12:.LC301
 	ubfx	x2, x2, 5, 3
 	bl	printk
-.L3543:
+.L3592:
 	ldrb	w0, [x20,2]
 	tst	w0, 192
-	beq	.L3587
+	beq	.L3636
 	and	w0, w0, 224
 	cmp	w0, 224
-	bne	.L3544
-.L3587:
+	bne	.L3593
+.L3636:
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 2372
+	mov	w2, 2419
 	add	x1, x1, 832
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L3544:
+.L3593:
 	add	x19, x19, :lo12:.LANCHOR0
 	add	x20, x19, 2896
 	ldrh	w0, [x19,2896]
@@ -22844,59 +23164,59 @@ zftl_do_gc:
 	add	w0, w0, 1
 	uxth	w0, w0
 	cmp	w0, 8
-	bhi	.L3546
+	bhi	.L3595
 	strh	w0, [x20,30]
-	b	.L3648
-.L3546:
+	b	.L3697
+.L3595:
 	strh	wzr, [x20,30]
-	b	.L3652
-.L3469:
-	cbnz	w26, .L3547
+	b	.L3701
+.L3518:
+	cbnz	w26, .L3596
 	add	x0, x19, :lo12:.LANCHOR0
 	ldrh	w0, [x0,2872]
 	cmp	w0, w20
-	bcc	.L3648
-.L3547:
+	bcc	.L3697
+.L3596:
 	ldrh	w1, [x22,80]
 	mov	w0, 65535
 	cmp	w1, w0
-	bne	.L3548
+	bne	.L3597
 	add	x24, x19, :lo12:.LANCHOR0
-	ldrb	w21, [x24,3273]
+	ldrb	w21, [x24,3297]
 	cmp	w21, 1
-	bne	.L3548
+	bne	.L3597
 	bl	ftl_flush
 	ldrh	w0, [x24,3214]
-	cbz	w0, .L3549
+	cbz	w0, .L3598
 	mov	w0, w21
-.L3549:
+.L3598:
 	mov	w1, 5
 	bl	zftl_gc_get_free_sblk
 	uxth	w20, w0
 	mov	w0, 65535
 	cmp	w20, w0
-	beq	.L3551
+	beq	.L3600
 	add	x0, x19, :lo12:.LANCHOR0
 	ldr	x21, [x0,584]
 	add	x21, x21, x20, uxth 2
 	ldrb	w0, [x21,2]
 	tst	w0, 224
-	beq	.L3552
+	beq	.L3601
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 2401
+	mov	w2, 2448
 	add	x1, x1, 832
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L3552:
+.L3601:
 	ldrb	w0, [x21,2]
 	mov	w1, 5
 	bfi	w0, w1, 5, 3
 	orr	w0, w0, 16
 	strb	w0, [x21,2]
-.L3574:
+.L3623:
 	mov	w0, w20
 	mov	w1, 1
 	add	x19, x19, :lo12:.LANCHOR0
@@ -22908,32 +23228,32 @@ zftl_do_gc:
 	mov	w0, w20
 	bl	ftl_get_blk_list_in_sblk
 	uxtb	w0, w0
-	ldrh	w1, [x19,3300]
+	ldrh	w1, [x19,3324]
 	strb	w0, [x22,89]
-	ldrb	w2, [x19,3276]
+	ldrb	w2, [x19,3300]
 	mul	w0, w0, w1
 	strh	w0, [x22,86]
 	mov	w1, 255
-	ldrh	w0, [x19,3274]
+	ldrh	w0, [x19,3298]
 	strh	w20, [x22,80]
 	strh	wzr, [x22,82]
 	mul	w2, w0, w2
-	ldr	x0, [x23,1128]
+	ldr	x0, [x23,1152]
 	strb	wzr, [x22,85]
 	lsl	w2, w2, 2
 	strh	wzr, [x22,90]
 	bl	ftl_memset
-	ldrh	w0, [x19,3274]
+	ldrh	w0, [x19,3298]
 	mov	w1, 255
-	ldrb	w2, [x19,3276]
+	ldrb	w2, [x19,3300]
 	mul	w2, w0, w2
-	ldr	x0, [x23,1136]
+	ldr	x0, [x23,1160]
 	lsl	w2, w2, 2
 	bl	ftl_memset
-	ldrh	w3, [x19,3274]
+	ldrh	w3, [x19,3298]
 	mov	w1, 255
-	ldrb	w2, [x19,3276]
-	ldr	x0, [x19,3264]
+	ldrb	w2, [x19,3300]
+	ldr	x0, [x19,3288]
 	mul	w2, w3, w2
 	bl	ftl_memset
 	ldr	x0, [x19,608]
@@ -22953,8 +23273,8 @@ zftl_do_gc:
 	strh	wzr, [x19,3212]
 	strh	wzr, [x19,3216]
 	bl	ftl_info_flush
-	b	.L3648
-.L3548:
+	b	.L3697
+.L3597:
 	cmp	w26, 1
 	mov	w21, 4
 	csinc	w21, w21, wzr, eq
@@ -22962,68 +23282,68 @@ zftl_do_gc:
 	add	w0, w21, 4
 	add	x24, x19, :lo12:.LANCHOR0
 	csel	w21, w0, w21, ls
-.L3555:
+.L3604:
 	sub	w21, w21, #1
 	uxtb	w21, w21
 	cmp	w21, 255
-	beq	.L3648
+	beq	.L3697
 	bl	gc_do_copy_back
-	ldrb	w0, [x24,3273]
-	cbnz	w0, .L3556
+	ldrb	w0, [x24,3297]
+	cbnz	w0, .L3605
 	ldrb	w0, [x24,2834]
 	cmp	w0, 3
-	bhi	.L3557
+	bhi	.L3606
 	bl	ftl_write_commit
-.L3557:
+.L3606:
 	ldrh	w1, [x24,2922]
 	ldrh	w0, [x24,2920]
 	cmp	w1, w0
-	bcc	.L3555
+	bcc	.L3604
 	add	x23, x23, :lo12:.LANCHOR4
 	mov	w0, 1
-	strb	w0, [x23,1122]
+	strb	w0, [x23,1146]
 	bl	ftl_write_commit
 	bl	ftl_flush
 	ldrh	w1, [x24,2896]
 	ldr	x0, [x24,600]
 	ldrh	w0, [x0,x1,lsl 1]
-	cbz	w0, .L3559
+	cbz	w0, .L3608
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 2476
+	mov	w2, 2523
 	add	x1, x1, 832
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L3559:
+.L3608:
 	add	x1, x19, :lo12:.LANCHOR0
 	ldrh	w0, [x1,2896]
 	ldr	x3, [x1,600]
 	ubfiz	x2, x0, 1, 16
 	ldrh	w4, [x3,x2]
-	cbnz	w4, .L3560
+	cbnz	w4, .L3609
 	strh	w4, [x3,x2]
 	ldrh	w0, [x1,2896]
 	bl	ftl_free_sblk
-	b	.L3533
-.L3560:
+	b	.L3582
+.L3609:
 	mov	w1, 0
 	mov	w2, 1
 	bl	gc_add_sblk
-	b	.L3533
-.L3556:
+	b	.L3582
+.L3605:
 	add	x20, x24, 2896
 	ldrh	w0, [x20,320]
-	cbz	w0, .L3561
+	cbz	w0, .L3610
 	strh	wzr, [x20,320]
 	bl	sblk_wait_write_queue_completed
 	bl	gc_write_completed
 	ldr	w0, [x20,324]
 	cmn	w0, #1
-	beq	.L3562
+	beq	.L3611
 	bl	ftl_mask_bad_block
-.L3562:
+.L3611:
 	add	x20, x19, :lo12:.LANCHOR0
 	ldr	x0, [x20,608]
 	str	wzr, [x20,3220]
@@ -23037,9 +23357,9 @@ zftl_do_gc:
 	strh	w0, [x2,126]
 	strh	w0, [x1,130]
 	ldr	x0, [x20,2904]
-	cbz	x0, .L3563
-	bl	buf_free
-.L3563:
+	cbz	x0, .L3612
+	bl	zbuf_free
+.L3612:
 	add	x19, x19, :lo12:.LANCHOR0
 	add	x23, x23, :lo12:.LANCHOR4
 	str	xzr, [x19,2904]
@@ -23047,24 +23367,24 @@ zftl_do_gc:
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 2514
+	mov	w2, 2561
 	add	x1, x1, 832
 	add	x0, x0, :lo12:.LC0
-	strb	wzr, [x23,1122]
+	strb	wzr, [x23,1146]
 	bl	printk
 	bl	dump_stack
-	b	.L3648
-.L3561:
+	b	.L3697
+.L3610:
 	ldrh	w0, [x22,86]
 	cmp	w0, 1
-	bls	.L3564
+	bls	.L3613
 	ldrh	w1, [x20,26]
 	ldrh	w0, [x20,24]
 	cmp	w1, w0
-	bcc	.L3555
+	bcc	.L3604
 	add	x23, x23, :lo12:.LANCHOR4
 	mov	w0, 1
-	strb	w0, [x23,1122]
+	strb	w0, [x23,1146]
 	ldrh	w0, [x20,56]
 	add	w1, w0, 1
 	add	x0, x20, x0, sxtw 1
@@ -23073,15 +23393,15 @@ zftl_do_gc:
 	strh	w1, [x0,58]
 	mov	w0, -1
 	strh	w0, [x20]
-	b	.L3648
-.L3564:
+	b	.L3697
+.L3613:
 	add	x23, x23, :lo12:.LANCHOR4
 	mov	w0, 5
 	ldrh	w1, [x20,26]
-	strb	w0, [x23,1122]
+	strb	w0, [x23,1146]
 	ldrh	w0, [x20,24]
 	cmp	w1, w0
-	bcc	.L3565
+	bcc	.L3614
 	ldrh	w0, [x20,56]
 	add	w1, w0, 1
 	add	x0, x20, x0, sxtw 1
@@ -23090,7 +23410,7 @@ zftl_do_gc:
 	strh	w1, [x0,58]
 	mov	w0, -1
 	strh	w0, [x20]
-.L3565:
+.L3614:
 	add	x20, x19, :lo12:.LANCHOR0
 	bl	ftl_flush
 	bl	sblk_wait_write_queue_completed
@@ -23101,28 +23421,28 @@ zftl_do_gc:
 	bl	pm_flush
 	bl	ftl_ext_info_flush
 	strh	wzr, [x20,2912]
-	ldrb	w2, [x20,3257]
-	ldrh	w1, [x20,3300]
+	ldrb	w2, [x20,3281]
+	ldrh	w1, [x20,3324]
 	strh	w1, [x20,2914]
 	cmp	w2, 2
 	strh	w2, [x20,2916]
-	bne	.L3567
+	bne	.L3616
 	lsl	w1, w1, 1
 	strh	w1, [x20,2914]
-	ldrb	w1, [x20,3258]
-	cbnz	w1, .L3567
+	ldrb	w1, [x20,3282]
+	cbnz	w1, .L3616
 	mov	w1, 1
 	strh	w1, [x20,2916]
-.L3567:
+.L3616:
 	add	x19, x19, :lo12:.LANCHOR0
 	strh	wzr, [x19,2918]
-	b	.L3648
-.L3576:
+	b	.L3697
+.L3625:
 	mov	w21, 0
 	add	x24, x19, :lo12:.LANCHOR0
-.L3470:
+.L3519:
 	bl	gc_check_data_one_wl
-	cbz	w0, .L3570
+	cbz	w0, .L3619
 	add	x19, x19, :lo12:.LANCHOR0
 	add	x23, x23, :lo12:.LANCHOR4
 	ldr	x0, [x19,608]
@@ -23136,35 +23456,35 @@ zftl_do_gc:
 	strh	w0, [x2,126]
 	strh	w0, [x1,130]
 	ldr	x0, [x19,2904]
-	bl	buf_free
+	bl	zbuf_free
 	str	xzr, [x19,2904]
-	strb	wzr, [x23,1122]
-.L3652:
+	strb	wzr, [x23,1146]
+.L3701:
 	bl	flt_sys_flush
-	b	.L3648
-.L3570:
+	b	.L3697
+.L3619:
 	ldrh	w1, [x24,2912]
 	ldrh	w0, [x24,2914]
 	cmp	w1, w0
-	bcc	.L3571
+	bcc	.L3620
 	add	x23, x23, :lo12:.LANCHOR4
 	mov	w0, 6
-	strb	w0, [x23,1122]
+	strb	w0, [x23,1146]
 	ldr	x0, [x24,2904]
-	bl	buf_free
+	bl	zbuf_free
 	str	xzr, [x24,2904]
-	b	.L3648
-.L3571:
+	b	.L3697
+.L3620:
 	cmp	w20, 15
-	bls	.L3470
+	bls	.L3519
 	cmp	w26, 1
-	bne	.L3648
+	bne	.L3697
 	add	w21, w21, 1
 	uxtb	w21, w21
 	cmp	w21, 4
-	bls	.L3470
-	b	.L3648
-.L3471:
+	bls	.L3519
+	b	.L3697
+.L3520:
 	bl	gc_update_l2p_map_new
 	mov	w20, -1
 	bl	gc_free_src_blk
@@ -23177,26 +23497,26 @@ zftl_do_gc:
 	strh	w20, [x0,126]
 	mov	w0, 0
 	bl	ftl_info_flush
-.L3649:
+.L3698:
 	add	x23, x23, :lo12:.LANCHOR4
-	strb	wzr, [x23,1122]
-.L3648:
+	strb	wzr, [x23,1146]
+.L3697:
 	mov	w1, 16
-	b	.L3620
-.L3500:
+	b	.L3669
+.L3549:
 	mov	w1, w24
-	b	.L3620
-.L3551:
+	b	.L3669
+.L3600:
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 2407
+	mov	w2, 2454
 	add	x1, x1, 832
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-	b	.L3574
-.L3620:
+	b	.L3623
+.L3669:
 	sub	sp, x29, #16
 	mov	w0, w1
 	ldp	x19, x20, [sp,32]
@@ -23225,31 +23545,31 @@ zftl_write:
 	stp	x25, x26, [sp,64]
 	mov	w23, w2
 	mov	x24, x3
-	tbz	x0, 12, .L3654
-	adrp	x0, .LC294
+	tbz	x0, 12, .L3703
+	adrp	x0, .LC302
 	ldr	w4, [x24]
-	add	x0, x0, :lo12:.LC294
+	add	x0, x0, :lo12:.LC302
 	mov	w1, w19
 	mov	w2, w28
 	mov	w3, w23
 	bl	printk
-.L3654:
-	cbnz	w19, .L3655
+.L3703:
+	cbnz	w19, .L3704
 	adrp	x0, .LANCHOR0+520
 	mov	w19, 24576
 	ldr	w2, [x0,#:lo12:.LANCHOR0+520]
-	b	.L3656
-.L3655:
+	b	.L3705
+.L3704:
 	cmp	w19, 3
 	mov	w0, -1
-	bhi	.L3657
+	bhi	.L3706
 	lsl	w19, w19, 13
 	mov	w2, 8192
-.L3656:
+.L3705:
 	add	w1, w28, w23
 	mov	w0, -1
 	cmp	w1, w2
-	bhi	.L3657
+	bhi	.L3706
 	add	w28, w19, w28
 	adrp	x19, .LANCHOR0
 	add	x0, x19, :lo12:.LANCHOR0
@@ -23262,15 +23582,15 @@ zftl_write:
 	udiv	w22, w22, w0
 	sub	w20, w22, w25
 	add	w20, w20, 1
-.L3658:
-	cbz	w20, .L3677
+.L3707:
+	cbz	w20, .L3726
 	mov	w0, 0
 	bl	buf_alloc
 	mov	x27, x0
-	cbnz	x0, .L3659
+	cbnz	x0, .L3708
 	bl	ftl_write_commit
-	b	.L3658
-.L3659:
+	b	.L3707
+.L3708:
 	strb	wzr, [x0,57]
 	add	x0, x19, :lo12:.LANCHOR0
 	cmp	w21, w25
@@ -23278,12 +23598,12 @@ zftl_write:
 	cset	w0, eq
 	strb	w4, [x27,56]
 	cmp	w21, w22
-	beq	.L3661
-	cbz	w0, .L3662
-	b	.L3671
-.L3661:
-	cbz	w0, .L3663
-.L3671:
+	beq	.L3710
+	cbz	w0, .L3711
+	b	.L3720
+.L3710:
+	cbz	w0, .L3712
+.L3720:
 	udiv	w0, w28, w4
 	msub	w0, w0, w4, w28
 	uxtb	w0, w0
@@ -23292,12 +23612,12 @@ zftl_write:
 	uxtb	w4, w4
 	cmp	w4, w23
 	csel	w4, w23, w4, hi
-	b	.L3675
-.L3663:
+	b	.L3724
+.L3712:
 	msub	w4, w4, w21, w26
-.L3675:
+.L3724:
 	strb	w4, [x27,56]
-.L3662:
+.L3711:
 	ldrb	w1, [x27,57]
 	sub	w20, w20, #1
 	ldr	x0, [x27,8]
@@ -23318,11 +23638,11 @@ zftl_write:
 	bl	ftl_write_buf
 	ldrb	w0, [x27,56]
 	add	x24, x24, x0, lsl 9
-	b	.L3658
-.L3677:
+	b	.L3707
+.L3726:
 	bl	ftl_write_commit
 	mov	w0, w20
-.L3676:
+.L3725:
 	mov	w1, 1
 	bl	zftl_do_gc
 	add	x1, x19, :lo12:.LANCHOR0
@@ -23330,15 +23650,15 @@ zftl_write:
 	ldrh	w0, [x1,2848]
 	add	w0, w2, w0
 	cmp	w0, 7
-	bgt	.L3678
+	bgt	.L3727
 	mov	w0, 0
-	b	.L3676
-.L3678:
+	b	.L3725
+.L3727:
 	bl	timer_get_time
 	adrp	x1, .LANCHOR7-60
 	str	w0, [x1,#:lo12:.LANCHOR7-60]
 	mov	w0, 0
-.L3657:
+.L3706:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -23396,7 +23716,7 @@ zftl_discard:
 	stp	x27, x28, [sp,80]
 	ldr	w1, [x1,520]
 	cmp	w2, w1
-	bhi	.L3682
+	bhi	.L3731
 	adrp	x23, .LANCHOR7
 	add	w24, w0, 24576
 	add	x0, x23, :lo12:.LANCHOR7
@@ -23405,14 +23725,14 @@ zftl_discard:
 	add	w1, w19, w1
 	str	w1, [x0,-56]
 	ldr	w0, [x25,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L3683
-	adrp	x0, .LC295
+	tbz	x0, 12, .L3732
+	adrp	x0, .LC303
 	mov	w2, w24
-	add	x0, x0, :lo12:.LC295
+	add	x0, x0, :lo12:.LC303
 	mov	w3, w19
 	mov	w4, 0
 	bl	printk
-.L3683:
+.L3732:
 	add	x20, x21, :lo12:.LANCHOR0
 	ldr	x0, [x20,2864]
 	ldr	w26, [x0,8]
@@ -23423,7 +23743,7 @@ zftl_discard:
 	ldrb	w22, [x20,2832]
 	udiv	w20, w24, w22
 	msub	w27, w20, w22, w24
-	cbz	w27, .L3684
+	cbz	w27, .L3733
 	sub	w22, w22, w27
 	mov	w0, w20
 	cmp	w22, w19
@@ -23431,20 +23751,20 @@ zftl_discard:
 	bl	lpa_hash_get_ppa
 	str	w0, [x29,120]
 	cmn	w0, #1
-	bne	.L3685
+	bne	.L3734
 	mov	w0, w20
 	add	x1, x29, 120
 	mov	w2, 0
 	bl	pm_log2phys
-.L3685:
+.L3734:
 	ldr	w0, [x29,120]
 	and	w28, w22, 65535
 	cmn	w0, #1
-	beq	.L3687
+	beq	.L3736
 	mov	w0, 0
 	bl	buf_alloc
 	mov	x3, x0
-	cbz	x0, .L3687
+	cbz	x0, .L3736
 	strb	w27, [x0,57]
 	ubfiz	x27, x27, 9, 25
 	str	w20, [x0,36]
@@ -23465,31 +23785,31 @@ zftl_discard:
 	ldr	w0, [x1,76]
 	add	w0, w0, 1
 	str	w0, [x1,76]
-.L3687:
+.L3736:
 	add	w20, w20, 1
 	sub	w19, w19, w28
-.L3684:
-	cbz	w19, .L3689
+.L3733:
+	cbz	w19, .L3738
 	bl	ftl_flush
-.L3689:
+.L3738:
 	mov	w0, -1
 	mov	w27, 1
 	str	w0, [x29,124]
 	mov	w28, 21
-.L3690:
+.L3739:
 	add	x22, x21, :lo12:.LANCHOR0
 	ldrb	w0, [x22,2832]
 	cmp	w19, w0
-	bcc	.L3729
+	bcc	.L3778
 	mov	w0, w20
 	bl	lpa_hash_get_ppa
 	str	w0, [x29,120]
 	cmn	w0, #1
-	beq	.L3691
+	beq	.L3740
 	mov	w0, 0
 	bl	buf_alloc
 	mov	x3, x0
-	cbz	x0, .L3693
+	cbz	x0, .L3742
 	ldrb	w2, [x22,2832]
 	mov	w1, 0
 	str	w20, [x0,36]
@@ -23504,59 +23824,59 @@ zftl_discard:
 	mov	x0, x3
 	bl	ftl_write_buf
 	bl	ftl_write_commit
-	b	.L3728
-.L3691:
+	b	.L3777
+.L3740:
 	mov	w0, w20
 	add	x1, x29, 120
 	mov	w2, 0
 	bl	pm_log2phys
 	ldr	w0, [x29,120]
 	cmn	w0, #1
-	beq	.L3693
+	beq	.L3742
 	add	x1, x29, 124
 	mov	w2, 1
 	mov	w0, w20
 	bl	pm_log2phys
-	ldrh	w0, [x22,3340]
+	ldrh	w0, [x22,3264]
 	ldr	w1, [x29,120]
 	sub	w2, w28, w0
 	lsl	w2, w27, w2
 	lsr	w0, w1, w0
 	sub	w2, w2, #1
-	ldrb	w1, [x22,3338]
+	ldrb	w1, [x22,3266]
 	and	w0, w2, w0
 	udiv	w0, w0, w1
 	bl	ftl_vpn_decrement
-.L3728:
+.L3777:
 	ldr	x1, [x22,2864]
 	ldr	w0, [x1,76]
 	add	w0, w0, 1
 	str	w0, [x1,76]
-.L3693:
+.L3742:
 	add	x0, x21, :lo12:.LANCHOR0
 	add	w20, w20, 1
 	ldrb	w0, [x0,2832]
 	sub	w19, w19, w0
-	b	.L3690
-.L3729:
-	cbz	w19, .L3697
+	b	.L3739
+.L3778:
+	cbz	w19, .L3746
 	mov	w0, w20
 	bl	lpa_hash_get_ppa
 	str	w0, [x29,120]
 	cmn	w0, #1
-	bne	.L3698
+	bne	.L3747
 	mov	w0, w20
 	add	x1, x29, 120
 	mov	w2, 0
 	bl	pm_log2phys
-.L3698:
+.L3747:
 	ldr	w0, [x29,120]
 	cmn	w0, #1
-	beq	.L3697
+	beq	.L3746
 	mov	w0, 0
 	bl	buf_alloc
 	mov	x22, x0
-	cbz	x0, .L3697
+	cbz	x0, .L3746
 	str	w20, [x0,36]
 	strb	wzr, [x0,57]
 	strb	w19, [x0,56]
@@ -23564,16 +23884,16 @@ zftl_discard:
 	add	x0, x21, :lo12:.LANCHOR0
 	ldrb	w0, [x0,2832]
 	cmp	w19, w0
-	bcc	.L3700
+	bcc	.L3749
 	adrp	x1, .LANCHOR3
 	adrp	x0, .LC0
 	add	x1, x1, :lo12:.LANCHOR3
-	mov	w2, 1241
+	mov	w2, 1251
 	add	x1, x1, 848
 	add	x0, x0, :lo12:.LC0
 	bl	printk
 	bl	dump_stack
-.L3700:
+.L3749:
 	ldr	x0, [x22,8]
 	mov	w1, 0
 	lsl	w2, w19, 9
@@ -23586,20 +23906,20 @@ zftl_discard:
 	ldr	w0, [x1,76]
 	add	w0, w0, 1
 	str	w0, [x1,76]
-.L3697:
+.L3746:
 	add	x0, x23, :lo12:.LANCHOR7
 	mov	w4, 0
 	ldr	w1, [x0,-56]
 	cmp	w1, 8192
-	bls	.L3682
+	bls	.L3731
 	ldr	w0, [x25,#:lo12:.LANCHOR2]
-	tbz	x0, 12, .L3701
-	adrp	x0, .LC295
+	tbz	x0, 12, .L3750
+	adrp	x0, .LC303
 	mov	w2, w24
-	add	x0, x0, :lo12:.LC295
+	add	x0, x0, :lo12:.LC303
 	mov	w3, w19
 	bl	printk
-.L3701:
+.L3750:
 	add	x23, x23, :lo12:.LANCHOR7
 	add	x21, x21, :lo12:.LANCHOR0
 	str	wzr, [x23,-56]
@@ -23607,7 +23927,7 @@ zftl_discard:
 	mov	w0, 1
 	mov	w4, 0
 	str	w0, [x21,2884]
-.L3682:
+.L3731:
 	mov	w0, w4
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
@@ -23633,33 +23953,33 @@ id_block_prog_msb_ff_data:
 	stp	x27, x28, [sp,80]
 	uxth	w19, w2
 	ldr	x2, [x0,624]
-	ldrb	w0, [x0,782]
+	ldrb	w0, [x0,634]
 	ldrb	w2, [x2,19]
-	cbnz	w0, .L3730
+	cbnz	w0, .L3779
 	sub	w0, w2, #5
 	uxtb	w0, w0
 	cmp	w0, 2
-	bls	.L3732
+	bls	.L3781
 	cmp	w2, 68
-	beq	.L3732
+	beq	.L3781
 	sub	w2, w2, #19
 	and	w2, w2, -17
 	uxtb	w2, w2
-	cbnz	w2, .L3730
-.L3732:
-	adrp	x24, .LC296
+	cbnz	w2, .L3779
+.L3781:
+	adrp	x24, .LC304
 	adrp	x20, .LANCHOR4
 	mov	w25, w1
-	add	x24, x24, :lo12:.LC296
+	add	x24, x24, :lo12:.LC304
 	add	x20, x20, :lo12:.LANCHOR4
 	mov	w27, 65535
-.L3734:
+.L3783:
 	add	x28, x21, :lo12:.LANCHOR0
 	ldr	x0, [x28,624]
 	ldrh	w0, [x0,10]
 	cmp	w0, w19
-	bls	.L3730
-	add	x22, x20, 60
+	bls	.L3779
+	add	x22, x20, 84
 	add	w26, w19, w25
 	mov	x0, x24
 	mov	w1, w19
@@ -23668,8 +23988,8 @@ id_block_prog_msb_ff_data:
 	bl	printk
 	ldrh	w0, [x22,w19,sxtw 1]
 	cmp	w0, w27
-	bne	.L3730
-	ldr	x0, [x20,1184]
+	bne	.L3779
+	ldr	x0, [x20,1208]
 	mov	w1, 255
 	mov	w2, 16384
 	add	w19, w19, 1
@@ -23677,13 +23997,13 @@ id_block_prog_msb_ff_data:
 	uxth	w19, w19
 	ldr	x4, [x28,624]
 	mov	w0, w23
-	ldr	x2, [x20,1184]
+	ldr	x2, [x20,1208]
 	mov	w1, w26
 	ldrb	w4, [x4,9]
 	mov	x3, x2
 	bl	flash_prog_page
-	b	.L3734
-.L3730:
+	b	.L3783
+.L3779:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
@@ -23696,196 +24016,240 @@ id_block_prog_msb_ff_data:
 	.global	write_idblock
 	.type	write_idblock, %function
 write_idblock:
-	stp	x29, x30, [sp, -224]!
+	stp	x29, x30, [sp, -256]!
 	add	x29, sp, 0
-	stp	x21, x22, [sp,32]
-	adrp	x21, .LANCHOR0
-	stp	x19, x20, [sp,16]
-	mov	w19, w0
-	add	x0, x21, :lo12:.LANCHOR0
-	stp	x23, x24, [sp,48]
 	stp	x25, x26, [sp,64]
+	adrp	x25, .LANCHOR0
+	add	x26, x25, :lo12:.LANCHOR0
+	str	x2, [x29,160]
+	stp	x23, x24, [sp,48]
+	stp	x19, x20, [sp,16]
+	stp	x21, x22, [sp,32]
 	stp	x27, x28, [sp,80]
-	adrp	x20, .LANCHOR2
-	mov	x25, x1
-	ldr	x0, [x0,624]
-	str	x2, [x29,128]
-	ldrb	w22, [x0,9]
-	ldrh	w26, [x0,10]
-	add	x0, x20, :lo12:.LANCHOR2
-	ldrh	w24, [x0,34]
+	mov	w19, w0
+	mov	x24, x1
+	ldr	x0, [x26,624]
+	ldrb	w20, [x0,9]
+	ldrh	w22, [x0,10]
+	adrp	x0, .LANCHOR2+34
+	ldrh	w21, [x0,#:lo12:.LANCHOR2+34]
+	ldrb	w0, [x25,#:lo12:.LANCHOR0]
+	str	w0, [x29,168]
 	mov	w0, 59392
 	movk	w0, 0x3, lsl 16
 	bl	ftl_malloc
+	str	x25, [x29,176]
 	mov	x23, x0
+	cbnz	x0, .L3786
+.L3790:
 	mov	w0, -1
-	cbz	x23, .L3785
+	b	.L3852
+.L3786:
+	ldr	x0, [x29,176]
+	str	wzr, [x29,172]
+	ldrb	w0, [x0,#:lo12:.LANCHOR0]
+	cbz	w0, .L3788
+	ldrb	w0, [x26,634]
+	cbnz	w0, .L3788
+	adrp	x0, .LANCHOR7-82
+	ldrb	w0, [x0,#:lo12:.LANCHOR7-82]
+	cmp	w0, wzr
+	cset	w0, ne
+	str	w0, [x29,172]
+.L3788:
+	mov	w0, 0
 	add	w19, w19, 511
 	lsr	w19, w19, 9
+	bl	zftl_flash_exit_slc_mode
+	ldr	x0, [x29,176]
 	cmp	w19, 8
-	bls	.L3768
+	ldr	x1, [x29,176]
+	add	x0, x0, :lo12:.LANCHOR0
+	ldrb	w0, [x0,634]
+	strb	w0, [x1,#:lo12:.LANCHOR0]
+	bls	.L3823
 	cmp	w19, 500
-	bhi	.L3785
-	b	.L3738
-.L3768:
+	bhi	.L3790
+	b	.L3789
+.L3823:
 	mov	w19, 8
-.L3738:
-	ldr	w2, [x25]
-	mov	w1, 35899
-	movk	w1, 0xfcdc, lsl 16
-	mov	w0, -1
-	cmp	w2, w1
-	bne	.L3785
-	uxth	w22, w22
-	add	x3, x25, 253952
-	add	x3, x3, 2044
-	mov	w2, 63999
-	mul	w0, w22, w26
+.L3789:
+	ldr	w1, [x24]
+	mov	w0, 35899
+	movk	w0, 0xfcdc, lsl 16
+	cmp	w1, w0
+	bne	.L3790
+	uxth	w20, w20
+	mov	w3, 0
+	mov	w2, 63871
 	mov	w4, 4097
-	uxth	w0, w0
-	sub	w1, w0, #1
-	add	w1, w1, w19
-	udiv	w0, w1, w0
-	str	w0, [x29,120]
-	mov	w0, 0
-.L3742:
-	ldr	w1, [x3]
-	cbnz	w1, .L3739
-	ldr	w1, [x25,w0,uxtw 2]
-	add	w0, w0, 1
-	cmp	w0, w4
+	mul	w22, w20, w22
+	uxth	w22, w22
+	sub	w0, w22, #1
+	add	w0, w0, w19
+	udiv	w0, w0, w22
+	str	w0, [x29,148]
+	add	x0, x24, 253952
+	add	x0, x0, 1532
+.L3794:
+	ldr	w1, [x0]
+	cbnz	w1, .L3791
+	ldr	w1, [x24,w3,uxtw 2]
+	add	w3, w3, 1
+	cmp	w3, w4
 	sub	w2, w2, #1
-	csel	w0, w0, wzr, cc
-	str	w1, [x3],-4
+	str	w1, [x0,512]
+	csel	w3, w3, wzr, cc
 	cmp	w2, 4096
-	bne	.L3742
-	b	.L3741
-.L3739:
-	adrp	x0, .LC297
-	add	x0, x0, :lo12:.LC297
+	sub	x0, x0, #4
+	bne	.L3794
+	b	.L3793
+.L3791:
+	adrp	x0, .LC305
+	add	x0, x0, :lo12:.LC305
 	bl	printk
-.L3741:
-	mul	w22, w22, w24
-	ldr	x1, [x29,128]
+.L3793:
+	mul	w20, w20, w21
+	ldr	x1, [x29,160]
 	mov	w2, 4
 	mov	w3, 5
-	uxth	w0, w22
-	str	w0, [x29,152]
-	adrp	x0, .LC298
-	mov	x22, 0
-	add	x0, x0, :lo12:.LC298
-	mov	w28, w22
+	mov	x21, 0
+	uxth	w0, w20
+	str	w0, [x29,156]
+	adrp	x0, .LC306
+	adrp	x25, .LANCHOR0
+	add	x0, x0, :lo12:.LC306
 	bl	rknand_print_hex
-	adrp	x0, .LC299
+	adrp	x0, .LC307
 	mov	w1, w19
-	add	x0, x0, :lo12:.LC299
+	add	x0, x0, :lo12:.LC307
 	mov	w2, w19
 	bl	printk
-	add	x0, x20, :lo12:.LANCHOR2
-	str	x0, [x29,104]
-.L3765:
-	adrp	x1, .LANCHOR7
-	add	x1, x1, :lo12:.LANCHOR7
-	ldrb	w1, [x1,-82]
-	cbnz	w1, .L3743
-	ldr	x1, [x29,128]
-	ldr	w2, [x29,152]
-	ldr	w1, [x1,x22,lsl 2]
+	str	w21, [x29,188]
+	adrp	x0, .LANCHOR2
+	add	x0, x0, :lo12:.LANCHOR2
+	str	x0, [x29,128]
+	adrp	x0, .LC308
+	add	x0, x0, :lo12:.LC308
+	str	x0, [x29,120]
+.L3819:
+	adrp	x1, .LANCHOR7-82
+	ldrb	w1, [x1,#:lo12:.LANCHOR7-82]
+	cbnz	w1, .L3795
+	ldr	x1, [x29,160]
+	ldr	w2, [x29,156]
+	ldr	w1, [x1,x21,lsl 2]
 	mul	w20, w1, w2
-	cbz	w22, .L3744
-	ldr	w2, [x29,120]
+	cbz	w21, .L3796
+	ldr	w2, [x29,148]
 	cmp	w2, 1
-	bls	.L3744
-	sub	w0, w22, #1
-	ldr	x2, [x29,128]
+	bls	.L3796
+	sub	w0, w21, #1
+	ldr	x2, [x29,160]
 	ldr	w0, [x2,x0,lsl 2]
 	add	w0, w0, 1
 	cmp	w1, w0
-	bne	.L3744
-	b	.L3745
-.L3743:
-	add	x0, x21, :lo12:.LANCHOR0
-	ldr	x0, [x0,728]
-	add	x0, x0, x22, uxtw
+	bne	.L3796
+	b	.L3797
+.L3795:
+	add	x22, x25, :lo12:.LANCHOR0
+	ldr	x0, [x22,728]
+	add	x0, x0, x21, uxtw
 	ldrb	w20, [x0,32]
 	cmp	w20, 255
-	beq	.L3745
-	ldr	w0, [x29,152]
+	beq	.L3797
+	ldr	w0, [x29,156]
 	mul	w20, w20, w0
-.L3744:
+	ldr	w0, [x29,172]
+	cbz	w0, .L3796
+	cmp	x21, 1
+	bne	.L3798
+	ldrb	w0, [x29,168]
+	strb	w0, [x25,#:lo12:.LANCHOR0]
+	strb	w0, [x22,634]
+	b	.L3796
+.L3798:
+	mov	w0, 0
+	bl	zftl_flash_exit_slc_mode
+	strb	wzr, [x25,#:lo12:.LANCHOR0]
+	strb	wzr, [x22,634]
+.L3796:
 	mov	w1, 0
 	mov	w2, 512
 	mov	x0, x23
 	bl	ftl_memset
-	add	x1, x21, :lo12:.LANCHOR0
+	ldr	x0, [x29,176]
+	add	x1, x0, :lo12:.LANCHOR0
 	ldr	x2, [x1,624]
 	ldrb	w26, [x2,9]
 	ldrh	w27, [x2,10]
-	ldr	x2, [x29,104]
+	ldr	x2, [x29,128]
 	uxth	w0, w26
-	ldrh	w24, [x2,34]
+	ldrh	w22, [x2,34]
 	mul	w27, w0, w27
-	mul	w24, w0, w24
+	mul	w22, w0, w22
 	ldrb	w0, [x1,720]
 	uxth	w27, w27
 	strb	wzr, [x1,720]
 	udiv	w1, w20, w26
-	str	w0, [x29,116]
+	str	w0, [x29,144]
 	mov	w0, 0
-	uxth	w24, w24
+	uxth	w22, w22
 	bl	flash_erase_block
 	cmp	w19, w27
 	mov	w2, 1
-	bls	.L3746
+	bls	.L3799
 	mov	w0, 0
-	add	w1, w20, w24
+	add	w1, w20, w22
 	bl	flash_erase_block
 	mov	w2, 2
-.L3746:
-	add	x27, x21, :lo12:.LANCHOR0
+.L3799:
+	add	x27, x25, :lo12:.LANCHOR0
 	ldr	x1, [x27,624]
 	ldrh	w0, [x1,10]
 	ldrb	w1, [x1,12]
 	lsl	w0, w0, 2
 	mul	w0, w0, w2
 	sdiv	w0, w0, w1
-	str	w0, [x29,112]
-	udiv	w0, w20, w24
-	msub	w0, w0, w24, w20
-	str	w0, [x29,124]
+	str	w0, [x29,140]
+	udiv	w0, w20, w22
+	msub	w0, w0, w22, w20
+	str	w0, [x29,152]
 	sub	w0, w20, w0
-	str	w0, [x29,156]
+	str	w0, [x29,184]
 	cmp	w20, w0
-	bne	.L3773
+	bne	.L3826
 	ldrb	w0, [x27,516]
 	cmp	w0, 9
-	bne	.L3773
-	adrp	x0, .LANCHOR4+1224
+	bne	.L3826
+	adrp	x0, .LANCHOR4+1248
 	mov	w1, 0
 	mov	w2, 1024
-	ldr	x3, [x0,#:lo12:.LANCHOR4+1224]
-	str	x3, [x29,144]
+	ldr	x3, [x0,#:lo12:.LANCHOR4+1248]
+	str	x3, [x29,112]
 	mov	x0, x3
 	bl	ftl_memset
-	ldr	x3, [x29,144]
+	ldr	x3, [x29,112]
 	mov	w0, 18766
 	movk	w0, 0x464e, lsl 16
 	str	w0, [x3]
 	mov	w0, 12
 	str	w0, [x3,4]
-	ldrb	w0, [x27,782]
+	ldrb	w0, [x27,634]
 	str	wzr, [x3,12]
 	strb	wzr, [x3,16]
-	cbz	w0, .L3748
+	cbz	w0, .L3801
 	ldr	x0, [x27,624]
 	ldrb	w0, [x0,29]
 	strb	w0, [x3,16]
-.L3748:
+.L3801:
 	mov	w0, 4
 	strb	w0, [x3,17]
-	add	x0, x21, :lo12:.LANCHOR0
+	adrp	x0, .LANCHOR0
 	cmp	w26, 8
-	str	x3, [x29,144]
+	add	x0, x0, :lo12:.LANCHOR0
+	str	x3, [x29,112]
+	sub	w22, w19, #4
 	ldr	x1, [x0,624]
 	ldrh	w0, [x1,10]
 	ldrb	w1, [x1,12]
@@ -23900,106 +24264,135 @@ write_idblock:
 	strb	w0, [x3,21]
 	add	x0, x3, 12
 	bl	js_hash
-	ldr	x3, [x29,144]
+	ldr	x3, [x29,112]
 	str	w0, [x3,8]
-	sub	w0, w19, #4
-	str	w0, [x29,144]
-	b	.L3747
-.L3773:
-	str	w19, [x29,144]
+	b	.L3800
+.L3826:
+	mov	w22, w19
 	mov	x3, 0
-.L3747:
-	str	x25, [x29,136]
-	mov	w24, 0
-	add	x27, x21, :lo12:.LANCHOR0
-.L3750:
-	ldr	w0, [x29,112]
-	cmp	w24, w0
-	bcs	.L3795
-	ldr	w0, [x29,124]
-	ldrb	w2, [x27,782]
-	add	w4, w24, w0
-	add	x0, x27, 4
-	ubfx	x4, x4, 2, 16
-	add	w1, w4, 1
+.L3800:
+	mov	x28, x24
+	mov	w27, 0
+	add	x11, x25, :lo12:.LANCHOR0
+.L3803:
+	ldr	w0, [x29,140]
+	cmp	w27, w0
+	bcs	.L3855
+	ldr	w0, [x29,152]
+	ldrb	w2, [x11,634]
+	add	w8, w27, w0
+	add	x0, x11, 4
+	ubfx	x8, x8, 2, 16
+	add	w1, w8, 1
 	ldrh	w0, [x0,w1,sxtw 1]
-	cbz	w2, .L3752
-	ldrb	w6, [x27,1]
+	cbz	w2, .L3805
+	ldrb	w4, [x11,1]
 	lsl	w0, w1, 1
-	cmp	w6, wzr
+	cmp	w4, wzr
 	csel	w0, w0, w1, ne
-.L3752:
-	ldrb	w1, [x27,516]
+.L3805:
+	ldrb	w1, [x11,516]
 	cmp	w1, 9
-	beq	.L3794
+	beq	.L3854
 	sub	w0, w0, #1
 	lsl	w0, w0, 2
-.L3794:
-	str	w0, [x29,160]
+.L3854:
+	str	w0, [x29,192]
 	mov	w0, 61424
-	str	w0, [x29,164]
-	add	x0, x27, 4
-	ldrh	w0, [x0,w4,sxtw 1]
-	cbnz	w2, .L3756
-	mov	w4, w0
-	b	.L3757
-.L3756:
-	ldrb	w1, [x27,1]
-	lsl	w0, w4, 1
+	str	w0, [x29,196]
+	add	x0, x11, 4
+	ldrh	w0, [x0,w8,sxtw 1]
+	cbnz	w2, .L3809
+	mov	w8, w0
+	b	.L3810
+.L3809:
+	ldrb	w1, [x11,1]
+	lsl	w0, w8, 1
 	cmp	w1, wzr
-	csel	w4, w0, w4, ne
-.L3757:
-	mul	w0, w4, w26
-	cbnz	x3, .L3758
-	ldr	w1, [x29,156]
-	add	x2, x29, 160
-	str	x4, [x29,96]
-	add	w0, w0, w1
-	ldr	x1, [x29,136]
-	bl	fw_flash_page_prog.constprop.31
-	ldrb	w0, [x27,782]
-	ldr	x4, [x29,96]
-	cbnz	w0, .L3759
-	ldr	w1, [x29,156]
-	add	w2, w4, 1
+	csel	w8, w0, w8, ne
+.L3810:
+	mul	w0, w8, w26
+	cbnz	x3, .L3811
+	ldr	w1, [x29,184]
+	mov	w2, w27
+	ldr	w5, [x28]
+	mov	w3, w19
+	add	w12, w0, w1
+	ldr	w6, [x29,192]
+	ldr	x0, [x29,120]
+	mov	w1, w12
+	mov	x4, x28
+	mov	w7, 61424
+	str	x11, [x29,96]
+	str	x8, [x29,104]
+	str	x12, [x29,112]
+	bl	printk
+	ldr	x12, [x29,112]
+	mov	x1, x28
+	add	x2, x29, 192
+	mov	w0, w12
+	bl	fw_flash_page_prog.constprop.29
+	ldr	x11, [x29,96]
+	ldr	x8, [x29,104]
+	ldrb	w0, [x11,634]
+	cbnz	w0, .L3812
+	ldr	w1, [x29,184]
+	add	w2, w8, 1
+	str	x11, [x29,112]
 	udiv	w1, w1, w26
 	bl	id_block_prog_msb_ff_data
-.L3759:
-	ldr	x0, [x29,136]
-	add	x0, x0, 2048
-	str	x0, [x29,136]
-	b	.L3760
-.L3758:
-	ldr	w1, [x29,156]
-	add	x2, x29, 160
+	ldr	x11, [x29,112]
+.L3812:
+	add	w0, w22, 16
+	add	x28, x28, 2048
+	cmp	w27, w0
+	bcc	.L3813
+	add	w1, w22, 20
+	add	x0, x24, 2048
+	cmp	w27, w1
+	csel	x28, x28, x0, cs
+	b	.L3813
+.L3811:
+	ldr	w1, [x29,184]
+	add	x2, x29, 192
+	str	x11, [x29,112]
 	add	w0, w0, w1
 	mov	x1, x3
-	bl	fw_flash_page_prog.constprop.31
-.L3760:
-	add	w24, w24, 4
+	bl	fw_flash_page_prog.constprop.29
+	ldr	x11, [x29,112]
+.L3813:
+	add	w9, w27, 4
 	mov	x3, 0
-	uxth	w24, w24
-	b	.L3750
-.L3795:
-	add	x0, x21, :lo12:.LANCHOR0
-	ldrb	w1, [x29,116]
+	uxth	w27, w9
+	b	.L3803
+.L3855:
+	adrp	x0, .LANCHOR0
+	mov	w1, w22
+	add	x26, x0, :lo12:.LANCHOR0
+	ldrb	w0, [x29,144]
 	mov	x2, x23
-	strb	w1, [x0,720]
+	strb	w0, [x26,720]
 	mov	w0, w20
-	ldr	w1, [x29,144]
-	bl	id_block_read_data.constprop.32
-	ldr	w0, [x29,144]
-	mov	x1, 0
-	lsl	w0, w0, 7
-.L3762:
-	cmp	w0, w1
-	bls	.L3796
-	ldr	w3, [x23,x1,lsl 2]
-	add	x1, x1, 1
-	add	x2, x25, x1, lsl 2
-	ldr	w2, [x2,-4]
-	cmp	w3, w2
-	beq	.L3762
+	bl	id_block_read_data.constprop.30
+	ldr	w0, [x29,172]
+	cbz	w0, .L3815
+	mov	w0, 0
+	bl	zftl_flash_exit_slc_mode
+	strb	wzr, [x26,634]
+	adrp	x0, .LANCHOR0
+	strb	wzr, [x0,#:lo12:.LANCHOR0]
+.L3815:
+	lsl	w22, w22, 7
+	mov	x0, 0
+.L3816:
+	cmp	w22, w0
+	bls	.L3856
+	ldr	w2, [x23,x0,lsl 2]
+	add	x0, x0, 1
+	add	x1, x24, x0, lsl 2
+	ldr	w1, [x1,-4]
+	cmp	w2, w1
+	beq	.L3816
 	mov	x0, x23
 	mov	w1, 0
 	mov	w2, 512
@@ -24007,27 +24400,38 @@ write_idblock:
 	mov	w1, w20
 	mov	w0, 0
 	bl	flash_erase_block
-	b	.L3745
-.L3796:
-	add	w28, w28, 1
-	cmp	w28, 5
-	bhi	.L3766
-.L3745:
-	add	x22, x22, 1
-	cmp	x22, 4
-	bne	.L3765
-.L3766:
+	b	.L3797
+.L3856:
+	ldr	w0, [x29,188]
+	add	w0, w0, 1
+	str	w0, [x29,188]
+	cmp	w0, 5
+	bhi	.L3820
+.L3797:
+	add	x21, x21, 1
+	cmp	x21, 4
+	bne	.L3819
+.L3820:
+	adrp	x0, .LANCHOR0
+	ldrb	w2, [x29,168]
+	add	x1, x0, :lo12:.LANCHOR0
+	strb	w2, [x0,#:lo12:.LANCHOR0]
+	mov	w0, 2
+	strb	w0, [x1,744]
+	mov	w0, 0
+	bl	zftl_flash_enter_slc_mode
 	mov	x0, x23
 	bl	ftl_free
-	cmp	w28, wzr
+	ldr	w0, [x29,188]
+	cmp	w0, wzr
 	csetm	w0, eq
-.L3785:
+.L3852:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x23, x24, [sp,48]
 	ldp	x25, x26, [sp,64]
 	ldp	x27, x28, [sp,80]
-	ldp	x29, x30, [sp], 224
+	ldp	x29, x30, [sp], 256
 	ret
 	.size	write_idblock, .-write_idblock
 	.align	2
@@ -24039,39 +24443,39 @@ CRC_32:
 	mov	x5, x0
 	add	x3, x3, :lo12:.LANCHOR2
 	mov	w0, w2
-.L3798:
+.L3858:
 	cmp	w1, w2
-	bls	.L3800
+	bls	.L3860
 	ldrb	w4, [x5,x2]
-	add	x6, x3, 2552
+	add	x6, x3, 2584
 	add	x2, x2, 1
 	eor	w4, w4, w0, lsr 24
 	ldr	w4, [x6,w4,uxtw 2]
 	eor	w0, w4, w0, lsl 8
-	b	.L3798
-.L3800:
+	b	.L3858
+.L3860:
 	ret
 	.size	CRC_32, .-CRC_32
 	.align	2
 	.global	write_loader_lba
 	.type	write_loader_lba, %function
 write_loader_lba:
-	stp	x29, x30, [sp, -96]!
+	stp	x29, x30, [sp, -112]!
 	cmp	w0, 64
 	add	x29, sp, 0
 	stp	x19, x20, [sp,16]
 	stp	x21, x22, [sp,32]
-	str	x23, [sp,48]
+	stp	x23, x24, [sp,48]
 	mov	w19, w0
 	mov	w21, w1
-	mov	x23, x2
+	mov	x24, x2
 	adrp	x20, .LANCHOR7
-	bne	.L3802
+	bne	.L3862
 	ldr	w1, [x2]
 	mov	w0, 35899
 	movk	w0, 0xfcdc, lsl 16
 	cmp	w1, w0
-	bne	.L3802
+	bne	.L3862
 	add	x22, x20, :lo12:.LANCHOR7
 	mov	w0, 1
 	strb	w0, [x22,-52]
@@ -24084,46 +24488,51 @@ write_loader_lba:
 	movk	w2, 0x3, lsl 16
 	bl	ftl_memset
 	str	w19, [x22,-40]
-.L3802:
-	add	x3, x20, :lo12:.LANCHOR7
-	ldrb	w0, [x3,-52]
-	cbz	w0, .L3801
+.L3862:
+	add	x23, x20, :lo12:.LANCHOR7
+	adrp	x0, .LC309
+	ldr	w2, [x24]
+	add	x0, x0, :lo12:.LC309
+	mov	w3, w19
+	mov	w4, w21
+	ldr	x1, [x23,-48]
+	bl	printk
+	ldrb	w0, [x23,-52]
+	cbz	w0, .L3861
+	ldr	x22, [x23,-48]
+	cbz	x22, .L3861
 	sub	w0, w19, #64
-	ldr	x22, [x3,-48]
 	cmp	w0, 499
-	bhi	.L3804
+	bhi	.L3864
 	mov	w3, 564
 	ubfiz	x0, x0, 9, 25
 	sub	w3, w3, w19
 	add	x0, x22, x0
 	cmp	w3, w21
-	mov	x1, x23
+	mov	x1, x24
 	csel	w2, w3, w21, ls
 	lsl	w2, w2, 9
 	bl	ftl_memcpy
-	b	.L3805
-.L3804:
+	b	.L3865
+.L3864:
 	cmp	w19, 563
-	bhi	.L3815
-.L3805:
-	add	x0, x20, :lo12:.LANCHOR7
-	ldr	w1, [x0,-40]
-	cmp	w1, w19
-	beq	.L3813
-	strb	wzr, [x0,-52]
-	cbz	x22, .L3814
+	bhi	.L3875
+.L3865:
+	add	x23, x20, :lo12:.LANCHOR7
+	ldr	w0, [x23,-40]
+	cmp	w0, w19
+	beq	.L3873
 	mov	x0, x22
+	strb	wzr, [x23,-52]
 	bl	ftl_free
-.L3814:
-	add	x0, x20, :lo12:.LANCHOR7
-	str	xzr, [x0,-48]
-.L3813:
+	str	xzr, [x23,-48]
+.L3873:
 	add	x20, x20, :lo12:.LANCHOR7
 	add	w19, w19, w21
 	str	w19, [x20,-40]
-	b	.L3801
-.L3815:
-	ldr	w2, [x3,-40]
+	b	.L3861
+.L3875:
+	ldr	w2, [x23,-40]
 	mov	w0, 500
 	sub	w2, w2, #64
 	cmp	w2, 500
@@ -24132,66 +24541,64 @@ write_loader_lba:
 	ldr	x0, [x0,#:lo12:.LANCHOR0+624]
 	ldrb	w0, [x0,9]
 	cmp	w0, 4
-	beq	.L3816
+	beq	.L3876
 	mov	w0, 2
-	str	w0, [x29,64]
+	str	w0, [x29,72]
 	mov	w0, 3
-	str	w0, [x29,68]
+	str	w0, [x29,76]
 	mov	w0, 4
-	str	w0, [x29,72]
+	str	w0, [x29,80]
 	mov	w0, 5
-	str	w0, [x29,76]
+	str	w0, [x29,84]
 	mov	w0, 6
-	str	w0, [x29,80]
-	b	.L3807
-.L3816:
+	str	w0, [x29,88]
+	b	.L3867
+.L3876:
 	mov	x3, 0
-.L3806:
+.L3866:
 	cmp	w2, 256
-	add	x0, x29, 64
-	bls	.L3808
+	add	x0, x29, 72
+	bls	.L3868
 	lsl	w1, w3, 1
 	str	w1, [x0,x3,lsl 2]
-	b	.L3809
-.L3808:
+	b	.L3869
+.L3868:
 	str	w3, [x0,x3,lsl 2]
-.L3809:
+.L3869:
 	add	x3, x3, 1
 	cmp	x3, 5
-	bne	.L3806
-.L3807:
-	add	x0, x20, :lo12:.LANCHOR7
-	mov	w4, 63999
-	ldr	x3, [x0,-32]
-	add	x3, x3, 61440
-	add	x3, x3, 2559
-.L3812:
-	ldrb	w0, [x3]
-	cbz	w0, .L3810
-	add	w2, w4, 1
-	lsl	w0, w2, 2
-	b	.L3811
-.L3810:
-	sub	w4, w4, #1
-	sub	x3, x3, #1
-	cmp	w4, 4096
-	bne	.L3812
+	bne	.L3866
+.L3867:
+	add	x0, x22, 245760
+	mov	w3, 61952
+	add	x0, x0, 2048
+.L3872:
+	ldr	w1, [x0]
+	cbz	w1, .L3870
+	add	w3, w3, 2048
+	lsl	w0, w3, 2
+	b	.L3871
+.L3870:
+	sub	w3, w3, #1
+	sub	x0, x0, #4
+	cmp	w3, 4096
+	bne	.L3872
 	lsl	w0, w2, 9
-.L3811:
+.L3871:
 	mov	x1, x22
-	add	x2, x29, 64
+	add	x2, x29, 72
 	add	x22, x20, :lo12:.LANCHOR7
 	bl	write_idblock
 	ldr	x0, [x22,-48]
 	strb	wzr, [x22,-52]
 	bl	ftl_free
 	str	xzr, [x22,-48]
-	b	.L3813
-.L3801:
+	b	.L3873
+.L3861:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
-	ldr	x23, [sp,48]
-	ldp	x29, x30, [sp], 96
+	ldp	x23, x24, [sp,48]
+	ldp	x29, x30, [sp], 112
 	ret
 	.size	write_loader_lba, .-write_loader_lba
 	.align	2
@@ -24207,19 +24614,19 @@ FtlWrite:
 	cmp	w0, 1983
 	mov	w19, w1
 	mov	w20, w2
-	bhi	.L3826
-	cbnz	w21, .L3826
+	bhi	.L3886
+	cbnz	w21, .L3886
 	mov	w0, w1
 	mov	w1, w2
 	mov	x2, x3
 	str	x3, [x29,56]
 	bl	write_loader_lba
 	ldr	x3, [x29,56]
-.L3826:
-	adrp	x0, .LANCHOR4+1168
+.L3886:
+	adrp	x0, .LANCHOR4+1192
 	mov	w1, w19
 	mov	w2, w20
-	ldr	x0, [x0,#:lo12:.LANCHOR4+1168]
+	ldr	x0, [x0,#:lo12:.LANCHOR4+1192]
 	ldr	x4, [x0,48]
 	mov	w0, w21
 	blr	x4
@@ -24242,257 +24649,257 @@ rknand_sys_storage_ioctl:
 	stp	x21, x22, [sp,32]
 	mov	w19, w1
 	mov	x20, x2
-	beq	.L3835
+	beq	.L3895
 	mov	w0, 29187
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	bhi	.L3836
+	bhi	.L3896
 	mov	w0, 25726
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	beq	.L3837
+	beq	.L3897
 	mov	w0, 25726
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	bhi	.L3838
+	bhi	.L3898
 	mov	w0, 25601
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	beq	.L3839
+	beq	.L3899
 	mov	w0, 25601
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	bhi	.L3840
+	bhi	.L3900
 	mov	w0, 25364
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	bne	.L3897
+	bne	.L3957
 	bl	rknand_dev_flush
-	b	.L3931
-.L3840:
+	b	.L3991
+.L3900:
 	mov	w0, 25602
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	beq	.L3842
+	beq	.L3902
 	mov	w0, 25603
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	beq	.L3843
-	b	.L3897
-.L3838:
+	beq	.L3903
+	b	.L3957
+.L3898:
 	mov	w0, 27688
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	beq	.L3844
+	beq	.L3904
 	mov	w0, 27688
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	bhi	.L3845
+	bhi	.L3905
 	mov	w0, 25727
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	beq	.L3846
-	b	.L3897
-.L3845:
+	beq	.L3906
+	b	.L3957
+.L3905:
 	mov	w0, 27698
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	beq	.L3844
+	beq	.L3904
 	mov	w0, 27708
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	beq	.L3844
-	b	.L3897
-.L3836:
+	beq	.L3904
+	b	.L3957
+.L3896:
 	mov	w0, 29267
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	beq	.L3847
+	beq	.L3907
 	mov	w0, 29267
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	bhi	.L3848
+	bhi	.L3908
 	mov	w0, 29189
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	beq	.L3849
+	beq	.L3909
 	mov	w0, 29189
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	bcc	.L3850
+	bcc	.L3910
 	mov	w0, 29210
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	beq	.L3851
+	beq	.L3911
 	mov	w0, 29266
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	beq	.L3852
-	b	.L3897
-.L3848:
+	beq	.L3912
+	b	.L3957
+.L3908:
 	mov	w0, 30225
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	beq	.L3853
+	beq	.L3913
 	mov	w0, 30225
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	bhi	.L3854
+	bhi	.L3914
 	mov	w0, 29268
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	beq	.L3855
+	beq	.L3915
 	mov	w0, 30224
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	beq	.L3856
-	b	.L3897
-.L3854:
+	beq	.L3916
+	b	.L3957
+.L3914:
 	mov	w0, 30226
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	beq	.L3856
+	beq	.L3916
 	mov	w0, 30227
 	movk	w0, 0x4004, lsl 16
 	cmp	w1, w0
-	beq	.L3853
-	b	.L3897
-.L3850:
-	adrp	x0, .LC300
-	add	x0, x0, :lo12:.LC300
+	beq	.L3913
+	b	.L3957
+.L3910:
+	adrp	x0, .LC310
+	add	x0, x0, :lo12:.LC310
 	bl	printk
 	mov	w0, 4096
 	bl	ftl_malloc
 	mov	x19, x0
-	cbnz	x0, .L3857
-.L3862:
+	cbnz	x0, .L3917
+.L3922:
 	mov	x0, -12
-	b	.L3834
-.L3857:
+	b	.L3894
+.L3917:
 	mov	x1, x20
 	mov	x2, 512
 	bl	rk_copy_from_user
-	cbnz	x0, .L3938
-	adrp	x0, .LC302
+	cbnz	x0, .L3998
+	adrp	x0, .LC312
 	ldr	w1, [x19]
 	ldr	w2, [x19,4]
-	add	x0, x0, :lo12:.LC302
+	add	x0, x0, :lo12:.LC312
 	bl	printk
 	ldr	w0, [x19,4]
 	str	w0, [x29,52]
 	cmp	w0, 8
-	bhi	.L3935
+	bhi	.L3995
 	bl	rknand_device_lock
 	ldr	w1, [x29,52]
 	mov	x2, x19
 	ldr	w0, [x19]
-	bl	id_block_read_data.constprop.32
+	bl	id_block_read_data.constprop.30
 	bl	rknand_device_unlock
 	ldr	w2, [x29,52]
 	mov	x0, x20
 	mov	x1, x19
 	ubfiz	x2, x2, 9, 23
 	bl	rk_copy_to_user
-	cbz	x0, .L3941
-	adrp	x0, .LC303
-	add	x0, x0, :lo12:.LC303
-.L3933:
+	cbz	x0, .L4001
+	adrp	x0, .LC313
+	add	x0, x0, :lo12:.LC313
+.L3993:
 	bl	printk
-.L3935:
+.L3995:
 	mov	x0, x19
-.L3936:
+.L3996:
 	bl	ftl_free
-.L3934:
+.L3994:
 	mov	x0, -14
-	b	.L3834
-.L3849:
-	adrp	x0, .LC304
-	add	x0, x0, :lo12:.LC304
+	b	.L3894
+.L3909:
+	adrp	x0, .LC314
+	add	x0, x0, :lo12:.LC314
 	bl	printk
 	mov	w0, 4096
 	bl	ftl_malloc
 	mov	x19, x0
-	cbz	x0, .L3862
+	cbz	x0, .L3922
 	mov	x1, x20
 	mov	x2, 4096
 	bl	rk_copy_from_user
-	cbnz	x0, .L3938
-	adrp	x0, .LC305
+	cbnz	x0, .L3998
+	adrp	x0, .LC315
 	ldr	w1, [x19]
 	ldr	w2, [x19,4]
-	add	x0, x0, :lo12:.LC305
+	add	x0, x0, :lo12:.LC315
 	bl	printk
 	adrp	x0, .LANCHOR7
 	add	x22, x0, :lo12:.LANCHOR7
 	mov	x20, x0
 	ldr	x21, [x22,-32]
-	cbnz	x21, .L3864
+	cbnz	x21, .L3924
 	mov	w0, 260096
 	bl	ftl_malloc
 	str	x0, [x22,-32]
-	cbz	x0, .L3935
+	cbz	x0, .L3995
 	mov	w1, w21
 	mov	x2, 260096
 	bl	memset
-.L3864:
+.L3924:
 	ldr	w2, [x19,4]
 	cmp	w2, 4088
-	bhi	.L3935
+	bhi	.L3995
 	ldr	w0, [x19]
 	mov	w1, 55296
 	movk	w1, 0x3, lsl 16
 	cmp	w0, w1
-	bhi	.L3935
+	bhi	.L3995
 	add	x20, x20, :lo12:.LANCHOR7
 	uxtw	x2, w2
 	ldr	x1, [x20,-32]
 	add	x0, x1, x0, uxtw
 	add	x1, x19, 8
 	bl	memcpy
-.L3941:
+.L4001:
 	mov	x0, x19
 	bl	ftl_free
-	b	.L3931
-.L3852:
-	adrp	x0, .LC306
-	add	x0, x0, :lo12:.LC306
+	b	.L3991
+.L3912:
+	adrp	x0, .LC316
+	add	x0, x0, :lo12:.LC316
 	bl	printk
 	mov	w0, 4096
 	bl	ftl_malloc
 	mov	x19, x0
-	cbz	x0, .L3862
+	cbz	x0, .L3922
 	mov	x1, x20
 	mov	x2, 28
 	bl	rk_copy_from_user
-	cbz	x0, .L3867
-.L3938:
-	adrp	x0, .LC301
-	add	x0, x0, :lo12:.LC301
-	b	.L3933
-.L3867:
+	cbz	x0, .L3927
+.L3998:
+	adrp	x0, .LC311
+	add	x0, x0, :lo12:.LC311
+	b	.L3993
+.L3927:
 	ldr	w1, [x19]
-	adrp	x0, .LC307
+	adrp	x0, .LC317
 	ldr	w2, [x19,4]
-	add	x0, x0, :lo12:.LC307
+	add	x0, x0, :lo12:.LC317
 	bl	printk
 	ldr	w1, [x19]
 	mov	w0, 59392
 	movk	w0, 0x3, lsl 16
 	cmp	w1, w0
-	bhi	.L3935
+	bhi	.L3995
 	adrp	x20, .LANCHOR7
 	add	x20, x20, :lo12:.LANCHOR7
 	ldr	x0, [x20,-32]
-	cbz	x0, .L3935
+	cbz	x0, .L3995
 	bl	CRC_32
 	ldr	w1, [x19,4]
 	cmp	w1, w0
-	beq	.L3870
+	beq	.L3930
 	mov	x0, x19
 	bl	ftl_free
 	mov	x0, -2
-	b	.L3834
-.L3870:
+	b	.L3894
+.L3930:
 	bl	rknand_device_lock
 	ldr	x1, [x20,-32]
 	add	x2, x19, 8
@@ -24502,39 +24909,39 @@ rknand_sys_storage_ioctl:
 	ldr	x0, [x20,-32]
 	bl	ftl_free
 	str	xzr, [x20,-32]
-	b	.L3941
-.L3851:
-	adrp	x0, .LC308
-	add	x0, x0, :lo12:.LC308
+	b	.L4001
+.L3911:
+	adrp	x0, .LC318
+	add	x0, x0, :lo12:.LC318
 	bl	printk
 	mov	w0, 4096
 	bl	ftl_malloc
 	mov	x21, x0
-	cbz	x0, .L3862
+	cbz	x0, .L3922
 	bl	ReadFlashInfo
 	mov	x0, x20
 	mov	x1, x21
 	mov	x2, 11
-	b	.L3943
-.L3835:
-	adrp	x0, .LC309
-	add	x0, x0, :lo12:.LC309
+	b	.L4003
+.L3895:
+	adrp	x0, .LC319
+	add	x0, x0, :lo12:.LC319
 	bl	printk
 	bl	nand_blk_add_whole_disk
 	mov	w0, 4096
 	bl	ftl_malloc
 	mov	x21, x0
-	cbz	x0, .L3862
+	cbz	x0, .L3922
 	mov	w1, 0
 	mov	w2, 64
 	bl	ftl_memset
 	mov	x0, x20
 	mov	x1, x21
 	mov	x2, 64
-	b	.L3943
-.L3847:
-	adrp	x0, .LC310
-	add	x0, x0, :lo12:.LC310
+	b	.L4003
+.L3907:
+	adrp	x0, .LC320
+	add	x0, x0, :lo12:.LC320
 	bl	printk
 	adrp	x0, .LANCHOR7-24
 	add	x1, x29, 52
@@ -24543,18 +24950,18 @@ rknand_sys_storage_ioctl:
 	ldr	w0, [x0,20]
 	str	w0, [x29,52]
 	mov	x0, x20
-.L3926:
+.L3986:
 	bl	rk_copy_to_user
-	cbnz	x0, .L3934
-	b	.L3931
-.L3855:
-	adrp	x0, .LC311
-	add	x0, x0, :lo12:.LC311
+	cbnz	x0, .L3994
+	b	.L3991
+.L3915:
+	adrp	x0, .LC321
+	add	x0, x0, :lo12:.LC321
 	bl	printk
 	mov	w0, 4096
 	bl	ftl_malloc
 	mov	x21, x0
-	cbz	x0, .L3862
+	cbz	x0, .L3922
 	bl	rknand_device_lock
 	mov	w1, 264
 	mov	w2, 2
@@ -24565,41 +24972,41 @@ rknand_sys_storage_ioctl:
 	mov	x0, x20
 	mov	x1, x21
 	mov	x2, 1024
-.L3943:
+.L4003:
 	bl	rk_copy_to_user
 	mov	x19, x0
 	mov	x0, x21
-	cbnz	x19, .L3936
+	cbnz	x19, .L3996
 	bl	ftl_free
-	b	.L3861
-.L3839:
-	adrp	x0, .LC312
-	add	x0, x0, :lo12:.LC312
+	b	.L3921
+.L3899:
+	adrp	x0, .LC322
+	add	x0, x0, :lo12:.LC322
 	bl	printk
 	add	x0, x29, 56
 	mov	x1, x20
 	mov	x2, 520
 	bl	rk_copy_from_user
 	mov	x19, x0
-	cbz	x0, .L3875
-.L3880:
-	adrp	x0, .LC301
-	add	x0, x0, :lo12:.LC301
+	cbz	x0, .L3935
+.L3940:
+	adrp	x0, .LC311
+	add	x0, x0, :lo12:.LC311
 	bl	printk
-	b	.L3934
-.L3875:
+	b	.L3994
+.L3935:
 	ldr	w1, [x29,56]
 	mov	w0, 21060
 	movk	w0, 0x4b4d, lsl 16
 	cmp	w1, w0
-	beq	.L3876
-.L3877:
+	beq	.L3936
+.L3937:
 	mov	x19, -1
-	b	.L3861
-.L3876:
+	b	.L3921
+.L3936:
 	ldr	w0, [x29,60]
 	cmp	w0, 512
-	bhi	.L3877
+	bhi	.L3937
 	adrp	x21, .LANCHOR7
 	add	x0, x29, 56
 	add	x21, x21, :lo12:.LANCHOR7
@@ -24610,37 +25017,37 @@ rknand_sys_storage_ioctl:
 	mov	w0, 5161
 	movk	w0, 0xc059, lsl 16
 	cmp	w1, w0
-	beq	.L3878
+	beq	.L3938
 	add	x0, x29, 120
 	mov	w1, w19
 	mov	x2, 128
 	str	w19, [x29,64]
 	str	w19, [x29,68]
 	bl	memset
-.L3878:
+.L3938:
 	add	x0, x29, 312
 	mov	w1, 0
 	mov	x2, 256
 	str	wzr, [x29,72]
 	bl	memset
-	b	.L3940
-.L3842:
-	adrp	x0, .LC313
-	add	x0, x0, :lo12:.LC313
+	b	.L4000
+.L3902:
+	adrp	x0, .LC323
+	add	x0, x0, :lo12:.LC323
 	bl	printk
 	add	x0, x29, 56
 	mov	x1, x20
 	mov	x2, 520
 	bl	rk_copy_from_user
-	cbnz	x0, .L3880
+	cbnz	x0, .L3940
 	ldr	w1, [x29,56]
 	mov	w0, 21060
 	movk	w0, 0x4b4d, lsl 16
 	cmp	w1, w0
-	bne	.L3877
+	bne	.L3937
 	ldr	w0, [x29,60]
 	cmp	w0, 512
-	bhi	.L3877
+	bhi	.L3937
 	adrp	x1, .LANCHOR7
 	mov	w2, 5161
 	add	x1, x1, :lo12:.LANCHOR7
@@ -24648,12 +25055,12 @@ rknand_sys_storage_ioctl:
 	mov	x0, -2
 	ldr	w3, [x1,-16]
 	cmp	w3, w2
-	bne	.L3834
+	bne	.L3894
 	ldr	w2, [x29,68]
 	mov	x0, -3
 	sub	w3, w2, #1
 	cmp	w3, 127
-	bhi	.L3834
+	bhi	.L3894
 	ldr	x19, [x1,-24]
 	add	x1, x29, 120
 	add	x0, x19, 64
@@ -24662,38 +25069,38 @@ rknand_sys_storage_ioctl:
 	bl	memcpy
 	mov	w0, 1
 	mov	x1, x19
-	b	.L3932
-.L3846:
-	adrp	x0, .LC314
-	add	x0, x0, :lo12:.LC314
+	b	.L3992
+.L3906:
+	adrp	x0, .LC324
+	add	x0, x0, :lo12:.LC324
 	bl	printk
 	add	x0, x29, 56
 	mov	x1, x20
 	mov	x2, 520
 	bl	rk_copy_from_user
-	cbnz	x0, .L3880
+	cbnz	x0, .L3940
 	ldr	w1, [x29,56]
 	mov	w0, 17476
 	movk	w0, 0x4253, lsl 16
 	cmp	w1, w0
-	bne	.L3877
+	bne	.L3937
 	ldr	w0, [x29,60]
 	cmp	w0, 512
-	bhi	.L3877
+	bhi	.L3937
 	adrp	x19, .LANCHOR7
 	add	x0, x19, :lo12:.LANCHOR7
 	ldr	w1, [x0,-12]
-	cbnz	w1, .L3881
-.L3884:
+	cbnz	w1, .L3941
+.L3944:
 	mov	x0, 0
-	b	.L3834
-.L3881:
+	b	.L3894
+.L3941:
 	ldr	x1, [x0,-8]
 	mov	w2, 22867
 	movk	w2, 0x4453, lsl 16
 	ldr	w3, [x1]
 	cmp	w3, w2
-	beq	.L3882
+	beq	.L3942
 	mov	w2, 22867
 	movk	w2, 0x4453, lsl 16
 	str	w2, [x1]
@@ -24703,7 +25110,7 @@ rknand_sys_storage_ioctl:
 	ldr	x0, [x0,-8]
 	str	wzr, [x0,8]
 	str	wzr, [x0,12]
-.L3882:
+.L3942:
 	add	x20, x19, :lo12:.LANCHOR7
 	mov	w0, 0
 	ldr	x1, [x20,-8]
@@ -24714,7 +25121,7 @@ rknand_sys_storage_ioctl:
 	movk	w1, 0x4b4d, lsl 16
 	ldr	w2, [x0]
 	cmp	w2, w1
-	beq	.L3883
+	beq	.L3943
 	mov	w1, 21060
 	movk	w1, 0x4b4d, lsl 16
 	str	w1, [x0]
@@ -24723,7 +25130,7 @@ rknand_sys_storage_ioctl:
 	str	w1, [x0,4]
 	ldr	x0, [x20,-24]
 	str	wzr, [x0,8]
-.L3883:
+.L3943:
 	add	x19, x19, :lo12:.LANCHOR7
 	mov	w1, 0
 	mov	x2, 128
@@ -24736,35 +25143,35 @@ rknand_sys_storage_ioctl:
 	bl	StorageSysDataStore
 	str	wzr, [x19,-12]
 	str	wzr, [x19,-16]
-	b	.L3931
-.L3837:
-	adrp	x0, .LC315
-	add	x0, x0, :lo12:.LC315
+	b	.L3991
+.L3897:
+	adrp	x0, .LC325
+	add	x0, x0, :lo12:.LC325
 	bl	printk
 	add	x0, x29, 56
 	mov	x1, x20
 	mov	x2, 520
 	bl	rk_copy_from_user
-	cbnz	x0, .L3880
+	cbnz	x0, .L3940
 	ldr	w2, [x29,56]
 	mov	w1, 20037
 	movk	w1, 0x4253, lsl 16
 	cmp	w2, w1
-	bne	.L3877
+	bne	.L3937
 	ldr	w1, [x29,60]
 	cmp	w1, 512
-	bhi	.L3877
+	bhi	.L3937
 	adrp	x19, .LANCHOR7
 	add	x1, x19, :lo12:.LANCHOR7
 	ldr	w2, [x1,-12]
 	cmp	w2, 1
-	beq	.L3884
+	beq	.L3944
 	ldr	x2, [x1,-8]
 	mov	w3, 22867
 	movk	w3, 0x4453, lsl 16
 	ldr	w4, [x2]
 	cmp	w4, w3
-	beq	.L3885
+	beq	.L3945
 	mov	w3, 22867
 	movk	w3, 0x4453, lsl 16
 	str	w3, [x2]
@@ -24774,7 +25181,7 @@ rknand_sys_storage_ioctl:
 	ldr	x1, [x1,-8]
 	str	w0, [x1,8]
 	str	w0, [x1,12]
-.L3885:
+.L3945:
 	add	x20, x19, :lo12:.LANCHOR7
 	mov	w0, 1
 	ldr	x1, [x20,-8]
@@ -24786,7 +25193,7 @@ rknand_sys_storage_ioctl:
 	movk	w1, 0x4b4d, lsl 16
 	ldr	w2, [x0]
 	cmp	w2, w1
-	beq	.L3886
+	beq	.L3946
 	mov	w1, 21060
 	movk	w1, 0x4b4d, lsl 16
 	str	w1, [x0]
@@ -24795,7 +25202,7 @@ rknand_sys_storage_ioctl:
 	str	w1, [x0,4]
 	ldr	x0, [x20,-24]
 	str	wzr, [x0,8]
-.L3886:
+.L3946:
 	add	x19, x19, :lo12:.LANCHOR7
 	mov	w1, 0
 	mov	x2, 128
@@ -24808,65 +25215,65 @@ rknand_sys_storage_ioctl:
 	bl	StorageSysDataStore
 	mov	w0, 1
 	str	w0, [x19,-12]
-	b	.L3931
-.L3843:
-	adrp	x0, .LC316
-	add	x0, x0, :lo12:.LC316
+	b	.L3991
+.L3903:
+	adrp	x0, .LC326
+	add	x0, x0, :lo12:.LC326
 	bl	printk
 	add	x0, x29, 56
 	mov	x1, x20
 	mov	x2, 520
 	bl	rk_copy_from_user
-	cbnz	x0, .L3880
+	cbnz	x0, .L3940
 	ldr	w1, [x29,56]
 	mov	w0, 20051
 	movk	w0, 0x4144, lsl 16
 	cmp	w1, w0
-	bne	.L3877
+	bne	.L3937
 	ldr	w2, [x29,60]
 	cmp	w2, 512
-	bhi	.L3877
+	bhi	.L3937
 	adrp	x1, .LANCHOR7
 	add	x0, x29, 64
 	add	x1, x1, :lo12:.LANCHOR7
 	uxtw	x2, w2
-	b	.L3939
-.L3844:
+	b	.L3999
+.L3904:
 	mov	w0, 27698
 	movk	w0, 0x4004, lsl 16
 	cmp	w19, w0
-	bne	.L3887
-	adrp	x0, .LC317
-	add	x0, x0, :lo12:.LC317
-	b	.L3929
-.L3887:
+	bne	.L3947
+	adrp	x0, .LC327
+	add	x0, x0, :lo12:.LC327
+	b	.L3989
+.L3947:
 	mov	w0, 27708
 	movk	w0, 0x4004, lsl 16
 	cmp	w19, w0
-	bne	.L3889
-	adrp	x0, .LC318
-	add	x0, x0, :lo12:.LC318
-	b	.L3929
-.L3889:
-	adrp	x0, .LC319
-	add	x0, x0, :lo12:.LC319
-.L3929:
+	bne	.L3949
+	adrp	x0, .LC328
+	add	x0, x0, :lo12:.LC328
+	b	.L3989
+.L3949:
+	adrp	x0, .LC329
+	add	x0, x0, :lo12:.LC329
+.L3989:
 	bl	printk
 	add	x0, x29, 56
 	mov	x1, x20
 	mov	x2, 520
 	bl	rk_copy_from_user
-	cbnz	x0, .L3880
+	cbnz	x0, .L3940
 	ldr	w1, [x29,56]
 	mov	w0, 17227
 	movk	w0, 0x4c4f, lsl 16
 	cmp	w1, w0
-	bne	.L3934
+	bne	.L3994
 	mov	w0, 27708
 	movk	w0, 0x4004, lsl 16
 	cmp	w19, w0
 	adrp	x0, .LANCHOR7
-	bne	.L3890
+	bne	.L3950
 	add	x0, x0, :lo12:.LANCHOR7
 	add	x1, x29, 56
 	mov	x2, 16
@@ -24876,65 +25283,65 @@ rknand_sys_storage_ioctl:
 	strb	w0, [x29,64]
 	mov	x0, x20
 	bl	rk_copy_to_user
-	cbz	x0, .L3834
-	b	.L3934
-.L3890:
+	cbz	x0, .L3894
+	b	.L3994
+.L3950:
 	add	x20, x0, :lo12:.LANCHOR7
 	ldr	w1, [x20,512]
 	cmp	w1, 10
-	bhi	.L3934
+	bhi	.L3994
 	ldr	x1, [x20,-24]
 	ldr	w2, [x29,60]
 	ldr	w3, [x1,24]
 	cmp	w3, w2
-	beq	.L3891
-	cbz	w3, .L3891
-	adrp	x0, .LC320
+	beq	.L3951
+	cbz	w3, .L3951
+	adrp	x0, .LC330
 	mov	w1, w2
-	add	x0, x0, :lo12:.LC320
+	add	x0, x0, :lo12:.LC330
 	bl	printk
 	ldr	w0, [x20,512]
 	add	w0, w0, 1
 	str	w0, [x20,512]
-	b	.L3934
-.L3891:
+	b	.L3994
+.L3951:
 	add	x0, x0, :lo12:.LANCHOR7
 	str	wzr, [x0,512]
 	mov	w0, 27698
 	movk	w0, 0x4004, lsl 16
 	cmp	w19, w0
-	bne	.L3892
+	bne	.L3952
 	str	wzr, [x1,20]
 	str	wzr, [x1,24]
-	b	.L3893
-.L3892:
+	b	.L3953
+.L3952:
 	mov	w0, 1
 	str	w2, [x1,24]
 	str	w0, [x1,20]
-.L3893:
+.L3953:
 	mov	w0, 1
 	mov	x19, -2
 	bl	StorageSysDataStore
 	cmn	w0, #1
-	bne	.L3931
-	b	.L3861
-.L3856:
-	adrp	x0, .LC321
-	add	x0, x0, :lo12:.LC321
+	bne	.L3991
+	b	.L3921
+.L3916:
+	adrp	x0, .LC331
+	add	x0, x0, :lo12:.LC331
 	bl	printk
 	add	x0, x29, 56
 	mov	x1, x20
 	mov	x2, 520
 	bl	rk_copy_from_user
-	cbnz	x0, .L3880
+	cbnz	x0, .L3940
 	ldr	w1, [x29,56]
 	mov	w0, 17750
 	movk	w0, 0x444e, lsl 16
 	cmp	w1, w0
-	bne	.L3877
+	bne	.L3937
 	ldr	w2, [x29,60]
 	cmp	w2, 504
-	bhi	.L3877
+	bhi	.L3937
 	mov	w0, 30224
 	adrp	x1, .LANCHOR7
 	movk	w0, 0x4004, lsl 16
@@ -24942,72 +25349,72 @@ rknand_sys_storage_ioctl:
 	cmp	w19, w0
 	add	x1, x1, :lo12:.LANCHOR7
 	add	x0, x29, 64
-	bne	.L3894
+	bne	.L3954
 	ldr	x1, [x1,520]
-	b	.L3930
-.L3894:
+	b	.L3990
+.L3954:
 	ldr	x1, [x1,528]
-.L3930:
+.L3990:
 	add	x1, x1, 8
-.L3939:
+.L3999:
 	bl	memcpy
-.L3940:
+.L4000:
 	mov	x0, x20
 	add	x1, x29, 56
 	mov	x2, 520
-	b	.L3926
-.L3853:
-	adrp	x0, .LC322
-	add	x0, x0, :lo12:.LC322
+	b	.L3986
+.L3913:
+	adrp	x0, .LC332
+	add	x0, x0, :lo12:.LC332
 	bl	printk
 	add	x0, x29, 56
 	mov	x1, x20
 	mov	x2, 520
 	bl	rk_copy_from_user
-	cbnz	x0, .L3880
+	cbnz	x0, .L3940
 	ldr	w1, [x29,56]
 	mov	w0, 17750
 	movk	w0, 0x444e, lsl 16
 	cmp	w1, w0
-	bne	.L3877
+	bne	.L3937
 	ldr	w2, [x29,60]
 	cmp	w2, 504
-	bhi	.L3877
+	bhi	.L3937
 	mov	w0, 30225
 	add	w2, w2, 8
 	movk	w0, 0x4004, lsl 16
 	cmp	w19, w0
 	adrp	x19, .LANCHOR7
 	add	x19, x19, :lo12:.LANCHOR7
-	bne	.L3896
+	bne	.L3956
 	ldr	x0, [x19,520]
 	add	x1, x29, 56
 	bl	memcpy
 	mov	w0, 2
 	ldr	x1, [x19,520]
-	b	.L3932
-.L3896:
+	b	.L3992
+.L3956:
 	ldr	x0, [x19,528]
 	add	x1, x29, 56
 	bl	memcpy
 	ldr	x1, [x19,528]
 	mov	w0, 3
-.L3932:
+.L3992:
 	bl	StorageSysDataStore
 	uxtw	x19, w0
-	b	.L3861
-.L3931:
+	b	.L3921
+.L3991:
 	mov	x19, 0
-.L3861:
-	adrp	x0, .LC323
+.L3921:
+	adrp	x0, .LC333
 	mov	x1, x19
-	add	x0, x0, :lo12:.LC323
+	add	x0, x0, :lo12:.LC333
 	bl	printk
 	mov	x0, x19
-	b	.L3834
-.L3897:
+	b	.L3894
+.L3957:
 	mov	x0, -22
-.L3834:
+.L3894:
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
 	ldp	x29, x30, [sp], 48
@@ -25046,25 +25453,25 @@ rk_ftl_storage_sys_init:
 	ldr	w1, [x0,16]
 	ldr	w21, [x0,508]
 	str	w1, [x19,-12]
-	cbz	w21, .L3947
+	cbz	w21, .L4007
 	mov	w1, 508
 	bl	js_hash
 	cmp	w21, w0
-	beq	.L3947
+	beq	.L4007
 	ldr	x0, [x19,-8]
 	str	wzr, [x19,-12]
 	str	wzr, [x0,16]
-	adrp	x0, .LC324
-	add	x0, x0, :lo12:.LC324
+	adrp	x0, .LC334
+	add	x0, x0, :lo12:.LC334
 	bl	printk
-.L3947:
+.L4007:
 	add	x0, x20, :lo12:.LANCHOR7
 	ldr	w1, [x0,-12]
-	cbz	w1, .L3949
+	cbz	w1, .L4009
 	mov	w1, 5161
 	movk	w1, 0xc059, lsl 16
 	str	w1, [x0,-16]
-.L3949:
+.L4009:
 	add	x20, x20, :lo12:.LANCHOR7
 	mov	w0, 2
 	ldr	x1, [x20,520]
@@ -25100,19 +25507,19 @@ rk_ftl_vendor_storage_init:
 	add	x1, x21, :lo12:.LANCHOR7
 	mov	w19, -12
 	str	x0, [x1,536]
-	cbz	x0, .L3955
+	cbz	x0, .L4015
 	mov	w23, 0
-	adrp	x24, .LC325
+	adrp	x24, .LC335
 	mov	w19, w23
 	mov	w22, w23
-	add	x24, x24, :lo12:.LC325
-.L3959:
+	add	x24, x24, :lo12:.LC335
+.L4019:
 	add	x20, x21, :lo12:.LANCHOR7
 	lsl	w0, w22, 7
 	mov	w1, 128
 	ldr	x2, [x20,536]
 	bl	FlashBootVendorRead
-	cbnz	w0, .L3956
+	cbnz	w0, .L4016
 	ldr	x3, [x20,536]
 	mov	x0, x24
 	add	x2, x3, 61440
@@ -25125,29 +25532,29 @@ rk_ftl_vendor_storage_init:
 	movk	w0, 0x524b, lsl 16
 	ldr	w1, [x20]
 	cmp	w1, w0
-	bne	.L3957
+	bne	.L4017
 	ldr	w0, [x20,4]
 	cmp	w19, w0
-	bcs	.L3957
+	bcs	.L4017
 	add	x1, x20, 61440
 	ldr	w1, [x1,4092]
 	cmp	w1, w0
 	csel	w23, w23, w22, ne
 	csel	w19, w19, w0, ne
-.L3957:
-	cbnz	w22, .L3967
+.L4017:
+	cbnz	w22, .L4027
 	mov	w22, 1
-	b	.L3959
-.L3967:
-	cbz	w19, .L3960
+	b	.L4019
+.L4027:
+	cbz	w19, .L4020
 	lsl	w0, w23, 7
 	mov	w1, 128
 	mov	x2, x20
 	bl	FlashBootVendorRead
 	mov	w19, w0
-	cbz	w0, .L3955
-	b	.L3956
-.L3960:
+	cbz	w0, .L4015
+	b	.L4016
+.L4020:
 	mov	x0, x20
 	mov	w1, w19
 	mov	x2, 65536
@@ -25161,14 +25568,14 @@ rk_ftl_vendor_storage_init:
 	mov	w0, -1032
 	strh	w19, [x20,12]
 	strh	w0, [x20,14]
-	b	.L3955
-.L3956:
+	b	.L4015
+.L4016:
 	add	x21, x21, :lo12:.LANCHOR7
 	mov	w19, -1
 	ldr	x0, [x21,536]
 	bl	kfree
 	str	xzr, [x21,536]
-.L3955:
+.L4015:
 	mov	w0, w19
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
@@ -25186,18 +25593,18 @@ rk_ftl_vendor_read:
 	ldr	x5, [x3,#:lo12:.LANCHOR7+536]
 	mov	w3, -1
 	str	x19, [sp,16]
-	cbz	x5, .L3969
+	cbz	x5, .L4029
 	ldrh	w3, [x5,10]
 	mov	x4, 0
-.L3970:
+.L4030:
 	cmp	w4, w3
 	mov	w6, w4
-	bcs	.L3974
+	bcs	.L4034
 	add	x7, x5, x4, lsl 3
 	add	x4, x4, 1
 	ldrh	w7, [x7,16]
 	cmp	w7, w0
-	bne	.L3970
+	bne	.L4030
 	add	x6, x5, x6, uxtw 3
 	ldrh	w4, [x6,20]
 	mov	x0, x1
@@ -25209,10 +25616,10 @@ rk_ftl_vendor_read:
 	uxtw	x2, w19
 	bl	memcpy
 	mov	w3, w19
-	b	.L3969
-.L3974:
+	b	.L4029
+.L4034:
 	mov	w3, -1
-.L3969:
+.L4029:
 	mov	w0, w3
 	ldr	x19, [sp,16]
 	ldp	x29, x30, [sp], 32
@@ -25235,38 +25642,38 @@ rk_ftl_vendor_write:
 	mov	w26, w2
 	mov	x28, x1
 	mov	w2, -1
-	cbz	x19, .L3976
+	cbz	x19, .L4036
 	add	w20, w26, 63
 	ldrh	w3, [x19,10]
 	ldrh	w23, [x19,8]
 	and	w20, w20, -64
 	mov	x2, 0
-.L3977:
+.L4037:
 	cmp	w2, w3
 	mov	w4, w2
-	bcs	.L3992
+	bcs	.L4052
 	add	x0, x19, x2, lsl 3
 	add	x2, x2, 1
 	ldrh	w0, [x0,16]
 	cmp	w0, w6
-	bne	.L3977
+	bne	.L4037
 	add	x21, x19, x4, uxtw 3
 	ldrh	w24, [x21,20]
 	add	x5, x19, 1024
 	add	w24, w24, 63
 	and	w24, w24, -64
 	cmp	w26, w24
-	bls	.L3978
+	bls	.L4038
 	ldrh	w0, [x19,14]
 	mov	w2, -1
 	cmp	w0, w20
-	bcc	.L3976
+	bcc	.L4036
 	ldrh	w21, [x21,18]
 	add	w22, w3, w2
-.L3979:
+.L4039:
 	cmp	w4, w22
 	uxtw	x3, w4
-	bcs	.L3993
+	bcs	.L4053
 	add	x3, x19, x3, lsl 3
 	add	w25, w4, 1
 	add	x1, x19, x25, uxtw 3
@@ -25289,8 +25696,8 @@ rk_ftl_vendor_write:
 	mov	w4, w25
 	ldr	x6, [x29,96]
 	ldr	x5, [x29,104]
-	b	.L3979
-.L3993:
+	b	.L4039
+.L4053:
 	add	x3, x19, x3, lsl 3
 	uxth	w21, w21
 	mov	x1, x28
@@ -25307,20 +25714,20 @@ rk_ftl_vendor_write:
 	add	w24, w24, w0
 	sub	w24, w24, w20
 	strh	w24, [x19,14]
-	b	.L3991
-.L3978:
+	b	.L4051
+.L4038:
 	ldrh	w0, [x21,18]
 	mov	x1, x28
 	uxtw	x2, w26
 	add	x0, x5, x0
 	bl	memcpy
 	strh	w26, [x21,20]
-	b	.L3991
-.L3992:
+	b	.L4051
+.L4052:
 	ldrh	w4, [x19,14]
 	mov	w2, -1
 	cmp	w4, w20
-	bcc	.L3976
+	bcc	.L4036
 	add	x3, x19, x3, uxth 3
 	strh	w6, [x3,16]
 	uxth	w20, w20
@@ -25340,7 +25747,7 @@ rk_ftl_vendor_write:
 	ldrh	w0, [x19,10]
 	add	w0, w0, 1
 	strh	w0, [x19,10]
-.L3991:
+.L4051:
 	ldr	w0, [x19,4]
 	add	x1, x19, 61440
 	mov	x2, x19
@@ -25357,7 +25764,7 @@ rk_ftl_vendor_write:
 	lsl	w0, w23, 7
 	bl	FlashBootVendorWrite
 	mov	w2, 0
-.L3976:
+.L4036:
 	mov	w0, w2
 	ldp	x19, x20, [sp,16]
 	ldp	x21, x22, [sp,32]
@@ -25381,37 +25788,37 @@ rk_ftl_vendor_storage_ioctl:
 	mov	x21, x2
 	bl	ftl_malloc
 	mov	x19, x0
-	cbz	x0, .L3995
+	cbz	x0, .L4055
 	mov	w2, 30209
 	ldr	x1, [x29,56]
 	movk	w2, 0x4004, lsl 16
 	cmp	w1, w2
-	beq	.L3997
+	beq	.L4057
 	mov	w2, 30210
 	movk	w2, 0x4004, lsl 16
 	cmp	w1, w2
-	beq	.L3998
-	b	.L4009
-.L3997:
+	beq	.L4058
+	b	.L4069
+.L4057:
 	mov	x1, x21
 	mov	x2, 8
 	bl	rk_copy_from_user
-	cbnz	x0, .L4009
+	cbnz	x0, .L4069
 	ldr	w1, [x19]
 	mov	w0, 17745
 	movk	w0, 0x5652, lsl 16
 	cmp	w1, w0
-	beq	.L4000
-.L4001:
+	beq	.L4060
+.L4061:
 	mov	x20, -1
-	b	.L3996
-.L4000:
+	b	.L4056
+.L4060:
 	ldrh	w0, [x19,4]
 	add	x1, x19, 8
 	ldrh	w2, [x19,6]
 	bl	rk_ftl_vendor_read
 	cmn	w0, #1
-	beq	.L4001
+	beq	.L4061
 	uxth	x2, w0
 	strh	w0, [x19,6]
 	mov	x1, x19
@@ -25421,38 +25828,38 @@ rk_ftl_vendor_storage_ioctl:
 	bl	rk_copy_to_user
 	cmp	x0, xzr
 	csel	x20, xzr, x20, eq
-	b	.L3996
-.L3998:
+	b	.L4056
+.L4058:
 	mov	x1, x21
 	mov	x2, 8
 	bl	rk_copy_from_user
-	cbnz	x0, .L4009
+	cbnz	x0, .L4069
 	ldr	w1, [x19]
 	mov	w0, 17745
 	movk	w0, 0x5652, lsl 16
 	cmp	w1, w0
-	bne	.L4001
+	bne	.L4061
 	ldrh	w3, [x19,6]
 	cmp	w3, 4087
-	bhi	.L4001
+	bhi	.L4061
 	add	w2, w3, 8
 	mov	x0, x19
 	mov	x1, x21
 	sxtw	x2, w2
 	bl	rk_copy_from_user
-	cbnz	x0, .L4009
+	cbnz	x0, .L4069
 	ldrh	w0, [x19,4]
 	add	x1, x19, 8
 	ldrh	w2, [x19,6]
 	bl	rk_ftl_vendor_write
 	sxtw	x20, w0
-	b	.L3996
-.L4009:
+	b	.L4056
+.L4069:
 	mov	x20, -14
-.L3996:
+.L4056:
 	mov	x0, x19
 	bl	kfree
-.L3995:
+.L4055:
 	mov	x0, x20
 	ldr	x21, [sp,32]
 	ldp	x19, x20, [sp,16]
@@ -25632,24 +26039,24 @@ rk_ftl_vendor_storage_ioctl:
 	.section	.rodata
 	.align	3
 .LANCHOR1 = . + 0
-	.type	__func__.34106, %object
-	.size	__func__.34106, 18
-__func__.34106:
+	.type	__func__.34137, %object
+	.size	__func__.34137, 18
+__func__.34137:
 	.string	"_list_remove_node"
 	.zero	6
-	.type	__func__.34131, %object
-	.size	__func__.34131, 23
-__func__.34131:
+	.type	__func__.34162, %object
+	.size	__func__.34162, 23
+__func__.34162:
 	.string	"_list_update_data_list"
 	.zero	1
-	.type	__func__.19084, %object
-	.size	__func__.19084, 22
-__func__.19084:
+	.type	__func__.19088, %object
+	.size	__func__.19088, 22
+__func__.19088:
 	.string	"nand_flash_print_info"
 	.zero	2
-	.type	__func__.19170, %object
-	.size	__func__.19170, 11
-__func__.19170:
+	.type	__func__.19174, %object
+	.size	__func__.19174, 11
+__func__.19174:
 	.string	"nandc_init"
 	.zero	5
 	.type	toshiba_A19ref_value, %object
@@ -25811,14 +26218,14 @@ toshiba_ref_value:
 	.byte	8
 	.byte	12
 	.byte	112
-	.type	__func__.18640, %object
-	.size	__func__.18640, 28
-__func__.18640:
+	.type	__func__.18644, %object
+	.size	__func__.18644, 28
+__func__.18644:
 	.string	"flash_wait_device_ready_raw"
 	.zero	4
-	.type	__func__.18704, %object
-	.size	__func__.18704, 22
-__func__.18704:
+	.type	__func__.18708, %object
+	.size	__func__.18708, 22
+__func__.18708:
 	.string	"flash_start_page_read"
 	.zero	2
 	.type	toshiba_3D_tlc_value, %object
@@ -26239,19 +26646,19 @@ toshiba_3D_slc_value:
 	.byte	-56
 	.byte	56
 	.zero	5
-	.type	__func__.18729, %object
-	.size	__func__.18729, 23
-__func__.18729:
+	.type	__func__.18733, %object
+	.size	__func__.18733, 23
+__func__.18733:
 	.string	"flash_start_plane_read"
 	.zero	1
-	.type	__func__.18615, %object
-	.size	__func__.18615, 26
-__func__.18615:
+	.type	__func__.18619, %object
+	.size	__func__.18619, 26
+__func__.18619:
 	.string	"flash_erase_duplane_block"
 	.zero	6
-	.type	__func__.18626, %object
-	.size	__func__.18626, 21
-__func__.18626:
+	.type	__func__.18630, %object
+	.size	__func__.18630, 21
+__func__.18630:
 	.string	"flash_erase_block_en"
 	.zero	3
 	.type	random_seed, %object
@@ -26385,19 +26792,19 @@ random_seed:
 	.hword	28406
 	.hword	17598
 	.hword	28087
-	.type	__func__.19349, %object
-	.size	__func__.19349, 13
-__func__.19349:
+	.type	__func__.19353, %object
+	.size	__func__.19353, 13
+__func__.19353:
 	.string	"buf_add_tail"
 	.zero	3
-	.type	__func__.19362, %object
-	.size	__func__.19362, 10
-__func__.19362:
+	.type	__func__.19366, %object
+	.size	__func__.19366, 10
+__func__.19366:
 	.string	"buf_alloc"
 	.zero	6
-	.type	__func__.19376, %object
-	.size	__func__.19376, 16
-__func__.19376:
+	.type	__func__.19380, %object
+	.size	__func__.19380, 16
+__func__.19380:
 	.string	"buf_remove_free"
 	.type	zftl_debug_proc_fops, %object
 	.size	zftl_debug_proc_fops, 216
@@ -26411,254 +26818,254 @@ zftl_debug_proc_fops:
 	.zero	8
 	.xword	single_release
 	.zero	104
-	.type	__func__.33701, %object
-	.size	__func__.33701, 12
-__func__.33701:
+	.type	__func__.33706, %object
+	.size	__func__.33706, 12
+__func__.33706:
 	.string	"gc_add_sblk"
 	.zero	4
-	.type	__func__.33769, %object
-	.size	__func__.33769, 19
-__func__.33769:
+	.type	__func__.33800, %object
+	.size	__func__.33800, 19
+__func__.33800:
 	.string	"gc_write_completed"
 	.zero	5
-	.type	__func__.33820, %object
-	.size	__func__.33820, 16
-__func__.33820:
-	.string	"gc_free_src_blk"
-	.type	__func__.34312, %object
-	.size	__func__.34312, 18
-__func__.34312:
+	.type	__func__.34344, %object
+	.size	__func__.34344, 18
+__func__.34344:
 	.string	"ftl_alloc_sys_blk"
 	.zero	6
-	.type	__func__.34322, %object
-	.size	__func__.34322, 17
-__func__.34322:
+	.type	__func__.34354, %object
+	.size	__func__.34354, 17
+__func__.34354:
 	.string	"ftl_free_sys_blk"
 	.zero	7
-	.type	__func__.34433, %object
-	.size	__func__.34433, 23
-__func__.34433:
+	.type	__func__.34465, %object
+	.size	__func__.34465, 23
+__func__.34465:
 	.string	"ftl_get_ppa_from_index"
 	.zero	1
-	.type	__func__.34472, %object
-	.size	__func__.34472, 22
-__func__.34472:
+	.type	__func__.34505, %object
+	.size	__func__.34505, 22
+__func__.34505:
 	.string	"ftl_get_new_free_page"
 	.zero	2
-	.type	__func__.34483, %object
-	.size	__func__.34483, 22
-__func__.34483:
+	.type	__func__.34516, %object
+	.size	__func__.34516, 22
+__func__.34516:
 	.string	"ftl_ext_alloc_new_blk"
 	.zero	2
-	.type	__func__.33455, %object
-	.size	__func__.33455, 14
-__func__.33455:
+	.type	__func__.33851, %object
+	.size	__func__.33851, 16
+__func__.33851:
+	.string	"gc_free_src_blk"
+	.type	__func__.33459, %object
+	.size	__func__.33459, 14
+__func__.33459:
 	.string	"ftl_write_buf"
 	.zero	2
-	.type	__func__.33499, %object
-	.size	__func__.33499, 18
-__func__.33499:
+	.type	__func__.33504, %object
+	.size	__func__.33504, 18
+__func__.33504:
 	.string	"zftl_add_read_buf"
 	.zero	6
-	.type	__func__.34271, %object
-	.size	__func__.34271, 15
-__func__.34271:
+	.type	__func__.34302, %object
+	.size	__func__.34302, 15
+__func__.34302:
 	.string	"ftl_alloc_sblk"
 	.align	3
 .LANCHOR3 = . + 0
-	.type	__func__.34857, %object
-	.size	__func__.34857, 17
-__func__.34857:
+	.type	__func__.34892, %object
+	.size	__func__.34892, 17
+__func__.34892:
 	.string	"pm_alloc_new_blk"
 	.zero	7
-	.type	__func__.34885, %object
-	.size	__func__.34885, 21
-__func__.34885:
+	.type	__func__.34920, %object
+	.size	__func__.34920, 21
+__func__.34920:
 	.string	"pm_select_ram_region"
 	.zero	3
-	.type	__func__.19074, %object
-	.size	__func__.19074, 20
-__func__.19074:
+	.type	__func__.19078, %object
+	.size	__func__.19078, 20
+__func__.19078:
 	.string	"flash_die_info_init"
 	.zero	4
-	.type	__func__.33390, %object
-	.size	__func__.33390, 17
-__func__.33390:
+	.type	__func__.33394, %object
+	.size	__func__.33394, 17
+__func__.33394:
 	.string	"lpa_rebuild_hash"
 	.zero	7
-	.type	__func__.34821, %object
-	.size	__func__.34821, 13
-__func__.34821:
+	.type	__func__.34856, %object
+	.size	__func__.34856, 13
+__func__.34856:
 	.string	"pm_free_sblk"
 	.zero	3
-	.type	__func__.19400, %object
-	.size	__func__.19400, 21
-__func__.19400:
+	.type	__func__.19404, %object
+	.size	__func__.19404, 21
+__func__.19404:
 	.string	"flash_info_data_init"
 	.zero	3
-	.type	__func__.18557, %object
-	.size	__func__.18557, 19
-__func__.18557:
+	.type	__func__.18561, %object
+	.size	__func__.18561, 19
+__func__.18561:
 	.string	"flash_read_page_en"
 	.zero	5
-	.type	__func__.18717, %object
-	.size	__func__.18717, 31
-__func__.18717:
+	.type	__func__.18721, %object
+	.size	__func__.18721, 31
+__func__.18721:
 	.string	"flash_complete_plane_page_read"
 	.zero	1
-	.type	__func__.18742, %object
-	.size	__func__.18742, 25
-__func__.18742:
+	.type	__func__.18746, %object
+	.size	__func__.18746, 25
+__func__.18746:
 	.string	"flash_complete_page_read"
 	.zero	7
-	.type	__func__.34666, %object
-	.size	__func__.34666, 31
-__func__.34666:
+	.type	__func__.34701, %object
+	.size	__func__.34701, 31
+__func__.34701:
 	.string	"queue_wait_first_req_completed"
 	.zero	1
-	.type	__func__.34747, %object
-	.size	__func__.34747, 15
-__func__.34747:
+	.type	__func__.34782, %object
+	.size	__func__.34782, 15
+__func__.34782:
 	.string	"sblk_read_page"
 	.zero	1
-	.type	__func__.18664, %object
-	.size	__func__.18664, 26
-__func__.18664:
+	.type	__func__.18668, %object
+	.size	__func__.18668, 26
+__func__.18668:
 	.string	"flash_start_tlc_page_prog"
 	.zero	6
-	.type	__func__.18675, %object
-	.size	__func__.18675, 29
-__func__.18675:
+	.type	__func__.18679, %object
+	.size	__func__.18679, 29
+__func__.18679:
 	.string	"flash_start_3d_mlc_page_prog"
 	.zero	3
-	.type	__func__.18693, %object
-	.size	__func__.18693, 22
-__func__.18693:
+	.type	__func__.18697, %object
+	.size	__func__.18697, 22
+__func__.18697:
 	.string	"flash_start_page_prog"
 	.zero	2
-	.type	__func__.34720, %object
-	.size	__func__.34720, 15
-__func__.34720:
+	.type	__func__.34755, %object
+	.size	__func__.34755, 15
+__func__.34755:
 	.string	"sblk_prog_page"
 	.zero	1
-	.type	__func__.18599, %object
-	.size	__func__.18599, 19
-__func__.18599:
+	.type	__func__.18603, %object
+	.size	__func__.18603, 19
+__func__.18603:
 	.string	"flash_prog_page_en"
 	.zero	5
-	.type	__func__.34544, %object
-	.size	__func__.34544, 14
-__func__.34544:
+	.type	__func__.34579, %object
+	.size	__func__.34579, 14
+__func__.34579:
 	.string	"ftl_prog_page"
 	.zero	2
-	.type	__func__.34239, %object
-	.size	__func__.34239, 15
-__func__.34239:
+	.type	__func__.34270, %object
+	.size	__func__.34270, 15
+__func__.34270:
 	.string	"ftl_info_flush"
 	.zero	1
-	.type	__func__.34508, %object
-	.size	__func__.34508, 19
-__func__.34508:
+	.type	__func__.34541, %object
+	.size	__func__.34541, 19
+__func__.34541:
 	.string	"ftl_ext_info_flush"
 	.zero	5
-	.type	__func__.34520, %object
-	.size	__func__.34520, 18
-__func__.34520:
+	.type	__func__.34553, %object
+	.size	__func__.34553, 18
+__func__.34553:
 	.string	"ftl_ext_info_init"
 	.zero	6
-	.type	__func__.34403, %object
-	.size	__func__.34403, 23
-__func__.34403:
+	.type	__func__.34435, %object
+	.size	__func__.34435, 23
+__func__.34435:
 	.string	"ftl_open_sblk_recovery"
 	.zero	1
-	.type	__func__.34867, %object
-	.size	__func__.34867, 14
-__func__.34867:
+	.type	__func__.34902, %object
+	.size	__func__.34902, 14
+__func__.34902:
 	.string	"pm_write_page"
 	.zero	2
-	.type	__func__.19422, %object
-	.size	__func__.19422, 17
-__func__.19422:
+	.type	__func__.19426, %object
+	.size	__func__.19426, 17
+__func__.19426:
 	.string	"flash_info_flush"
 	.zero	7
-	.type	__func__.19389, %object
-	.size	__func__.19389, 20
-__func__.19389:
+	.type	__func__.19393, %object
+	.size	__func__.19393, 20
+__func__.19393:
 	.string	"flash_info_blk_init"
 	.zero	4
-	.type	__func__.19129, %object
-	.size	__func__.19129, 16
-__func__.19129:
+	.type	__func__.19133, %object
+	.size	__func__.19133, 16
+__func__.19133:
 	.string	"nand_flash_init"
-	.type	__func__.34381, %object
-	.size	__func__.34381, 16
-__func__.34381:
+	.type	__func__.34413, %object
+	.size	__func__.34413, 16
+__func__.34413:
 	.string	"ftl_sysblk_dump"
-	.type	__func__.34807, %object
-	.size	__func__.34807, 16
-__func__.34807:
+	.type	__func__.34842, %object
+	.size	__func__.34842, 16
+__func__.34842:
 	.string	"load_l2p_region"
-	.type	__func__.34841, %object
-	.size	__func__.34841, 6
-__func__.34841:
+	.type	__func__.34876, %object
+	.size	__func__.34876, 6
+__func__.34876:
 	.string	"pm_gc"
 	.zero	2
-	.type	__func__.33756, %object
-	.size	__func__.33756, 22
-__func__.33756:
+	.type	__func__.33787, %object
+	.size	__func__.33787, 22
+__func__.33787:
 	.string	"gc_update_l2p_map_new"
 	.zero	2
-	.type	__func__.33864, %object
-	.size	__func__.33864, 16
-__func__.33864:
+	.type	__func__.33895, %object
+	.size	__func__.33895, 16
+__func__.33895:
 	.string	"gc_scan_src_blk"
-	.type	__func__.33922, %object
-	.size	__func__.33922, 20
-__func__.33922:
+	.type	__func__.33953, %object
+	.size	__func__.33953, 20
+__func__.33953:
 	.string	"gc_scan_static_data"
 	.zero	4
-	.type	__func__.33985, %object
-	.size	__func__.33985, 18
-__func__.33985:
+	.type	__func__.34016, %object
+	.size	__func__.34016, 18
+__func__.34016:
 	.string	"gc_block_vpn_scan"
 	.zero	6
-	.type	__func__.34357, %object
-	.size	__func__.34357, 14
-__func__.34357:
+	.type	__func__.34389, %object
+	.size	__func__.34389, 14
+__func__.34389:
 	.string	"ftl_sblk_dump"
 	.zero	2
-	.type	__func__.33532, %object
-	.size	__func__.33532, 10
-__func__.33532:
+	.type	__func__.33537, %object
+	.size	__func__.33537, 10
+__func__.33537:
 	.string	"zftl_read"
 	.zero	6
-	.type	__func__.33722, %object
-	.size	__func__.33722, 21
-__func__.33722:
+	.type	__func__.33753, %object
+	.size	__func__.33753, 21
+__func__.33753:
 	.string	"gc_check_data_one_wl"
 	.zero	3
-	.type	__func__.34454, %object
-	.size	__func__.34454, 19
-__func__.34454:
+	.type	__func__.34486, %object
+	.size	__func__.34486, 19
+__func__.34486:
 	.string	"ftl_update_l2p_map"
 	.zero	5
-	.type	__func__.33437, %object
-	.size	__func__.33437, 17
-__func__.33437:
+	.type	__func__.33441, %object
+	.size	__func__.33441, 17
+__func__.33441:
 	.string	"ftl_write_commit"
 	.zero	7
-	.type	__func__.33798, %object
-	.size	__func__.33798, 16
-__func__.33798:
+	.type	__func__.33829, %object
+	.size	__func__.33829, 16
+__func__.33829:
 	.string	"gc_do_copy_back"
-	.type	__func__.34013, %object
-	.size	__func__.34013, 11
-__func__.34013:
+	.type	__func__.34044, %object
+	.size	__func__.34044, 11
+__func__.34044:
 	.string	"zftl_do_gc"
 	.zero	5
-	.type	__func__.33563, %object
-	.size	__func__.33563, 13
-__func__.33563:
+	.type	__func__.33568, %object
+	.size	__func__.33568, 13
+__func__.33568:
 	.string	"_ftl_discard"
 	.section	.rodata.str1.1,"aMS",%progbits,1
 .LC0:
@@ -26666,7 +27073,7 @@ __func__.33563:
 .LC1:
 	.string	"%s\n"
 .LC2:
-	.string	"FTL version: 6.0.14 20181128"
+	.string	"FTL version: 6.0.16 20190603"
 .LC3:
 	.string	"zftl_debug:0x%x\n"
 .LC4:
@@ -26724,594 +27131,614 @@ __func__.33563:
 .LC30:
 	.string	"TOGGLE enable: %x\n"
 .LC31:
-	.string	"MultiPlaneProgCmd: %x %x\n"
+	.string	"g_flash_slc_mode: %x %x\n"
 .LC32:
-	.string	"MultiPlaneReadCmd: %x %x\n"
+	.string	"MultiPlaneProgCmd: %x %x\n"
 .LC33:
-	.string	"g_flash_toggle_mode_en: %x\n"
+	.string	"MultiPlaneReadCmd: %x %x\n"
 .LC34:
-	.string	"...%s enter... %p\n"
+	.string	"g_flash_toggle_mode_en: %x\n"
 .LC35:
-	.string	"0:%x %x %x %x %x\n"
+	.string	"...%s enter... %p\n"
 .LC36:
-	.string	"g_nandc_ver...%d\n"
+	.string	"0:%x %x %x %x %x\n"
 .LC37:
-	.string	"nand sdr mode %x\n"
+	.string	"g_nandc_ver...%d\n"
 .LC38:
-	.string	"nand ddr mode %x\n"
+	.string	"nand sdr mode %x\n"
 .LC39:
-	.string	"No.%d FLASH ID:%x %x %x %x %x %x\n"
+	.string	"nand ddr mode %x\n"
 .LC40:
-	.string	"otp:%x %x %x %x\n"
+	.string	"No.%d FLASH ID:%x %x %x %x %x %x\n"
 .LC41:
-	.string	"bad block test:%x %x\n"
+	.string	"otp:%x %x %x %x\n"
 .LC42:
-	.string	"flash_erase_duplane_block %x %x %x\n"
+	.string	"bad block test:%x %x\n"
 .LC43:
-	.string	"flash_erase_duplane_block pageadd = %x status = %x\n"
+	.string	"flash_erase_duplane_block %x %x %x\n"
 .LC44:
-	.string	"flash_erase_block %x %x %x\n"
+	.string	"flash_erase_duplane_block pageadd = %x status = %x\n"
 .LC45:
-	.string	"flash_erase_block %d block = %x status = %x\n"
+	.string	"flash_erase_block %x %x %x\n"
 .LC46:
-	.string	"erase done: %x\n"
+	.string	"flash_erase_block %d block = %x status = %x\n"
 .LC47:
-	.string	"flash_mask_bad_block %d %d\n"
+	.string	"erase done: %x\n"
 .LC48:
-	.string	"zftl_debug"
+	.string	"flash_mask_bad_block %d %d\n"
 .LC49:
-	.string	"FLASH ID: %x %x %x %x %x %x\n"
+	.string	"zftl_debug"
 .LC50:
-	.string	"density: %d MB\n"
+	.string	"FLASH ID: %x %x %x %x %x %x\n"
 .LC51:
-	.string	"device density: %d MB\n"
+	.string	"density: %d MB\n"
 .LC52:
-	.string	"FTL INFO:\n"
+	.string	"device density: %d MB\n"
 .LC53:
-	.string	"max_lpn = 0x%x\n"
+	.string	"FTL INFO:\n"
 .LC54:
-	.string	"density = 0x%x\n"
+	.string	"max_lpn = 0x%x\n"
 .LC55:
-	.string	"slc vpn = 0x%x\n"
+	.string	"density = 0x%x\n"
 .LC56:
-	.string	"xlc vpn = 0x%x\n"
+	.string	"slc vpn = 0x%x\n"
 .LC57:
-	.string	"free slc blk = 0x%x\n"
+	.string	"xlc vpn = 0x%x\n"
 .LC58:
-	.string	"free xlc blk = 0x%x\n"
+	.string	"free slc blk = 0x%x\n"
 .LC59:
-	.string	"free mix blk = 0x%x\n"
+	.string	"free xlc blk = 0x%x\n"
 .LC60:
-	.string	"slc data blk = 0x%x\n"
+	.string	"free mix blk = 0x%x\n"
 .LC61:
-	.string	"slc cache blk = 0x%x\n"
+	.string	"slc data blk = 0x%x\n"
 .LC62:
-	.string	"xlc data blk = 0x%x\n"
+	.string	"slc cache blk = 0x%x\n"
 .LC63:
-	.string	"free buf = %d, %d, %d\n"
+	.string	"xlc data blk = 0x%x\n"
 .LC64:
-	.string	"bad blk = %d %d\n"
+	.string	"free buf = %d, %d, %d\n"
 .LC65:
-	.string	"TBW = %d MB\n"
+	.string	"bad blk = %d %d\n"
 .LC66:
-	.string	"TBR = %d MB\n"
+	.string	"TBW = %d MB\n"
 .LC67:
-	.string	"POC = %d\n"
+	.string	"TBR = %d MB\n"
 .LC68:
-	.string	"PLC = %d\n"
+	.string	"POC = %d\n"
 .LC69:
-	.string	"sys run time = %d S\n"
+	.string	"PLC = %d\n"
 .LC70:
-	.string	"slc mode = %d\n"
+	.string	"sys run time = %d S\n"
 .LC71:
-	.string	"prog err = %d\n"
+	.string	"slc mode = %d\n"
 .LC72:
-	.string	"read err = %d\n"
+	.string	"prog err = %d\n"
 .LC73:
-	.string	"GC XLC page = %d\n"
+	.string	"read err = %d\n"
 .LC74:
-	.string	"GC SLC page = %d\n"
+	.string	"GC XLC page = %d\n"
 .LC75:
-	.string	"discard page = 0x%x\n"
+	.string	"GC SLC page = %d\n"
 .LC76:
-	.string	"version = %d\n"
+	.string	"discard page = 0x%x\n"
 .LC77:
-	.string	"acblk = 0x%x %d %d\n"
+	.string	"version = %d\n"
 .LC78:
-	.string	"tmblk = 0x%x %d %d\n"
+	.string	"acblk = 0x%x %d %d\n"
 .LC79:
-	.string	"gcblk = 0x%x %d %d\n"
+	.string	"tmblk = 0x%x %d %d\n"
 .LC80:
-	.string	"slc ec = %d, %d, %d, %d, %d\n"
+	.string	"gcblk = 0x%x %d %d\n"
 .LC81:
-	.string	"xlc ec = %d, %d, %d, %d, %d\n"
+	.string	"slc ec = %d, %d, %d, %d, %d\n"
 .LC82:
-	.string	"gc free blk th = %d\n"
+	.string	"xlc ec = %d, %d, %d, %d, %d\n"
 .LC83:
-	.string	"gc vpn th = %d %d %d %d %d\n"
+	.string	"gc free blk th = %d\n"
 .LC84:
-	.string	"swl blk = %x %x %x %x\n"
+	.string	"gc vpn th = %d %d %d %d %d\n"
 .LC85:
-	.string	"rf info = %x %x %x %x %x\n"
+	.string	"swl blk = %x %x %x %x\n"
 .LC86:
-	.string	"gc_add_sblk = %d, %d, %d, %d, %d, %d\n"
+	.string	"rf info = %x %x %x %x %x\n"
 .LC87:
-	.string	"gc_add_sblk = %d, %d, %d,last update:%d, %d\n"
+	.string	"gc_add_sblk = %d, %d, %d, %d, %d, %d\n"
 .LC88:
-	.string	"status: %x, ppa: %x\n"
+	.string	"gc_add_sblk = %d, %d, %d,last update:%d, %d\n"
 .LC89:
-	.string	"gc_write_completed: %x  %x  %x %x\n"
+	.string	"gc_mark_bad_ppa %d %x %x\n"
 .LC90:
-	.string	"%d gc_free_temp_buf buf id= %x\n"
+	.string	"status: %x, ppa: %x\n"
 .LC91:
-	.string	"gc: b:%x,p:%x,i:%x; free buf=%d %d free slc th: %d\n"
+	.string	"gc_write_completed: %x  %x  %x %x\n"
 .LC92:
-	.string	"zftl_get_gc_node cache = %x index = %d vpn = %x\n"
+	.string	"%d gc_free_temp_buf buf id= %x\n"
 .LC93:
-	.string	"gc_search_src_blk mode = %x, src mode = %x, count= %d %d\n"
+	.string	"gc: b:%x,p:%x,i:%x; free buf=%d %d free slc th: %d\n"
 .LC94:
-	.string	"swl_tlc_free_mini_ec_blk alloc sblk %x\n"
+	.string	"zftl_get_gc_node cache = %x index = %d vpn = %x\n"
 .LC95:
-	.string	"zftl_get_free_sblk %x %d, %p %d %d\n"
+	.string	"gc_search_src_blk mode = %x, src mode = %x, count= %d %d\n"
 .LC96:
-	.string	"zftl_gc_get_free_sblk %x %x %x, %d %d %d\n"
+	.string	"swl_tlc_free_mini_ec_blk alloc sblk %x\n"
 .LC97:
-	.string	"swl_slc_free_mini_ec_blk alloc sblk %x\n"
+	.string	"zftl_get_free_sblk %x %d, %p %d %d\n"
 .LC98:
-	.string	"list count:%p %d\n"
+	.string	"zftl_gc_get_free_sblk %x %x %x, %d %d %d\n"
 .LC99:
-	.string	"%d: node:%x %x %x %x, %d %d %d %d %d\n"
+	.string	"swl_slc_free_mini_ec_blk alloc sblk %x\n"
 .LC100:
-	.string	"swl_tlc_free_mini_ec_blk sblk %x\n"
+	.string	"list count:%p %d\n"
 .LC101:
-	.string	"swl_slc_free_mini_ec_blk sblk %x\n"
+	.string	"%d: node:%x %x %x %x, %d %d %d %d %d\n"
 .LC102:
-	.string	"gc_free_src_blk = %x, vpn = %d\n"
+	.string	"ftl_vpn_decrement %x = %d, %d\n"
 .LC103:
-	.string	"gc_free_src_blk %x, %d\n"
+	.string	"mask bad block:cs %x %x block: %x %x\n"
 .LC104:
-	.string	"ftl_vpn_decrement %x = %d, %d\n"
+	.string	"gc_free_bad_sblk 0x%x\n"
 .LC105:
-	.string	"mask bad block:cs %x block: %x\n"
+	.string	"swl_tlc_free_mini_ec_blk sblk %x\n"
 .LC106:
-	.string	"bad blk = %x, %x free blk: s:%x,t:%x,m:%x, data blk:s:%x,%x,t%x vpn: s:%x t:%x, max_vpn: %x\n"
+	.string	"swl_slc_free_mini_ec_blk sblk %x\n"
 .LC107:
-	.string	"totle w: %d MB,r: %d MB %d dv:0x%X,poc:%d\n"
+	.string	"gc_free_src_blk = %x, vpn = %d\n"
 .LC108:
-	.string	"gc xlc page: %d,gc slc page: %d, tmp w: %d MB\n"
+	.string	"gc_free_src_blk %x, %d\n"
 .LC109:
-	.string	"slc ec: %d,%d,%d,%d,%d,tlc ec: %d,%d,%d,%d,%d\n"
+	.string	"bad blk = %x, %x free blk: s:%x,t:%x,m:%x, data blk:s:%x,%x,t%x vpn: s:%x t:%x, max_vpn: %x\n"
 .LC110:
-	.string	"gc th: tlc_tlc: %d tlc_slc: %d slc_slc: %d slc_tlc:%d free_th: %d\n"
+	.string	"totle w: %d MB,r: %d MB %d dv:0x%X,poc:%d\n"
 .LC111:
-	.string	"swl : %x %x %x %x\n"
+	.string	"gc xlc page: %d,gc slc page: %d, tmp w: %d MB\n"
 .LC112:
-	.string	"ftl prog error =%x, lpa = %x, ppa= %x\n"
+	.string	"slc ec: %d,%d,%d,%d,%d,tlc ec: %d,%d,%d,%d,%d\n"
 .LC113:
-	.string	"alloc sblk %x %d\n"
+	.string	"gc th: tlc_tlc: %d tlc_slc: %d slc_slc: %d slc_tlc:%d free_th: %d\n"
 .LC114:
-	.string	"dump_sblk_queue: %d\n"
+	.string	"swl : %x %x %x %x\n"
 .LC115:
-	.string	"buf id= %d state = %d ppa = %x\n"
+	.string	"ftl prog error =%x, lpa = %x, ppa= %x\n"
 .LC116:
-	.string	"blk %x is bad block\n"
+	.string	"ftl re prog: lpa = %x, ppa= %x\n"
 .LC117:
-	.string	"pm_alloc_new_blk: %x %x %x %x\n"
+	.string	"alloc sblk %x %d\n"
 .LC118:
-	.string	"%s %d %d\n"
+	.string	"dump_sblk_queue: %d\n"
 .LC119:
-	.string	"gc_static_wearleveling: min blk: %x,sec=%d,xec = %d ,mode=%d, func=%x, bbt=%x vpn = %d\n"
+	.string	"buf id= %d state = %d ppa = %x\n"
 .LC120:
-	.string	"gc_static_wearleveling: min slc blk: %x,sec=%d,xec = %d ,mode=%d, func=%x, bbt=%x vpn = %d\n"
+	.string	"blk %x is bad block\n"
 .LC121:
-	.string	"gc_static_wearleveling: min tlc blk: %x,sec=%d,xec = %d ,mode=%d, func=%x, bbt=%x vpn = %d\n"
+	.string	"pm_alloc_new_blk: %x %x %x %x\n"
 .LC122:
-	.string	"gc_static_wearleveling: max slc blk: %x,sec=%d,xec = %d ,mode=%d, func=%x, bbt=%x vpn = %d\n"
+	.string	"%s %d %d\n"
 .LC123:
-	.string	"gc_static_wearleveling: max xlc blk: %x,sec=%d,xec = %d ,mode=%d, func=%x, bbt=%x vpn = %d\n"
+	.string	"gc_static_wearleveling: min blk: %x,sec=%d,xec = %d ,mode=%d, func=%x, bbt=%x vpn = %d\n"
 .LC124:
-	.string	"gc_static_wearleveling: slc blk: %x, tlc blk: %d avg slc ec: %d, avg tlc ec: %d \n"
+	.string	"gc_static_wearleveling: min slc blk: %x,sec=%d,xec = %d ,mode=%d, func=%x, bbt=%x vpn = %d\n"
 .LC125:
-	.string	"gc_static_wearleveling: min slc ec: %x, min tlc ec: %d max slc ec: %d, max tlc ec: %d; %d %d\n"
+	.string	"gc_static_wearleveling: min tlc blk: %x,sec=%d,xec = %d ,mode=%d, func=%x, bbt=%x vpn = %d\n"
 .LC126:
-	.string	"swl add tlc gc = %x, %d, %d, %d, %d, %d\n"
+	.string	"gc_static_wearleveling: max slc blk: %x,sec=%d,xec = %d ,mode=%d, func=%x, bbt=%x vpn = %d\n"
 .LC127:
-	.string	"swl add slc gc  = %x, %d, %d, %d, %d, %d\n"
+	.string	"gc_static_wearleveling: max xlc blk: %x,sec=%d,xec = %d ,mode=%d, func=%x, bbt=%x vpn = %d\n"
 .LC128:
-	.string	"free blk vpn error: %x %x\n"
+	.string	"gc_static_wearleveling: slc blk: %x, tlc blk: %d avg slc ec: %d, avg tlc ec: %d \n"
 .LC129:
-	.string	"ftl_free_no_use_map_blk %x %x %x %d\n"
+	.string	"gc_static_wearleveling: min slc ec: %x, min tlc ec: %d max slc ec: %d, max tlc ec: %d; %d %d\n"
 .LC130:
-	.string	"...%d @ %s\n"
+	.string	"swl add tlc gc = %x, %d, %d, %d, %d, %d\n"
 .LC131:
-	.string	"rk_ftl_de_init %x\n"
+	.string	"swl add slc gc  = %x, %d, %d, %d, %d, %d\n"
 .LC132:
-	.string	"%s %p:0x%x:"
+	.string	"free blk vpn error: %x %x\n"
 .LC133:
-	.string	"%x "
+	.string	"ftl_free_no_use_map_blk %x %x %x %d\n"
 .LC134:
-	.string	""
+	.string	"...%d @ %s\n"
 .LC135:
-	.string	"otp error! %d"
+	.string	"rk_ftl_de_init %x\n"
 .LC136:
-	.string	"rr"
+	.string	"%s %p:0x%x:"
 .LC137:
-	.string	"flash_abort_clear = %d\n"
+	.string	"%x "
 .LC138:
-	.string	"%d mtrans_cnt = %d page_num = %d\n"
+	.string	""
 .LC139:
-	.string	"nandc:"
+	.string	"otp error! %d"
 .LC140:
-	.string	"%d flReg.d32=%x %x\n"
+	.string	"rr"
 .LC141:
-	.string	"nandc_xfer_done read error %x\n"
+	.string	"flash_abort_clear = %d\n"
 .LC142:
-	.string	"dqs data abort %x\n"
+	.string	"%d mtrans_cnt = %d page_num = %d\n"
 .LC143:
-	.string	"dqs data timeout %x\n"
+	.string	"nandc:"
 .LC144:
-	.string	"xfer error %x\n"
+	.string	"%d flReg.d32=%x %x\n"
 .LC145:
-	.string	"flash_read_page %x %x %x\n"
+	.string	"nandc_xfer_done read error %x\n"
 .LC146:
-	.string	"micron %d row=%x,last status %d,status = %d\n"
+	.string	"dqs data abort %x\n"
 .LC147:
-	.string	"micron RR %d row=%x,count %d,status=%d\n"
+	.string	"dqs data timeout %x\n"
 .LC148:
-	.string	"toshiba SRR %d row=%x, status=%d\n"
+	.string	"xfer error %x\n"
 .LC149:
-	.string	"toshiba TRR %d row=%x, status=%d\n"
+	.string	"flash_read_page %x %x %x\n"
 .LC150:
-	.string	"toshiba RR %d row=%x,count %d,status=%d\n"
+	.string	"micron %d row=%x,last status %d,status = %d\n"
 .LC151:
-	.string	"hynix RR %d row=%x, count %d, status=%d\n"
+	.string	"micron RR %d row=%x,count %d,status=%d\n"
 .LC152:
-	.string	"%d flash_ddr_tuning_read %x ecc=%d\n"
+	.string	"toshiba SRR %d row=%x, status=%d\n"
 .LC153:
-	.string	"sync para %d\n"
+	.string	"toshiba TRR %d row=%x, status=%d\n"
 .LC154:
-	.string	"DDR mode Read error %x %x\n"
+	.string	"toshiba RR %d row=%x,count %d,status=%d\n"
 .LC155:
-	.string	"SDR mode Read %x %x ecc:%x\n"
+	.string	"hynix RR %d row=%x, count %d, status=%d\n"
 .LC156:
-	.string	"flash_read_page_en %x %x %x\n"
+	.string	"%d flash_ddr_tuning_read %x ecc=%d\n"
 .LC157:
-	.string	"flash_read_page_en %x %x error_ecc %d %d\n"
+	.string	"sync para %d\n"
 .LC158:
-	.string	"flash_get_last_written_page: %x %x %x\n"
+	.string	"DDR mode Read error %x %x\n"
 .LC159:
-	.string	"read page: %x %x %x %x\n"
+	.string	"SDR mode Read %x %x ecc:%x\n"
 .LC160:
-	.string	"flash_complete_page_read %x %x error_ecc %d %d\n"
+	.string	"flash_read_page_en %x %x %x\n"
 .LC161:
-	.string	"read: %x %x %x %x\n"
+	.string	"flash_read_page_en %x %x error_ecc %d %d\n"
 .LC162:
-	.string	"0set buf %d,status = %x, ppa = %x lun state = %d\n"
+	.string	"flash_get_last_written_page: %x %x %x\n"
 .LC163:
-	.string	"1set buf %d,status = %x, ppa = %x lun state = %d\n"
+	.string	"read page: %x %x %x %x\n"
 .LC164:
-	.string	"flash_prog_page %x %x %x\n"
+	.string	"flash_complete_page_read %x %x error_ecc %d %d\n"
 .LC165:
-	.string	"flash_prog_page page_addr = %x status = %x\n"
+	.string	"read: %x %x %x %x\n"
 .LC166:
-	.string	"sblk_3d_tlc_dump_prog wl_addr= %x ppa = %x ppa = %x\n"
+	.string	"0set buf %d,status = %x, ppa = %x lun state = %d\n"
 .LC167:
-	.string	"sblk_mlc_dump_prog wl_addr= %x ppa = %x ppa = %x\n"
+	.string	"prog end %x %x error_ecc %d %d\n"
 .LC168:
-	.string	"sblk_prog_page ppa = %x, count = %d\n"
+	.string	"1set buf %d,status = %x, ppa = %x lun state = %d\n"
 .LC169:
-	.string	"flash_prog_page_en:%x %x %x\n"
+	.string	"dp prog end %x %x error_ecc %d %d\n"
 .LC170:
-	.string	"w d:"
+	.string	"sblk_3d_tlc_dump_prog wl_addr= %x ppa = %x ppa = %x\n"
 .LC171:
-	.string	"w s:"
+	.string	"sblk_mlc_dump_prog wl_addr= %x ppa = %x ppa = %x\n"
 .LC172:
-	.string	"spare"
+	.string	"sblk_prog_page ppa = %x, count = %d\n"
 .LC173:
-	.string	"data"
+	.string	"flash_prog_page %x %x %x\n"
 .LC174:
-	.string	"write error: %x\n"
+	.string	"flash_prog_page page_addr = %x status = %x\n"
 .LC175:
-	.string	"g_ftl_info_blk blk = %x, page = %x version = %d\n"
+	.string	"flash_prog_page_en:%x %x %x\n"
 .LC176:
-	.string	"%d %x @%d %x\n"
+	.string	"w d:"
 .LC177:
-	.string	"ftl_info_blk_init %d %d %x\n"
+	.string	"w s:"
 .LC178:
-	.string	"%s %d %d %x %x\n"
+	.string	"spare"
 .LC179:
-	.string	"saved_active_page  = %x\n"
+	.string	"data"
 .LC180:
-	.string	"saved_active_plane = %x\n"
+	.string	"write error: %x\n"
 .LC181:
-	.string	"sblk = %x\n"
+	.string	"g_ftl_info_blk blk = %x, page = %x version = %d\n"
 .LC182:
-	.string	"phy_blk = %x %x\n"
+	.string	"%d %x @%d %x\n"
 .LC183:
-	.string	"sblk = %x, vpn0 = %d, vpn1 = %d\n"
+	.string	"ftl_info_blk_init %d %d %x\n"
 .LC184:
-	.string	"dump_write_lpa = %x %x %x %x\n"
+	.string	"ink flag: %x\n"
 .LC185:
-	.string	"dump write new ppa = %x, last ppa = %x lpa = %x\n"
+	.string	"%s %d %d %x %x\n"
 .LC186:
-	.string	"dump write = %x %x\n"
+	.string	"saved_active_page  = %x\n"
 .LC187:
-	.string	"dump write hash update = %x %x %x\n"
+	.string	"saved_active_plane = %x\n"
 .LC188:
-	.string	"pm_write_page write error: %x\n"
+	.string	"sblk = %x\n"
 .LC189:
-	.string	"ftl_sblk_dump_write = %x %d %d %d %d\n"
+	.string	"phy_blk = %x %x\n"
 .LC190:
-	.string	"blk= %x, page=%x, ppa = %x, status = %x, data:%x %x %x %x, spare: %x %x %x %x\n"
+	.string	"sblk = %x, vpn0 = %d, vpn1 = %d\n"
 .LC191:
-	.string	"ftl_sblk_dump_write2 = %x %d %d %d\n"
+	.string	"dump_write_lpa = %x %x %x %x\n"
 .LC192:
-	.string	"ftl_sblk_dump_write = %x %x\n"
+	.string	"dump write new ppa = %x, last ppa = %x lpa = %x\n"
 .LC193:
-	.string	"ftl_sblk_dump_write done = %x\n"
+	.string	"dump write = %x %x\n"
 .LC194:
-	.string	"finfo:"
+	.string	"dump write hash update = %x %x %x\n"
 .LC195:
-	.string	"flash_info_flush id = %x, page = %x\n"
+	.string	"pm_write_page write error: %x\n"
 .LC196:
-	.string	"sys_info_flush error:%x\n"
+	.string	"ftl_sblk_dump_write = %x %d %d %d %d\n"
 .LC197:
-	.string	"...%d @ %s %d %p\n"
+	.string	"blk= %x, page=%x, ppa = %x, status = %x, data:%x %x %x %x, spare: %x %x %x %x\n"
 .LC198:
-	.string	"no sys info %x\n"
+	.string	"ftl_sblk_dump_write2 = %x %d %d %d\n"
 .LC199:
-	.string	"l2p:"
+	.string	"ftl_sblk_dump_write = %x %x\n"
 .LC200:
-	.string	"free_buf_count: %d\n"
+	.string	"ftl_sblk_dump_write done = %x\n"
 .LC201:
-	.string	"g_ftl_info_blk blk:0x%x, index:0x%x, page:0x%x\n"
+	.string	"finfo:"
 .LC202:
-	.string	"ftl_ext_info_blk blk:0x%x, page:0x%x\n"
+	.string	"flash_info_flush id = %x, page = %x\n"
 .LC203:
-	.string	"ac_blk:0x%x, page:0x%x, index:0x%x, free:0x%x, page_index:0x%x\n"
+	.string	"sys_info_flush error:%x\n"
 .LC204:
-	.string	"tmp_blk:0x%x, page:0x%x, index:0x%x, free:0x%x, page_index:0x%x\n"
+	.string	"...%d @ %s %d %p\n"
 .LC205:
-	.string	"gc_blk:0x%x, page:0x%x, index:0x%x, free:0x%x, page_index:0x%x\n"
+	.string	"no sys info %x\n"
 .LC206:
-	.string	"lpa:"
+	.string	"l2p:"
 .LC207:
-	.string	"vpn:"
+	.string	"free_buf_count: %d\n"
 .LC208:
-	.string	"sblk:"
+	.string	"g_ftl_info_blk blk:0x%x, index:0x%x, page:0x%x\n"
 .LC209:
-	.string	"lpa_hash:"
+	.string	"ftl_ext_info_blk blk:0x%x, page:0x%x\n"
 .LC210:
-	.string	"lpa_hash_index:"
+	.string	"ac_blk:0x%x, page:0x%x, index:0x%x, free:0x%x, page_index:0x%x\n"
 .LC211:
-	.string	"%s w error lpn = %x, max ppa = %d\n"
+	.string	"tmp_blk:0x%x, page:0x%x, index:0x%x, free:0x%x, page_index:0x%x\n"
 .LC212:
-	.string	"region_id = %d, pm_max_region = %d\n"
+	.string	"gc_blk:0x%x, page:0x%x, index:0x%x, free:0x%x, page_index:0x%x\n"
 .LC213:
-	.string	"load_l2p_region no ppa = %x , %x, all setting 0xff....\n"
+	.string	"lpa:"
 .LC214:
-	.string	"load_l2p_region = %x,%x,%x, %x\n"
+	.string	"vpn:"
 .LC215:
-	.string	"pm_ppa:"
+	.string	"sblk:"
 .LC216:
-	.string	"data:"
+	.string	"lpa_hash:"
 .LC217:
-	.string	"spare:"
+	.string	"lpa_hash_index:"
 .LC218:
-	.string	"pm_init posr %x %x %x\n"
+	.string	"%s w error lpn = %x, max ppa = %d\n"
 .LC219:
-	.string	"pm_init recovery %x %x %x\n"
+	.string	"region_id = %d, pm_max_region = %d\n"
 .LC220:
-	.string	"pm_log2phys  lpn = %d, max lpn = %d\n"
+	.string	"load_l2p_region no ppa = %x , %x, all setting 0xff....\n"
 .LC221:
-	.string	"ppa = %x, status = %x, data:%x %x %x %x, spare: %x %x %x %x\n"
+	.string	"load_l2p_region = %x,%x,%x, %x\n"
 .LC222:
-	.string	"ppa = %x, status = %x, %x %x spare: %x %x %x %x\n"
+	.string	"pm_ppa:"
 .LC223:
-	.string	"gc_recovery: %x vpn = %x\n"
+	.string	"data:"
 .LC224:
-	.string	"_c_user_data_density := %d\n"
+	.string	"spare:"
 .LC225:
-	.string	"_c_totle_phy_density := %d\n"
+	.string	"pm_init posr %x %x %x\n"
 .LC226:
-	.string	"_c_totle_log_page := %d\n"
+	.string	"pm_init recovery %x %x %x\n"
 .LC227:
-	.string	"_c_totle_data_density := %d\n"
+	.string	"pm_log2phys  lpn = %d, max lpn = %d\n"
 .LC228:
-	.string	"_c_ftl_pm_page_num := %d\n"
+	.string	"ppa = %x, status = %x, data:%x %x %x %x, spare: %x %x %x %x\n"
 .LC229:
-	.string	"_c_ftl_byte_pre_page := %d\n"
+	.string	"ppa = %x, status = %x, %x %x spare: %x %x %x %x\n"
 .LC230:
-	.string	"_c_max_pm_sblk := %d\n"
+	.string	"gc_recovery: %x vpn = %x\n"
 .LC231:
-	.string	"_min_slc_super_block := %d\n"
+	.string	"_c_user_data_density := %d\n"
 .LC232:
-	.string	"_max_xlc_super_block := %d\n"
+	.string	"_c_totle_phy_density := %d\n"
 .LC233:
-	.string	"gp_ftl_ext_info %p %p %p\n"
+	.string	"_c_totle_log_page := %d\n"
 .LC234:
-	.string	"flash info size: %d %d %d\n"
+	.string	"_c_totle_data_density := %d\n"
 .LC235:
-	.string	"ftl_init %x\n"
+	.string	"_c_ftl_pm_page_num := %d\n"
 .LC236:
-	.string	"gc_update_l2p_map_new sblk %x\n"
+	.string	"_c_ftl_byte_pre_page := %d\n"
 .LC237:
-	.string	"gc_update_l2p_map_new: %x %x %x\n"
+	.string	"_c_max_pm_sblk := %d\n"
 .LC238:
+	.string	"_min_slc_super_block := %d\n"
+.LC239:
+	.string	"_max_xlc_super_block := %d\n"
+.LC240:
+	.string	"gp_ftl_ext_info %p %p %p\n"
+.LC241:
+	.string	"flash info size: %d %d %d\n"
+.LC242:
+	.string	"ftl_init %x\n"
+.LC243:
+	.string	"gc_update_l2p_map_new sblk %x\n"
+.LC244:
+	.string	"gc_update_l2p_map_new: %x %x %x\n"
+.LC245:
 	.string	"lpa: %x %x %x\n"
-.LC239:
+.LC246:
 	.string	"gc_update_l2p_map_new: %x vpn = %x vpn1 = %x done\n"
-.LC240:
+.LC247:
 	.string	"gc_scan_src_blk = %x, vpn = %d\n"
-.LC241:
+.LC248:
 	.string	"gc_scan_src_blk = %x, s vpn0 = %d, c vpn1 = %d\n"
-.LC242:
+.LC249:
 	.string	"gc_block_vpn_scan = %x, s vpn0 = %d, c vpn1 = %d f:%d\n"
-.LC243:
+.LC250:
 	.string	"ftl_sblk_dump = %x %d %d %d %d\n"
-.LC244:
+.LC251:
 	.string	"ftl_sblk_dump = %x %x %x %x\n"
-.LC245:
+.LC252:
 	.string	"page_addr = %x, lpa=%x vpn = %d\n"
-.LC246:
+.LC253:
 	.string	"index= %x, lpa=%x\n"
-.LC247:
+.LC254:
 	.string	"block = %x, vpn=%x check vpn = %d\n"
-.LC248:
+.LC255:
 	.string	"ftl_read %x %x %x\n"
-.LC249:
+.LC256:
 	.string	"ftl_read refresh =%x, lpa = %x, ppa= %x\n"
-.LC250:
+.LC257:
 	.string	"id=%d, status = %x, lpa = %x, ppa = %x spare = %x %x %x %x\n"
-.LC251:
+.LC258:
 	.string	"zftl debug cmd: %s\n"
-.LC252:
+.LC259:
 	.string	"cmd:"
-.LC253:
+.LC260:
 	.string	"dumpl2p"
-.LC254:
+.LC261:
 	.string	"pm l2p:"
-.LC255:
+.LC262:
 	.string	"pm blk:"
-.LC256:
+.LC263:
 	.string	"dumppm:"
-.LC257:
+.LC264:
 	.string	"p_cmd: %s\n"
-.LC258:
+.LC265:
 	.string	"pm ram = %x, %x\n"
-.LC259:
+.LC266:
 	.string	"ram:"
-.LC260:
+.LC267:
 	.string	"pm:"
-.LC261:
+.LC268:
 	.string	"dumpsys"
-.LC262:
+.LC269:
 	.string	"dumplist:"
-.LC263:
+.LC270:
 	.string	"vpncheck"
-.LC264:
+.LC271:
 	.string	"dumpppa:"
-.LC265:
+.LC272:
 	.string	"dumpblk:"
-.LC266:
+.LC273:
 	.string	"setzdebug:"
-.LC267:
+.LC274:
 	.string	"lpa2ppa:"
-.LC268:
+.LC275:
 	.string	"lpa: %x--> ppa: %x\n"
-.LC269:
+.LC276:
 	.string	"help:\n"
-.LC270:
+.LC277:
 	.string	"1. echo dumpl2p > /proc/zftl_debug\n"
-.LC271:
+.LC278:
 	.string	"2. echo dumppm:x > /proc/zftl_debug\n"
-.LC272:
+.LC279:
 	.string	"3. echo dumpsys > /proc/zftl_debug\n"
-.LC273:
+.LC280:
 	.string	"4. echo dumpppa:x > /proc/zftl_debug\n"
-.LC274:
+.LC281:
 	.string	"5. echo vpncheck > /proc/zftl_debug\n"
-.LC275:
+.LC282:
 	.string	"6. echo setzdebug:x > /proc/zftl_debug\n"
-.LC276:
+.LC283:
 	.string	"7. echo dumplist > /proc/zftl_debug\n"
-.LC277:
+.LC284:
 	.string	"8. echo lpa2ppa:x> /proc/zftl_debug\n"
-.LC278:
+.LC285:
 	.string	"gc_lpa:"
-.LC279:
+.LC286:
 	.string	"gc_ppa:"
-.LC280:
+.LC287:
 	.string	"err: ppa = %x, status = %x, %x %x spare: %x %x %x %x\n"
-.LC281:
+.LC288:
 	.string	"ftl_update_l2p_map: %x %x %x\n"
-.LC282:
+.LC289:
 	.string	"ftl_update_l2p_map"
-.LC283:
+.LC290:
 	.string	"lpa_tbl:"
-.LC284:
+.LC291:
 	.string	"sblk %x vpn: %d %d\n"
-.LC285:
+.LC292:
+	.string	"error gc_add_sblk: %x\n"
+.LC293:
 	.string	"%d read error: ppa:%x, lpa:%x, status:%x\n"
-.LC286:
+.LC294:
 	.string	"gc page in buf: lpa %x ppa = %x pageindex= %x\n"
-.LC287:
+.LC295:
 	.string	"gc_do_copy_back: lpa %x des_ppa = %x %x gc_ppa= %x page_index= %d\n"
-.LC288:
+.LC296:
 	.string	"gc_do_copy_back: %x %x %x %x gc_ppa:%x %x\n"
-.LC289:
+.LC297:
 	.string	"%d prog_step: %x %x buf id= %x ppa = %x hash=%x id = %x plane = %x lpa=%x\n"
-.LC290:
+.LC298:
 	.string	"gc %d: %d %d %d %d %d %d %d\n"
-.LC291:
+.LC299:
 	.string	"gc %d: %d %d %d %d %d %d\n"
-.LC292:
+.LC300:
 	.string	"GC_STATE_SCAN_ALL_PAGE = %x, vpn0 = %d, vpn1 = %d\n"
-.LC293:
+.LC301:
 	.string	"gc free %x, %d\n"
-.LC294:
+.LC302:
 	.string	"ftlwrite %x %x %x %x\n"
-.LC295:
+.LC303:
 	.string	"ftl_discard:(%x, %x, %x, %x)\n"
-.LC296:
+.LC304:
 	.string	"id_block_prog_msb_ff_data slc page = %d pageadd=%x %x\n"
-.LC297:
+.LC305:
 	.string	"write_idblock fix data %x %x\n"
-.LC298:
+.LC306:
 	.string	"idblk:"
-.LC299:
+.LC307:
 	.string	"write_idblock totle_sec %x %x\n"
-.LC300:
+.LC308:
+	.string	"prog page: %x %x %x, %p %x %x %x\n"
+.LC309:
+	.string	"wl_lba %p %x %x %x\n"
+.LC310:
 	.string	"READ_SECTOR_IO\n"
-.LC301:
+.LC311:
 	.string	"rk_copy_from_user error\n"
-.LC302:
+.LC312:
 	.string	"READ_SECTOR_IO %x %x\n"
-.LC303:
+.LC313:
 	.string	"rk_copy_to_user error\n"
-.LC304:
+.LC314:
 	.string	"WRITE_SECTOR_IO\n"
-.LC305:
+.LC315:
 	.string	"WRITE_SECTOR_IO %x %x\n"
-.LC306:
+.LC316:
 	.string	"END_WRITE_SECTOR_IO\n"
-.LC307:
+.LC317:
 	.string	"END_WRITE_SECTOR_IO %x %x\n"
-.LC308:
+.LC318:
 	.string	"GET_FLASH_INFO_IO\n"
-.LC309:
+.LC319:
 	.string	"GET_BAD_BLOCK_IO\n"
-.LC310:
+.LC320:
 	.string	"GET_LOCK_FLAG_IO\n"
-.LC311:
+.LC321:
 	.string	"GET_PUBLIC_KEY_IO\n"
-.LC312:
+.LC322:
 	.string	"RKNAND_GET_DRM_KEY\n"
-.LC313:
+.LC323:
 	.string	"RKNAND_STORE_DRM_KEY\n"
-.LC314:
+.LC324:
 	.string	"RKNAND_DIASBLE_SECURE_BOOT\n"
-.LC315:
+.LC325:
 	.string	"RKNAND_ENASBLE_SECURE_BOOT\n"
-.LC316:
+.LC326:
 	.string	"RKNAND_GET_SN_SECTOR\n"
-.LC317:
+.LC327:
 	.string	"RKNAND_LOADER_UNLOCK\n"
-.LC318:
+.LC328:
 	.string	"RKNAND_LOADER_STATUS\n"
-.LC319:
+.LC329:
 	.string	"RKNAND_LOADER_LOCK\n"
-.LC320:
+.LC330:
 	.string	"LockKey not match %d\n"
-.LC321:
+.LC331:
 	.string	"RKNAND_GET_VENDOR_SECTOR\n"
-.LC322:
+.LC332:
 	.string	"RKNAND_STORE_VENDOR_SECTOR\n"
-.LC323:
+.LC333:
 	.string	"return ret = %lx\n"
-.LC324:
+.LC334:
 	.string	"secureBootEn check error\n"
-.LC325:
+.LC335:
 	.string	"\0013vendor storage %x,%x,%x\n"
 	.data
 	.align	3
@@ -27747,7 +28174,7 @@ hy_f26_ref_value:
 	.byte	-37
 	.zero	4
 	.type	zftl_nand_flash_para_tbl, %object
-	.size	zftl_nand_flash_para_tbl, 1216
+	.size	zftl_nand_flash_para_tbl, 1248
 zftl_nand_flash_para_tbl:
 	.byte	6
 	.byte	-104
@@ -28305,7 +28732,7 @@ zftl_nand_flash_para_tbl:
 	.byte	1
 	.byte	0
 	.hword	512
-	.byte	3
+	.byte	0
 	.byte	0
 	.byte	0
 	.byte	0
@@ -28561,6 +28988,34 @@ zftl_nand_flash_para_tbl:
 	.byte	0
 	.byte	0
 	.byte	0
+	.byte	5
+	.byte	44
+	.byte	-124
+	.byte	100
+	.byte	60
+	.byte	-87
+	.byte	4
+	.byte	4
+	.byte	1
+	.byte	32
+	.hword	512
+	.byte	2
+	.byte	2
+	.hword	1024
+	.hword	479
+	.byte	3
+	.byte	17
+	.byte	40
+	.byte	32
+	.byte	1
+	.byte	0
+	.byte	1
+	.byte	0
+	.hword	512
+	.byte	0
+	.byte	0
+	.byte	0
+	.byte	0
 	.byte	6
 	.byte	-83
 	.byte	-34
@@ -29649,7 +30104,11 @@ g_idb_ecc_bits:
 	.size	g_nand_max_die, 1
 g_nand_max_die:
 	.zero	1
-	.zero	6
+	.type	g_idb_slc_mode_enable, %object
+	.size	g_idb_slc_mode_enable, 1
+g_idb_slc_mode_enable:
+	.zero	1
+	.zero	5
 	.type	g_nand_opt_para, %object
 	.size	g_nand_opt_para, 32
 g_nand_opt_para:
@@ -29713,11 +30172,7 @@ g_flash_interface_mode:
 	.size	g_flash_multi_page_prog_en, 1
 g_flash_multi_page_prog_en:
 	.zero	1
-	.type	g_idb_slc_mode_enable, %object
-	.size	g_idb_slc_mode_enable, 1
-g_idb_slc_mode_enable:
-	.zero	1
-	.zero	1
+	.zero	2
 	.type	g_buf, %object
 	.size	g_buf, 2048
 g_buf:
@@ -29814,9 +30269,9 @@ write_buf_head:
 	.zero	1
 	.zero	7
 	.type	g_gc_info, %object
-	.size	g_gc_info, 328
+	.size	g_gc_info, 344
 g_gc_info:
-	.zero	328
+	.zero	344
 	.type	ftl_sblk_vpn_update_id, %object
 	.size	ftl_sblk_vpn_update_id, 2
 ftl_sblk_vpn_update_id:
@@ -29826,6 +30281,15 @@ ftl_sblk_vpn_update_id:
 	.size	ftl_sblk_update_list, 16
 ftl_sblk_update_list:
 	.zero	16
+	.type	_c_ftl_block_addr_log2, %object
+	.size	_c_ftl_block_addr_log2, 2
+_c_ftl_block_addr_log2:
+	.zero	2
+	.type	_c_ftl_planes_per_die, %object
+	.size	_c_ftl_planes_per_die, 1
+_c_ftl_planes_per_die:
+	.zero	1
+	.zero	5
 	.type	gc_valid_page_ppa, %object
 	.size	gc_valid_page_ppa, 8
 gc_valid_page_ppa:
@@ -29920,27 +30384,6 @@ gp_free_mix_head:
 	.type	zftl_print_list_count, %object
 	.size	zftl_print_list_count, 2
 zftl_print_list_count:
-	.zero	2
-	.type	_c_ftl_planes_per_die, %object
-	.size	_c_ftl_planes_per_die, 1
-_c_ftl_planes_per_die:
-	.zero	1
-	.zero	1
-	.type	_c_ftl_block_addr_log2, %object
-	.size	_c_ftl_block_addr_log2, 2
-_c_ftl_block_addr_log2:
-	.zero	2
-	.type	_c_mix_max_xlc_ec_count, %object
-	.size	_c_mix_max_xlc_ec_count, 2
-_c_mix_max_xlc_ec_count:
-	.zero	2
-	.type	_max_slc_super_block, %object
-	.size	_max_slc_super_block, 2
-_max_slc_super_block:
-	.zero	2
-	.type	_c_mix_max_slc_ec_count, %object
-	.size	_c_mix_max_slc_ec_count, 2
-_c_mix_max_slc_ec_count:
 	.zero	2
 	.type	_c_ftl_block_align_addr, %object
 	.size	_c_ftl_block_align_addr, 2
@@ -29950,7 +30393,7 @@ _c_ftl_block_align_addr:
 	.size	_c_ftl_nand_die_num, 1
 _c_ftl_nand_die_num:
 	.zero	1
-	.zero	1
+	.zero	3
 	.type	lpa_hash, %object
 	.size	lpa_hash, 512
 lpa_hash:
@@ -29970,6 +30413,18 @@ ftl_vpn_update_count:
 	.type	ftl_sblk_update_list_offset, %object
 	.size	ftl_sblk_update_list_offset, 2
 ftl_sblk_update_list_offset:
+	.zero	2
+	.type	_c_mix_max_xlc_ec_count, %object
+	.size	_c_mix_max_xlc_ec_count, 2
+_c_mix_max_xlc_ec_count:
+	.zero	2
+	.type	_max_slc_super_block, %object
+	.size	_max_slc_super_block, 2
+_max_slc_super_block:
+	.zero	2
+	.type	_c_mix_max_slc_ec_count, %object
+	.size	_c_mix_max_slc_ec_count, 2
+_c_mix_max_slc_ec_count:
 	.zero	2
 	.type	sblk_write_completed_queue_head, %object
 	.size	sblk_write_completed_queue_head, 1
@@ -29987,6 +30442,7 @@ read_buf_count:
 	.size	sblk_read_completed_queue_head, 1
 sblk_read_completed_queue_head:
 	.zero	1
+	.zero	2
 	.type	pm_gc_enable, %object
 	.size	pm_gc_enable, 4
 pm_gc_enable:
@@ -30111,7 +30567,7 @@ write_commit_head:
 	.size	ftl_flush_jiffies, 4
 ftl_flush_jiffies:
 	.zero	4
-	.zero	32
+	.zero	8
 	.type	ftl_info_spare, %object
 	.size	ftl_info_spare, 256
 ftl_info_spare:
diff --git a/kernel/fs/Kconfig b/kernel/fs/Kconfig
index 80af051635..c269e2379a 100644
--- a/kernel/fs/Kconfig
+++ b/kernel/fs/Kconfig
@@ -103,6 +103,7 @@ if BLOCK
 menu "DOS/FAT/NT Filesystems"
 
 source "fs/fat/Kconfig"
+source "fs/exfat/Kconfig"
 source "fs/ntfs/Kconfig"
 
 endmenu
diff --git a/kernel/fs/Makefile b/kernel/fs/Makefile
index 4644db462b..7470b5317d 100644
--- a/kernel/fs/Makefile
+++ b/kernel/fs/Makefile
@@ -77,6 +77,7 @@ obj-$(CONFIG_HUGETLBFS)		+= hugetlbfs/
 obj-$(CONFIG_CODA_FS)		+= coda/
 obj-$(CONFIG_MINIX_FS)		+= minix/
 obj-$(CONFIG_FAT_FS)		+= fat/
+obj-$(CONFIG_EXFAT_FS)		+= exfat/
 obj-$(CONFIG_BFS_FS)		+= bfs/
 obj-$(CONFIG_ISO9660_FS)	+= isofs/
 obj-$(CONFIG_HFSPLUS_FS)	+= hfsplus/ # Before hfs to find wrapped HFS+
diff --git a/kernel/fs/exfat/.gitignore b/kernel/fs/exfat/.gitignore
new file mode 100755
index 0000000000..241505f47e
--- /dev/null
+++ b/kernel/fs/exfat/.gitignore
@@ -0,0 +1,7 @@
+*.cmd
+*.ko
+*.mod.c
+modules.order
+Module.symvers
+*.o
+.tmp_versions
diff --git a/kernel/fs/exfat/Kconfig b/kernel/fs/exfat/Kconfig
new file mode 100755
index 0000000000..78b32aa2ca
--- /dev/null
+++ b/kernel/fs/exfat/Kconfig
@@ -0,0 +1,39 @@
+config EXFAT_FS
+	tristate "exFAT fs support"
+	select NLS
+	help
+	  This adds support for the exFAT file system.
+
+config EXFAT_DISCARD
+	bool "enable discard support"
+	depends on EXFAT_FS
+	default y
+
+config EXFAT_DELAYED_SYNC
+	bool "enable delayed sync"
+	depends on EXFAT_FS
+	default n
+
+config EXFAT_KERNEL_DEBUG
+	bool "enable kernel debug features via ioctl"
+	depends on EXFAT_FS
+	default n
+
+config EXFAT_DEBUG_MSG
+	bool "print debug messages"
+	depends on EXFAT_FS
+	default n
+
+config EXFAT_DEFAULT_CODEPAGE
+	int "Default codepage for exFAT"
+	default 437
+	depends on EXFAT_FS
+	help
+	  This option should be set to the codepage of your exFAT filesystems.
+
+config EXFAT_DEFAULT_IOCHARSET
+	string "Default iocharset for exFAT"
+	default "utf8"
+	depends on EXFAT_FS
+	help
+	  Set this to the default input/output character set you'd like exFAT to use.
diff --git a/kernel/fs/exfat/LICENSE b/kernel/fs/exfat/LICENSE
new file mode 100755
index 0000000000..d159169d10
--- /dev/null
+++ b/kernel/fs/exfat/LICENSE
@@ -0,0 +1,339 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff --git a/kernel/fs/exfat/Makefile b/kernel/fs/exfat/Makefile
new file mode 100755
index 0000000000..711ed87f99
--- /dev/null
+++ b/kernel/fs/exfat/Makefile
@@ -0,0 +1,54 @@
+#
+# Makefile for Linux FAT12/FAT16/FAT32(VFAT)/FAT64(ExFAT) filesystem driver.
+#
+
+ifneq ($(KERNELRELEASE),)
+# call from kernel build system
+
+obj-$(CONFIG_EXFAT_FS) += exfat.o
+
+exfat-objs := exfat_core.o exfat_super.o exfat_api.o exfat_blkdev.o exfat_cache.o \
+			   exfat_data.o exfat_bitmap.o exfat_nls.o exfat_oal.o exfat_upcase.o
+
+else
+# external module build
+
+EXTRA_FLAGS += -I$(PWD)
+
+#
+# KDIR is a path to a directory containing kernel source.
+# It can be specified on the command line passed to make to enable the module to
+# be built and installed for a kernel other than the one currently running.
+# By default it is the path to the symbolic link created when
+# the current kernel's modules were installed, but
+# any valid path to the directory in which the target kernel's source is located
+# can be provided on the command line.
+#
+KDIR	?= /lib/modules/$(shell uname -r)/build
+MDIR	?= /lib/modules/$(shell uname -r)
+PWD	:= $(shell pwd)
+PWD	:= $(shell pwd)
+
+export CONFIG_EXFAT_FS := m
+
+all:
+	$(MAKE) -C $(KDIR) M=$(PWD) modules
+
+clean:
+	$(MAKE) -C $(KDIR) M=$(PWD) clean
+
+help:
+	$(MAKE) -C $(KDIR) M=$(PWD) help
+
+install: exfat.ko
+	rm -f ${MDIR}/kernel/fs/exfat/exfat.ko
+	install -m644 -b -D exfat.ko ${MDIR}/kernel/fs/exfat/exfat.ko
+	depmod -aq
+
+uninstall:
+	rm -rf ${MDIR}/kernel/fs/exfat
+	depmod -aq
+
+endif
+
+.PHONY : all clean install uninstall
diff --git a/kernel/fs/exfat/README.md b/kernel/fs/exfat/README.md
new file mode 100755
index 0000000000..feab400383
--- /dev/null
+++ b/kernel/fs/exfat/README.md
@@ -0,0 +1,98 @@
+exfat-nofuse
+============
+
+Linux non-fuse read/write kernel driver for the exFAT, FAT12, FAT16 and vfat (FAT32) file systems.<br />
+Originally ported from Android kernel v3.0.
+
+Kudos to ksv1986 for the mutex patch!<br />
+Thanks to JackNorris for being awesome and providing the clear_inode() patch.<br />
+<br />
+Big thanks to lqs for completing the driver!<br />
+Big thanks to benpicco for fixing 3.11.y compatibility!
+
+
+Special thanks to github user AndreiLux for spreading the word about the leak!<br />
+
+
+Installing as a stand-alone module:
+====================================
+
+    make
+    sudo make install
+
+To load the driver manually, run this as root:
+
+    modprobe exfat
+
+You may also specify custom toolchains by using CROSS_COMPILE flag, in my case:
+>CROSS_COMPILE=../dorimanx-SG2-I9100-Kernel/android-toolchain/bin/arm-eabi-
+
+Installing as a part of the kernel:
+======================================
+
+Let's take [linux] as the path to your kernel source dir...
+
+	cd [linux]
+	cp -rvf exfat-nofuse [linux]/fs/exfat
+
+edit [linux]/fs/Kconfig
+```
+ menu "DOS/FAT/NT Filesystems"
+
+  source "fs/fat/Kconfig"
+ +source "fs/exfat/Kconfig"
+  source "fs/ntfs/Kconfig"
+  endmenu
+```
+  
+
+edit [linux]/fs/Makefile
+```
+  obj-$(CONFIG_FAT_FS)    += fat/
+ +obj-$(CONFIG_EXFAT_FS)  += exfat/
+  obj-$(CONFIG_BFS_FS)    += bfs/
+```
+
+	cd [linux]
+	make menuconfig
+
+Go to:
+> File systems > DOS/FAT/NT
+>   check exfat as MODULE (M)
+>   (437) Default codepage for exFAT
+>   (utf8) Default iocharset for exFAT
+
+> ESC to main menu
+> Save an Alternate Configuration File
+> ESC ESC
+
+build your kernel
+
+Have fun.
+
+
+Installing as a DKMS module:
+=================================
+
+You can have even more fun with exfat-nofuse by installing it as a DKMS module has the main advantage of being auto-compiled (and thus, possibly surviving) between kernel upgrades.
+
+First, get dkms. On Ubuntu this should be:
+
+	sudo apt install dkms
+
+Then copy the root of this repository to /usr/share:
+
+	sudo cp -R . /usr/src/exfat-1.2.8 (or whatever version number declared on dkms.conf is)
+	sudo dkms add -m exfat -v 1.2.8
+
+Build and load the module:
+
+	sudo dkms build -m exfat -v 1.2.8
+	sudo dkms install -m exfat -v 1.2.8
+
+Now you have a proper dkms module that will work for a long time... hopefully.
+
+
+
+Free Software for the Free Minds!
+=================================
diff --git a/kernel/fs/exfat/dkms.conf b/kernel/fs/exfat/dkms.conf
new file mode 100755
index 0000000000..d873c0aef4
--- /dev/null
+++ b/kernel/fs/exfat/dkms.conf
@@ -0,0 +1,7 @@
+PACKAGE_NAME="exfat"
+PACKAGE_VERSION="1.2.8"
+MAKE="KDIR=/lib/modules/$kernelver/build MDIR=/lib/modules/$kernelver make"
+CLEAN="make clean"
+BUILT_MODULE_NAME[0]="exfat"
+AUTOINSTALL="yes"
+DEST_MODULE_LOCATION="/extra"
diff --git a/kernel/fs/exfat/exfat-km.mk b/kernel/fs/exfat/exfat-km.mk
new file mode 100755
index 0000000000..4e3ef07b36
--- /dev/null
+++ b/kernel/fs/exfat/exfat-km.mk
@@ -0,0 +1,11 @@
+EXFAT_FOLDER ?= external/exfat-nofuse
+
+EXFAT_MODULE:
+	make clean -C $(EXFAT_FOLDER) KDIR=$(KERNEL_OUT)
+	make -j8 -C $(EXFAT_FOLDER) ARCH=arm KDIR=$(KERNEL_OUT) \
+		$(if $(ARM_CROSS_COMPILE),$(ARM_CROSS_COMPILE),$(KERNEL_CROSS_COMPILE))
+	mv $(EXFAT_FOLDER)/exfat.ko $(KERNEL_MODULES_OUT)
+	$(if $(ARM_EABI_TOOLCHAIN),$(ARM_EABI_TOOLCHAIN)/arm-eabi-strip, \
+		$(KERNEL_TOOLCHAIN_PATH)strip) --strip-unneeded $(KERNEL_MODULES_OUT)/exfat.ko
+
+TARGET_KERNEL_MODULES += EXFAT_MODULE
diff --git a/kernel/fs/exfat/exfat_api.c b/kernel/fs/exfat/exfat_api.c
new file mode 100755
index 0000000000..32b29f0dd8
--- /dev/null
+++ b/kernel/fs/exfat/exfat_api.c
@@ -0,0 +1,528 @@
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*  PROJECT : exFAT & FAT12/16/32 File System                           */
+/*  FILE    : exfat_api.c                                               */
+/*  PURPOSE : exFAT API Glue Layer                                      */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  NOTES                                                               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  REVISION HISTORY (Ver 0.9)                                          */
+/*                                                                      */
+/*  - 2010.11.15 [Joosun Hahn] : first writing                          */
+/*                                                                      */
+/************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include "exfat_version.h"
+#include "exfat_config.h"
+#include "exfat_data.h"
+#include "exfat_oal.h"
+
+#include "exfat_nls.h"
+#include "exfat_api.h"
+#include "exfat_super.h"
+#include "exfat_core.h"
+
+/*----------------------------------------------------------------------*/
+/*  Constant & Macro Definitions                                        */
+/*----------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------*/
+/*  Global Variable Definitions                                         */
+/*----------------------------------------------------------------------*/
+
+extern struct semaphore z_sem;
+
+/*----------------------------------------------------------------------*/
+/*  Local Variable Definitions                                          */
+/*----------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------*/
+/*  Local Function Declarations                                         */
+/*----------------------------------------------------------------------*/
+
+/*======================================================================*/
+/*  Global Function Definitions                                         */
+/*    - All functions for global use have same return value format,     */
+/*      that is, FFS_SUCCESS on success and several FS error code on    */
+/*      various error condition.                                        */
+/*======================================================================*/
+
+/*----------------------------------------------------------------------*/
+/*  exFAT Filesystem Init & Exit Functions                              */
+/*----------------------------------------------------------------------*/
+
+int FsInit(void)
+{
+	return ffsInit();
+}
+
+int FsShutdown(void)
+{
+	return ffsShutdown();
+}
+
+/*----------------------------------------------------------------------*/
+/*  Volume Management Functions                                         */
+/*----------------------------------------------------------------------*/
+
+/* FsMountVol : mount the file system volume */
+int FsMountVol(struct super_block *sb)
+{
+	int err;
+
+	sm_P(&z_sem);
+
+	err = buf_init(sb);
+	if (!err)
+		err = ffsMountVol(sb);
+	else
+		buf_shutdown(sb);
+
+	sm_V(&z_sem);
+
+	return err;
+} /* end of FsMountVol */
+
+/* FsUmountVol : unmount the file system volume */
+int FsUmountVol(struct super_block *sb)
+{
+	int err;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	sm_P(&z_sem);
+
+	/* acquire the lock for file system critical section */
+	sm_P(&p_fs->v_sem);
+
+	err = ffsUmountVol(sb);
+	buf_shutdown(sb);
+
+	/* release the lock for file system critical section */
+	sm_V(&p_fs->v_sem);
+
+	sm_V(&z_sem);
+
+	return err;
+} /* end of FsUmountVol */
+
+/* FsGetVolInfo : get the information of a file system volume */
+int FsGetVolInfo(struct super_block *sb, VOL_INFO_T *info)
+{
+	int err;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	/* check the validity of pointer parameters */
+	if (info == NULL)
+		return FFS_ERROR;
+
+	/* acquire the lock for file system critical section */
+	sm_P(&p_fs->v_sem);
+
+	err = ffsGetVolInfo(sb, info);
+
+	/* release the lock for file system critical section */
+	sm_V(&p_fs->v_sem);
+
+	return err;
+} /* end of FsGetVolInfo */
+
+/* FsSyncVol : synchronize a file system volume */
+int FsSyncVol(struct super_block *sb, int do_sync)
+{
+	int err;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	/* acquire the lock for file system critical section */
+	sm_P(&p_fs->v_sem);
+
+	err = ffsSyncVol(sb, do_sync);
+
+	/* release the lock for file system critical section */
+	sm_V(&p_fs->v_sem);
+
+	return err;
+} /* end of FsSyncVol */
+
+
+/*----------------------------------------------------------------------*/
+/*  File Operation Functions                                            */
+/*----------------------------------------------------------------------*/
+
+/* FsCreateFile : create a file */
+int FsLookupFile(struct inode *inode, char *path, FILE_ID_T *fid)
+{
+	int err;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	/* check the validity of pointer parameters */
+	if ((fid == NULL) || (path == NULL) || (*path == '\0'))
+		return FFS_ERROR;
+
+	/* acquire the lock for file system critical section */
+	sm_P(&p_fs->v_sem);
+
+	err = ffsLookupFile(inode, path, fid);
+
+	/* release the lock for file system critical section */
+	sm_V(&p_fs->v_sem);
+
+	return err;
+} /* end of FsLookupFile */
+
+/* FsCreateFile : create a file */
+int FsCreateFile(struct inode *inode, char *path, u8 mode, FILE_ID_T *fid)
+{
+	int err;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	/* check the validity of pointer parameters */
+	if ((fid == NULL) || (path == NULL) || (*path == '\0'))
+		return FFS_ERROR;
+
+	/* acquire the lock for file system critical section */
+	sm_P(&p_fs->v_sem);
+
+	err = ffsCreateFile(inode, path, mode, fid);
+
+	/* release the lock for file system critical section */
+	sm_V(&p_fs->v_sem);
+
+	return err;
+} /* end of FsCreateFile */
+
+int FsReadFile(struct inode *inode, FILE_ID_T *fid, void *buffer, u64 count, u64 *rcount)
+{
+	int err;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	/* check the validity of the given file id */
+	if (fid == NULL)
+		return FFS_INVALIDFID;
+
+	/* check the validity of pointer parameters */
+	if (buffer == NULL)
+		return FFS_ERROR;
+
+	/* acquire the lock for file system critical section */
+	sm_P(&p_fs->v_sem);
+
+	err = ffsReadFile(inode, fid, buffer, count, rcount);
+
+	/* release the lock for file system critical section */
+	sm_V(&p_fs->v_sem);
+
+	return err;
+} /* end of FsReadFile */
+
+int FsWriteFile(struct inode *inode, FILE_ID_T *fid, void *buffer, u64 count, u64 *wcount)
+{
+	int err;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	/* check the validity of the given file id */
+	if (fid == NULL)
+		return FFS_INVALIDFID;
+
+	/* check the validity of pointer parameters */
+	if (buffer == NULL)
+		return FFS_ERROR;
+
+	/* acquire the lock for file system critical section */
+	sm_P(&p_fs->v_sem);
+
+	err = ffsWriteFile(inode, fid, buffer, count, wcount);
+
+	/* release the lock for file system critical section */
+	sm_V(&p_fs->v_sem);
+
+	return err;
+} /* end of FsWriteFile */
+
+/* FsTruncateFile : resize the file length */
+int FsTruncateFile(struct inode *inode, u64 old_size, u64 new_size)
+{
+	int err;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	/* acquire the lock for file system critical section */
+	sm_P(&p_fs->v_sem);
+
+	DPRINTK("FsTruncateFile entered (inode %p size %llu)\n", inode, new_size);
+
+	err = ffsTruncateFile(inode, old_size, new_size);
+
+	DPRINTK("FsTruncateFile exitted (%d)\n", err);
+
+	/* release the lock for file system critical section */
+	sm_V(&p_fs->v_sem);
+
+	return err;
+} /* end of FsTruncateFile */
+
+/* FsMoveFile : move(rename) a old file into a new file */
+int FsMoveFile(struct inode *old_parent_inode, FILE_ID_T *fid, struct inode *new_parent_inode, struct dentry *new_dentry)
+{
+	int err;
+	struct super_block *sb = old_parent_inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	/* check the validity of the given file id */
+	if (fid == NULL)
+		return FFS_INVALIDFID;
+
+	/* acquire the lock for file system critical section */
+	sm_P(&p_fs->v_sem);
+
+	err = ffsMoveFile(old_parent_inode, fid, new_parent_inode, new_dentry);
+
+	/* release the lock for file system critical section */
+	sm_V(&p_fs->v_sem);
+
+	return err;
+} /* end of FsMoveFile */
+
+/* FsRemoveFile : remove a file */
+int FsRemoveFile(struct inode *inode, FILE_ID_T *fid)
+{
+	int err;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	/* check the validity of the given file id */
+	if (fid == NULL)
+		return FFS_INVALIDFID;
+
+	/* acquire the lock for file system critical section */
+	sm_P(&p_fs->v_sem);
+
+	err = ffsRemoveFile(inode, fid);
+
+	/* release the lock for file system critical section */
+	sm_V(&p_fs->v_sem);
+
+	return err;
+} /* end of FsRemoveFile */
+
+/* FsSetAttr : set the attribute of a given file */
+int FsSetAttr(struct inode *inode, u32 attr)
+{
+	int err;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	/* acquire the lock for file system critical section */
+	sm_P(&p_fs->v_sem);
+
+	err = ffsSetAttr(inode, attr);
+
+	/* release the lock for file system critical section */
+	sm_V(&p_fs->v_sem);
+
+	return err;
+} /* end of FsSetAttr */
+
+/* FsReadStat : get the information of a given file */
+int FsReadStat(struct inode *inode, DIR_ENTRY_T *info)
+{
+	int err;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	/* acquire the lock for file system critical section */
+	sm_P(&p_fs->v_sem);
+
+	err = ffsGetStat(inode, info);
+
+	/* release the lock for file system critical section */
+	sm_V(&p_fs->v_sem);
+
+	return err;
+} /* end of FsReadStat */
+
+/* FsWriteStat : set the information of a given file */
+int FsWriteStat(struct inode *inode, DIR_ENTRY_T *info)
+{
+	int err;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	/* acquire the lock for file system critical section */
+	sm_P(&p_fs->v_sem);
+
+	DPRINTK("FsWriteStat entered (inode %p info %p\n", inode, info);
+
+	err = ffsSetStat(inode, info);
+
+	/* release the lock for file system critical section */
+	sm_V(&p_fs->v_sem);
+
+	DPRINTK("FsWriteStat exited (%d)\n", err);
+
+	return err;
+} /* end of FsWriteStat */
+
+/* FsMapCluster : return the cluster number in the given cluster offset */
+int FsMapCluster(struct inode *inode, s32 clu_offset, u32 *clu)
+{
+	int err;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	/* check the validity of pointer parameters */
+	if (clu == NULL)
+		return FFS_ERROR;
+
+	/* acquire the lock for file system critical section */
+	sm_P(&p_fs->v_sem);
+
+	err = ffsMapCluster(inode, clu_offset, clu);
+
+	/* release the lock for file system critical section */
+	sm_V(&p_fs->v_sem);
+
+	return err;
+} /* end of FsMapCluster */
+
+/*----------------------------------------------------------------------*/
+/*  Directory Operation Functions                                       */
+/*----------------------------------------------------------------------*/
+
+/* FsCreateDir : create(make) a directory */
+int FsCreateDir(struct inode *inode, char *path, FILE_ID_T *fid)
+{
+	int err;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	/* check the validity of pointer parameters */
+	if ((fid == NULL) || (path == NULL) || (*path == '\0'))
+		return FFS_ERROR;
+
+	/* acquire the lock for file system critical section */
+	sm_P(&p_fs->v_sem);
+
+	err = ffsCreateDir(inode, path, fid);
+
+	/* release the lock for file system critical section */
+	sm_V(&p_fs->v_sem);
+
+	return err;
+} /* end of FsCreateDir */
+
+/* FsReadDir : read a directory entry from the opened directory */
+int FsReadDir(struct inode *inode, DIR_ENTRY_T *dir_entry)
+{
+	int err;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	/* check the validity of pointer parameters */
+	if (dir_entry == NULL)
+		return FFS_ERROR;
+
+	/* acquire the lock for file system critical section */
+	sm_P(&p_fs->v_sem);
+
+	err = ffsReadDir(inode, dir_entry);
+
+	/* release the lock for file system critical section */
+	sm_V(&p_fs->v_sem);
+
+	return err;
+} /* end of FsReadDir */
+
+/* FsRemoveDir : remove a directory */
+int FsRemoveDir(struct inode *inode, FILE_ID_T *fid)
+{
+	int err;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	/* check the validity of the given file id */
+	if (fid == NULL)
+		return FFS_INVALIDFID;
+
+	/* acquire the lock for file system critical section */
+	sm_P(&p_fs->v_sem);
+
+	err = ffsRemoveDir(inode, fid);
+
+	/* release the lock for file system critical section */
+	sm_V(&p_fs->v_sem);
+
+	return err;
+} /* end of FsRemoveDir */
+
+EXPORT_SYMBOL(FsMountVol);
+EXPORT_SYMBOL(FsUmountVol);
+EXPORT_SYMBOL(FsGetVolInfo);
+EXPORT_SYMBOL(FsSyncVol);
+EXPORT_SYMBOL(FsLookupFile);
+EXPORT_SYMBOL(FsCreateFile);
+EXPORT_SYMBOL(FsReadFile);
+EXPORT_SYMBOL(FsWriteFile);
+EXPORT_SYMBOL(FsTruncateFile);
+EXPORT_SYMBOL(FsMoveFile);
+EXPORT_SYMBOL(FsRemoveFile);
+EXPORT_SYMBOL(FsSetAttr);
+EXPORT_SYMBOL(FsReadStat);
+EXPORT_SYMBOL(FsWriteStat);
+EXPORT_SYMBOL(FsMapCluster);
+EXPORT_SYMBOL(FsCreateDir);
+EXPORT_SYMBOL(FsReadDir);
+EXPORT_SYMBOL(FsRemoveDir);
+
+#ifdef CONFIG_EXFAT_KERNEL_DEBUG
+/* FsReleaseCache: Release FAT & buf cache */
+int FsReleaseCache(struct super_block *sb)
+{
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	/* acquire the lock for file system critical section */
+	sm_P(&p_fs->v_sem);
+
+	FAT_release_all(sb);
+	buf_release_all(sb);
+
+	/* release the lock for file system critical section */
+	sm_V(&p_fs->v_sem);
+
+	return 0;
+}
+/* FsReleaseCache */
+
+EXPORT_SYMBOL(FsReleaseCache);
+#endif /* CONFIG_EXFAT_KERNEL_DEBUG */
+
+/*======================================================================*/
+/*  Local Function Definitions                                          */
+/*======================================================================*/
diff --git a/kernel/fs/exfat/exfat_api.h b/kernel/fs/exfat/exfat_api.h
new file mode 100755
index 0000000000..84bdf612a1
--- /dev/null
+++ b/kernel/fs/exfat/exfat_api.h
@@ -0,0 +1,206 @@
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*  PROJECT : exFAT & FAT12/16/32 File System                           */
+/*  FILE    : exfat_api.h                                               */
+/*  PURPOSE : Header File for exFAT API Glue Layer                      */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  NOTES                                                               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  REVISION HISTORY (Ver 0.9)                                          */
+/*                                                                      */
+/*  - 2010.11.15 [Joosun Hahn] : first writing                          */
+/*                                                                      */
+/************************************************************************/
+
+#ifndef _EXFAT_API_H
+#define _EXFAT_API_H
+
+#include <linux/fs.h>
+#include "exfat_config.h"
+
+/*----------------------------------------------------------------------*/
+/*  Constant & Macro Definitions                                        */
+/*----------------------------------------------------------------------*/
+
+#define EXFAT_SUPER_MAGIC       (0x2011BAB0L)
+#define EXFAT_ROOT_INO          1
+
+/* FAT types */
+#define FAT12                   0x01    /* FAT12 */
+#define FAT16                   0x0E    /* Win95 FAT16 (LBA) */
+#define FAT32                   0x0C    /* Win95 FAT32 (LBA) */
+#define EXFAT                   0x07    /* exFAT */
+
+/* file name lengths */
+#define MAX_CHARSET_SIZE        3       /* max size of multi-byte character	*/
+#define MAX_PATH_DEPTH          15      /* max depth of path name */
+#define MAX_NAME_LENGTH         256     /* max len of file name including NULL */
+#define MAX_PATH_LENGTH         260     /* max len of path name including NULL */
+#define DOS_NAME_LENGTH         11      /* DOS file name length excluding NULL */
+#define DOS_PATH_LENGTH         80      /* DOS path name length excluding NULL */
+
+/* file attributes */
+#define ATTR_NORMAL             0x0000
+#define ATTR_READONLY           0x0001
+#define ATTR_HIDDEN             0x0002
+#define ATTR_SYSTEM             0x0004
+#define ATTR_VOLUME             0x0008
+#define ATTR_SUBDIR             0x0010
+#define ATTR_ARCHIVE            0x0020
+#define ATTR_SYMLINK            0x0040
+#define ATTR_EXTEND             0x000F
+#define ATTR_RWMASK             0x007E
+
+/* file creation modes */
+#define FM_REGULAR              0x00
+#define FM_SYMLINK              0x40
+
+/* return values */
+#define FFS_SUCCESS             0
+#define FFS_MEDIAERR            1
+#define FFS_FORMATERR           2
+#define FFS_MOUNTED             3
+#define FFS_NOTMOUNTED          4
+#define FFS_ALIGNMENTERR        5
+#define FFS_SEMAPHOREERR        6
+#define FFS_INVALIDPATH         7
+#define FFS_INVALIDFID          8
+#define FFS_NOTFOUND            9
+#define FFS_FILEEXIST           10
+#define FFS_PERMISSIONERR       11
+#define FFS_NOTOPENED           12
+#define FFS_MAXOPENED           13
+#define FFS_FULL                14
+#define FFS_EOF                 15
+#define FFS_DIRBUSY             16
+#define FFS_MEMORYERR           17
+#define FFS_NAMETOOLONG		18
+#define FFS_ERROR               19
+
+/*----------------------------------------------------------------------*/
+/*  Type Definitions                                                    */
+/*----------------------------------------------------------------------*/
+
+typedef struct {
+	u16      Year;
+	u16      Month;
+	u16      Day;
+	u16      Hour;
+	u16      Minute;
+	u16      Second;
+	u16      MilliSecond;
+} DATE_TIME_T;
+
+typedef struct {
+	u32      Offset;    /* start sector number of the partition */
+	u32      Size;      /* in sectors */
+} PART_INFO_T;
+
+typedef struct {
+	u32      SecSize;    /* sector size in bytes */
+	u32      DevSize;    /* block device size in sectors */
+} DEV_INFO_T;
+
+typedef struct {
+	u32      FatType;
+	u32      ClusterSize;
+	u32      NumClusters;
+	u32      FreeClusters;
+	u32      UsedClusters;
+} VOL_INFO_T;
+
+/* directory structure */
+typedef struct {
+	u32      dir;
+	s32       size;
+	u8       flags;
+} CHAIN_T;
+
+/* file id structure */
+typedef struct {
+	CHAIN_T     dir;
+	s32       entry;
+	u32      type;
+	u32      attr;
+	u32      start_clu;
+	u64      size;
+	u8       flags;
+	s64       rwoffset;
+	s32       hint_last_off;
+	u32      hint_last_clu;
+} FILE_ID_T;
+
+typedef struct {
+	char        Name[MAX_NAME_LENGTH * MAX_CHARSET_SIZE];
+	char        ShortName[DOS_NAME_LENGTH + 2];     /* used only for FAT12/16/32, not used for exFAT */
+	u32      Attr;
+	u64      Size;
+	u32      NumSubdirs;
+	DATE_TIME_T CreateTimestamp;
+	DATE_TIME_T ModifyTimestamp;
+	DATE_TIME_T AccessTimestamp;
+} DIR_ENTRY_T;
+
+/*======================================================================*/
+/*                                                                      */
+/*                     API FUNCTION DECLARATIONS                        */
+/*                  (CHANGE THIS PART IF REQUIRED)                      */
+/*                                                                      */
+/*======================================================================*/
+
+/*----------------------------------------------------------------------*/
+/*  External Function Declarations                                      */
+/*----------------------------------------------------------------------*/
+
+/* file system initialization & shutdown functions */
+	int FsInit(void);
+	int FsShutdown(void);
+
+/* volume management functions */
+	int FsMountVol(struct super_block *sb);
+	int FsUmountVol(struct super_block *sb);
+	int FsGetVolInfo(struct super_block *sb, VOL_INFO_T *info);
+	int FsSyncVol(struct super_block *sb, int do_sync);
+
+/* file management functions */
+	int FsLookupFile(struct inode *inode, char *path, FILE_ID_T *fid);
+	int FsCreateFile(struct inode *inode, char *path, u8 mode, FILE_ID_T *fid);
+	int FsReadFile(struct inode *inode, FILE_ID_T *fid, void *buffer, u64 count, u64 *rcount);
+	int FsWriteFile(struct inode *inode, FILE_ID_T *fid, void *buffer, u64 count, u64 *wcount);
+	int FsTruncateFile(struct inode *inode, u64 old_size, u64 new_size);
+	int FsMoveFile(struct inode *old_parent_inode, FILE_ID_T *fid, struct inode *new_parent_inode, struct dentry *new_dentry);
+	int FsRemoveFile(struct inode *inode, FILE_ID_T *fid);
+	int FsSetAttr(struct inode *inode, u32 attr);
+	int FsReadStat(struct inode *inode, DIR_ENTRY_T *info);
+	int FsWriteStat(struct inode *inode, DIR_ENTRY_T *info);
+	int FsMapCluster(struct inode *inode, s32 clu_offset, u32 *clu);
+
+/* directory management functions */
+	int FsCreateDir(struct inode *inode, char *path, FILE_ID_T *fid);
+	int FsReadDir(struct inode *inode, DIR_ENTRY_T *dir_entry);
+	int FsRemoveDir(struct inode *inode, FILE_ID_T *fid);
+
+/* debug functions */
+s32 FsReleaseCache(struct super_block *sb);
+
+#endif /* _EXFAT_API_H */
diff --git a/kernel/fs/exfat/exfat_bitmap.c b/kernel/fs/exfat/exfat_bitmap.c
new file mode 100755
index 0000000000..b0672dd073
--- /dev/null
+++ b/kernel/fs/exfat/exfat_bitmap.c
@@ -0,0 +1,63 @@
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*  PROJECT : exFAT & FAT12/16/32 File System                           */
+/*  FILE    : exfat_global.c                                            */
+/*  PURPOSE : exFAT Miscellaneous Functions                             */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  NOTES                                                               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  REVISION HISTORY (Ver 0.9)                                          */
+/*                                                                      */
+/*  - 2010.11.15 [Joosun Hahn] : first writing                          */
+/*                                                                      */
+/************************************************************************/
+
+#include "exfat_config.h"
+#include "exfat_bitmap.h"
+
+/*----------------------------------------------------------------------*/
+/*  Bitmap Manipulation Functions                                       */
+/*----------------------------------------------------------------------*/
+
+#define BITMAP_LOC(v)           ((v) >> 3)
+#define BITMAP_SHIFT(v)         ((v) & 0x07)
+
+s32 exfat_bitmap_test(u8 *bitmap, int i)
+{
+	u8 data;
+
+	data = bitmap[BITMAP_LOC(i)];
+	if ((data >> BITMAP_SHIFT(i)) & 0x01)
+		return 1;
+	return 0;
+} /* end of Bitmap_test */
+
+void exfat_bitmap_set(u8 *bitmap, int i)
+{
+	bitmap[BITMAP_LOC(i)] |= (0x01 << BITMAP_SHIFT(i));
+} /* end of Bitmap_set */
+
+void exfat_bitmap_clear(u8 *bitmap, int i)
+{
+	bitmap[BITMAP_LOC(i)] &= ~(0x01 << BITMAP_SHIFT(i));
+} /* end of Bitmap_clear */
diff --git a/kernel/fs/exfat/exfat_bitmap.h b/kernel/fs/exfat/exfat_bitmap.h
new file mode 100755
index 0000000000..4f482c7b28
--- /dev/null
+++ b/kernel/fs/exfat/exfat_bitmap.h
@@ -0,0 +1,55 @@
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*  PROJECT : exFAT & FAT12/16/32 File System                           */
+/*  FILE    : exfat_global.h                                            */
+/*  PURPOSE : Header File for exFAT Global Definitions & Misc Functions */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  NOTES                                                               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  REVISION HISTORY (Ver 0.9)                                          */
+/*                                                                      */
+/*  - 2010.11.15 [Joosun Hahn] : first writing                          */
+/*                                                                      */
+/************************************************************************/
+
+#ifndef _EXFAT_BITMAP_H
+#define _EXFAT_BITMAP_H
+
+#include <linux/types.h>
+
+/*======================================================================*/
+/*                                                                      */
+/*       LIBRARY FUNCTION DECLARATIONS -- OTHER UTILITY FUNCTIONS       */
+/*                    (DO NOT CHANGE THIS PART !!)                      */
+/*                                                                      */
+/*======================================================================*/
+
+/*----------------------------------------------------------------------*/
+/*  Bitmap Manipulation Functions                                       */
+/*----------------------------------------------------------------------*/
+
+s32	exfat_bitmap_test(u8 *bitmap, int i);
+void	exfat_bitmap_set(u8 *bitmap, int i);
+void	exfat_bitmap_clear(u8 *bitmpa, int i);
+
+#endif /* _EXFAT_BITMAP_H */
diff --git a/kernel/fs/exfat/exfat_blkdev.c b/kernel/fs/exfat/exfat_blkdev.c
new file mode 100755
index 0000000000..eaccfd84e9
--- /dev/null
+++ b/kernel/fs/exfat/exfat_blkdev.c
@@ -0,0 +1,197 @@
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*  PROJECT : exFAT & FAT12/16/32 File System                           */
+/*  FILE    : exfat_blkdev.c                                            */
+/*  PURPOSE : exFAT Block Device Driver Glue Layer                      */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  NOTES                                                               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  REVISION HISTORY (Ver 0.9)                                          */
+/*                                                                      */
+/*  - 2010.11.15 [Joosun Hahn] : first writing                          */
+/*                                                                      */
+/************************************************************************/
+
+#include <linux/blkdev.h>
+#include <linux/log2.h>
+#include "exfat_config.h"
+#include "exfat_blkdev.h"
+#include "exfat_data.h"
+#include "exfat_api.h"
+#include "exfat_super.h"
+
+/*----------------------------------------------------------------------*/
+/*  Constant & Macro Definitions                                        */
+/*----------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------*/
+/*  Global Variable Definitions                                         */
+/*----------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------*/
+/*  Local Variable Definitions                                          */
+/*----------------------------------------------------------------------*/
+
+/*======================================================================*/
+/*  Function Definitions                                                */
+/*======================================================================*/
+
+s32 bdev_init(void)
+{
+	return FFS_SUCCESS;
+}
+
+s32 bdev_shutdown(void)
+{
+	return FFS_SUCCESS;
+}
+
+s32 bdev_open(struct super_block *sb)
+{
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+
+	if (p_bd->opened)
+		return FFS_SUCCESS;
+
+	p_bd->sector_size      = bdev_logical_block_size(sb->s_bdev);
+	p_bd->sector_size_bits = ilog2(p_bd->sector_size);
+	p_bd->sector_size_mask = p_bd->sector_size - 1;
+	p_bd->num_sectors      = i_size_read(sb->s_bdev->bd_inode) >> p_bd->sector_size_bits;
+
+	p_bd->opened = TRUE;
+
+	return FFS_SUCCESS;
+}
+
+s32 bdev_close(struct super_block *sb)
+{
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+
+	if (!p_bd->opened)
+		return FFS_SUCCESS;
+
+	p_bd->opened = FALSE;
+	return FFS_SUCCESS;
+}
+
+s32 bdev_read(struct super_block *sb, sector_t secno, struct buffer_head **bh, u32 num_secs, s32 read)
+{
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+#ifdef CONFIG_EXFAT_KERNEL_DEBUG
+	struct exfat_sb_info *sbi = EXFAT_SB(sb);
+	long flags = sbi->debug_flags;
+
+	if (flags & EXFAT_DEBUGFLAGS_ERROR_RW)
+		return FFS_MEDIAERR;
+#endif /* CONFIG_EXFAT_KERNEL_DEBUG */
+
+	if (!p_bd->opened)
+		return FFS_MEDIAERR;
+
+	if (*bh)
+		__brelse(*bh);
+
+	if (read)
+		*bh = __bread(sb->s_bdev, secno, num_secs << p_bd->sector_size_bits);
+	else
+		*bh = __getblk(sb->s_bdev, secno, num_secs << p_bd->sector_size_bits);
+
+	if (*bh)
+		return FFS_SUCCESS;
+
+	WARN(!p_fs->dev_ejected,
+		"[EXFAT] No bh, device seems wrong or to be ejected.\n");
+
+	return FFS_MEDIAERR;
+}
+
+s32 bdev_write(struct super_block *sb, sector_t secno, struct buffer_head *bh, u32 num_secs, s32 sync)
+{
+	s32 count;
+	struct buffer_head *bh2;
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+#ifdef CONFIG_EXFAT_KERNEL_DEBUG
+	struct exfat_sb_info *sbi = EXFAT_SB(sb);
+	long flags = sbi->debug_flags;
+
+	if (flags & EXFAT_DEBUGFLAGS_ERROR_RW)
+		return FFS_MEDIAERR;
+#endif /* CONFIG_EXFAT_KERNEL_DEBUG */
+
+	if (!p_bd->opened)
+		return FFS_MEDIAERR;
+
+	if (secno == bh->b_blocknr) {
+		lock_buffer(bh);
+		set_buffer_uptodate(bh);
+		mark_buffer_dirty(bh);
+		unlock_buffer(bh);
+		if (sync && (sync_dirty_buffer(bh) != 0))
+			return FFS_MEDIAERR;
+	} else {
+		count = num_secs << p_bd->sector_size_bits;
+
+		bh2 = __getblk(sb->s_bdev, secno, count);
+
+		if (bh2 == NULL)
+			goto no_bh;
+
+		lock_buffer(bh2);
+		memcpy(bh2->b_data, bh->b_data, count);
+		set_buffer_uptodate(bh2);
+		mark_buffer_dirty(bh2);
+		unlock_buffer(bh2);
+		if (sync && (sync_dirty_buffer(bh2) != 0)) {
+			__brelse(bh2);
+			goto no_bh;
+		}
+		__brelse(bh2);
+	}
+
+	return FFS_SUCCESS;
+
+no_bh:
+	WARN(!p_fs->dev_ejected,
+		"[EXFAT] No bh, device seems wrong or to be ejected.\n");
+
+	return FFS_MEDIAERR;
+}
+
+s32 bdev_sync(struct super_block *sb)
+{
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+#ifdef CONFIG_EXFAT_KERNEL_DEBUG
+	struct exfat_sb_info *sbi = EXFAT_SB(sb);
+	long flags = sbi->debug_flags;
+
+	if (flags & EXFAT_DEBUGFLAGS_ERROR_RW)
+		return FFS_MEDIAERR;
+#endif /* CONFIG_EXFAT_KERNEL_DEBUG */
+
+	if (!p_bd->opened)
+		return FFS_MEDIAERR;
+
+	return sync_blockdev(sb->s_bdev);
+}
diff --git a/kernel/fs/exfat/exfat_blkdev.h b/kernel/fs/exfat/exfat_blkdev.h
new file mode 100755
index 0000000000..3363b591ca
--- /dev/null
+++ b/kernel/fs/exfat/exfat_blkdev.h
@@ -0,0 +1,73 @@
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*  PROJECT : exFAT & FAT12/16/32 File System                           */
+/*  FILE    : exfat_blkdev.h                                            */
+/*  PURPOSE : Header File for exFAT Block Device Driver Glue Layer      */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  NOTES                                                               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  REVISION HISTORY (Ver 0.9)                                          */
+/*                                                                      */
+/*  - 2010.11.15 [Joosun Hahn] : first writing                          */
+/*                                                                      */
+/************************************************************************/
+
+#ifndef _EXFAT_BLKDEV_H
+#define _EXFAT_BLKDEV_H
+
+#include <linux/fs.h>
+#include "exfat_config.h"
+
+/*----------------------------------------------------------------------*/
+/*  Constant & Macro Definitions (Non-Configurable)                     */
+/*----------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------*/
+/*  Type Definitions                                                    */
+/*----------------------------------------------------------------------*/
+
+typedef struct __BD_INFO_T {
+	s32 sector_size;      /* in bytes */
+	s32 sector_size_bits;
+	s32 sector_size_mask;
+	s32 num_sectors;      /* total number of sectors in this block device */
+	bool  opened;           /* opened or not */
+} BD_INFO_T;
+
+/*----------------------------------------------------------------------*/
+/*  External Variable Declarations                                      */
+/*----------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------*/
+/*  External Function Declarations                                      */
+/*----------------------------------------------------------------------*/
+
+s32 bdev_init(void);
+s32 bdev_shutdown(void);
+s32 bdev_open(struct super_block *sb);
+s32 bdev_close(struct super_block *sb);
+s32 bdev_read(struct super_block *sb, sector_t secno, struct buffer_head **bh, u32 num_secs, s32 read);
+s32 bdev_write(struct super_block *sb, sector_t secno, struct buffer_head *bh, u32 num_secs, s32 sync);
+s32 bdev_sync(struct super_block *sb);
+
+#endif /* _EXFAT_BLKDEV_H */
diff --git a/kernel/fs/exfat/exfat_cache.c b/kernel/fs/exfat/exfat_cache.c
new file mode 100755
index 0000000000..4130102e37
--- /dev/null
+++ b/kernel/fs/exfat/exfat_cache.c
@@ -0,0 +1,784 @@
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*  PROJECT : exFAT & FAT12/16/32 File System                           */
+/*  FILE    : exfat_cache.c                                             */
+/*  PURPOSE : exFAT Cache Manager                                       */
+/*            (FAT Cache & Buffer Cache)                                */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  NOTES                                                               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  REVISION HISTORY (Ver 0.9)                                          */
+/*                                                                      */
+/*  - 2010.11.15 [Sung-Kwan Kim] : first writing                        */
+/*                                                                      */
+/************************************************************************/
+
+#include "exfat_config.h"
+#include "exfat_data.h"
+
+#include "exfat_cache.h"
+#include "exfat_super.h"
+#include "exfat_core.h"
+
+/*----------------------------------------------------------------------*/
+/*  Global Variable Definitions                                         */
+/*----------------------------------------------------------------------*/
+
+#define sm_P(s)
+#define sm_V(s)
+
+static s32 __FAT_read(struct super_block *sb, u32 loc, u32 *content);
+static s32 __FAT_write(struct super_block *sb, u32 loc, u32 content);
+
+static BUF_CACHE_T *FAT_cache_find(struct super_block *sb, sector_t sec);
+static BUF_CACHE_T *FAT_cache_get(struct super_block *sb, sector_t sec);
+static void FAT_cache_insert_hash(struct super_block *sb, BUF_CACHE_T *bp);
+static void FAT_cache_remove_hash(BUF_CACHE_T *bp);
+
+static u8 *__buf_getblk(struct super_block *sb, sector_t sec);
+
+static BUF_CACHE_T *buf_cache_find(struct super_block *sb, sector_t sec);
+static BUF_CACHE_T *buf_cache_get(struct super_block *sb, sector_t sec);
+static void buf_cache_insert_hash(struct super_block *sb, BUF_CACHE_T *bp);
+static void buf_cache_remove_hash(BUF_CACHE_T *bp);
+
+static void push_to_mru(BUF_CACHE_T *bp, BUF_CACHE_T *list);
+static void push_to_lru(BUF_CACHE_T *bp, BUF_CACHE_T *list);
+static void move_to_mru(BUF_CACHE_T *bp, BUF_CACHE_T *list);
+static void move_to_lru(BUF_CACHE_T *bp, BUF_CACHE_T *list);
+
+/*======================================================================*/
+/*  Cache Initialization Functions                                      */
+/*======================================================================*/
+
+s32 buf_init(struct super_block *sb)
+{
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	int i;
+
+	/* LRU list */
+	p_fs->FAT_cache_lru_list.next = p_fs->FAT_cache_lru_list.prev = &p_fs->FAT_cache_lru_list;
+
+	for (i = 0; i < FAT_CACHE_SIZE; i++) {
+		p_fs->FAT_cache_array[i].drv = -1;
+		p_fs->FAT_cache_array[i].sec = ~0;
+		p_fs->FAT_cache_array[i].flag = 0;
+		p_fs->FAT_cache_array[i].buf_bh = NULL;
+		p_fs->FAT_cache_array[i].prev = p_fs->FAT_cache_array[i].next = NULL;
+		push_to_mru(&(p_fs->FAT_cache_array[i]), &p_fs->FAT_cache_lru_list);
+	}
+
+	p_fs->buf_cache_lru_list.next = p_fs->buf_cache_lru_list.prev = &p_fs->buf_cache_lru_list;
+
+	for (i = 0; i < BUF_CACHE_SIZE; i++) {
+		p_fs->buf_cache_array[i].drv = -1;
+		p_fs->buf_cache_array[i].sec = ~0;
+		p_fs->buf_cache_array[i].flag = 0;
+		p_fs->buf_cache_array[i].buf_bh = NULL;
+		p_fs->buf_cache_array[i].prev = p_fs->buf_cache_array[i].next = NULL;
+		push_to_mru(&(p_fs->buf_cache_array[i]), &p_fs->buf_cache_lru_list);
+	}
+
+	/* HASH list */
+	for (i = 0; i < FAT_CACHE_HASH_SIZE; i++) {
+		p_fs->FAT_cache_hash_list[i].drv = -1;
+		p_fs->FAT_cache_hash_list[i].sec = ~0;
+		p_fs->FAT_cache_hash_list[i].hash_next = p_fs->FAT_cache_hash_list[i].hash_prev = &(p_fs->FAT_cache_hash_list[i]);
+	}
+
+	for (i = 0; i < FAT_CACHE_SIZE; i++)
+		FAT_cache_insert_hash(sb, &(p_fs->FAT_cache_array[i]));
+
+	for (i = 0; i < BUF_CACHE_HASH_SIZE; i++) {
+		p_fs->buf_cache_hash_list[i].drv = -1;
+		p_fs->buf_cache_hash_list[i].sec = ~0;
+		p_fs->buf_cache_hash_list[i].hash_next = p_fs->buf_cache_hash_list[i].hash_prev = &(p_fs->buf_cache_hash_list[i]);
+	}
+
+	for (i = 0; i < BUF_CACHE_SIZE; i++)
+		buf_cache_insert_hash(sb, &(p_fs->buf_cache_array[i]));
+
+	return FFS_SUCCESS;
+} /* end of buf_init */
+
+s32 buf_shutdown(struct super_block *sb)
+{
+	return FFS_SUCCESS;
+} /* end of buf_shutdown */
+
+/*======================================================================*/
+/*  FAT Read/Write Functions                                            */
+/*======================================================================*/
+
+/* in : sb, loc
+  * out: content
+  * returns 0 on success
+  *            -1 on error
+  */
+s32 FAT_read(struct super_block *sb, u32 loc, u32 *content)
+{
+	s32 ret;
+
+	sm_P(&f_sem);
+
+	ret = __FAT_read(sb, loc, content);
+
+	sm_V(&f_sem);
+
+	return ret;
+} /* end of FAT_read */
+
+s32 FAT_write(struct super_block *sb, u32 loc, u32 content)
+{
+	s32 ret;
+
+	sm_P(&f_sem);
+
+	ret = __FAT_write(sb, loc, content);
+
+	sm_V(&f_sem);
+
+	return ret;
+} /* end of FAT_write */
+
+static s32 __FAT_read(struct super_block *sb, u32 loc, u32 *content)
+{
+	s32 off;
+	u32 _content;
+	sector_t sec;
+	u8 *fat_sector, *fat_entry;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+
+	if (p_fs->vol_type == FAT12) {
+		sec = p_fs->FAT1_start_sector + ((loc + (loc >> 1)) >> p_bd->sector_size_bits);
+		off = (loc + (loc >> 1)) & p_bd->sector_size_mask;
+
+		if (off == (p_bd->sector_size-1)) {
+			fat_sector = FAT_getblk(sb, sec);
+			if (!fat_sector)
+				return -1;
+
+			_content  = (u32) fat_sector[off];
+
+			fat_sector = FAT_getblk(sb, ++sec);
+			if (!fat_sector)
+				return -1;
+
+			_content |= (u32) fat_sector[0] << 8;
+		} else {
+			fat_sector = FAT_getblk(sb, sec);
+			if (!fat_sector)
+				return -1;
+
+			fat_entry = &(fat_sector[off]);
+			_content = GET16(fat_entry);
+		}
+
+		if (loc & 1)
+			_content >>= 4;
+
+		_content &= 0x00000FFF;
+
+		if (_content >= CLUSTER_16(0x0FF8)) {
+			*content = CLUSTER_32(~0);
+			return 0;
+		} else {
+			*content = CLUSTER_32(_content);
+			return 0;
+		}
+	} else if (p_fs->vol_type == FAT16) {
+		sec = p_fs->FAT1_start_sector + (loc >> (p_bd->sector_size_bits-1));
+		off = (loc << 1) & p_bd->sector_size_mask;
+
+		fat_sector = FAT_getblk(sb, sec);
+		if (!fat_sector)
+			return -1;
+
+		fat_entry = &(fat_sector[off]);
+
+		_content = GET16_A(fat_entry);
+
+		_content &= 0x0000FFFF;
+
+		if (_content >= CLUSTER_16(0xFFF8)) {
+			*content = CLUSTER_32(~0);
+			return 0;
+		} else {
+			*content = CLUSTER_32(_content);
+			return 0;
+		}
+	} else if (p_fs->vol_type == FAT32) {
+		sec = p_fs->FAT1_start_sector + (loc >> (p_bd->sector_size_bits-2));
+		off = (loc << 2) & p_bd->sector_size_mask;
+
+		fat_sector = FAT_getblk(sb, sec);
+		if (!fat_sector)
+			return -1;
+
+		fat_entry = &(fat_sector[off]);
+
+		_content = GET32_A(fat_entry);
+
+		_content &= 0x0FFFFFFF;
+
+		if (_content >= CLUSTER_32(0x0FFFFFF8)) {
+			*content = CLUSTER_32(~0);
+			return 0;
+		} else {
+			*content = CLUSTER_32(_content);
+			return 0;
+		}
+	} else {
+		sec = p_fs->FAT1_start_sector + (loc >> (p_bd->sector_size_bits-2));
+		off = (loc << 2) & p_bd->sector_size_mask;
+
+		fat_sector = FAT_getblk(sb, sec);
+		if (!fat_sector)
+			return -1;
+
+		fat_entry = &(fat_sector[off]);
+		_content = GET32_A(fat_entry);
+
+		if (_content >= CLUSTER_32(0xFFFFFFF8)) {
+			*content = CLUSTER_32(~0);
+			return 0;
+		} else {
+			*content = CLUSTER_32(_content);
+			return 0;
+		}
+	}
+
+	*content = CLUSTER_32(~0);
+	return 0;
+} /* end of __FAT_read */
+
+static s32 __FAT_write(struct super_block *sb, u32 loc, u32 content)
+{
+	s32 off;
+	sector_t sec;
+	u8 *fat_sector, *fat_entry;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+
+	if (p_fs->vol_type == FAT12) {
+
+		content &= 0x00000FFF;
+
+		sec = p_fs->FAT1_start_sector + ((loc + (loc >> 1)) >> p_bd->sector_size_bits);
+		off = (loc + (loc >> 1)) & p_bd->sector_size_mask;
+
+		fat_sector = FAT_getblk(sb, sec);
+		if (!fat_sector)
+			return -1;
+
+		if (loc & 1) { /* odd */
+
+			content <<= 4;
+
+			if (off == (p_bd->sector_size-1)) {
+				fat_sector[off] = (u8)(content | (fat_sector[off] & 0x0F));
+				FAT_modify(sb, sec);
+
+				fat_sector = FAT_getblk(sb, ++sec);
+				if (!fat_sector)
+					return -1;
+
+				fat_sector[0] = (u8)(content >> 8);
+			} else {
+				fat_entry = &(fat_sector[off]);
+				content |= GET16(fat_entry) & 0x000F;
+
+				SET16(fat_entry, content);
+			}
+		} else { /* even */
+			fat_sector[off] = (u8)(content);
+
+			if (off == (p_bd->sector_size-1)) {
+				fat_sector[off] = (u8)(content);
+				FAT_modify(sb, sec);
+
+				fat_sector = FAT_getblk(sb, ++sec);
+				fat_sector[0] = (u8)((fat_sector[0] & 0xF0) | (content >> 8));
+			} else {
+				fat_entry = &(fat_sector[off]);
+				content |= GET16(fat_entry) & 0xF000;
+
+				SET16(fat_entry, content);
+			}
+		}
+	}
+
+	else if (p_fs->vol_type == FAT16) {
+
+		content &= 0x0000FFFF;
+
+		sec = p_fs->FAT1_start_sector + (loc >> (p_bd->sector_size_bits-1));
+		off = (loc << 1) & p_bd->sector_size_mask;
+
+		fat_sector = FAT_getblk(sb, sec);
+		if (!fat_sector)
+			return -1;
+
+		fat_entry = &(fat_sector[off]);
+
+		SET16_A(fat_entry, content);
+	}
+
+	else if (p_fs->vol_type == FAT32) {
+
+		content &= 0x0FFFFFFF;
+
+		sec = p_fs->FAT1_start_sector + (loc >> (p_bd->sector_size_bits-2));
+		off = (loc << 2) & p_bd->sector_size_mask;
+
+		fat_sector = FAT_getblk(sb, sec);
+		if (!fat_sector)
+			return -1;
+
+		fat_entry = &(fat_sector[off]);
+
+		content |= GET32_A(fat_entry) & 0xF0000000;
+
+		SET32_A(fat_entry, content);
+	}
+
+	else { /* p_fs->vol_type == EXFAT */
+
+		sec = p_fs->FAT1_start_sector + (loc >> (p_bd->sector_size_bits-2));
+		off = (loc << 2) & p_bd->sector_size_mask;
+
+		fat_sector = FAT_getblk(sb, sec);
+		if (!fat_sector)
+			return -1;
+
+		fat_entry = &(fat_sector[off]);
+
+		SET32_A(fat_entry, content);
+	}
+
+	FAT_modify(sb, sec);
+	return 0;
+} /* end of __FAT_write */
+
+u8 *FAT_getblk(struct super_block *sb, sector_t sec)
+{
+	BUF_CACHE_T *bp;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	bp = FAT_cache_find(sb, sec);
+	if (bp != NULL) {
+		move_to_mru(bp, &p_fs->FAT_cache_lru_list);
+		return bp->buf_bh->b_data;
+	}
+
+	bp = FAT_cache_get(sb, sec);
+
+	FAT_cache_remove_hash(bp);
+
+	bp->drv = p_fs->drv;
+	bp->sec = sec;
+	bp->flag = 0;
+
+	FAT_cache_insert_hash(sb, bp);
+
+	if (sector_read(sb, sec, &(bp->buf_bh), 1) != FFS_SUCCESS) {
+		FAT_cache_remove_hash(bp);
+		bp->drv = -1;
+		bp->sec = ~0;
+		bp->flag = 0;
+		bp->buf_bh = NULL;
+
+		move_to_lru(bp, &p_fs->FAT_cache_lru_list);
+		return NULL;
+	}
+
+	return bp->buf_bh->b_data;
+} /* end of FAT_getblk */
+
+void FAT_modify(struct super_block *sb, sector_t sec)
+{
+	BUF_CACHE_T *bp;
+
+	bp = FAT_cache_find(sb, sec);
+	if (bp != NULL)
+		sector_write(sb, sec, bp->buf_bh, 0);
+} /* end of FAT_modify */
+
+void FAT_release_all(struct super_block *sb)
+{
+	BUF_CACHE_T *bp;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	sm_P(&f_sem);
+
+	bp = p_fs->FAT_cache_lru_list.next;
+	while (bp != &p_fs->FAT_cache_lru_list) {
+		if (bp->drv == p_fs->drv) {
+			bp->drv = -1;
+			bp->sec = ~0;
+			bp->flag = 0;
+
+			if (bp->buf_bh) {
+				__brelse(bp->buf_bh);
+				bp->buf_bh = NULL;
+			}
+		}
+		bp = bp->next;
+	}
+
+	sm_V(&f_sem);
+} /* end of FAT_release_all */
+
+void FAT_sync(struct super_block *sb)
+{
+	BUF_CACHE_T *bp;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	sm_P(&f_sem);
+
+	bp = p_fs->FAT_cache_lru_list.next;
+	while (bp != &p_fs->FAT_cache_lru_list) {
+		if ((bp->drv == p_fs->drv) && (bp->flag & DIRTYBIT)) {
+			sync_dirty_buffer(bp->buf_bh);
+			bp->flag &= ~(DIRTYBIT);
+		}
+		bp = bp->next;
+	}
+
+	sm_V(&f_sem);
+} /* end of FAT_sync */
+
+static BUF_CACHE_T *FAT_cache_find(struct super_block *sb, sector_t sec)
+{
+	s32 off;
+	BUF_CACHE_T *bp, *hp;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	off = (sec + (sec >> p_fs->sectors_per_clu_bits)) & (FAT_CACHE_HASH_SIZE - 1);
+
+	hp = &(p_fs->FAT_cache_hash_list[off]);
+	for (bp = hp->hash_next; bp != hp; bp = bp->hash_next) {
+		if ((bp->drv == p_fs->drv) && (bp->sec == sec)) {
+
+			WARN(!bp->buf_bh, "[EXFAT] FAT_cache has no bh. "
+					  "It will make system panic.\n");
+
+			touch_buffer(bp->buf_bh);
+			return bp;
+		}
+	}
+	return NULL;
+} /* end of FAT_cache_find */
+
+static BUF_CACHE_T *FAT_cache_get(struct super_block *sb, sector_t sec)
+{
+	BUF_CACHE_T *bp;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	bp = p_fs->FAT_cache_lru_list.prev;
+
+
+	move_to_mru(bp, &p_fs->FAT_cache_lru_list);
+	return bp;
+} /* end of FAT_cache_get */
+
+static void FAT_cache_insert_hash(struct super_block *sb, BUF_CACHE_T *bp)
+{
+	s32 off;
+	BUF_CACHE_T *hp;
+	FS_INFO_T *p_fs;
+
+	p_fs = &(EXFAT_SB(sb)->fs_info);
+	off = (bp->sec + (bp->sec >> p_fs->sectors_per_clu_bits)) & (FAT_CACHE_HASH_SIZE-1);
+
+	hp = &(p_fs->FAT_cache_hash_list[off]);
+	bp->hash_next = hp->hash_next;
+	bp->hash_prev = hp;
+	hp->hash_next->hash_prev = bp;
+	hp->hash_next = bp;
+} /* end of FAT_cache_insert_hash */
+
+static void FAT_cache_remove_hash(BUF_CACHE_T *bp)
+{
+	(bp->hash_prev)->hash_next = bp->hash_next;
+	(bp->hash_next)->hash_prev = bp->hash_prev;
+} /* end of FAT_cache_remove_hash */
+
+/*======================================================================*/
+/*  Buffer Read/Write Functions                                         */
+/*======================================================================*/
+
+u8 *buf_getblk(struct super_block *sb, sector_t sec)
+{
+	u8 *buf;
+
+	sm_P(&b_sem);
+
+	buf = __buf_getblk(sb, sec);
+
+	sm_V(&b_sem);
+
+	return buf;
+} /* end of buf_getblk */
+
+static u8 *__buf_getblk(struct super_block *sb, sector_t sec)
+{
+	BUF_CACHE_T *bp;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	bp = buf_cache_find(sb, sec);
+	if (bp != NULL) {
+		move_to_mru(bp, &p_fs->buf_cache_lru_list);
+		return bp->buf_bh->b_data;
+	}
+
+	bp = buf_cache_get(sb, sec);
+
+	buf_cache_remove_hash(bp);
+
+	bp->drv = p_fs->drv;
+	bp->sec = sec;
+	bp->flag = 0;
+
+	buf_cache_insert_hash(sb, bp);
+
+	if (sector_read(sb, sec, &(bp->buf_bh), 1) != FFS_SUCCESS) {
+		buf_cache_remove_hash(bp);
+		bp->drv = -1;
+		bp->sec = ~0;
+		bp->flag = 0;
+		bp->buf_bh = NULL;
+
+		move_to_lru(bp, &p_fs->buf_cache_lru_list);
+		return NULL;
+	}
+
+	return bp->buf_bh->b_data;
+
+} /* end of __buf_getblk */
+
+void buf_modify(struct super_block *sb, sector_t sec)
+{
+	BUF_CACHE_T *bp;
+
+	sm_P(&b_sem);
+
+	bp = buf_cache_find(sb, sec);
+	if (likely(bp != NULL))
+		sector_write(sb, sec, bp->buf_bh, 0);
+
+	WARN(!bp, "[EXFAT] failed to find buffer_cache(sector:%llu).\n",
+	     (unsigned long long)sec);
+
+	sm_V(&b_sem);
+} /* end of buf_modify */
+
+void buf_lock(struct super_block *sb, sector_t sec)
+{
+	BUF_CACHE_T *bp;
+
+	sm_P(&b_sem);
+
+	bp = buf_cache_find(sb, sec);
+	if (likely(bp != NULL))
+		bp->flag |= LOCKBIT;
+
+	WARN(!bp, "[EXFAT] failed to find buffer_cache(sector:%llu).\n",
+	     (unsigned long long)sec);
+
+	sm_V(&b_sem);
+} /* end of buf_lock */
+
+void buf_unlock(struct super_block *sb, sector_t sec)
+{
+	BUF_CACHE_T *bp;
+
+	sm_P(&b_sem);
+
+	bp = buf_cache_find(sb, sec);
+	if (likely(bp != NULL))
+		bp->flag &= ~(LOCKBIT);
+
+	WARN(!bp, "[EXFAT] failed to find buffer_cache(sector:%llu).\n",
+	     (unsigned long long)sec);
+
+	sm_V(&b_sem);
+} /* end of buf_unlock */
+
+void buf_release(struct super_block *sb, sector_t sec)
+{
+	BUF_CACHE_T *bp;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	sm_P(&b_sem);
+
+	bp = buf_cache_find(sb, sec);
+	if (likely(bp != NULL)) {
+		bp->drv = -1;
+		bp->sec = ~0;
+		bp->flag = 0;
+
+		if (bp->buf_bh) {
+			__brelse(bp->buf_bh);
+			bp->buf_bh = NULL;
+		}
+
+		move_to_lru(bp, &p_fs->buf_cache_lru_list);
+	}
+
+	sm_V(&b_sem);
+} /* end of buf_release */
+
+void buf_release_all(struct super_block *sb)
+{
+	BUF_CACHE_T *bp;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	sm_P(&b_sem);
+
+	bp = p_fs->buf_cache_lru_list.next;
+	while (bp != &p_fs->buf_cache_lru_list) {
+		if (bp->drv == p_fs->drv) {
+			bp->drv = -1;
+			bp->sec = ~0;
+			bp->flag = 0;
+
+			if (bp->buf_bh) {
+				__brelse(bp->buf_bh);
+				bp->buf_bh = NULL;
+			}
+		}
+		bp = bp->next;
+	}
+
+	sm_V(&b_sem);
+} /* end of buf_release_all */
+
+void buf_sync(struct super_block *sb)
+{
+	BUF_CACHE_T *bp;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	sm_P(&b_sem);
+
+	bp = p_fs->buf_cache_lru_list.next;
+	while (bp != &p_fs->buf_cache_lru_list) {
+		if ((bp->drv == p_fs->drv) && (bp->flag & DIRTYBIT)) {
+			sync_dirty_buffer(bp->buf_bh);
+			bp->flag &= ~(DIRTYBIT);
+		}
+		bp = bp->next;
+	}
+
+	sm_V(&b_sem);
+} /* end of buf_sync */
+
+static BUF_CACHE_T *buf_cache_find(struct super_block *sb, sector_t sec)
+{
+	s32 off;
+	BUF_CACHE_T *bp, *hp;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	off = (sec + (sec >> p_fs->sectors_per_clu_bits)) & (BUF_CACHE_HASH_SIZE - 1);
+
+	hp = &(p_fs->buf_cache_hash_list[off]);
+	for (bp = hp->hash_next; bp != hp; bp = bp->hash_next) {
+		if ((bp->drv == p_fs->drv) && (bp->sec == sec)) {
+			touch_buffer(bp->buf_bh);
+			return bp;
+		}
+	}
+	return NULL;
+} /* end of buf_cache_find */
+
+static BUF_CACHE_T *buf_cache_get(struct super_block *sb, sector_t sec)
+{
+	BUF_CACHE_T *bp;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	bp = p_fs->buf_cache_lru_list.prev;
+	while (bp->flag & LOCKBIT)
+		bp = bp->prev;
+
+
+	move_to_mru(bp, &p_fs->buf_cache_lru_list);
+	return bp;
+} /* end of buf_cache_get */
+
+static void buf_cache_insert_hash(struct super_block *sb, BUF_CACHE_T *bp)
+{
+	s32 off;
+	BUF_CACHE_T *hp;
+	FS_INFO_T *p_fs;
+
+	p_fs = &(EXFAT_SB(sb)->fs_info);
+	off = (bp->sec + (bp->sec >> p_fs->sectors_per_clu_bits)) & (BUF_CACHE_HASH_SIZE-1);
+
+	hp = &(p_fs->buf_cache_hash_list[off]);
+	bp->hash_next = hp->hash_next;
+	bp->hash_prev = hp;
+	hp->hash_next->hash_prev = bp;
+	hp->hash_next = bp;
+} /* end of buf_cache_insert_hash */
+
+static void buf_cache_remove_hash(BUF_CACHE_T *bp)
+{
+	(bp->hash_prev)->hash_next = bp->hash_next;
+	(bp->hash_next)->hash_prev = bp->hash_prev;
+} /* end of buf_cache_remove_hash */
+
+/*======================================================================*/
+/*  Local Function Definitions                                          */
+/*======================================================================*/
+
+static void push_to_mru(BUF_CACHE_T *bp, BUF_CACHE_T *list)
+{
+	bp->next = list->next;
+	bp->prev = list;
+	list->next->prev = bp;
+	list->next = bp;
+} /* end of buf_cache_push_to_mru */
+
+static void push_to_lru(BUF_CACHE_T *bp, BUF_CACHE_T *list)
+{
+	bp->prev = list->prev;
+	bp->next = list;
+	list->prev->next = bp;
+	list->prev = bp;
+} /* end of buf_cache_push_to_lru */
+
+static void move_to_mru(BUF_CACHE_T *bp, BUF_CACHE_T *list)
+{
+	bp->prev->next = bp->next;
+	bp->next->prev = bp->prev;
+	push_to_mru(bp, list);
+} /* end of buf_cache_move_to_mru */
+
+static void move_to_lru(BUF_CACHE_T *bp, BUF_CACHE_T *list)
+{
+	bp->prev->next = bp->next;
+	bp->next->prev = bp->prev;
+	push_to_lru(bp, list);
+} /* end of buf_cache_move_to_lru */
diff --git a/kernel/fs/exfat/exfat_cache.h b/kernel/fs/exfat/exfat_cache.h
new file mode 100755
index 0000000000..540e31681d
--- /dev/null
+++ b/kernel/fs/exfat/exfat_cache.h
@@ -0,0 +1,85 @@
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*  PROJECT : exFAT & FAT12/16/32 File System                           */
+/*  FILE    : exfat_cache.h                                             */
+/*  PURPOSE : Header File for exFAT Cache Manager                       */
+/*            (FAT Cache & Buffer Cache)                                */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  NOTES                                                               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  REVISION HISTORY (Ver 0.9)                                          */
+/*                                                                      */
+/*  - 2010.11.15 [Sung-Kwan Kim] : first writing                        */
+/*                                                                      */
+/************************************************************************/
+
+#ifndef _EXFAT_CACHE_H
+#define _EXFAT_CACHE_H
+
+#include <linux/fs.h>
+#include <linux/types.h>
+#include "exfat_config.h"
+
+/*----------------------------------------------------------------------*/
+/*  Constant & Macro Definitions                                        */
+/*----------------------------------------------------------------------*/
+
+#define LOCKBIT                 0x01
+#define DIRTYBIT                0x02
+
+/*----------------------------------------------------------------------*/
+/*  Type Definitions                                                    */
+/*----------------------------------------------------------------------*/
+
+typedef struct __BUF_CACHE_T {
+	struct __BUF_CACHE_T *next;
+	struct __BUF_CACHE_T *prev;
+	struct __BUF_CACHE_T *hash_next;
+	struct __BUF_CACHE_T *hash_prev;
+	s32                drv;
+	sector_t          sec;
+	u32               flag;
+	struct buffer_head   *buf_bh;
+} BUF_CACHE_T;
+
+/*----------------------------------------------------------------------*/
+/*  External Function Declarations                                      */
+/*----------------------------------------------------------------------*/
+
+s32  buf_init(struct super_block *sb);
+s32  buf_shutdown(struct super_block *sb);
+s32  FAT_read(struct super_block *sb, u32 loc, u32 *content);
+s32  FAT_write(struct super_block *sb, u32 loc, u32 content);
+u8 *FAT_getblk(struct super_block *sb, sector_t sec);
+void   FAT_modify(struct super_block *sb, sector_t sec);
+void   FAT_release_all(struct super_block *sb);
+void   FAT_sync(struct super_block *sb);
+u8 *buf_getblk(struct super_block *sb, sector_t sec);
+void   buf_modify(struct super_block *sb, sector_t sec);
+void   buf_lock(struct super_block *sb, sector_t sec);
+void   buf_unlock(struct super_block *sb, sector_t sec);
+void   buf_release(struct super_block *sb, sector_t sec);
+void   buf_release_all(struct super_block *sb);
+void   buf_sync(struct super_block *sb);
+
+#endif /* _EXFAT_CACHE_H */
diff --git a/kernel/fs/exfat/exfat_config.h b/kernel/fs/exfat/exfat_config.h
new file mode 100755
index 0000000000..33c6525e44
--- /dev/null
+++ b/kernel/fs/exfat/exfat_config.h
@@ -0,0 +1,69 @@
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*  PROJECT : exFAT & FAT12/16/32 File System                           */
+/*  FILE    : exfat_config.h                                            */
+/*  PURPOSE : Header File for exFAT Configuable Policies                */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  NOTES                                                               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  REVISION HISTORY (Ver 0.9)                                          */
+/*                                                                      */
+/*  - 2010.11.15 [Joosun Hahn] : first writing                          */
+/*                                                                      */
+/************************************************************************/
+
+#ifndef _EXFAT_CONFIG_H
+#define _EXFAT_CONFIG_H
+
+/*======================================================================*/
+/*                                                                      */
+/*                        FFS CONFIGURATIONS                            */
+/*                  (CHANGE THIS PART IF REQUIRED)                      */
+/*                                                                      */
+/*======================================================================*/
+
+/*----------------------------------------------------------------------*/
+/* Feature Config                                                       */
+/*----------------------------------------------------------------------*/
+#ifndef CONFIG_EXFAT_DISCARD
+#define CONFIG_EXFAT_DISCARD		1	/* mount option -o discard support */
+#endif
+
+#ifndef CONFIG_EXFAT_DELAYED_SYNC
+#define CONFIG_EXFAT_DELAYED_SYNC 0
+#endif
+
+#ifndef CONFIG_EXFAT_KERNEL_DEBUG
+#define CONFIG_EXFAT_KERNEL_DEBUG	1	/* kernel debug features via ioctl */
+#endif
+
+#ifndef CONFIG_EXFAT_DEBUG_MSG
+#define CONFIG_EXFAT_DEBUG_MSG		0	/* debugging message on/off */
+#endif
+
+#ifndef CONFIG_EXFAT_DEFAULT_CODEPAGE
+#define CONFIG_EXFAT_DEFAULT_CODEPAGE	437
+#define CONFIG_EXFAT_DEFAULT_IOCHARSET	"utf8"
+#endif
+
+#endif /* _EXFAT_CONFIG_H */
diff --git a/kernel/fs/exfat/exfat_core.c b/kernel/fs/exfat/exfat_core.c
new file mode 100755
index 0000000000..143b72155e
--- /dev/null
+++ b/kernel/fs/exfat/exfat_core.c
@@ -0,0 +1,5138 @@
+/* Some of the source code in this file came from "linux/fs/fat/misc.c".  */
+/*
+ *  linux/fs/fat/misc.c
+ *
+ *  Written 1992,1993 by Werner Almesberger
+ *  22/11/2000 - Fixed fat_date_unix2dos for dates earlier than 01/01/1980
+ *         and date_dos2unix for date==0 by Igor Zhbanov(bsg@uniyar.ac.ru)
+ */
+
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*  PROJECT : exFAT & FAT12/16/32 File System                           */
+/*  FILE    : exfat_core.c                                              */
+/*  PURPOSE : exFAT File Manager                                        */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  NOTES                                                               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  REVISION HISTORY (Ver 0.9)                                          */
+/*                                                                      */
+/*  - 2010.11.15 [Joosun Hahn] : first writing                          */
+/*                                                                      */
+/************************************************************************/
+
+#include <linux/version.h>
+#include <linux/param.h>
+#include <linux/log2.h>
+
+#include "exfat_bitmap.h"
+#include "exfat_config.h"
+#include "exfat_data.h"
+#include "exfat_oal.h"
+#include "exfat_blkdev.h"
+#include "exfat_cache.h"
+#include "exfat_nls.h"
+#include "exfat_api.h"
+#include "exfat_super.h"
+#include "exfat_core.h"
+
+#include <linux/blkdev.h>
+#include <linux/slab.h>
+
+static void __set_sb_dirty(struct super_block *sb)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+	sb->s_dirt = 1;
+#else
+	struct exfat_sb_info *sbi = EXFAT_SB(sb);
+	sbi->s_dirt = 1;
+#endif
+}
+
+/*----------------------------------------------------------------------*/
+/*  Global Variable Definitions                                         */
+/*----------------------------------------------------------------------*/
+
+extern u8 uni_upcase[];
+
+/*----------------------------------------------------------------------*/
+/*  Local Variable Definitions                                          */
+/*----------------------------------------------------------------------*/
+
+static u8 name_buf[MAX_PATH_LENGTH * MAX_CHARSET_SIZE];
+
+static char *reserved_names[] = {
+	"AUX     ", "CON     ", "NUL     ", "PRN     ",
+	"COM1    ", "COM2    ", "COM3    ", "COM4    ",
+	"COM5    ", "COM6    ", "COM7    ", "COM8    ", "COM9    ",
+	"LPT1    ", "LPT2    ", "LPT3    ", "LPT4    ",
+	"LPT5    ", "LPT6    ", "LPT7    ", "LPT8    ", "LPT9    ",
+	NULL
+};
+
+static u8 free_bit[] = {
+	0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, /*   0 ~  19 */
+	0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, /*  20 ~  39 */
+	0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, /*  40 ~  59 */
+	0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, /*  60 ~  79 */
+	0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, /*  80 ~  99 */
+	0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, /* 100 ~ 119 */
+	0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, /* 120 ~ 139 */
+	0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, /* 140 ~ 159 */
+	0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, /* 160 ~ 179 */
+	0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, /* 180 ~ 199 */
+	0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, /* 200 ~ 219 */
+	0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, /* 220 ~ 239 */
+	0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0                 /* 240 ~ 254 */
+};
+
+static u8 used_bit[] = {
+	0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, /*   0 ~  19 */
+	2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, /*  20 ~  39 */
+	2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, /*  40 ~  59 */
+	4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, /*  60 ~  79 */
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, /*  80 ~  99 */
+	3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, /* 100 ~ 119 */
+	4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, /* 120 ~ 139 */
+	3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, /* 140 ~ 159 */
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, /* 160 ~ 179 */
+	4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, /* 180 ~ 199 */
+	3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, /* 200 ~ 219 */
+	5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, /* 220 ~ 239 */
+	4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8              /* 240 ~ 255 */
+};
+
+/*======================================================================*/
+/*  Global Function Definitions                                         */
+/*======================================================================*/
+
+/* ffsInit : roll back to the initial state of the file system */
+s32 ffsInit(void)
+{
+	s32 ret;
+
+	ret = bdev_init();
+	if (ret)
+		return ret;
+
+	ret = fs_init();
+	if (ret)
+		return ret;
+
+	return FFS_SUCCESS;
+} /* end of ffsInit */
+
+/* ffsShutdown : make free all memory-alloced global buffers */
+s32 ffsShutdown(void)
+{
+	s32 ret;
+	ret = fs_shutdown();
+	if (ret)
+		return ret;
+
+	ret = bdev_shutdown();
+	if (ret)
+		return ret;
+
+	return FFS_SUCCESS;
+} /* end of ffsShutdown */
+
+/* ffsMountVol : mount the file system volume */
+s32 ffsMountVol(struct super_block *sb)
+{
+	int i, ret;
+	PBR_SECTOR_T *p_pbr;
+	struct buffer_head *tmp_bh = NULL;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+
+	printk("[EXFAT] trying to mount...\n");
+
+	sm_init(&p_fs->v_sem);
+	p_fs->dev_ejected = FALSE;
+
+	/* open the block device */
+	if (bdev_open(sb))
+		return FFS_MEDIAERR;
+
+	if (p_bd->sector_size < sb->s_blocksize)
+		return FFS_MEDIAERR;
+	if (p_bd->sector_size > sb->s_blocksize)
+		sb_set_blocksize(sb, p_bd->sector_size);
+
+	/* read Sector 0 */
+	if (sector_read(sb, 0, &tmp_bh, 1) != FFS_SUCCESS)
+		return FFS_MEDIAERR;
+
+	p_fs->PBR_sector = 0;
+
+	p_pbr = (PBR_SECTOR_T *) tmp_bh->b_data;
+
+	/* check the validity of PBR */
+	if (GET16_A(p_pbr->signature) != PBR_SIGNATURE) {
+		brelse(tmp_bh);
+		bdev_close(sb);
+		return FFS_FORMATERR;
+	}
+
+	/* fill fs_stuct */
+	for (i = 0; i < 53; i++)
+		if (p_pbr->bpb[i])
+			break;
+
+	if (i < 53) {
+		if (GET16(p_pbr->bpb+11)) /* num_fat_sectors */
+			ret = fat16_mount(sb, p_pbr);
+		else
+			ret = fat32_mount(sb, p_pbr);
+	} else {
+		ret = exfat_mount(sb, p_pbr);
+	}
+
+	brelse(tmp_bh);
+
+	if (ret) {
+		bdev_close(sb);
+		return ret;
+	}
+
+	if (p_fs->vol_type == EXFAT) {
+		ret = load_alloc_bitmap(sb);
+		if (ret) {
+			bdev_close(sb);
+			return ret;
+		}
+		ret = load_upcase_table(sb);
+		if (ret) {
+			free_alloc_bitmap(sb);
+			bdev_close(sb);
+			return ret;
+		}
+	}
+
+	if (p_fs->dev_ejected) {
+		if (p_fs->vol_type == EXFAT) {
+			free_upcase_table(sb);
+			free_alloc_bitmap(sb);
+		}
+		bdev_close(sb);
+		return FFS_MEDIAERR;
+	}
+
+	printk("[EXFAT] mounted successfully\n");
+
+	return FFS_SUCCESS;
+} /* end of ffsMountVol */
+
+/* ffsUmountVol : umount the file system volume */
+s32 ffsUmountVol(struct super_block *sb)
+{
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	printk("[EXFAT] trying to unmount...\n");
+
+	fs_sync(sb, 0);
+	fs_set_vol_flags(sb, VOL_CLEAN);
+
+	if (p_fs->vol_type == EXFAT) {
+		free_upcase_table(sb);
+		free_alloc_bitmap(sb);
+	}
+
+	FAT_release_all(sb);
+	buf_release_all(sb);
+
+	/* close the block device */
+	bdev_close(sb);
+
+	if (p_fs->dev_ejected) {
+		printk("[EXFAT] unmounted with media errors. "
+			"device's already ejected.\n");
+		return FFS_MEDIAERR;
+	}
+
+	printk("[EXFAT] unmounted successfully\n");
+
+	return FFS_SUCCESS;
+} /* end of ffsUmountVol */
+
+/* ffsGetVolInfo : get the information of a file system volume */
+s32 ffsGetVolInfo(struct super_block *sb, VOL_INFO_T *info)
+{
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	if (p_fs->used_clusters == (u32) ~0)
+		p_fs->used_clusters = p_fs->fs_func->count_used_clusters(sb);
+
+	info->FatType = p_fs->vol_type;
+	info->ClusterSize = p_fs->cluster_size;
+	info->NumClusters = p_fs->num_clusters - 2; /* clu 0 & 1 */
+	info->UsedClusters = p_fs->used_clusters;
+	info->FreeClusters = info->NumClusters - info->UsedClusters;
+
+	if (p_fs->dev_ejected)
+		return FFS_MEDIAERR;
+
+	return FFS_SUCCESS;
+} /* end of ffsGetVolInfo */
+
+/* ffsSyncVol : synchronize all file system volumes */
+s32 ffsSyncVol(struct super_block *sb, s32 do_sync)
+{
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	/* synchronize the file system */
+	fs_sync(sb, do_sync);
+	fs_set_vol_flags(sb, VOL_CLEAN);
+
+	if (p_fs->dev_ejected)
+		return FFS_MEDIAERR;
+
+	return FFS_SUCCESS;
+} /* end of ffsSyncVol */
+
+/*----------------------------------------------------------------------*/
+/*  File Operation Functions                                            */
+/*----------------------------------------------------------------------*/
+
+/* ffsLookupFile : lookup a file */
+s32 ffsLookupFile(struct inode *inode, char *path, FILE_ID_T *fid)
+{
+	s32 ret, dentry, num_entries;
+	CHAIN_T dir;
+	UNI_NAME_T uni_name;
+	DOS_NAME_T dos_name;
+	DENTRY_T *ep, *ep2;
+	ENTRY_SET_CACHE_T *es = NULL;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	DPRINTK("ffsLookupFile entered\n");
+
+	/* check the validity of directory name in the given pathname */
+	ret = resolve_path(inode, path, &dir, &uni_name);
+	if (ret)
+		return ret;
+
+	ret = get_num_entries_and_dos_name(sb, &dir, &uni_name, &num_entries, &dos_name);
+	if (ret)
+		return ret;
+
+	/* search the file name for directories */
+	dentry = p_fs->fs_func->find_dir_entry(sb, &dir, &uni_name, num_entries, &dos_name, TYPE_ALL);
+	if (dentry < -1)
+		return FFS_NOTFOUND;
+
+	fid->dir.dir = dir.dir;
+	fid->dir.size = dir.size;
+	fid->dir.flags = dir.flags;
+	fid->entry = dentry;
+
+	if (dentry == -1) {
+		fid->type = TYPE_DIR;
+		fid->rwoffset = 0;
+		fid->hint_last_off = -1;
+
+		fid->attr = ATTR_SUBDIR;
+		fid->flags = 0x01;
+		fid->size = 0;
+		fid->start_clu = p_fs->root_dir;
+	} else {
+		if (p_fs->vol_type == EXFAT) {
+			es = get_entry_set_in_dir(sb, &dir, dentry, ES_2_ENTRIES, &ep);
+			if (!es)
+				return FFS_MEDIAERR;
+			ep2 = ep+1;
+		} else {
+			ep = get_entry_in_dir(sb, &dir, dentry, NULL);
+			if (!ep)
+				return FFS_MEDIAERR;
+			ep2 = ep;
+		}
+
+		fid->type = p_fs->fs_func->get_entry_type(ep);
+		fid->rwoffset = 0;
+		fid->hint_last_off = -1;
+		fid->attr = p_fs->fs_func->get_entry_attr(ep);
+
+		fid->size = p_fs->fs_func->get_entry_size(ep2);
+		if ((fid->type == TYPE_FILE) && (fid->size == 0)) {
+			fid->flags = (p_fs->vol_type == EXFAT) ? 0x03 : 0x01;
+			fid->start_clu = CLUSTER_32(~0);
+		} else {
+			fid->flags = p_fs->fs_func->get_entry_flag(ep2);
+			fid->start_clu = p_fs->fs_func->get_entry_clu0(ep2);
+		}
+
+		if (p_fs->vol_type == EXFAT)
+			release_entry_set(es);
+	}
+
+	if (p_fs->dev_ejected)
+		return FFS_MEDIAERR;
+
+	DPRINTK("ffsLookupFile exited successfully\n");
+
+	return FFS_SUCCESS;
+} /* end of ffsLookupFile */
+
+/* ffsCreateFile : create a file */
+s32 ffsCreateFile(struct inode *inode, char *path, u8 mode, FILE_ID_T *fid)
+{
+	s32 ret/*, dentry*/;
+	CHAIN_T dir;
+	UNI_NAME_T uni_name;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	/* check the validity of directory name in the given pathname */
+	ret = resolve_path(inode, path, &dir, &uni_name);
+	if (ret)
+		return ret;
+
+	fs_set_vol_flags(sb, VOL_DIRTY);
+
+	/* create a new file */
+	ret = create_file(inode, &dir, &uni_name, mode, fid);
+
+#ifdef CONFIG_EXFAT_DELAYED_SYNC
+	fs_sync(sb, 0);
+	fs_set_vol_flags(sb, VOL_CLEAN);
+#endif
+
+	if (p_fs->dev_ejected)
+		return FFS_MEDIAERR;
+
+	return ret;
+} /* end of ffsCreateFile */
+
+/* ffsReadFile : read data from a opened file */
+s32 ffsReadFile(struct inode *inode, FILE_ID_T *fid, void *buffer, u64 count, u64 *rcount)
+{
+	s32 offset, sec_offset, clu_offset;
+	u32 clu;
+	sector_t LogSector;
+	u64 oneblkread, read_bytes;
+	struct buffer_head *tmp_bh = NULL;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+
+	/* check if the given file ID is opened */
+	if (fid->type != TYPE_FILE)
+		return FFS_PERMISSIONERR;
+
+	if (fid->rwoffset > fid->size)
+		fid->rwoffset = fid->size;
+
+	if (count > (fid->size - fid->rwoffset))
+		count = fid->size - fid->rwoffset;
+
+	if (count == 0) {
+		if (rcount != NULL)
+			*rcount = 0;
+		return FFS_EOF;
+	}
+
+	read_bytes = 0;
+
+	while (count > 0) {
+		clu_offset = (s32)(fid->rwoffset >> p_fs->cluster_size_bits);
+		clu = fid->start_clu;
+
+		if (fid->flags == 0x03) {
+			clu += clu_offset;
+		} else {
+			/* hint information */
+			if ((clu_offset > 0) && (fid->hint_last_off > 0) &&
+				(clu_offset >= fid->hint_last_off)) {
+				clu_offset -= fid->hint_last_off;
+				clu = fid->hint_last_clu;
+			}
+
+			while (clu_offset > 0) {
+				/* clu = FAT_read(sb, clu); */
+				if (FAT_read(sb, clu, &clu) == -1)
+					return FFS_MEDIAERR;
+
+				clu_offset--;
+			}
+		}
+
+		/* hint information */
+		fid->hint_last_off = (s32)(fid->rwoffset >> p_fs->cluster_size_bits);
+		fid->hint_last_clu = clu;
+
+		offset = (s32)(fid->rwoffset & (p_fs->cluster_size-1)); /* byte offset in cluster   */
+		sec_offset = offset >> p_bd->sector_size_bits;            /* sector offset in cluster */
+		offset &= p_bd->sector_size_mask;                         /* byte offset in sector    */
+
+		LogSector = START_SECTOR(clu) + sec_offset;
+
+		oneblkread = (u64)(p_bd->sector_size - offset);
+		if (oneblkread > count)
+			oneblkread = count;
+
+		if ((offset == 0) && (oneblkread == p_bd->sector_size)) {
+			if (sector_read(sb, LogSector, &tmp_bh, 1) != FFS_SUCCESS)
+				goto err_out;
+			memcpy(((char *) buffer)+read_bytes, ((char *) tmp_bh->b_data), (s32) oneblkread);
+		} else {
+			if (sector_read(sb, LogSector, &tmp_bh, 1) != FFS_SUCCESS)
+				goto err_out;
+			memcpy(((char *) buffer)+read_bytes, ((char *) tmp_bh->b_data)+offset, (s32) oneblkread);
+		}
+		count -= oneblkread;
+		read_bytes += oneblkread;
+		fid->rwoffset += oneblkread;
+	}
+	brelse(tmp_bh);
+
+err_out:
+	/* set the size of read bytes */
+	if (rcount != NULL)
+		*rcount = read_bytes;
+
+	if (p_fs->dev_ejected)
+		return FFS_MEDIAERR;
+
+	return FFS_SUCCESS;
+} /* end of ffsReadFile */
+
+/* ffsWriteFile : write data into a opened file */
+s32 ffsWriteFile(struct inode *inode, FILE_ID_T *fid, void *buffer, u64 count, u64 *wcount)
+{
+	s32 modified = FALSE, offset, sec_offset, clu_offset;
+	s32 num_clusters, num_alloc, num_alloced = (s32) ~0;
+	u32 clu, last_clu;
+	sector_t LogSector, sector = 0;
+	u64 oneblkwrite, write_bytes;
+	CHAIN_T new_clu;
+	TIMESTAMP_T tm;
+	DENTRY_T *ep, *ep2;
+	ENTRY_SET_CACHE_T *es = NULL;
+	struct buffer_head *tmp_bh = NULL;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+
+	/* check if the given file ID is opened */
+	if (fid->type != TYPE_FILE)
+		return FFS_PERMISSIONERR;
+
+	if (fid->rwoffset > fid->size)
+		fid->rwoffset = fid->size;
+
+	if (count == 0) {
+		if (wcount != NULL)
+			*wcount = 0;
+		return FFS_SUCCESS;
+	}
+
+	fs_set_vol_flags(sb, VOL_DIRTY);
+
+	if (fid->size == 0)
+		num_clusters = 0;
+	else
+		num_clusters = (s32)((fid->size-1) >> p_fs->cluster_size_bits) + 1;
+
+	write_bytes = 0;
+
+	while (count > 0) {
+		clu_offset = (s32)(fid->rwoffset >> p_fs->cluster_size_bits);
+		clu = last_clu = fid->start_clu;
+
+		if (fid->flags == 0x03) {
+			if ((clu_offset > 0) && (clu != CLUSTER_32(~0))) {
+				last_clu += clu_offset - 1;
+
+				if (clu_offset == num_clusters)
+					clu = CLUSTER_32(~0);
+				else
+					clu += clu_offset;
+			}
+		} else {
+			/* hint information */
+			if ((clu_offset > 0) && (fid->hint_last_off > 0) &&
+				(clu_offset >= fid->hint_last_off)) {
+				clu_offset -= fid->hint_last_off;
+				clu = fid->hint_last_clu;
+			}
+
+			while ((clu_offset > 0) && (clu != CLUSTER_32(~0))) {
+				last_clu = clu;
+				/* clu = FAT_read(sb, clu); */
+				if (FAT_read(sb, clu, &clu) == -1)
+					return FFS_MEDIAERR;
+
+				clu_offset--;
+			}
+		}
+
+		if (clu == CLUSTER_32(~0)) {
+			num_alloc = (s32)((count-1) >> p_fs->cluster_size_bits) + 1;
+			new_clu.dir = (last_clu == CLUSTER_32(~0)) ? CLUSTER_32(~0) : last_clu+1;
+			new_clu.size = 0;
+			new_clu.flags = fid->flags;
+
+			/* (1) allocate a chain of clusters */
+			num_alloced = p_fs->fs_func->alloc_cluster(sb, num_alloc, &new_clu);
+			if (num_alloced == 0)
+				break;
+			else if (num_alloced < 0)
+				return FFS_MEDIAERR;
+
+			/* (2) append to the FAT chain */
+			if (last_clu == CLUSTER_32(~0)) {
+				if (new_clu.flags == 0x01)
+					fid->flags = 0x01;
+				fid->start_clu = new_clu.dir;
+				modified = TRUE;
+			} else {
+				if (new_clu.flags != fid->flags) {
+					exfat_chain_cont_cluster(sb, fid->start_clu, num_clusters);
+					fid->flags = 0x01;
+					modified = TRUE;
+				}
+				if (new_clu.flags == 0x01)
+					FAT_write(sb, last_clu, new_clu.dir);
+			}
+
+			num_clusters += num_alloced;
+			clu = new_clu.dir;
+		}
+
+		/* hint information */
+		fid->hint_last_off = (s32)(fid->rwoffset >> p_fs->cluster_size_bits);
+		fid->hint_last_clu = clu;
+
+		offset = (s32)(fid->rwoffset & (p_fs->cluster_size-1)); /* byte offset in cluster   */
+		sec_offset = offset >> p_bd->sector_size_bits;            /* sector offset in cluster */
+		offset &= p_bd->sector_size_mask;                         /* byte offset in sector    */
+
+		LogSector = START_SECTOR(clu) + sec_offset;
+
+		oneblkwrite = (u64)(p_bd->sector_size - offset);
+		if (oneblkwrite > count)
+			oneblkwrite = count;
+
+		if ((offset == 0) && (oneblkwrite == p_bd->sector_size)) {
+			if (sector_read(sb, LogSector, &tmp_bh, 0) != FFS_SUCCESS)
+				goto err_out;
+			memcpy(((char *) tmp_bh->b_data), ((char *) buffer)+write_bytes, (s32) oneblkwrite);
+			if (sector_write(sb, LogSector, tmp_bh, 0) != FFS_SUCCESS) {
+				brelse(tmp_bh);
+				goto err_out;
+			}
+		} else {
+			if ((offset > 0) || ((fid->rwoffset+oneblkwrite) < fid->size)) {
+				if (sector_read(sb, LogSector, &tmp_bh, 1) != FFS_SUCCESS)
+					goto err_out;
+			} else {
+				if (sector_read(sb, LogSector, &tmp_bh, 0) != FFS_SUCCESS)
+					goto err_out;
+			}
+
+			memcpy(((char *) tmp_bh->b_data)+offset, ((char *) buffer)+write_bytes, (s32) oneblkwrite);
+			if (sector_write(sb, LogSector, tmp_bh, 0) != FFS_SUCCESS) {
+				brelse(tmp_bh);
+				goto err_out;
+			}
+		}
+
+		count -= oneblkwrite;
+		write_bytes += oneblkwrite;
+		fid->rwoffset += oneblkwrite;
+
+		fid->attr |= ATTR_ARCHIVE;
+
+		if (fid->size < fid->rwoffset) {
+			fid->size = fid->rwoffset;
+			modified = TRUE;
+		}
+	}
+
+	brelse(tmp_bh);
+
+	/* (3) update the direcoty entry */
+	if (p_fs->vol_type == EXFAT) {
+		es = get_entry_set_in_dir(sb, &(fid->dir), fid->entry, ES_ALL_ENTRIES, &ep);
+		if (es == NULL)
+			goto err_out;
+		ep2 = ep+1;
+	} else {
+		ep = get_entry_in_dir(sb, &(fid->dir), fid->entry, &sector);
+		if (!ep)
+			goto err_out;
+		ep2 = ep;
+	}
+
+	p_fs->fs_func->set_entry_time(ep, tm_current(&tm), TM_MODIFY);
+	p_fs->fs_func->set_entry_attr(ep, fid->attr);
+
+	if (p_fs->vol_type != EXFAT)
+		buf_modify(sb, sector);
+
+	if (modified) {
+		if (p_fs->fs_func->get_entry_flag(ep2) != fid->flags)
+			p_fs->fs_func->set_entry_flag(ep2, fid->flags);
+
+		if (p_fs->fs_func->get_entry_size(ep2) != fid->size)
+			p_fs->fs_func->set_entry_size(ep2, fid->size);
+
+		if (p_fs->fs_func->get_entry_clu0(ep2) != fid->start_clu)
+			p_fs->fs_func->set_entry_clu0(ep2, fid->start_clu);
+
+		if (p_fs->vol_type != EXFAT)
+			buf_modify(sb, sector);
+	}
+
+	if (p_fs->vol_type == EXFAT) {
+		update_dir_checksum_with_entry_set(sb, es);
+		release_entry_set(es);
+	}
+
+#ifdef CONFIG_EXFAT_DELAYED_SYNC
+	fs_sync(sb, 0);
+	fs_set_vol_flags(sb, VOL_CLEAN);
+#endif
+
+err_out:
+	/* set the size of written bytes */
+	if (wcount != NULL)
+		*wcount = write_bytes;
+
+	if (num_alloced == 0)
+		return FFS_FULL;
+
+	if (p_fs->dev_ejected)
+		return FFS_MEDIAERR;
+
+	return FFS_SUCCESS;
+} /* end of ffsWriteFile */
+
+/* ffsTruncateFile : resize the file length */
+s32 ffsTruncateFile(struct inode *inode, u64 old_size, u64 new_size)
+{
+	s32 num_clusters;
+	u32 last_clu = CLUSTER_32(0);
+	sector_t sector = 0;
+	CHAIN_T clu;
+	TIMESTAMP_T tm;
+	DENTRY_T *ep, *ep2;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	FILE_ID_T *fid = &(EXFAT_I(inode)->fid);
+	ENTRY_SET_CACHE_T *es = NULL;
+
+	/* check if the given file ID is opened */
+	if (fid->type != TYPE_FILE)
+		return FFS_PERMISSIONERR;
+
+	if (fid->size != old_size) {
+		printk(KERN_ERR "[EXFAT] truncate : can't skip it because of "
+				"size-mismatch(old:%lld->fid:%lld).\n"
+				,old_size, fid->size);
+	}
+
+	if (old_size <= new_size)
+		return FFS_SUCCESS;
+
+	fs_set_vol_flags(sb, VOL_DIRTY);
+
+	clu.dir = fid->start_clu;
+	clu.size = (s32)((old_size-1) >> p_fs->cluster_size_bits) + 1;
+	clu.flags = fid->flags;
+
+	if (new_size > 0) {
+		num_clusters = (s32)((new_size-1) >> p_fs->cluster_size_bits) + 1;
+
+		if (clu.flags == 0x03) {
+			clu.dir += num_clusters;
+		} else {
+			while (num_clusters > 0) {
+				last_clu = clu.dir;
+				if (FAT_read(sb, clu.dir, &(clu.dir)) == -1)
+					return FFS_MEDIAERR;
+				num_clusters--;
+			}
+		}
+
+		clu.size -= num_clusters;
+	}
+
+	fid->size = new_size;
+	fid->attr |= ATTR_ARCHIVE;
+	if (new_size == 0) {
+		fid->flags = (p_fs->vol_type == EXFAT) ? 0x03 : 0x01;
+		fid->start_clu = CLUSTER_32(~0);
+	}
+
+	/* (1) update the directory entry */
+	if (p_fs->vol_type == EXFAT) {
+		es = get_entry_set_in_dir(sb, &(fid->dir), fid->entry, ES_ALL_ENTRIES, &ep);
+		if (es == NULL)
+			return FFS_MEDIAERR;
+		ep2 = ep+1;
+	} else {
+		ep = get_entry_in_dir(sb, &(fid->dir), fid->entry, &sector);
+		if (!ep)
+			return FFS_MEDIAERR;
+		ep2 = ep;
+	}
+
+	p_fs->fs_func->set_entry_time(ep, tm_current(&tm), TM_MODIFY);
+	p_fs->fs_func->set_entry_attr(ep, fid->attr);
+
+	p_fs->fs_func->set_entry_size(ep2, new_size);
+	if (new_size == 0) {
+		p_fs->fs_func->set_entry_flag(ep2, 0x01);
+		p_fs->fs_func->set_entry_clu0(ep2, CLUSTER_32(0));
+	}
+
+	if (p_fs->vol_type != EXFAT)
+		buf_modify(sb, sector);
+	else {
+		update_dir_checksum_with_entry_set(sb, es);
+		release_entry_set(es);
+	}
+
+	/* (2) cut off from the FAT chain */
+	if (last_clu != CLUSTER_32(0)) {
+		if (fid->flags == 0x01)
+			FAT_write(sb, last_clu, CLUSTER_32(~0));
+	}
+
+	/* (3) free the clusters */
+	p_fs->fs_func->free_cluster(sb, &clu, 0);
+
+	/* hint information */
+	fid->hint_last_off = -1;
+	if (fid->rwoffset > fid->size)
+		fid->rwoffset = fid->size;
+
+#ifdef CONFIG_EXFAT_DELAYED_SYNC
+	fs_sync(sb, 0);
+	fs_set_vol_flags(sb, VOL_CLEAN);
+#endif
+
+	if (p_fs->dev_ejected)
+		return FFS_MEDIAERR;
+
+	return FFS_SUCCESS;
+} /* end of ffsTruncateFile */
+
+static void update_parent_info(FILE_ID_T *fid, struct inode *parent_inode)
+{
+	FS_INFO_T *p_fs = &(EXFAT_SB(parent_inode->i_sb)->fs_info);
+	FILE_ID_T *parent_fid = &(EXFAT_I(parent_inode)->fid);
+
+	if (unlikely((parent_fid->flags != fid->dir.flags)
+		|| (parent_fid->size != (fid->dir.size<<p_fs->cluster_size_bits))
+		|| (parent_fid->start_clu != fid->dir.dir))) {
+
+		fid->dir.dir = parent_fid->start_clu;
+		fid->dir.flags = parent_fid->flags;
+		fid->dir.size = ((parent_fid->size + (p_fs->cluster_size-1))
+						>> p_fs->cluster_size_bits);
+	}
+}
+
+/* ffsMoveFile : move(rename) a old file into a new file */
+s32 ffsMoveFile(struct inode *old_parent_inode, FILE_ID_T *fid, struct inode *new_parent_inode, struct dentry *new_dentry)
+{
+	s32 ret;
+	s32 dentry;
+	CHAIN_T olddir, newdir;
+	CHAIN_T *p_dir = NULL;
+	UNI_NAME_T uni_name;
+	DENTRY_T *ep;
+	struct super_block *sb = old_parent_inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	u8 *new_path = (u8 *) new_dentry->d_name.name;
+	struct inode *new_inode = new_dentry->d_inode;
+	int num_entries;
+	FILE_ID_T *new_fid = NULL;
+	s32 new_entry = 0;
+
+	/* check the validity of pointer parameters */
+	if ((new_path == NULL) || (*new_path == '\0'))
+		return FFS_ERROR;
+
+	update_parent_info(fid, old_parent_inode);
+
+	olddir.dir = fid->dir.dir;
+	olddir.size = fid->dir.size;
+	olddir.flags = fid->dir.flags;
+
+	dentry = fid->entry;
+
+	/* check if the old file is "." or ".." */
+	if (p_fs->vol_type != EXFAT) {
+		if ((olddir.dir != p_fs->root_dir) && (dentry < 2))
+			return FFS_PERMISSIONERR;
+	}
+
+	ep = get_entry_in_dir(sb, &olddir, dentry, NULL);
+	if (!ep)
+		return FFS_MEDIAERR;
+
+	if (p_fs->fs_func->get_entry_attr(ep) & ATTR_READONLY)
+		return FFS_PERMISSIONERR;
+
+	/* check whether new dir is existing directory and empty */
+	if (new_inode) {
+		u32 entry_type;
+
+		ret = FFS_MEDIAERR;
+		new_fid = &EXFAT_I(new_inode)->fid;
+
+		update_parent_info(new_fid, new_parent_inode);
+
+		p_dir = &(new_fid->dir);
+		new_entry = new_fid->entry;
+		ep = get_entry_in_dir(sb, p_dir, new_entry, NULL);
+		if (!ep)
+			goto out;
+
+		entry_type = p_fs->fs_func->get_entry_type(ep);
+
+		if (entry_type == TYPE_DIR) {
+			CHAIN_T new_clu;
+			new_clu.dir = new_fid->start_clu;
+			new_clu.size = (s32)((new_fid->size-1) >> p_fs->cluster_size_bits) + 1;
+			new_clu.flags = new_fid->flags;
+
+			if (!is_dir_empty(sb, &new_clu))
+				return FFS_FILEEXIST;
+		}
+	}
+
+	/* check the validity of directory name in the given new pathname */
+	ret = resolve_path(new_parent_inode, new_path, &newdir, &uni_name);
+	if (ret)
+		return ret;
+
+	fs_set_vol_flags(sb, VOL_DIRTY);
+
+	if (olddir.dir == newdir.dir)
+		ret = rename_file(new_parent_inode, &olddir, dentry, &uni_name, fid);
+	else
+		ret = move_file(new_parent_inode, &olddir, dentry, &newdir, &uni_name, fid);
+
+	if ((ret == FFS_SUCCESS) && new_inode) {
+		/* delete entries of new_dir */
+		ep = get_entry_in_dir(sb, p_dir, new_entry, NULL);
+		if (!ep)
+			goto out;
+
+		num_entries = p_fs->fs_func->count_ext_entries(sb, p_dir, new_entry, ep);
+		if (num_entries < 0)
+			goto out;
+		p_fs->fs_func->delete_dir_entry(sb, p_dir, new_entry, 0, num_entries+1);
+	}
+out:
+#ifdef CONFIG_EXFAT_DELAYED_SYNC
+	fs_sync(sb, 0);
+	fs_set_vol_flags(sb, VOL_CLEAN);
+#endif
+
+	if (p_fs->dev_ejected)
+		return FFS_MEDIAERR;
+
+	return ret;
+} /* end of ffsMoveFile */
+
+/* ffsRemoveFile : remove a file */
+s32 ffsRemoveFile(struct inode *inode, FILE_ID_T *fid)
+{
+	s32 dentry;
+	CHAIN_T dir, clu_to_free;
+	DENTRY_T *ep;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	dir.dir = fid->dir.dir;
+	dir.size = fid->dir.size;
+	dir.flags = fid->dir.flags;
+
+	dentry = fid->entry;
+
+	ep = get_entry_in_dir(sb, &dir, dentry, NULL);
+	if (!ep)
+		return FFS_MEDIAERR;
+
+	if (p_fs->fs_func->get_entry_attr(ep) & ATTR_READONLY)
+		return FFS_PERMISSIONERR;
+
+	fs_set_vol_flags(sb, VOL_DIRTY);
+
+	/* (1) update the directory entry */
+	remove_file(inode, &dir, dentry);
+
+	clu_to_free.dir = fid->start_clu;
+	clu_to_free.size = (s32)((fid->size-1) >> p_fs->cluster_size_bits) + 1;
+	clu_to_free.flags = fid->flags;
+
+	/* (2) free the clusters */
+	p_fs->fs_func->free_cluster(sb, &clu_to_free, 0);
+
+	fid->size = 0;
+	fid->start_clu = CLUSTER_32(~0);
+	fid->flags = (p_fs->vol_type == EXFAT) ? 0x03 : 0x01;
+
+#ifdef CONFIG_EXFAT_DELAYED_SYNC
+	fs_sync(sb, 0);
+	fs_set_vol_flags(sb, VOL_CLEAN);
+#endif
+
+	if (p_fs->dev_ejected)
+		return FFS_MEDIAERR;
+
+	return FFS_SUCCESS;
+} /* end of ffsRemoveFile */
+
+/* ffsSetAttr : set the attribute of a given file */
+s32 ffsSetAttr(struct inode *inode, u32 attr)
+{
+	u32 type;
+	sector_t sector = 0;
+	DENTRY_T *ep;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	FILE_ID_T *fid = &(EXFAT_I(inode)->fid);
+	u8 is_dir = (fid->type == TYPE_DIR) ? 1 : 0;
+	ENTRY_SET_CACHE_T *es = NULL;
+
+	if (fid->attr == attr) {
+		if (p_fs->dev_ejected)
+			return FFS_MEDIAERR;
+		return FFS_SUCCESS;
+	}
+
+	if (is_dir) {
+		if ((fid->dir.dir == p_fs->root_dir) &&
+			(fid->entry == -1)) {
+			if (p_fs->dev_ejected)
+				return FFS_MEDIAERR;
+			return FFS_SUCCESS;
+		}
+	}
+
+	/* get the directory entry of given file */
+	if (p_fs->vol_type == EXFAT) {
+		es = get_entry_set_in_dir(sb, &(fid->dir), fid->entry, ES_ALL_ENTRIES, &ep);
+		if (es == NULL)
+			return FFS_MEDIAERR;
+	} else {
+		ep = get_entry_in_dir(sb, &(fid->dir), fid->entry, &sector);
+		if (!ep)
+			return FFS_MEDIAERR;
+	}
+
+	type = p_fs->fs_func->get_entry_type(ep);
+
+	if (((type == TYPE_FILE) && (attr & ATTR_SUBDIR)) ||
+		((type == TYPE_DIR) && (!(attr & ATTR_SUBDIR)))) {
+		s32 err;
+		if (p_fs->dev_ejected)
+			err = FFS_MEDIAERR;
+		else
+			err = FFS_ERROR;
+
+		if (p_fs->vol_type == EXFAT)
+			release_entry_set(es);
+		return err;
+	}
+
+	fs_set_vol_flags(sb, VOL_DIRTY);
+
+	/* set the file attribute */
+	fid->attr = attr;
+	p_fs->fs_func->set_entry_attr(ep, attr);
+
+	if (p_fs->vol_type != EXFAT)
+		buf_modify(sb, sector);
+	else {
+		update_dir_checksum_with_entry_set(sb, es);
+		release_entry_set(es);
+	}
+
+#ifdef CONFIG_EXFAT_DELAYED_SYNC
+	fs_sync(sb, 0);
+	fs_set_vol_flags(sb, VOL_CLEAN);
+#endif
+
+	if (p_fs->dev_ejected)
+		return FFS_MEDIAERR;
+
+	return FFS_SUCCESS;
+} /* end of ffsSetAttr */
+
+/* ffsGetStat : get the information of a given file */
+s32 ffsGetStat(struct inode *inode, DIR_ENTRY_T *info)
+{
+	sector_t sector = 0;
+	s32 count;
+	CHAIN_T dir;
+	UNI_NAME_T uni_name;
+	TIMESTAMP_T tm;
+	DENTRY_T *ep, *ep2;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	FILE_ID_T *fid = &(EXFAT_I(inode)->fid);
+	ENTRY_SET_CACHE_T *es = NULL;
+	u8 is_dir = (fid->type == TYPE_DIR) ? 1 : 0;
+
+	DPRINTK("ffsGetStat entered\n");
+
+	if (is_dir) {
+		if ((fid->dir.dir == p_fs->root_dir) &&
+			(fid->entry == -1)) {
+			info->Attr = ATTR_SUBDIR;
+			memset((char *) &info->CreateTimestamp, 0, sizeof(DATE_TIME_T));
+			memset((char *) &info->ModifyTimestamp, 0, sizeof(DATE_TIME_T));
+			memset((char *) &info->AccessTimestamp, 0, sizeof(DATE_TIME_T));
+			strcpy(info->ShortName, ".");
+			strcpy(info->Name, ".");
+
+			dir.dir = p_fs->root_dir;
+			dir.flags = 0x01;
+
+			if (p_fs->root_dir == CLUSTER_32(0)) /* FAT16 root_dir */
+				info->Size = p_fs->dentries_in_root << DENTRY_SIZE_BITS;
+			else
+				info->Size = count_num_clusters(sb, &dir) << p_fs->cluster_size_bits;
+
+			count = count_dos_name_entries(sb, &dir, TYPE_DIR);
+			if (count < 0)
+				return FFS_MEDIAERR;
+			info->NumSubdirs = count;
+
+			if (p_fs->dev_ejected)
+				return FFS_MEDIAERR;
+			return FFS_SUCCESS;
+		}
+	}
+
+	/* get the directory entry of given file or directory */
+	if (p_fs->vol_type == EXFAT) {
+		es = get_entry_set_in_dir(sb, &(fid->dir), fid->entry, ES_2_ENTRIES, &ep);
+		if (es == NULL)
+			return FFS_MEDIAERR;
+		ep2 = ep+1;
+	} else {
+		ep = get_entry_in_dir(sb, &(fid->dir), fid->entry, &sector);
+		if (!ep)
+			return FFS_MEDIAERR;
+		ep2 = ep;
+		buf_lock(sb, sector);
+	}
+
+	/* set FILE_INFO structure using the acquired DENTRY_T */
+	info->Attr = p_fs->fs_func->get_entry_attr(ep);
+
+	p_fs->fs_func->get_entry_time(ep, &tm, TM_CREATE);
+	info->CreateTimestamp.Year = tm.year;
+	info->CreateTimestamp.Month = tm.mon;
+	info->CreateTimestamp.Day = tm.day;
+	info->CreateTimestamp.Hour = tm.hour;
+	info->CreateTimestamp.Minute = tm.min;
+	info->CreateTimestamp.Second = tm.sec;
+	info->CreateTimestamp.MilliSecond = 0;
+
+	p_fs->fs_func->get_entry_time(ep, &tm, TM_MODIFY);
+	info->ModifyTimestamp.Year = tm.year;
+	info->ModifyTimestamp.Month = tm.mon;
+	info->ModifyTimestamp.Day = tm.day;
+	info->ModifyTimestamp.Hour = tm.hour;
+	info->ModifyTimestamp.Minute = tm.min;
+	info->ModifyTimestamp.Second = tm.sec;
+	info->ModifyTimestamp.MilliSecond = 0;
+
+	memset((char *) &info->AccessTimestamp, 0, sizeof(DATE_TIME_T));
+
+	*(uni_name.name) = 0x0;
+	/* XXX this is very bad for exfat cuz name is already included in es.
+	 API should be revised */
+	p_fs->fs_func->get_uni_name_from_ext_entry(sb, &(fid->dir), fid->entry, uni_name.name);
+	if (*(uni_name.name) == 0x0 && p_fs->vol_type != EXFAT)
+		get_uni_name_from_dos_entry(sb, (DOS_DENTRY_T *) ep, &uni_name, 0x1);
+	nls_uniname_to_cstring(sb, info->Name, &uni_name);
+
+	if (p_fs->vol_type == EXFAT) {
+		info->NumSubdirs = 2;
+	} else {
+		buf_unlock(sb, sector);
+		get_uni_name_from_dos_entry(sb, (DOS_DENTRY_T *) ep, &uni_name, 0x0);
+		nls_uniname_to_cstring(sb, info->ShortName, &uni_name);
+		info->NumSubdirs = 0;
+	}
+
+	info->Size = p_fs->fs_func->get_entry_size(ep2);
+
+	if (p_fs->vol_type == EXFAT)
+		release_entry_set(es);
+
+	if (is_dir) {
+		dir.dir = fid->start_clu;
+		dir.flags = 0x01;
+
+		if (info->Size == 0)
+			info->Size = (u64) count_num_clusters(sb, &dir) << p_fs->cluster_size_bits;
+
+		count = count_dos_name_entries(sb, &dir, TYPE_DIR);
+		if (count < 0)
+			return FFS_MEDIAERR;
+		info->NumSubdirs += count;
+	}
+
+	if (p_fs->dev_ejected)
+		return FFS_MEDIAERR;
+
+	DPRINTK("ffsGetStat exited successfully\n");
+	return FFS_SUCCESS;
+} /* end of ffsGetStat */
+
+/* ffsSetStat : set the information of a given file */
+s32 ffsSetStat(struct inode *inode, DIR_ENTRY_T *info)
+{
+	sector_t sector = 0;
+	TIMESTAMP_T tm;
+	DENTRY_T *ep, *ep2;
+	ENTRY_SET_CACHE_T *es = NULL;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	FILE_ID_T *fid = &(EXFAT_I(inode)->fid);
+	u8 is_dir = (fid->type == TYPE_DIR) ? 1 : 0;
+
+	if (is_dir) {
+		if ((fid->dir.dir == p_fs->root_dir) &&
+			(fid->entry == -1)) {
+			if (p_fs->dev_ejected)
+				return FFS_MEDIAERR;
+			return FFS_SUCCESS;
+		}
+	}
+
+	fs_set_vol_flags(sb, VOL_DIRTY);
+
+	/* get the directory entry of given file or directory */
+	if (p_fs->vol_type == EXFAT) {
+		es = get_entry_set_in_dir(sb, &(fid->dir), fid->entry, ES_ALL_ENTRIES, &ep);
+		if (es == NULL)
+			return FFS_MEDIAERR;
+		ep2 = ep+1;
+	} else {
+		/* for other than exfat */
+		ep = get_entry_in_dir(sb, &(fid->dir), fid->entry, &sector);
+		if (!ep)
+			return FFS_MEDIAERR;
+		ep2 = ep;
+	}
+
+
+	p_fs->fs_func->set_entry_attr(ep, info->Attr);
+
+	/* set FILE_INFO structure using the acquired DENTRY_T */
+	tm.sec  = info->CreateTimestamp.Second;
+	tm.min  = info->CreateTimestamp.Minute;
+	tm.hour = info->CreateTimestamp.Hour;
+	tm.day  = info->CreateTimestamp.Day;
+	tm.mon  = info->CreateTimestamp.Month;
+	tm.year = info->CreateTimestamp.Year;
+	p_fs->fs_func->set_entry_time(ep, &tm, TM_CREATE);
+
+	tm.sec  = info->ModifyTimestamp.Second;
+	tm.min  = info->ModifyTimestamp.Minute;
+	tm.hour = info->ModifyTimestamp.Hour;
+	tm.day  = info->ModifyTimestamp.Day;
+	tm.mon  = info->ModifyTimestamp.Month;
+	tm.year = info->ModifyTimestamp.Year;
+	p_fs->fs_func->set_entry_time(ep, &tm, TM_MODIFY);
+
+
+	p_fs->fs_func->set_entry_size(ep2, info->Size);
+
+	if (p_fs->vol_type != EXFAT) {
+		buf_modify(sb, sector);
+	} else {
+		update_dir_checksum_with_entry_set(sb, es);
+		release_entry_set(es);
+	}
+
+	if (p_fs->dev_ejected)
+		return FFS_MEDIAERR;
+
+	return FFS_SUCCESS;
+} /* end of ffsSetStat */
+
+s32 ffsMapCluster(struct inode *inode, s32 clu_offset, u32 *clu)
+{
+	s32 num_clusters, num_alloced, modified = FALSE;
+	u32 last_clu;
+	sector_t sector = 0;
+	CHAIN_T new_clu;
+	DENTRY_T *ep;
+	ENTRY_SET_CACHE_T *es = NULL;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	FILE_ID_T *fid = &(EXFAT_I(inode)->fid);
+
+	fid->rwoffset = (s64)(clu_offset) << p_fs->cluster_size_bits;
+
+	if (EXFAT_I(inode)->mmu_private == 0)
+		num_clusters = 0;
+	else
+		num_clusters = (s32)((EXFAT_I(inode)->mmu_private-1) >> p_fs->cluster_size_bits) + 1;
+
+	*clu = last_clu = fid->start_clu;
+
+	if (fid->flags == 0x03) {
+		if ((clu_offset > 0) && (*clu != CLUSTER_32(~0))) {
+			last_clu += clu_offset - 1;
+
+			if (clu_offset == num_clusters)
+				*clu = CLUSTER_32(~0);
+			else
+				*clu += clu_offset;
+		}
+	} else {
+		/* hint information */
+		if ((clu_offset > 0) && (fid->hint_last_off > 0) &&
+			(clu_offset >= fid->hint_last_off)) {
+			clu_offset -= fid->hint_last_off;
+			*clu = fid->hint_last_clu;
+		}
+
+		while ((clu_offset > 0) && (*clu != CLUSTER_32(~0))) {
+			last_clu = *clu;
+			if (FAT_read(sb, *clu, clu) == -1)
+				return FFS_MEDIAERR;
+			clu_offset--;
+		}
+	}
+
+	if (*clu == CLUSTER_32(~0)) {
+		fs_set_vol_flags(sb, VOL_DIRTY);
+
+		new_clu.dir = (last_clu == CLUSTER_32(~0)) ? CLUSTER_32(~0) : last_clu+1;
+		new_clu.size = 0;
+		new_clu.flags = fid->flags;
+
+		/* (1) allocate a cluster */
+		num_alloced = p_fs->fs_func->alloc_cluster(sb, 1, &new_clu);
+		if (num_alloced < 0)
+			return FFS_MEDIAERR;
+		else if (num_alloced == 0)
+			return FFS_FULL;
+
+		/* (2) append to the FAT chain */
+		if (last_clu == CLUSTER_32(~0)) {
+			if (new_clu.flags == 0x01)
+				fid->flags = 0x01;
+			fid->start_clu = new_clu.dir;
+			modified = TRUE;
+		} else {
+			if (new_clu.flags != fid->flags) {
+				exfat_chain_cont_cluster(sb, fid->start_clu, num_clusters);
+				fid->flags = 0x01;
+				modified = TRUE;
+			}
+			if (new_clu.flags == 0x01)
+				FAT_write(sb, last_clu, new_clu.dir);
+		}
+
+		num_clusters += num_alloced;
+		*clu = new_clu.dir;
+
+		if (p_fs->vol_type == EXFAT) {
+			es = get_entry_set_in_dir(sb, &(fid->dir), fid->entry, ES_ALL_ENTRIES, &ep);
+			if (es == NULL)
+				return FFS_MEDIAERR;
+			/* get stream entry */
+			ep++;
+		}
+
+		/* (3) update directory entry */
+		if (modified) {
+			if (p_fs->vol_type != EXFAT) {
+				ep = get_entry_in_dir(sb, &(fid->dir), fid->entry, &sector);
+				if (!ep)
+					return FFS_MEDIAERR;
+			}
+
+			if (p_fs->fs_func->get_entry_flag(ep) != fid->flags)
+				p_fs->fs_func->set_entry_flag(ep, fid->flags);
+
+			if (p_fs->fs_func->get_entry_clu0(ep) != fid->start_clu)
+				p_fs->fs_func->set_entry_clu0(ep, fid->start_clu);
+
+			if (p_fs->vol_type != EXFAT)
+				buf_modify(sb, sector);
+		}
+
+		if (p_fs->vol_type == EXFAT) {
+			update_dir_checksum_with_entry_set(sb, es);
+			release_entry_set(es);
+		}
+
+		/* add number of new blocks to inode */
+		inode->i_blocks += num_alloced << (p_fs->cluster_size_bits - 9);
+	}
+
+	/* hint information */
+	fid->hint_last_off = (s32)(fid->rwoffset >> p_fs->cluster_size_bits);
+	fid->hint_last_clu = *clu;
+
+	if (p_fs->dev_ejected)
+		return FFS_MEDIAERR;
+
+	return FFS_SUCCESS;
+} /* end of ffsMapCluster */
+
+/*----------------------------------------------------------------------*/
+/*  Directory Operation Functions                                       */
+/*----------------------------------------------------------------------*/
+
+/* ffsCreateDir : create(make) a directory */
+s32 ffsCreateDir(struct inode *inode, char *path, FILE_ID_T *fid)
+{
+	s32 ret/*, dentry*/;
+	CHAIN_T dir;
+	UNI_NAME_T uni_name;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	DPRINTK("ffsCreateDir entered\n");
+
+	/* check the validity of directory name in the given old pathname */
+	ret = resolve_path(inode, path, &dir, &uni_name);
+	if (ret)
+		return ret;
+
+	fs_set_vol_flags(sb, VOL_DIRTY);
+
+	ret = create_dir(inode, &dir, &uni_name, fid);
+
+#ifdef CONFIG_EXFAT_DELAYED_SYNC
+	fs_sync(sb, 0);
+	fs_set_vol_flags(sb, VOL_CLEAN);
+#endif
+
+	if (p_fs->dev_ejected)
+		return FFS_MEDIAERR;
+
+	return ret;
+} /* end of ffsCreateDir */
+
+/* ffsReadDir : read a directory entry from the opened directory */
+s32 ffsReadDir(struct inode *inode, DIR_ENTRY_T *dir_entry)
+{
+	int i, dentry, clu_offset;
+	s32 dentries_per_clu, dentries_per_clu_bits = 0;
+	u32 type;
+	sector_t sector;
+	CHAIN_T dir, clu;
+	UNI_NAME_T uni_name;
+	TIMESTAMP_T tm;
+	DENTRY_T *ep;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	FILE_ID_T *fid = &(EXFAT_I(inode)->fid);
+
+	/* check if the given file ID is opened */
+	if (fid->type != TYPE_DIR)
+		return FFS_PERMISSIONERR;
+
+	if (fid->entry == -1) {
+		dir.dir = p_fs->root_dir;
+		dir.flags = 0x01;
+	} else {
+		dir.dir = fid->start_clu;
+		dir.size = (s32)(fid->size >> p_fs->cluster_size_bits);
+		dir.flags = fid->flags;
+	}
+
+	dentry = (s32) fid->rwoffset;
+
+	if (dir.dir == CLUSTER_32(0)) { /* FAT16 root_dir */
+		dentries_per_clu = p_fs->dentries_in_root;
+
+		if (dentry == dentries_per_clu) {
+			clu.dir = CLUSTER_32(~0);
+		} else {
+			clu.dir = dir.dir;
+			clu.size = dir.size;
+			clu.flags = dir.flags;
+		}
+	} else {
+		dentries_per_clu = p_fs->dentries_per_clu;
+		dentries_per_clu_bits = ilog2(dentries_per_clu);
+
+		clu_offset = dentry >> dentries_per_clu_bits;
+		clu.dir = dir.dir;
+		clu.size = dir.size;
+		clu.flags = dir.flags;
+
+		if (clu.flags == 0x03) {
+			clu.dir += clu_offset;
+			clu.size -= clu_offset;
+		} else {
+			/* hint_information */
+			if ((clu_offset > 0) && (fid->hint_last_off > 0) &&
+				(clu_offset >= fid->hint_last_off)) {
+				clu_offset -= fid->hint_last_off;
+				clu.dir = fid->hint_last_clu;
+			}
+
+			while (clu_offset > 0) {
+				/* clu.dir = FAT_read(sb, clu.dir); */
+				if (FAT_read(sb, clu.dir, &(clu.dir)) == -1)
+					return FFS_MEDIAERR;
+
+				clu_offset--;
+			}
+		}
+	}
+
+	while (clu.dir != CLUSTER_32(~0)) {
+		if (p_fs->dev_ejected)
+			break;
+
+		if (dir.dir == CLUSTER_32(0)) /* FAT16 root_dir */
+			i = dentry % dentries_per_clu;
+		else
+			i = dentry & (dentries_per_clu-1);
+
+		for ( ; i < dentries_per_clu; i++, dentry++) {
+			ep = get_entry_in_dir(sb, &clu, i, &sector);
+			if (!ep)
+				return FFS_MEDIAERR;
+
+			type = p_fs->fs_func->get_entry_type(ep);
+
+			if (type == TYPE_UNUSED)
+				break;
+
+			if ((type != TYPE_FILE) && (type != TYPE_DIR))
+				continue;
+
+			buf_lock(sb, sector);
+			dir_entry->Attr = p_fs->fs_func->get_entry_attr(ep);
+
+			p_fs->fs_func->get_entry_time(ep, &tm, TM_CREATE);
+			dir_entry->CreateTimestamp.Year = tm.year;
+			dir_entry->CreateTimestamp.Month = tm.mon;
+			dir_entry->CreateTimestamp.Day = tm.day;
+			dir_entry->CreateTimestamp.Hour = tm.hour;
+			dir_entry->CreateTimestamp.Minute = tm.min;
+			dir_entry->CreateTimestamp.Second = tm.sec;
+			dir_entry->CreateTimestamp.MilliSecond = 0;
+
+			p_fs->fs_func->get_entry_time(ep, &tm, TM_MODIFY);
+			dir_entry->ModifyTimestamp.Year = tm.year;
+			dir_entry->ModifyTimestamp.Month = tm.mon;
+			dir_entry->ModifyTimestamp.Day = tm.day;
+			dir_entry->ModifyTimestamp.Hour = tm.hour;
+			dir_entry->ModifyTimestamp.Minute = tm.min;
+			dir_entry->ModifyTimestamp.Second = tm.sec;
+			dir_entry->ModifyTimestamp.MilliSecond = 0;
+
+			memset((char *) &dir_entry->AccessTimestamp, 0, sizeof(DATE_TIME_T));
+
+			*(uni_name.name) = 0x0;
+			p_fs->fs_func->get_uni_name_from_ext_entry(sb, &dir, dentry, uni_name.name);
+			if (*(uni_name.name) == 0x0 && p_fs->vol_type != EXFAT)
+				get_uni_name_from_dos_entry(sb, (DOS_DENTRY_T *) ep, &uni_name, 0x1);
+			nls_uniname_to_cstring(sb, dir_entry->Name, &uni_name);
+			buf_unlock(sb, sector);
+
+			if (p_fs->vol_type == EXFAT) {
+				ep = get_entry_in_dir(sb, &clu, i+1, NULL);
+				if (!ep)
+					return FFS_MEDIAERR;
+			} else {
+				get_uni_name_from_dos_entry(sb, (DOS_DENTRY_T *) ep, &uni_name, 0x0);
+				nls_uniname_to_cstring(sb, dir_entry->ShortName, &uni_name);
+			}
+
+			dir_entry->Size = p_fs->fs_func->get_entry_size(ep);
+
+			/* hint information */
+			if (dir.dir == CLUSTER_32(0)) { /* FAT16 root_dir */
+			} else {
+				fid->hint_last_off = dentry >> dentries_per_clu_bits;
+				fid->hint_last_clu = clu.dir;
+			}
+
+			fid->rwoffset = (s64) ++dentry;
+
+			if (p_fs->dev_ejected)
+				return FFS_MEDIAERR;
+
+			return FFS_SUCCESS;
+		}
+
+		if (dir.dir == CLUSTER_32(0))
+			break; /* FAT16 root_dir */
+
+		if (clu.flags == 0x03) {
+			if ((--clu.size) > 0)
+				clu.dir++;
+			else
+				clu.dir = CLUSTER_32(~0);
+		} else {
+			/* clu.dir = FAT_read(sb, clu.dir); */
+			if (FAT_read(sb, clu.dir, &(clu.dir)) == -1)
+				return FFS_MEDIAERR;
+		}
+	}
+
+	*(dir_entry->Name) = '\0';
+
+	fid->rwoffset = (s64) ++dentry;
+
+	if (p_fs->dev_ejected)
+		return FFS_MEDIAERR;
+
+	return FFS_SUCCESS;
+} /* end of ffsReadDir */
+
+/* ffsRemoveDir : remove a directory */
+s32 ffsRemoveDir(struct inode *inode, FILE_ID_T *fid)
+{
+	s32 dentry;
+	CHAIN_T dir, clu_to_free;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	dir.dir = fid->dir.dir;
+	dir.size = fid->dir.size;
+	dir.flags = fid->dir.flags;
+
+	dentry = fid->entry;
+
+	/* check if the file is "." or ".." */
+	if (p_fs->vol_type != EXFAT) {
+		if ((dir.dir != p_fs->root_dir) && (dentry < 2))
+			return FFS_PERMISSIONERR;
+	}
+
+	clu_to_free.dir = fid->start_clu;
+	clu_to_free.size = (s32)((fid->size-1) >> p_fs->cluster_size_bits) + 1;
+	clu_to_free.flags = fid->flags;
+
+	if (!is_dir_empty(sb, &clu_to_free))
+		return FFS_FILEEXIST;
+
+	fs_set_vol_flags(sb, VOL_DIRTY);
+
+	/* (1) update the directory entry */
+	remove_file(inode, &dir, dentry);
+
+	/* (2) free the clusters */
+	p_fs->fs_func->free_cluster(sb, &clu_to_free, 1);
+
+	fid->size = 0;
+	fid->start_clu = CLUSTER_32(~0);
+	fid->flags = (p_fs->vol_type == EXFAT)? 0x03: 0x01;
+
+#ifdef CONFIG_EXFAT_DELAYED_SYNC
+	fs_sync(sb, 0);
+	fs_set_vol_flags(sb, VOL_CLEAN);
+#endif
+
+	if (p_fs->dev_ejected)
+		return FFS_MEDIAERR;
+
+	return FFS_SUCCESS;
+} /* end of ffsRemoveDir */
+
+/*======================================================================*/
+/*  Local Function Definitions                                          */
+/*======================================================================*/
+
+/*
+ *  File System Management Functions
+ */
+
+s32 fs_init(void)
+{
+	/* critical check for system requirement on size of DENTRY_T structure */
+	if (sizeof(DENTRY_T) != DENTRY_SIZE)
+		return FFS_ALIGNMENTERR;
+
+	if (sizeof(DOS_DENTRY_T) != DENTRY_SIZE)
+		return FFS_ALIGNMENTERR;
+
+	if (sizeof(EXT_DENTRY_T) != DENTRY_SIZE)
+		return FFS_ALIGNMENTERR;
+
+	if (sizeof(FILE_DENTRY_T) != DENTRY_SIZE)
+		return FFS_ALIGNMENTERR;
+
+	if (sizeof(STRM_DENTRY_T) != DENTRY_SIZE)
+		return FFS_ALIGNMENTERR;
+
+	if (sizeof(NAME_DENTRY_T) != DENTRY_SIZE)
+		return FFS_ALIGNMENTERR;
+
+	if (sizeof(BMAP_DENTRY_T) != DENTRY_SIZE)
+		return FFS_ALIGNMENTERR;
+
+	if (sizeof(CASE_DENTRY_T) != DENTRY_SIZE)
+		return FFS_ALIGNMENTERR;
+
+	if (sizeof(VOLM_DENTRY_T) != DENTRY_SIZE)
+		return FFS_ALIGNMENTERR;
+
+	return FFS_SUCCESS;
+} /* end of fs_init */
+
+s32 fs_shutdown(void)
+{
+	return FFS_SUCCESS;
+} /* end of fs_shutdown */
+
+void fs_set_vol_flags(struct super_block *sb, u32 new_flag)
+{
+	PBR_SECTOR_T *p_pbr;
+	BPBEX_T *p_bpb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	if (p_fs->vol_flag == new_flag)
+		return;
+
+	p_fs->vol_flag = new_flag;
+
+	if (p_fs->vol_type == EXFAT) {
+		if (p_fs->pbr_bh == NULL) {
+			if (sector_read(sb, p_fs->PBR_sector, &(p_fs->pbr_bh), 1) != FFS_SUCCESS)
+				return;
+		}
+
+		p_pbr = (PBR_SECTOR_T *) p_fs->pbr_bh->b_data;
+		p_bpb = (BPBEX_T *) p_pbr->bpb;
+		SET16(p_bpb->vol_flags, (u16) new_flag);
+
+		/* XXX duyoung
+		 what can we do here? (cuz fs_set_vol_flags() is void) */
+		if ((new_flag == VOL_DIRTY) && (!buffer_dirty(p_fs->pbr_bh)))
+			sector_write(sb, p_fs->PBR_sector, p_fs->pbr_bh, 1);
+		else
+			sector_write(sb, p_fs->PBR_sector, p_fs->pbr_bh, 0);
+	}
+} /* end of fs_set_vol_flags */
+
+void fs_sync(struct super_block *sb, s32 do_sync)
+{
+	if (do_sync)
+		bdev_sync(sb);
+} /* end of fs_sync */
+
+void fs_error(struct super_block *sb)
+{
+	struct exfat_mount_options *opts = &EXFAT_SB(sb)->options;
+
+	if (opts->errors == EXFAT_ERRORS_PANIC)
+		panic("[EXFAT] Filesystem panic from previous error\n");
+	else if ((opts->errors == EXFAT_ERRORS_RO) && !(sb->s_flags & MS_RDONLY)) {
+		sb->s_flags |= MS_RDONLY;
+		printk(KERN_ERR "[EXFAT] Filesystem has been set read-only\n");
+	}
+}
+
+/*
+ *  Cluster Management Functions
+ */
+
+s32 clear_cluster(struct super_block *sb, u32 clu)
+{
+	sector_t s, n;
+	s32 ret = FFS_SUCCESS;
+	struct buffer_head *tmp_bh = NULL;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+
+	if (clu == CLUSTER_32(0)) { /* FAT16 root_dir */
+		s = p_fs->root_start_sector;
+		n = p_fs->data_start_sector;
+	} else {
+		s = START_SECTOR(clu);
+		n = s + p_fs->sectors_per_clu;
+	}
+
+	for (; s < n; s++) {
+		ret = sector_read(sb, s, &tmp_bh, 0);
+		if (ret != FFS_SUCCESS)
+			return ret;
+
+		memset((char *) tmp_bh->b_data, 0x0, p_bd->sector_size);
+		ret = sector_write(sb, s, tmp_bh, 0);
+		if (ret != FFS_SUCCESS)
+			break;
+	}
+
+	brelse(tmp_bh);
+	return ret;
+} /* end of clear_cluster */
+
+s32 fat_alloc_cluster(struct super_block *sb, s32 num_alloc, CHAIN_T *p_chain)
+{
+	int i, num_clusters = 0;
+	u32 new_clu, last_clu = CLUSTER_32(~0), read_clu;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	new_clu = p_chain->dir;
+	if (new_clu == CLUSTER_32(~0))
+		new_clu = p_fs->clu_srch_ptr;
+	else if (new_clu >= p_fs->num_clusters)
+		new_clu = 2;
+
+	__set_sb_dirty(sb);
+
+	p_chain->dir = CLUSTER_32(~0);
+
+	for (i = 2; i < p_fs->num_clusters; i++) {
+		if (FAT_read(sb, new_clu, &read_clu) != 0)
+			return -1;
+
+		if (read_clu == CLUSTER_32(0)) {
+			if (FAT_write(sb, new_clu, CLUSTER_32(~0)) < 0)
+				return -1;
+			num_clusters++;
+
+			if (p_chain->dir == CLUSTER_32(~0))
+				p_chain->dir = new_clu;
+			else {
+				if (FAT_write(sb, last_clu, new_clu) < 0)
+					return -1;
+			}
+
+			last_clu = new_clu;
+
+			if ((--num_alloc) == 0) {
+				p_fs->clu_srch_ptr = new_clu;
+				if (p_fs->used_clusters != (u32) ~0)
+					p_fs->used_clusters += num_clusters;
+
+				return num_clusters;
+			}
+		}
+		if ((++new_clu) >= p_fs->num_clusters)
+			new_clu = 2;
+	}
+
+	p_fs->clu_srch_ptr = new_clu;
+	if (p_fs->used_clusters != (u32) ~0)
+		p_fs->used_clusters += num_clusters;
+
+	return num_clusters;
+} /* end of fat_alloc_cluster */
+
+s32 exfat_alloc_cluster(struct super_block *sb, s32 num_alloc, CHAIN_T *p_chain)
+{
+	s32 num_clusters = 0;
+	u32 hint_clu, new_clu, last_clu = CLUSTER_32(~0);
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	hint_clu = p_chain->dir;
+	if (hint_clu == CLUSTER_32(~0)) {
+		hint_clu = test_alloc_bitmap(sb, p_fs->clu_srch_ptr-2);
+		if (hint_clu == CLUSTER_32(~0))
+			return 0;
+	} else if (hint_clu >= p_fs->num_clusters) {
+		hint_clu = 2;
+		p_chain->flags = 0x01;
+	}
+
+	__set_sb_dirty(sb);
+
+	p_chain->dir = CLUSTER_32(~0);
+
+	while ((new_clu = test_alloc_bitmap(sb, hint_clu-2)) != CLUSTER_32(~0)) {
+		if (new_clu != hint_clu) {
+			if (p_chain->flags == 0x03) {
+				exfat_chain_cont_cluster(sb, p_chain->dir, num_clusters);
+				p_chain->flags = 0x01;
+			}
+		}
+
+		if (set_alloc_bitmap(sb, new_clu-2) != FFS_SUCCESS)
+			return -1;
+
+		num_clusters++;
+
+		if (p_chain->flags == 0x01) {
+			if (FAT_write(sb, new_clu, CLUSTER_32(~0)) < 0)
+				return -1;
+		}
+
+		if (p_chain->dir == CLUSTER_32(~0)) {
+			p_chain->dir = new_clu;
+		} else {
+			if (p_chain->flags == 0x01) {
+				if (FAT_write(sb, last_clu, new_clu) < 0)
+					return -1;
+			}
+		}
+		last_clu = new_clu;
+
+		if ((--num_alloc) == 0) {
+			p_fs->clu_srch_ptr = hint_clu;
+			if (p_fs->used_clusters != (u32) ~0)
+				p_fs->used_clusters += num_clusters;
+
+			p_chain->size += num_clusters;
+			return num_clusters;
+		}
+
+		hint_clu = new_clu + 1;
+		if (hint_clu >= p_fs->num_clusters) {
+			hint_clu = 2;
+
+			if (p_chain->flags == 0x03) {
+				exfat_chain_cont_cluster(sb, p_chain->dir, num_clusters);
+				p_chain->flags = 0x01;
+			}
+		}
+	}
+
+	p_fs->clu_srch_ptr = hint_clu;
+	if (p_fs->used_clusters != (u32) ~0)
+		p_fs->used_clusters += num_clusters;
+
+	p_chain->size += num_clusters;
+	return num_clusters;
+} /* end of exfat_alloc_cluster */
+
+void fat_free_cluster(struct super_block *sb, CHAIN_T *p_chain, s32 do_relse)
+{
+	s32 num_clusters = 0;
+	u32 clu, prev;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	int i;
+	sector_t sector;
+
+	if ((p_chain->dir == CLUSTER_32(0)) || (p_chain->dir == CLUSTER_32(~0)))
+		return;
+	__set_sb_dirty(sb);
+	clu = p_chain->dir;
+
+	if (p_chain->size <= 0)
+		return;
+
+	do {
+		if (p_fs->dev_ejected)
+			break;
+
+		if (do_relse) {
+			sector = START_SECTOR(clu);
+			for (i = 0; i < p_fs->sectors_per_clu; i++)
+				buf_release(sb, sector+i);
+		}
+
+		prev = clu;
+		if (FAT_read(sb, clu, &clu) == -1)
+			break;
+
+		if (FAT_write(sb, prev, CLUSTER_32(0)) < 0)
+			break;
+		num_clusters++;
+
+	} while (clu != CLUSTER_32(~0));
+
+	if (p_fs->used_clusters != (u32) ~0)
+		p_fs->used_clusters -= num_clusters;
+} /* end of fat_free_cluster */
+
+void exfat_free_cluster(struct super_block *sb, CHAIN_T *p_chain, s32 do_relse)
+{
+	s32 num_clusters = 0;
+	u32 clu;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	int i;
+	sector_t sector;
+
+	if ((p_chain->dir == CLUSTER_32(0)) || (p_chain->dir == CLUSTER_32(~0)))
+		return;
+
+	if (p_chain->size <= 0) {
+		printk(KERN_ERR "[EXFAT] free_cluster : skip free-req clu:%u, "
+				"because of zero-size truncation\n"
+				,p_chain->dir);
+		return;
+	}
+
+	__set_sb_dirty(sb);
+	clu = p_chain->dir;
+
+	if (p_chain->flags == 0x03) {
+		do {
+			if (do_relse) {
+				sector = START_SECTOR(clu);
+				for (i = 0; i < p_fs->sectors_per_clu; i++)
+					buf_release(sb, sector+i);
+			}
+
+			if (clr_alloc_bitmap(sb, clu-2) != FFS_SUCCESS)
+				break;
+			clu++;
+
+			num_clusters++;
+		} while (num_clusters < p_chain->size);
+	} else {
+		do {
+			if (p_fs->dev_ejected)
+				break;
+
+			if (do_relse) {
+				sector = START_SECTOR(clu);
+				for (i = 0; i < p_fs->sectors_per_clu; i++)
+					buf_release(sb, sector+i);
+			}
+
+			if (clr_alloc_bitmap(sb, clu-2) != FFS_SUCCESS)
+				break;
+
+			if (FAT_read(sb, clu, &clu) == -1)
+				break;
+			num_clusters++;
+		} while ((clu != CLUSTER_32(0)) && (clu != CLUSTER_32(~0)));
+	}
+
+	if (p_fs->used_clusters != (u32) ~0)
+		p_fs->used_clusters -= num_clusters;
+} /* end of exfat_free_cluster */
+
+u32 find_last_cluster(struct super_block *sb, CHAIN_T *p_chain)
+{
+	u32 clu, next;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	clu = p_chain->dir;
+
+	if (p_chain->flags == 0x03) {
+		clu += p_chain->size - 1;
+	} else {
+		while ((FAT_read(sb, clu, &next) == 0) && (next != CLUSTER_32(~0))) {
+			if (p_fs->dev_ejected)
+				break;
+			clu = next;
+		}
+	}
+
+	return clu;
+} /* end of find_last_cluster */
+
+s32 count_num_clusters(struct super_block *sb, CHAIN_T *p_chain)
+{
+	int i, count = 0;
+	u32 clu;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	if ((p_chain->dir == CLUSTER_32(0)) || (p_chain->dir == CLUSTER_32(~0)))
+		return 0;
+
+	clu = p_chain->dir;
+
+	if (p_chain->flags == 0x03) {
+		count = p_chain->size;
+	} else {
+		for (i = 2; i < p_fs->num_clusters; i++) {
+			count++;
+			if (FAT_read(sb, clu, &clu) != 0)
+				return 0;
+			if (clu == CLUSTER_32(~0))
+				break;
+		}
+	}
+
+	return count;
+} /* end of count_num_clusters */
+
+s32 fat_count_used_clusters(struct super_block *sb)
+{
+	int i, count = 0;
+	u32 clu;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	for (i = 2; i < p_fs->num_clusters; i++) {
+		if (FAT_read(sb, i, &clu) != 0)
+			break;
+		if (clu != CLUSTER_32(0))
+			count++;
+	}
+
+	return count;
+} /* end of fat_count_used_clusters */
+
+s32 exfat_count_used_clusters(struct super_block *sb)
+{
+	int i, map_i, map_b, count = 0;
+	u8 k;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+
+	map_i = map_b = 0;
+
+	for (i = 2; i < p_fs->num_clusters; i += 8) {
+		k = *(((u8 *) p_fs->vol_amap[map_i]->b_data) + map_b);
+		count += used_bit[k];
+
+		if ((++map_b) >= p_bd->sector_size) {
+			map_i++;
+			map_b = 0;
+		}
+	}
+
+	return count;
+} /* end of exfat_count_used_clusters */
+
+void exfat_chain_cont_cluster(struct super_block *sb, u32 chain, s32 len)
+{
+	if (len == 0)
+		return;
+
+	while (len > 1) {
+		if (FAT_write(sb, chain, chain+1) < 0)
+			break;
+		chain++;
+		len--;
+	}
+	FAT_write(sb, chain, CLUSTER_32(~0));
+} /* end of exfat_chain_cont_cluster */
+
+/*
+ *  Allocation Bitmap Management Functions
+ */
+
+s32 load_alloc_bitmap(struct super_block *sb)
+{
+	int i, j, ret;
+	u32 map_size;
+	u32 type;
+	sector_t sector;
+	CHAIN_T clu;
+	BMAP_DENTRY_T *ep;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+
+	clu.dir = p_fs->root_dir;
+	clu.flags = 0x01;
+
+	while (clu.dir != CLUSTER_32(~0)) {
+		if (p_fs->dev_ejected)
+			break;
+
+		for (i = 0; i < p_fs->dentries_per_clu; i++) {
+			ep = (BMAP_DENTRY_T *) get_entry_in_dir(sb, &clu, i, NULL);
+			if (!ep)
+				return FFS_MEDIAERR;
+
+			type = p_fs->fs_func->get_entry_type((DENTRY_T *) ep);
+
+			if (type == TYPE_UNUSED)
+				break;
+			if (type != TYPE_BITMAP)
+				continue;
+
+			if (ep->flags == 0x0) {
+				p_fs->map_clu  = GET32_A(ep->start_clu);
+				map_size = (u32) GET64_A(ep->size);
+
+				p_fs->map_sectors = ((map_size-1) >> p_bd->sector_size_bits) + 1;
+
+				p_fs->vol_amap = (struct buffer_head **) kmalloc(sizeof(struct buffer_head *) * p_fs->map_sectors, GFP_KERNEL);
+				if (p_fs->vol_amap == NULL)
+					return FFS_MEMORYERR;
+
+				sector = START_SECTOR(p_fs->map_clu);
+
+				for (j = 0; j < p_fs->map_sectors; j++) {
+					p_fs->vol_amap[j] = NULL;
+					ret = sector_read(sb, sector+j, &(p_fs->vol_amap[j]), 1);
+					if (ret != FFS_SUCCESS) {
+						/*  release all buffers and free vol_amap */
+						i = 0;
+						while (i < j)
+							brelse(p_fs->vol_amap[i++]);
+
+						if (p_fs->vol_amap)
+							kfree(p_fs->vol_amap);
+						p_fs->vol_amap = NULL;
+						return ret;
+					}
+				}
+
+				p_fs->pbr_bh = NULL;
+				return FFS_SUCCESS;
+			}
+		}
+
+		if (FAT_read(sb, clu.dir, &(clu.dir)) != 0)
+			return FFS_MEDIAERR;
+	}
+
+	return FFS_FORMATERR;
+} /* end of load_alloc_bitmap */
+
+void free_alloc_bitmap(struct super_block *sb)
+{
+	int i;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	brelse(p_fs->pbr_bh);
+
+	for (i = 0; i < p_fs->map_sectors; i++)
+		__brelse(p_fs->vol_amap[i]);
+
+	if (p_fs->vol_amap)
+		kfree(p_fs->vol_amap);
+	p_fs->vol_amap = NULL;
+} /* end of free_alloc_bitmap */
+
+s32 set_alloc_bitmap(struct super_block *sb, u32 clu)
+{
+	int i, b;
+	sector_t sector;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+
+	i = clu >> (p_bd->sector_size_bits + 3);
+	b = clu & ((p_bd->sector_size << 3) - 1);
+
+	sector = START_SECTOR(p_fs->map_clu) + i;
+
+	exfat_bitmap_set((u8 *) p_fs->vol_amap[i]->b_data, b);
+
+	return sector_write(sb, sector, p_fs->vol_amap[i], 0);
+} /* end of set_alloc_bitmap */
+
+s32 clr_alloc_bitmap(struct super_block *sb, u32 clu)
+{
+	int i, b;
+	sector_t sector;
+#ifdef CONFIG_EXFAT_DISCARD
+	struct exfat_sb_info *sbi = EXFAT_SB(sb);
+	struct exfat_mount_options *opts = &sbi->options;
+	int ret;
+#endif /* CONFIG_EXFAT_DISCARD */
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+
+	i = clu >> (p_bd->sector_size_bits + 3);
+	b = clu & ((p_bd->sector_size << 3) - 1);
+
+	sector = START_SECTOR(p_fs->map_clu) + i;
+
+	exfat_bitmap_clear((u8 *) p_fs->vol_amap[i]->b_data, b);
+
+	return sector_write(sb, sector, p_fs->vol_amap[i], 0);
+
+#ifdef CONFIG_EXFAT_DISCARD
+	if (opts->discard) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
+		ret = sb_issue_discard(sb, START_SECTOR(clu), (1 << p_fs->sectors_per_clu_bits));
+#else
+		ret = sb_issue_discard(sb, START_SECTOR(clu), (1 << p_fs->sectors_per_clu_bits), GFP_NOFS, 0);
+#endif
+		if (ret == -EOPNOTSUPP) {
+			printk(KERN_WARNING "discard not supported by device, disabling");
+			opts->discard = 0;
+		}
+	}
+#endif /* CONFIG_EXFAT_DISCARD */
+} /* end of clr_alloc_bitmap */
+
+u32 test_alloc_bitmap(struct super_block *sb, u32 clu)
+{
+	int i, map_i, map_b;
+	u32 clu_base, clu_free;
+	u8 k, clu_mask;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+
+	clu_base = (clu & ~(0x7)) + 2;
+	clu_mask = (1 << (clu - clu_base + 2)) - 1;
+
+	map_i = clu >> (p_bd->sector_size_bits + 3);
+	map_b = (clu >> 3) & p_bd->sector_size_mask;
+
+	for (i = 2; i < p_fs->num_clusters; i += 8) {
+		k = *(((u8 *) p_fs->vol_amap[map_i]->b_data) + map_b);
+		if (clu_mask > 0) {
+			k |= clu_mask;
+			clu_mask = 0;
+		}
+		if (k < 0xFF) {
+			clu_free = clu_base + free_bit[k];
+			if (clu_free < p_fs->num_clusters)
+				return clu_free;
+		}
+		clu_base += 8;
+
+		if (((++map_b) >= p_bd->sector_size) || (clu_base >= p_fs->num_clusters)) {
+			if ((++map_i) >= p_fs->map_sectors) {
+				clu_base = 2;
+				map_i = 0;
+			}
+			map_b = 0;
+		}
+	}
+
+	return CLUSTER_32(~0);
+} /* end of test_alloc_bitmap */
+
+void sync_alloc_bitmap(struct super_block *sb)
+{
+	int i;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	if (p_fs->vol_amap == NULL)
+		return;
+
+	for (i = 0; i < p_fs->map_sectors; i++)
+		sync_dirty_buffer(p_fs->vol_amap[i]);
+} /* end of sync_alloc_bitmap */
+
+/*
+ *  Upcase table Management Functions
+ */
+s32 __load_upcase_table(struct super_block *sb, sector_t sector, u32 num_sectors, u32 utbl_checksum)
+{
+	int i, ret = FFS_ERROR;
+	u32 j;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+	struct buffer_head *tmp_bh = NULL;
+	sector_t end_sector = num_sectors + sector;
+
+	u8	skip = FALSE;
+	u32	index = 0;
+	u16	uni = 0;
+	u16 **upcase_table;
+
+	u32 checksum = 0;
+
+	upcase_table = p_fs->vol_utbl = (u16 **) kmalloc(UTBL_COL_COUNT * sizeof(u16 *), GFP_KERNEL);
+	if (upcase_table == NULL)
+		return FFS_MEMORYERR;
+	memset(upcase_table, 0, UTBL_COL_COUNT * sizeof(u16 *));
+
+	while (sector < end_sector) {
+		ret = sector_read(sb, sector, &tmp_bh, 1);
+		if (ret != FFS_SUCCESS) {
+			DPRINTK("sector read (0x%llX)fail\n", (unsigned long long)sector);
+			goto error;
+		}
+		sector++;
+
+		for (i = 0; i < p_bd->sector_size && index <= 0xFFFF; i += 2) {
+			uni = GET16(((u8 *) tmp_bh->b_data)+i);
+
+			checksum = ((checksum & 1) ? 0x80000000 : 0) + (checksum >> 1) + *(((u8 *) tmp_bh->b_data)+i);
+			checksum = ((checksum & 1) ? 0x80000000 : 0) + (checksum >> 1) + *(((u8 *) tmp_bh->b_data)+(i+1));
+
+			if (skip) {
+				DPRINTK("skip from 0x%X ", index);
+				index += uni;
+				DPRINTK("to 0x%X (amount of 0x%X)\n", index, uni);
+				skip = FALSE;
+			} else if (uni == index)
+				index++;
+			else if (uni == 0xFFFF)
+				skip = TRUE;
+			else { /* uni != index , uni != 0xFFFF */
+				u16 col_index = get_col_index(index);
+
+				if (upcase_table[col_index] == NULL) {
+					DPRINTK("alloc = 0x%X\n", col_index);
+					upcase_table[col_index] = (u16 *) kmalloc(UTBL_ROW_COUNT * sizeof(u16), GFP_KERNEL);
+					if (upcase_table[col_index] == NULL) {
+						ret = FFS_MEMORYERR;
+						goto error;
+					}
+
+					for (j = 0; j < UTBL_ROW_COUNT; j++)
+						upcase_table[col_index][j] = (col_index << LOW_INDEX_BIT) | j;
+				}
+
+				upcase_table[col_index][get_row_index(index)] = uni;
+				index++;
+			}
+		}
+	}
+	if (index >= 0xFFFF && utbl_checksum == checksum) {
+		if (tmp_bh)
+			brelse(tmp_bh);
+		return FFS_SUCCESS;
+	}
+	ret = FFS_ERROR;
+error:
+	if (tmp_bh)
+		brelse(tmp_bh);
+	free_upcase_table(sb);
+	return ret;
+}
+
+s32 __load_default_upcase_table(struct super_block *sb)
+{
+	int i, ret = FFS_ERROR;
+	u32 j;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	u8	skip = FALSE;
+	u32	index = 0;
+	u16	uni = 0;
+	u16 **upcase_table;
+
+	upcase_table = p_fs->vol_utbl = (u16 **) kmalloc(UTBL_COL_COUNT * sizeof(u16 *), GFP_KERNEL);
+	if (upcase_table == NULL)
+		return FFS_MEMORYERR;
+	memset(upcase_table, 0, UTBL_COL_COUNT * sizeof(u16 *));
+
+	for (i = 0; index <= 0xFFFF && i < NUM_UPCASE*2; i += 2) {
+		uni = GET16(uni_upcase + i);
+		if (skip) {
+			DPRINTK("skip from 0x%X ", index);
+			index += uni;
+			DPRINTK("to 0x%X (amount of 0x%X)\n", index, uni);
+			skip = FALSE;
+		} else if (uni == index)
+			index++;
+		else if (uni == 0xFFFF)
+			skip = TRUE;
+		else { /* uni != index , uni != 0xFFFF */
+			u16 col_index = get_col_index(index);
+
+			if (upcase_table[col_index] == NULL) {
+				DPRINTK("alloc = 0x%X\n", col_index);
+				upcase_table[col_index] = (u16 *) kmalloc(UTBL_ROW_COUNT * sizeof(u16), GFP_KERNEL);
+				if (upcase_table[col_index] == NULL) {
+					ret = FFS_MEMORYERR;
+					goto error;
+				}
+
+				for (j = 0; j < UTBL_ROW_COUNT; j++)
+					upcase_table[col_index][j] = (col_index << LOW_INDEX_BIT) | j;
+			}
+
+			upcase_table[col_index][get_row_index(index)] = uni;
+			index++;
+		}
+	}
+
+	if (index >= 0xFFFF)
+		return FFS_SUCCESS;
+
+error:
+	/* FATAL error: default upcase table has error */
+	free_upcase_table(sb);
+	return ret;
+}
+
+s32 load_upcase_table(struct super_block *sb)
+{
+	int i;
+	u32 tbl_clu, tbl_size;
+	sector_t sector;
+	u32 type, num_sectors;
+	CHAIN_T clu;
+	CASE_DENTRY_T *ep;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+
+	clu.dir = p_fs->root_dir;
+	clu.flags = 0x01;
+
+	if (p_fs->dev_ejected)
+		return FFS_MEDIAERR;
+
+	while (clu.dir != CLUSTER_32(~0)) {
+		for (i = 0; i < p_fs->dentries_per_clu; i++) {
+			ep = (CASE_DENTRY_T *) get_entry_in_dir(sb, &clu, i, NULL);
+			if (!ep)
+				return FFS_MEDIAERR;
+
+			type = p_fs->fs_func->get_entry_type((DENTRY_T *) ep);
+
+			if (type == TYPE_UNUSED)
+				break;
+			if (type != TYPE_UPCASE)
+				continue;
+
+			tbl_clu  = GET32_A(ep->start_clu);
+			tbl_size = (u32) GET64_A(ep->size);
+
+			sector = START_SECTOR(tbl_clu);
+			num_sectors = ((tbl_size-1) >> p_bd->sector_size_bits) + 1;
+			if (__load_upcase_table(sb, sector, num_sectors, GET32_A(ep->checksum)) != FFS_SUCCESS)
+				break;
+			else
+				return FFS_SUCCESS;
+		}
+		if (FAT_read(sb, clu.dir, &(clu.dir)) != 0)
+			return FFS_MEDIAERR;
+	}
+	/* load default upcase table */
+	return __load_default_upcase_table(sb);
+} /* end of load_upcase_table */
+
+void free_upcase_table(struct super_block *sb)
+{
+	u32 i;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	u16 **upcase_table;
+
+	upcase_table = p_fs->vol_utbl;
+	for (i = 0; i < UTBL_COL_COUNT; i++) {
+		if (upcase_table[i])
+			kfree(upcase_table[i]);
+	}
+
+	if (p_fs->vol_utbl)
+		kfree(p_fs->vol_utbl);
+	p_fs->vol_utbl = NULL;
+} /* end of free_upcase_table */
+
+/*
+ *  Directory Entry Management Functions
+ */
+
+u32 fat_get_entry_type(DENTRY_T *p_entry)
+{
+	DOS_DENTRY_T *ep = (DOS_DENTRY_T *) p_entry;
+
+	if (*(ep->name) == 0x0)
+		return TYPE_UNUSED;
+
+	else if (*(ep->name) == 0xE5)
+		return TYPE_DELETED;
+
+	else if (ep->attr == ATTR_EXTEND)
+		return TYPE_EXTEND;
+
+	else if ((ep->attr & (ATTR_SUBDIR|ATTR_VOLUME)) == ATTR_VOLUME)
+		return TYPE_VOLUME;
+
+	else if ((ep->attr & (ATTR_SUBDIR|ATTR_VOLUME)) == ATTR_SUBDIR)
+		return TYPE_DIR;
+
+	return TYPE_FILE;
+} /* end of fat_get_entry_type */
+
+u32 exfat_get_entry_type(DENTRY_T *p_entry)
+{
+	FILE_DENTRY_T *ep = (FILE_DENTRY_T *) p_entry;
+
+	if (ep->type == 0x0) {
+		return TYPE_UNUSED;
+	} else if (ep->type < 0x80) {
+		return TYPE_DELETED;
+	} else if (ep->type == 0x80) {
+		return TYPE_INVALID;
+	} else if (ep->type < 0xA0) {
+		if (ep->type == 0x81) {
+			return TYPE_BITMAP;
+		} else if (ep->type == 0x82) {
+			return TYPE_UPCASE;
+		} else if (ep->type == 0x83) {
+			return TYPE_VOLUME;
+		} else if (ep->type == 0x85) {
+			if (GET16_A(ep->attr) & ATTR_SUBDIR)
+				return TYPE_DIR;
+			else
+				return TYPE_FILE;
+		}
+		return TYPE_CRITICAL_PRI;
+	} else if (ep->type < 0xC0) {
+		if (ep->type == 0xA0)
+			return TYPE_GUID;
+		else if (ep->type == 0xA1)
+			return TYPE_PADDING;
+		else if (ep->type == 0xA2)
+			return TYPE_ACLTAB;
+		return TYPE_BENIGN_PRI;
+	} else if (ep->type < 0xE0) {
+		if (ep->type == 0xC0)
+			return TYPE_STREAM;
+		else if (ep->type == 0xC1)
+			return TYPE_EXTEND;
+		else if (ep->type == 0xC2)
+			return TYPE_ACL;
+		return TYPE_CRITICAL_SEC;
+	}
+
+	return TYPE_BENIGN_SEC;
+} /* end of exfat_get_entry_type */
+
+void fat_set_entry_type(DENTRY_T *p_entry, u32 type)
+{
+	DOS_DENTRY_T *ep = (DOS_DENTRY_T *) p_entry;
+
+	if (type == TYPE_UNUSED)
+		*(ep->name) = 0x0;
+
+	else if (type == TYPE_DELETED)
+		*(ep->name) = 0xE5;
+
+	else if (type == TYPE_EXTEND)
+		ep->attr = ATTR_EXTEND;
+
+	else if (type == TYPE_DIR)
+		ep->attr = ATTR_SUBDIR;
+
+	else if (type == TYPE_FILE)
+		ep->attr = ATTR_ARCHIVE;
+
+	else if (type == TYPE_SYMLINK)
+		ep->attr = ATTR_ARCHIVE | ATTR_SYMLINK;
+} /* end of fat_set_entry_type */
+
+void exfat_set_entry_type(DENTRY_T *p_entry, u32 type)
+{
+	FILE_DENTRY_T *ep = (FILE_DENTRY_T *) p_entry;
+
+	if (type == TYPE_UNUSED) {
+		ep->type = 0x0;
+	} else if (type == TYPE_DELETED) {
+		ep->type &= ~0x80;
+	} else if (type == TYPE_STREAM) {
+		ep->type = 0xC0;
+	} else if (type == TYPE_EXTEND) {
+		ep->type = 0xC1;
+	} else if (type == TYPE_BITMAP) {
+		ep->type = 0x81;
+	} else if (type == TYPE_UPCASE) {
+		ep->type = 0x82;
+	} else if (type == TYPE_VOLUME) {
+		ep->type = 0x83;
+	} else if (type == TYPE_DIR) {
+		ep->type = 0x85;
+		SET16_A(ep->attr, ATTR_SUBDIR);
+	} else if (type == TYPE_FILE) {
+		ep->type = 0x85;
+		SET16_A(ep->attr, ATTR_ARCHIVE);
+	} else if (type == TYPE_SYMLINK) {
+		ep->type = 0x85;
+		SET16_A(ep->attr, ATTR_ARCHIVE | ATTR_SYMLINK);
+	}
+} /* end of exfat_set_entry_type */
+
+u32 fat_get_entry_attr(DENTRY_T *p_entry)
+{
+	DOS_DENTRY_T *ep = (DOS_DENTRY_T *) p_entry;
+	return (u32) ep->attr;
+} /* end of fat_get_entry_attr */
+
+u32 exfat_get_entry_attr(DENTRY_T *p_entry)
+{
+	FILE_DENTRY_T *ep = (FILE_DENTRY_T *) p_entry;
+	return (u32) GET16_A(ep->attr);
+} /* end of exfat_get_entry_attr */
+
+void fat_set_entry_attr(DENTRY_T *p_entry, u32 attr)
+{
+	DOS_DENTRY_T *ep = (DOS_DENTRY_T *) p_entry;
+	ep->attr = (u8) attr;
+} /* end of fat_set_entry_attr */
+
+void exfat_set_entry_attr(DENTRY_T *p_entry, u32 attr)
+{
+	FILE_DENTRY_T *ep = (FILE_DENTRY_T *) p_entry;
+	SET16_A(ep->attr, (u16) attr);
+} /* end of exfat_set_entry_attr */
+
+u8 fat_get_entry_flag(DENTRY_T *p_entry)
+{
+	return 0x01;
+} /* end of fat_get_entry_flag */
+
+u8 exfat_get_entry_flag(DENTRY_T *p_entry)
+{
+	STRM_DENTRY_T *ep = (STRM_DENTRY_T *) p_entry;
+	return ep->flags;
+} /* end of exfat_get_entry_flag */
+
+void fat_set_entry_flag(DENTRY_T *p_entry, u8 flags)
+{
+} /* end of fat_set_entry_flag */
+
+void exfat_set_entry_flag(DENTRY_T *p_entry, u8 flags)
+{
+	STRM_DENTRY_T *ep = (STRM_DENTRY_T *) p_entry;
+	ep->flags = flags;
+} /* end of exfat_set_entry_flag */
+
+u32 fat_get_entry_clu0(DENTRY_T *p_entry)
+{
+	DOS_DENTRY_T *ep = (DOS_DENTRY_T *) p_entry;
+	return ((u32) GET16_A(ep->start_clu_hi) << 16) | GET16_A(ep->start_clu_lo);
+} /* end of fat_get_entry_clu0 */
+
+u32 exfat_get_entry_clu0(DENTRY_T *p_entry)
+{
+	STRM_DENTRY_T *ep = (STRM_DENTRY_T *) p_entry;
+	return GET32_A(ep->start_clu);
+} /* end of exfat_get_entry_clu0 */
+
+void fat_set_entry_clu0(DENTRY_T *p_entry, u32 start_clu)
+{
+	DOS_DENTRY_T *ep = (DOS_DENTRY_T *) p_entry;
+	SET16_A(ep->start_clu_lo, CLUSTER_16(start_clu));
+	SET16_A(ep->start_clu_hi, CLUSTER_16(start_clu >> 16));
+} /* end of fat_set_entry_clu0 */
+
+void exfat_set_entry_clu0(DENTRY_T *p_entry, u32 start_clu)
+{
+	STRM_DENTRY_T *ep = (STRM_DENTRY_T *) p_entry;
+	SET32_A(ep->start_clu, start_clu);
+} /* end of exfat_set_entry_clu0 */
+
+u64 fat_get_entry_size(DENTRY_T *p_entry)
+{
+	DOS_DENTRY_T *ep = (DOS_DENTRY_T *) p_entry;
+	return (u64) GET32_A(ep->size);
+} /* end of fat_get_entry_size */
+
+u64 exfat_get_entry_size(DENTRY_T *p_entry)
+{
+	STRM_DENTRY_T *ep = (STRM_DENTRY_T *) p_entry;
+	return GET64_A(ep->valid_size);
+} /* end of exfat_get_entry_size */
+
+void fat_set_entry_size(DENTRY_T *p_entry, u64 size)
+{
+	DOS_DENTRY_T *ep = (DOS_DENTRY_T *) p_entry;
+	SET32_A(ep->size, (u32) size);
+} /* end of fat_set_entry_size */
+
+void exfat_set_entry_size(DENTRY_T *p_entry, u64 size)
+{
+	STRM_DENTRY_T *ep = (STRM_DENTRY_T *) p_entry;
+	SET64_A(ep->valid_size, size);
+	SET64_A(ep->size, size);
+} /* end of exfat_set_entry_size */
+
+void fat_get_entry_time(DENTRY_T *p_entry, TIMESTAMP_T *tp, u8 mode)
+{
+	u16 t = 0x00, d = 0x21;
+	DOS_DENTRY_T *ep = (DOS_DENTRY_T *) p_entry;
+
+	switch (mode) {
+	case TM_CREATE:
+		t = GET16_A(ep->create_time);
+		d = GET16_A(ep->create_date);
+		break;
+	case TM_MODIFY:
+		t = GET16_A(ep->modify_time);
+		d = GET16_A(ep->modify_date);
+		break;
+	}
+
+	tp->sec  = (t & 0x001F) << 1;
+	tp->min  = (t >> 5) & 0x003F;
+	tp->hour = (t >> 11);
+	tp->day  = (d & 0x001F);
+	tp->mon  = (d >> 5) & 0x000F;
+	tp->year = (d >> 9);
+} /* end of fat_get_entry_time */
+
+void exfat_get_entry_time(DENTRY_T *p_entry, TIMESTAMP_T *tp, u8 mode)
+{
+	u16 t = 0x00, d = 0x21;
+	FILE_DENTRY_T *ep = (FILE_DENTRY_T *) p_entry;
+
+	switch (mode) {
+	case TM_CREATE:
+		t = GET16_A(ep->create_time);
+		d = GET16_A(ep->create_date);
+		break;
+	case TM_MODIFY:
+		t = GET16_A(ep->modify_time);
+		d = GET16_A(ep->modify_date);
+		break;
+	case TM_ACCESS:
+		t = GET16_A(ep->access_time);
+		d = GET16_A(ep->access_date);
+		break;
+	}
+
+	tp->sec  = (t & 0x001F) << 1;
+	tp->min  = (t >> 5) & 0x003F;
+	tp->hour = (t >> 11);
+	tp->day  = (d & 0x001F);
+	tp->mon  = (d >> 5) & 0x000F;
+	tp->year = (d >> 9);
+} /* end of exfat_get_entry_time */
+
+void fat_set_entry_time(DENTRY_T *p_entry, TIMESTAMP_T *tp, u8 mode)
+{
+	u16 t, d;
+	DOS_DENTRY_T *ep = (DOS_DENTRY_T *) p_entry;
+
+	t = (tp->hour << 11) | (tp->min << 5) | (tp->sec >> 1);
+	d = (tp->year <<  9) | (tp->mon << 5) |  tp->day;
+
+	switch (mode) {
+	case TM_CREATE:
+		SET16_A(ep->create_time, t);
+		SET16_A(ep->create_date, d);
+		break;
+	case TM_MODIFY:
+		SET16_A(ep->modify_time, t);
+		SET16_A(ep->modify_date, d);
+		break;
+	}
+} /* end of fat_set_entry_time */
+
+void exfat_set_entry_time(DENTRY_T *p_entry, TIMESTAMP_T *tp, u8 mode)
+{
+	u16 t, d;
+	FILE_DENTRY_T *ep = (FILE_DENTRY_T *) p_entry;
+
+	t = (tp->hour << 11) | (tp->min << 5) | (tp->sec >> 1);
+	d = (tp->year <<  9) | (tp->mon << 5) |  tp->day;
+
+	switch (mode) {
+	case TM_CREATE:
+		SET16_A(ep->create_time, t);
+		SET16_A(ep->create_date, d);
+		break;
+	case TM_MODIFY:
+		SET16_A(ep->modify_time, t);
+		SET16_A(ep->modify_date, d);
+		break;
+	case TM_ACCESS:
+		SET16_A(ep->access_time, t);
+		SET16_A(ep->access_date, d);
+		break;
+	}
+} /* end of exfat_set_entry_time */
+
+s32 fat_init_dir_entry(struct super_block *sb, CHAIN_T *p_dir, s32 entry, u32 type,
+						 u32 start_clu, u64 size)
+{
+	sector_t sector;
+	DOS_DENTRY_T *dos_ep;
+
+	dos_ep = (DOS_DENTRY_T *) get_entry_in_dir(sb, p_dir, entry, &sector);
+	if (!dos_ep)
+		return FFS_MEDIAERR;
+
+	init_dos_entry(dos_ep, type, start_clu);
+	buf_modify(sb, sector);
+
+	return FFS_SUCCESS;
+} /* end of fat_init_dir_entry */
+
+s32 exfat_init_dir_entry(struct super_block *sb, CHAIN_T *p_dir, s32 entry, u32 type,
+						   u32 start_clu, u64 size)
+{
+	sector_t sector;
+	u8 flags;
+	FILE_DENTRY_T *file_ep;
+	STRM_DENTRY_T *strm_ep;
+
+	flags = (type == TYPE_FILE) ? 0x01 : 0x03;
+
+	/* we cannot use get_entry_set_in_dir here because file ep is not initialized yet */
+	file_ep = (FILE_DENTRY_T *) get_entry_in_dir(sb, p_dir, entry, &sector);
+	if (!file_ep)
+		return FFS_MEDIAERR;
+
+	strm_ep = (STRM_DENTRY_T *) get_entry_in_dir(sb, p_dir, entry+1, &sector);
+	if (!strm_ep)
+		return FFS_MEDIAERR;
+
+	init_file_entry(file_ep, type);
+	buf_modify(sb, sector);
+
+	init_strm_entry(strm_ep, flags, start_clu, size);
+	buf_modify(sb, sector);
+
+	return FFS_SUCCESS;
+} /* end of exfat_init_dir_entry */
+
+s32 fat_init_ext_entry(struct super_block *sb, CHAIN_T *p_dir, s32 entry, s32 num_entries,
+						 UNI_NAME_T *p_uniname, DOS_NAME_T *p_dosname)
+{
+	int i;
+	sector_t sector;
+	u8 chksum;
+	u16 *uniname = p_uniname->name;
+	DOS_DENTRY_T *dos_ep;
+	EXT_DENTRY_T *ext_ep;
+
+	dos_ep = (DOS_DENTRY_T *) get_entry_in_dir(sb, p_dir, entry, &sector);
+	if (!dos_ep)
+		return FFS_MEDIAERR;
+
+	dos_ep->lcase = p_dosname->name_case;
+	memcpy(dos_ep->name, p_dosname->name, DOS_NAME_LENGTH);
+	buf_modify(sb, sector);
+
+	if ((--num_entries) > 0) {
+		chksum = calc_checksum_1byte((void *) dos_ep->name, DOS_NAME_LENGTH, 0);
+
+		for (i = 1; i < num_entries; i++) {
+			ext_ep = (EXT_DENTRY_T *) get_entry_in_dir(sb, p_dir, entry-i, &sector);
+			if (!ext_ep)
+				return FFS_MEDIAERR;
+
+			init_ext_entry(ext_ep, i, chksum, uniname);
+			buf_modify(sb, sector);
+			uniname += 13;
+		}
+
+		ext_ep = (EXT_DENTRY_T *) get_entry_in_dir(sb, p_dir, entry-i, &sector);
+		if (!ext_ep)
+			return FFS_MEDIAERR;
+
+		init_ext_entry(ext_ep, i+0x40, chksum, uniname);
+		buf_modify(sb, sector);
+	}
+
+	return FFS_SUCCESS;
+} /* end of fat_init_ext_entry */
+
+s32 exfat_init_ext_entry(struct super_block *sb, CHAIN_T *p_dir, s32 entry, s32 num_entries,
+						   UNI_NAME_T *p_uniname, DOS_NAME_T *p_dosname)
+{
+	int i;
+	sector_t sector;
+	u16 *uniname = p_uniname->name;
+	FILE_DENTRY_T *file_ep;
+	STRM_DENTRY_T *strm_ep;
+	NAME_DENTRY_T *name_ep;
+
+	file_ep = (FILE_DENTRY_T *) get_entry_in_dir(sb, p_dir, entry, &sector);
+	if (!file_ep)
+		return FFS_MEDIAERR;
+
+	file_ep->num_ext = (u8)(num_entries - 1);
+	buf_modify(sb, sector);
+
+	strm_ep = (STRM_DENTRY_T *) get_entry_in_dir(sb, p_dir, entry+1, &sector);
+	if (!strm_ep)
+		return FFS_MEDIAERR;
+
+	strm_ep->name_len = p_uniname->name_len;
+	SET16_A(strm_ep->name_hash, p_uniname->name_hash);
+	buf_modify(sb, sector);
+
+	for (i = 2; i < num_entries; i++) {
+		name_ep = (NAME_DENTRY_T *) get_entry_in_dir(sb, p_dir, entry+i, &sector);
+		if (!name_ep)
+			return FFS_MEDIAERR;
+
+		init_name_entry(name_ep, uniname);
+		buf_modify(sb, sector);
+		uniname += 15;
+	}
+
+	update_dir_checksum(sb, p_dir, entry);
+
+	return FFS_SUCCESS;
+} /* end of exfat_init_ext_entry */
+
+void init_dos_entry(DOS_DENTRY_T *ep, u32 type, u32 start_clu)
+{
+	TIMESTAMP_T tm, *tp;
+
+	fat_set_entry_type((DENTRY_T *) ep, type);
+	SET16_A(ep->start_clu_lo, CLUSTER_16(start_clu));
+	SET16_A(ep->start_clu_hi, CLUSTER_16(start_clu >> 16));
+	SET32_A(ep->size, 0);
+
+	tp = tm_current(&tm);
+	fat_set_entry_time((DENTRY_T *) ep, tp, TM_CREATE);
+	fat_set_entry_time((DENTRY_T *) ep, tp, TM_MODIFY);
+	SET16_A(ep->access_date, 0);
+	ep->create_time_ms = 0;
+} /* end of init_dos_entry */
+
+void init_ext_entry(EXT_DENTRY_T *ep, s32 order, u8 chksum, u16 *uniname)
+{
+	int i;
+	u8 end = FALSE;
+
+	fat_set_entry_type((DENTRY_T *) ep, TYPE_EXTEND);
+	ep->order = (u8) order;
+	ep->sysid = 0;
+	ep->checksum = chksum;
+	SET16_A(ep->start_clu, 0);
+
+	for (i = 0; i < 10; i += 2) {
+		if (!end) {
+			SET16(ep->unicode_0_4+i, *uniname);
+			if (*uniname == 0x0)
+				end = TRUE;
+			else
+				uniname++;
+		} else {
+			SET16(ep->unicode_0_4+i, 0xFFFF);
+		}
+	}
+
+	for (i = 0; i < 12; i += 2) {
+		if (!end) {
+			SET16_A(ep->unicode_5_10+i, *uniname);
+			if (*uniname == 0x0)
+				end = TRUE;
+			else
+				uniname++;
+		} else {
+			SET16_A(ep->unicode_5_10+i, 0xFFFF);
+		}
+	}
+
+	for (i = 0; i < 4; i += 2) {
+		if (!end) {
+			SET16_A(ep->unicode_11_12+i, *uniname);
+			if (*uniname == 0x0)
+				end = TRUE;
+			else
+				uniname++;
+		} else {
+			SET16_A(ep->unicode_11_12+i, 0xFFFF);
+		}
+	}
+} /* end of init_ext_entry */
+
+void init_file_entry(FILE_DENTRY_T *ep, u32 type)
+{
+	TIMESTAMP_T tm, *tp;
+
+	exfat_set_entry_type((DENTRY_T *) ep, type);
+
+	tp = tm_current(&tm);
+	exfat_set_entry_time((DENTRY_T *) ep, tp, TM_CREATE);
+	exfat_set_entry_time((DENTRY_T *) ep, tp, TM_MODIFY);
+	exfat_set_entry_time((DENTRY_T *) ep, tp, TM_ACCESS);
+	ep->create_time_ms = 0;
+	ep->modify_time_ms = 0;
+	ep->access_time_ms = 0;
+} /* end of init_file_entry */
+
+void init_strm_entry(STRM_DENTRY_T *ep, u8 flags, u32 start_clu, u64 size)
+{
+	exfat_set_entry_type((DENTRY_T *) ep, TYPE_STREAM);
+	ep->flags = flags;
+	SET32_A(ep->start_clu, start_clu);
+	SET64_A(ep->valid_size, size);
+	SET64_A(ep->size, size);
+} /* end of init_strm_entry */
+
+void init_name_entry(NAME_DENTRY_T *ep, u16 *uniname)
+{
+	int i;
+
+	exfat_set_entry_type((DENTRY_T *) ep, TYPE_EXTEND);
+	ep->flags = 0x0;
+
+	for (i = 0; i < 30; i++, i++) {
+		SET16_A(ep->unicode_0_14+i, *uniname);
+		if (*uniname == 0x0)
+			break;
+		uniname++;
+	}
+} /* end of init_name_entry */
+
+void fat_delete_dir_entry(struct super_block *sb, CHAIN_T *p_dir, s32 entry, s32 order, s32 num_entries)
+{
+	int i;
+	sector_t sector;
+	DENTRY_T *ep;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	for (i = num_entries-1; i >= order; i--) {
+		ep = get_entry_in_dir(sb, p_dir, entry-i, &sector);
+		if (!ep)
+			return;
+
+		p_fs->fs_func->set_entry_type(ep, TYPE_DELETED);
+		buf_modify(sb, sector);
+	}
+} /* end of fat_delete_dir_entry */
+
+void exfat_delete_dir_entry(struct super_block *sb, CHAIN_T *p_dir, s32 entry, s32 order, s32 num_entries)
+{
+	int i;
+	sector_t sector;
+	DENTRY_T *ep;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	for (i = order; i < num_entries; i++) {
+		ep = get_entry_in_dir(sb, p_dir, entry+i, &sector);
+		if (!ep)
+			return;
+
+		p_fs->fs_func->set_entry_type(ep, TYPE_DELETED);
+		buf_modify(sb, sector);
+	}
+} /* end of exfat_delete_dir_entry */
+
+void update_dir_checksum(struct super_block *sb, CHAIN_T *p_dir, s32 entry)
+{
+	int i, num_entries;
+	sector_t sector;
+	u16 chksum;
+	FILE_DENTRY_T *file_ep;
+	DENTRY_T *ep;
+
+	file_ep = (FILE_DENTRY_T *) get_entry_in_dir(sb, p_dir, entry, &sector);
+	if (!file_ep)
+		return;
+
+	buf_lock(sb, sector);
+
+	num_entries = (s32) file_ep->num_ext + 1;
+	chksum = calc_checksum_2byte((void *) file_ep, DENTRY_SIZE, 0, CS_DIR_ENTRY);
+
+	for (i = 1; i < num_entries; i++) {
+		ep = get_entry_in_dir(sb, p_dir, entry+i, NULL);
+		if (!ep) {
+			buf_unlock(sb, sector);
+			return;
+		}
+
+		chksum = calc_checksum_2byte((void *) ep, DENTRY_SIZE, chksum, CS_DEFAULT);
+	}
+
+	SET16_A(file_ep->checksum, chksum);
+	buf_modify(sb, sector);
+	buf_unlock(sb, sector);
+} /* end of update_dir_checksum */
+
+void update_dir_checksum_with_entry_set(struct super_block *sb, ENTRY_SET_CACHE_T *es)
+{
+	DENTRY_T *ep;
+	u16 chksum = 0;
+	s32 chksum_type = CS_DIR_ENTRY, i;
+
+	ep = (DENTRY_T *)&(es->__buf);
+	for (i = 0; i < es->num_entries; i++) {
+		DPRINTK("update_dir_checksum_with_entry_set ep %p\n", ep);
+		chksum = calc_checksum_2byte((void *) ep, DENTRY_SIZE, chksum, chksum_type);
+		ep++;
+		chksum_type = CS_DEFAULT;
+	}
+
+	ep = (DENTRY_T *)&(es->__buf);
+	SET16_A(((FILE_DENTRY_T *)ep)->checksum, chksum);
+	write_whole_entry_set(sb, es);
+}
+
+static s32 _walk_fat_chain(struct super_block *sb, CHAIN_T *p_dir, s32 byte_offset, u32 *clu)
+{
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	s32 clu_offset;
+	u32 cur_clu;
+
+	clu_offset = byte_offset >> p_fs->cluster_size_bits;
+	cur_clu = p_dir->dir;
+
+	if (p_dir->flags == 0x03) {
+		cur_clu += clu_offset;
+	} else {
+		while (clu_offset > 0) {
+			if (FAT_read(sb, cur_clu, &cur_clu) == -1)
+				return FFS_MEDIAERR;
+			clu_offset--;
+		}
+	}
+
+	if (clu)
+		*clu = cur_clu;
+	return FFS_SUCCESS;
+}
+s32 find_location(struct super_block *sb, CHAIN_T *p_dir, s32 entry, sector_t *sector, s32 *offset)
+{
+	s32 off, ret;
+	u32 clu = 0;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+
+	off = entry << DENTRY_SIZE_BITS;
+
+	if (p_dir->dir == CLUSTER_32(0)) { /* FAT16 root_dir */
+		*offset = off & p_bd->sector_size_mask;
+		*sector = off >> p_bd->sector_size_bits;
+		*sector += p_fs->root_start_sector;
+	} else {
+		ret = _walk_fat_chain(sb, p_dir, off, &clu);
+		if (ret != FFS_SUCCESS)
+			return ret;
+
+		off &= p_fs->cluster_size - 1;	/* byte offset in cluster */
+
+		*offset = off & p_bd->sector_size_mask;	/* byte offset in sector    */
+		*sector = off >> p_bd->sector_size_bits;	/* sector offset in cluster */
+		*sector += START_SECTOR(clu);
+	}
+	return FFS_SUCCESS;
+} /* end of find_location */
+
+DENTRY_T *get_entry_with_sector(struct super_block *sb, sector_t sector, s32 offset)
+{
+	u8 *buf;
+
+	buf = buf_getblk(sb, sector);
+
+	if (buf == NULL)
+		return NULL;
+
+	return (DENTRY_T *)(buf + offset);
+} /* end of get_entry_with_sector */
+
+DENTRY_T *get_entry_in_dir(struct super_block *sb, CHAIN_T *p_dir, s32 entry, sector_t *sector)
+{
+	s32 off;
+	sector_t sec;
+	u8 *buf;
+
+	if (find_location(sb, p_dir, entry, &sec, &off) != FFS_SUCCESS)
+		return NULL;
+
+	buf = buf_getblk(sb, sec);
+
+	if (buf == NULL)
+		return NULL;
+
+	if (sector != NULL)
+		*sector = sec;
+	return (DENTRY_T *)(buf + off);
+} /* end of get_entry_in_dir */
+
+
+/* returns a set of dentries for a file or dir.
+ * Note that this is a copy (dump) of dentries so that user should call write_entry_set()
+ * to apply changes made in this entry set to the real device.
+ * in:
+ *   sb+p_dir+entry: indicates a file/dir
+ *   type:  specifies how many dentries should be included.
+ * out:
+ *   file_ep: will point the first dentry(= file dentry) on success
+ * return:
+ *   pointer of entry set on success,
+ *   NULL on failure.
+ */
+
+#define ES_MODE_STARTED				0
+#define ES_MODE_GET_FILE_ENTRY			1
+#define ES_MODE_GET_STRM_ENTRY			2
+#define ES_MODE_GET_NAME_ENTRY			3
+#define ES_MODE_GET_CRITICAL_SEC_ENTRY		4
+ENTRY_SET_CACHE_T *get_entry_set_in_dir(struct super_block *sb, CHAIN_T *p_dir, s32 entry, u32 type, DENTRY_T **file_ep)
+{
+	s32 off, ret, byte_offset;
+	u32 clu = 0;
+	sector_t sec;
+	u32 entry_type;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+	ENTRY_SET_CACHE_T *es = NULL;
+	DENTRY_T *ep, *pos;
+	u8 *buf;
+	u8 num_entries;
+	s32 mode = ES_MODE_STARTED;
+
+	DPRINTK("get_entry_set_in_dir entered\n");
+	DPRINTK("p_dir dir %u flags %x size %d\n", p_dir->dir, p_dir->flags, p_dir->size);
+
+	byte_offset = entry << DENTRY_SIZE_BITS;
+	ret = _walk_fat_chain(sb, p_dir, byte_offset, &clu);
+	if (ret != FFS_SUCCESS)
+		return NULL;
+
+
+	byte_offset &= p_fs->cluster_size - 1;	/* byte offset in cluster */
+
+	off = byte_offset & p_bd->sector_size_mask;	/* byte offset in sector    */
+	sec = byte_offset >> p_bd->sector_size_bits;	/* sector offset in cluster */
+	sec += START_SECTOR(clu);
+
+	buf = buf_getblk(sb, sec);
+	if (buf == NULL)
+		goto err_out;
+
+
+	ep = (DENTRY_T *)(buf + off);
+	entry_type = p_fs->fs_func->get_entry_type(ep);
+
+	if ((entry_type != TYPE_FILE)
+		&& (entry_type != TYPE_DIR))
+		goto err_out;
+
+	if (type == ES_ALL_ENTRIES)
+		num_entries = ((FILE_DENTRY_T *)ep)->num_ext+1;
+	else
+		num_entries = type;
+
+	DPRINTK("trying to kmalloc %zx bytes for %d entries\n", offsetof(ENTRY_SET_CACHE_T, __buf) + (num_entries)  * sizeof(DENTRY_T), num_entries);
+	es = kmalloc(offsetof(ENTRY_SET_CACHE_T, __buf) + (num_entries)  * sizeof(DENTRY_T), GFP_KERNEL);
+	if (es == NULL)
+		goto err_out;
+
+	es->num_entries = num_entries;
+	es->sector = sec;
+	es->offset = off;
+	es->alloc_flag = p_dir->flags;
+
+	pos = (DENTRY_T *) &(es->__buf);
+
+	while(num_entries) {
+		/* instead of copying whole sector, we will check every entry.
+		 * this will provide minimum stablity and consistancy.
+		 */
+
+		entry_type = p_fs->fs_func->get_entry_type(ep);
+
+		if ((entry_type == TYPE_UNUSED) || (entry_type == TYPE_DELETED))
+			goto err_out;
+
+		switch (mode) {
+		case ES_MODE_STARTED:
+			if  ((entry_type == TYPE_FILE) || (entry_type == TYPE_DIR))
+				mode = ES_MODE_GET_FILE_ENTRY;
+			else
+				goto err_out;
+			break;
+		case ES_MODE_GET_FILE_ENTRY:
+			if (entry_type == TYPE_STREAM)
+				mode = ES_MODE_GET_STRM_ENTRY;
+			else
+				goto err_out;
+			break;
+		case ES_MODE_GET_STRM_ENTRY:
+			if (entry_type == TYPE_EXTEND)
+				mode = ES_MODE_GET_NAME_ENTRY;
+			else
+				goto err_out;
+			break;
+		case ES_MODE_GET_NAME_ENTRY:
+			if (entry_type == TYPE_EXTEND)
+				break;
+			else if (entry_type == TYPE_STREAM)
+				goto err_out;
+			else if (entry_type & TYPE_CRITICAL_SEC)
+				mode = ES_MODE_GET_CRITICAL_SEC_ENTRY;
+			else
+				goto err_out;
+			break;
+		case ES_MODE_GET_CRITICAL_SEC_ENTRY:
+			if ((entry_type == TYPE_EXTEND) || (entry_type == TYPE_STREAM))
+				goto err_out;
+			else if ((entry_type & TYPE_CRITICAL_SEC) != TYPE_CRITICAL_SEC)
+				goto err_out;
+			break;
+		}
+
+		memcpy(pos, ep, sizeof(DENTRY_T));
+
+		if (--num_entries == 0)
+			break;
+
+		if (((off + DENTRY_SIZE) & p_bd->sector_size_mask) < (off &  p_bd->sector_size_mask)) {
+			/* get the next sector */
+			if (IS_LAST_SECTOR_IN_CLUSTER(sec)) {
+				if (es->alloc_flag == 0x03) {
+					clu++;
+				} else {
+					if (FAT_read(sb, clu, &clu) == -1)
+						goto err_out;
+				}
+				sec = START_SECTOR(clu);
+			} else {
+				sec++;
+			}
+			buf = buf_getblk(sb, sec);
+			if (buf == NULL)
+				goto err_out;
+			off = 0;
+			ep = (DENTRY_T *)(buf);
+		} else {
+			ep++;
+			off += DENTRY_SIZE;
+		}
+		pos++;
+	}
+
+	if (file_ep)
+		*file_ep = (DENTRY_T *)&(es->__buf);
+
+	DPRINTK("es sec %llu offset %d flags %d, num_entries %u buf ptr %p\n",
+		   (unsigned long long)es->sector, es->offset, es->alloc_flag,
+		   es->num_entries, &(es->__buf));
+	DPRINTK("get_entry_set_in_dir exited %p\n", es);
+	return es;
+err_out:
+	DPRINTK("get_entry_set_in_dir exited NULL (es %p)\n", es);
+	if (es)
+		kfree(es);
+	return NULL;
+}
+
+void release_entry_set(ENTRY_SET_CACHE_T *es)
+{
+	DPRINTK("release_entry_set %p\n", es);
+	if (es)
+		kfree(es);
+}
+
+
+static s32 __write_partial_entries_in_entry_set(struct super_block *sb, ENTRY_SET_CACHE_T *es, sector_t sec, s32 off, u32 count)
+{
+	s32 num_entries, buf_off = (off - es->offset);
+	u32 remaining_byte_in_sector, copy_entries;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+	u32 clu;
+	u8 *buf, *esbuf = (u8 *)&(es->__buf);
+
+	DPRINTK("__write_partial_entries_in_entry_set entered\n");
+	DPRINTK("es %p sec %llu off %d count %d\n", es, (unsigned long long)sec, off, count);
+	num_entries = count;
+
+	while (num_entries) {
+		/* white per sector base */
+		remaining_byte_in_sector = (1 << p_bd->sector_size_bits) - off;
+		copy_entries = MIN(remaining_byte_in_sector >> DENTRY_SIZE_BITS , num_entries);
+		buf = buf_getblk(sb, sec);
+		if (buf == NULL)
+			goto err_out;
+		DPRINTK("es->buf %p buf_off %u\n", esbuf, buf_off);
+		DPRINTK("copying %d entries from %p to sector %llu\n", copy_entries, (esbuf + buf_off), (unsigned long long)sec);
+		memcpy(buf + off, esbuf + buf_off, copy_entries << DENTRY_SIZE_BITS);
+		buf_modify(sb, sec);
+		num_entries -= copy_entries;
+
+		if (num_entries) {
+			/* get next sector */
+			if (IS_LAST_SECTOR_IN_CLUSTER(sec)) {
+				clu = GET_CLUSTER_FROM_SECTOR(sec);
+				if (es->alloc_flag == 0x03) {
+					clu++;
+				} else {
+					if (FAT_read(sb, clu, &clu) == -1)
+						goto err_out;
+				}
+				sec = START_SECTOR(clu);
+			} else {
+				sec++;
+			}
+			off = 0;
+			buf_off += copy_entries << DENTRY_SIZE_BITS;
+		}
+	}
+
+	DPRINTK("__write_partial_entries_in_entry_set exited successfully\n");
+	return FFS_SUCCESS;
+err_out:
+	DPRINTK("__write_partial_entries_in_entry_set failed\n");
+	return FFS_ERROR;
+}
+
+/* write back all entries in entry set */
+s32 write_whole_entry_set(struct super_block *sb, ENTRY_SET_CACHE_T *es)
+{
+	return __write_partial_entries_in_entry_set(sb, es, es->sector, es->offset, es->num_entries);
+}
+
+/* write back some entries in entry set */
+s32 write_partial_entries_in_entry_set (struct super_block *sb, ENTRY_SET_CACHE_T *es, DENTRY_T *ep, u32 count)
+{
+	s32 ret, byte_offset, off;
+	u32 clu=0;
+	sector_t sec;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+	CHAIN_T dir;
+
+	/* vaidity check */
+	if (ep + count  > ((DENTRY_T *)&(es->__buf)) + es->num_entries)
+		return FFS_ERROR;
+
+	dir.dir = GET_CLUSTER_FROM_SECTOR(es->sector);
+	dir.flags = es->alloc_flag;
+	dir.size = 0xffffffff;		/* XXX */
+
+	byte_offset = (es->sector - START_SECTOR(dir.dir)) << p_bd->sector_size_bits;
+	byte_offset += ((void **)ep - &(es->__buf)) + es->offset;
+
+	ret =_walk_fat_chain(sb, &dir, byte_offset, &clu);
+	if (ret != FFS_SUCCESS)
+		return ret;
+	byte_offset &= p_fs->cluster_size - 1;	/* byte offset in cluster */
+	off = byte_offset & p_bd->sector_size_mask;	/* byte offset in sector    */
+	sec = byte_offset >> p_bd->sector_size_bits;	/* sector offset in cluster */
+	sec += START_SECTOR(clu);
+	return __write_partial_entries_in_entry_set(sb, es, sec, off, count);
+}
+
+/* search EMPTY CONTINUOUS "num_entries" entries */
+s32 search_deleted_or_unused_entry(struct super_block *sb, CHAIN_T *p_dir, s32 num_entries)
+{
+	int i, dentry, num_empty = 0;
+	s32 dentries_per_clu;
+	u32 type;
+	CHAIN_T clu;
+	DENTRY_T *ep;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	if (p_dir->dir == CLUSTER_32(0)) /* FAT16 root_dir */
+		dentries_per_clu = p_fs->dentries_in_root;
+	else
+		dentries_per_clu = p_fs->dentries_per_clu;
+
+	if (p_fs->hint_uentry.dir == p_dir->dir) {
+		if (p_fs->hint_uentry.entry == -1)
+			return -1;
+
+		clu.dir = p_fs->hint_uentry.clu.dir;
+		clu.size = p_fs->hint_uentry.clu.size;
+		clu.flags = p_fs->hint_uentry.clu.flags;
+
+		dentry = p_fs->hint_uentry.entry;
+	} else {
+		p_fs->hint_uentry.entry = -1;
+
+		clu.dir = p_dir->dir;
+		clu.size = p_dir->size;
+		clu.flags = p_dir->flags;
+
+		dentry = 0;
+	}
+
+	while (clu.dir != CLUSTER_32(~0)) {
+		if (p_fs->dev_ejected)
+			break;
+
+		if (p_dir->dir == CLUSTER_32(0)) /* FAT16 root_dir */
+			i = dentry % dentries_per_clu;
+		else
+			i = dentry & (dentries_per_clu-1);
+
+		for (; i < dentries_per_clu; i++, dentry++) {
+			ep = get_entry_in_dir(sb, &clu, i, NULL);
+			if (!ep)
+				return -1;
+
+			type = p_fs->fs_func->get_entry_type(ep);
+
+			if (type == TYPE_UNUSED) {
+				num_empty++;
+				if (p_fs->hint_uentry.entry == -1) {
+					p_fs->hint_uentry.dir = p_dir->dir;
+					p_fs->hint_uentry.entry = dentry;
+
+					p_fs->hint_uentry.clu.dir = clu.dir;
+					p_fs->hint_uentry.clu.size = clu.size;
+					p_fs->hint_uentry.clu.flags = clu.flags;
+				}
+			} else if (type == TYPE_DELETED) {
+				num_empty++;
+			} else {
+				num_empty = 0;
+			}
+
+			if (num_empty >= num_entries) {
+				p_fs->hint_uentry.dir = CLUSTER_32(~0);
+				p_fs->hint_uentry.entry = -1;
+
+				if (p_fs->vol_type == EXFAT)
+					return dentry - (num_entries-1);
+				else
+					return dentry;
+			}
+		}
+
+		if (p_dir->dir == CLUSTER_32(0))
+			break; /* FAT16 root_dir */
+
+		if (clu.flags == 0x03) {
+			if ((--clu.size) > 0)
+				clu.dir++;
+			else
+				clu.dir = CLUSTER_32(~0);
+		} else {
+			if (FAT_read(sb, clu.dir, &(clu.dir)) != 0)
+				return -1;
+		}
+	}
+
+	return -1;
+} /* end of search_deleted_or_unused_entry */
+
+s32 find_empty_entry(struct inode *inode, CHAIN_T *p_dir, s32 num_entries)
+{
+	s32 ret, dentry;
+	u32 last_clu;
+	sector_t sector;
+	u64 size = 0;
+	CHAIN_T clu;
+	DENTRY_T *ep = NULL;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	FILE_ID_T *fid = &(EXFAT_I(inode)->fid);
+
+	if (p_dir->dir == CLUSTER_32(0)) /* FAT16 root_dir */
+		return search_deleted_or_unused_entry(sb, p_dir, num_entries);
+
+	while ((dentry = search_deleted_or_unused_entry(sb, p_dir, num_entries)) < 0) {
+		if (p_fs->dev_ejected)
+			break;
+
+		if (p_fs->vol_type == EXFAT) {
+			if (p_dir->dir != p_fs->root_dir)
+				size = i_size_read(inode);
+		}
+
+		last_clu = find_last_cluster(sb, p_dir);
+		clu.dir = last_clu + 1;
+		clu.size = 0;
+		clu.flags = p_dir->flags;
+
+		/* (1) allocate a cluster */
+		ret = p_fs->fs_func->alloc_cluster(sb, 1, &clu);
+		if (ret < 1)
+			return -1;
+
+		if (clear_cluster(sb, clu.dir) != FFS_SUCCESS)
+			return -1;
+
+		/* (2) append to the FAT chain */
+		if (clu.flags != p_dir->flags) {
+			exfat_chain_cont_cluster(sb, p_dir->dir, p_dir->size);
+			p_dir->flags = 0x01;
+			p_fs->hint_uentry.clu.flags = 0x01;
+		}
+		if (clu.flags == 0x01)
+			if (FAT_write(sb, last_clu, clu.dir) < 0)
+				return -1;
+
+		if (p_fs->hint_uentry.entry == -1) {
+			p_fs->hint_uentry.dir = p_dir->dir;
+			p_fs->hint_uentry.entry = p_dir->size << (p_fs->cluster_size_bits - DENTRY_SIZE_BITS);
+
+			p_fs->hint_uentry.clu.dir = clu.dir;
+			p_fs->hint_uentry.clu.size = 0;
+			p_fs->hint_uentry.clu.flags = clu.flags;
+		}
+		p_fs->hint_uentry.clu.size++;
+		p_dir->size++;
+
+		/* (3) update the directory entry */
+		if (p_fs->vol_type == EXFAT) {
+			if (p_dir->dir != p_fs->root_dir) {
+				size += p_fs->cluster_size;
+
+				ep = get_entry_in_dir(sb, &(fid->dir), fid->entry+1, &sector);
+				if (!ep)
+					return -1;
+				p_fs->fs_func->set_entry_size(ep, size);
+				p_fs->fs_func->set_entry_flag(ep, p_dir->flags);
+				buf_modify(sb, sector);
+
+				update_dir_checksum(sb, &(fid->dir), fid->entry);
+			}
+		}
+
+		i_size_write(inode, i_size_read(inode)+p_fs->cluster_size);
+		EXFAT_I(inode)->mmu_private += p_fs->cluster_size;
+		EXFAT_I(inode)->fid.size += p_fs->cluster_size;
+		EXFAT_I(inode)->fid.flags = p_dir->flags;
+		inode->i_blocks += 1 << (p_fs->cluster_size_bits - 9);
+	}
+
+	return dentry;
+} /* end of find_empty_entry */
+
+/* return values of fat_find_dir_entry()
+   >= 0 : return dir entiry position with the name in dir
+   -1 : (root dir, ".") it is the root dir itself
+   -2 : entry with the name does not exist */
+s32 fat_find_dir_entry(struct super_block *sb, CHAIN_T *p_dir, UNI_NAME_T *p_uniname, s32 num_entries, DOS_NAME_T *p_dosname, u32 type)
+{
+	int i, dentry = 0, lossy = FALSE, len;
+	s32 order = 0, is_feasible_entry = TRUE, has_ext_entry = FALSE;
+	s32 dentries_per_clu;
+	u32 entry_type;
+	u16 entry_uniname[14], *uniname = NULL, unichar;
+	CHAIN_T clu;
+	DENTRY_T *ep;
+	DOS_DENTRY_T *dos_ep;
+	EXT_DENTRY_T *ext_ep;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	if (p_dir->dir == p_fs->root_dir) {
+		if ((!nls_uniname_cmp(sb, p_uniname->name, (u16 *) UNI_CUR_DIR_NAME)) ||
+			(!nls_uniname_cmp(sb, p_uniname->name, (u16 *) UNI_PAR_DIR_NAME)))
+			return -1; // special case, root directory itself
+	}
+
+	if (p_dir->dir == CLUSTER_32(0)) /* FAT16 root_dir */
+		dentries_per_clu = p_fs->dentries_in_root;
+	else
+		dentries_per_clu = p_fs->dentries_per_clu;
+
+	clu.dir = p_dir->dir;
+	clu.flags = p_dir->flags;
+
+	while (clu.dir != CLUSTER_32(~0)) {
+		if (p_fs->dev_ejected)
+			break;
+
+		for (i = 0; i < dentries_per_clu; i++, dentry++) {
+			ep = get_entry_in_dir(sb, &clu, i, NULL);
+			if (!ep)
+				return -2;
+
+			entry_type = p_fs->fs_func->get_entry_type(ep);
+
+			if ((entry_type == TYPE_FILE) || (entry_type == TYPE_DIR)) {
+				if ((type == TYPE_ALL) || (type == entry_type)) {
+					if (is_feasible_entry && has_ext_entry)
+						return dentry;
+
+					dos_ep = (DOS_DENTRY_T *) ep;
+					if ((!lossy) && (!nls_dosname_cmp(sb, p_dosname->name, dos_ep->name)))
+						return dentry;
+				}
+				is_feasible_entry = TRUE;
+				has_ext_entry = FALSE;
+			} else if (entry_type == TYPE_EXTEND) {
+				if (is_feasible_entry) {
+					ext_ep = (EXT_DENTRY_T *) ep;
+					if (ext_ep->order > 0x40) {
+						order = (s32)(ext_ep->order - 0x40);
+						uniname = p_uniname->name + 13 * (order-1);
+					} else {
+						order = (s32) ext_ep->order;
+						uniname -= 13;
+					}
+
+					len = extract_uni_name_from_ext_entry(ext_ep, entry_uniname, order);
+
+					unichar = *(uniname+len);
+					*(uniname+len) = 0x0;
+
+					if (nls_uniname_cmp(sb, uniname, entry_uniname))
+						is_feasible_entry = FALSE;
+
+					*(uniname+len) = unichar;
+				}
+				has_ext_entry = TRUE;
+			} else if (entry_type == TYPE_UNUSED) {
+				return -2;
+			} else {
+				is_feasible_entry = TRUE;
+				has_ext_entry = FALSE;
+			}
+		}
+
+		if (p_dir->dir == CLUSTER_32(0))
+			break; /* FAT16 root_dir */
+
+		if (FAT_read(sb, clu.dir, &(clu.dir)) != 0)
+			return -2;
+	}
+
+	return -2;
+} /* end of fat_find_dir_entry */
+
+/* return values of exfat_find_dir_entry()
+   >= 0 : return dir entiry position with the name in dir
+   -1 : (root dir, ".") it is the root dir itself
+   -2 : entry with the name does not exist */
+s32 exfat_find_dir_entry(struct super_block *sb, CHAIN_T *p_dir, UNI_NAME_T *p_uniname, s32 num_entries, DOS_NAME_T *p_dosname, u32 type)
+{
+	int i = 0, dentry = 0, num_ext_entries = 0, len, step;
+	s32 order = 0, is_feasible_entry = FALSE;
+	s32 dentries_per_clu, num_empty = 0;
+	u32 entry_type;
+	u16 entry_uniname[16], *uniname = NULL, unichar;
+	CHAIN_T clu;
+	DENTRY_T *ep;
+	FILE_DENTRY_T *file_ep;
+	STRM_DENTRY_T *strm_ep;
+	NAME_DENTRY_T *name_ep;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	if (p_dir->dir == p_fs->root_dir) {
+		if ((!nls_uniname_cmp(sb, p_uniname->name, (u16 *) UNI_CUR_DIR_NAME)) ||
+			(!nls_uniname_cmp(sb, p_uniname->name, (u16 *) UNI_PAR_DIR_NAME)))
+			return -1; // special case, root directory itself
+	}
+
+	if (p_dir->dir == CLUSTER_32(0)) /* FAT16 root_dir */
+		dentries_per_clu = p_fs->dentries_in_root;
+	else
+		dentries_per_clu = p_fs->dentries_per_clu;
+
+	clu.dir = p_dir->dir;
+	clu.size = p_dir->size;
+	clu.flags = p_dir->flags;
+
+	p_fs->hint_uentry.dir = p_dir->dir;
+	p_fs->hint_uentry.entry = -1;
+
+	while (clu.dir != CLUSTER_32(~0)) {
+		if (p_fs->dev_ejected)
+			break;
+
+		while (i < dentries_per_clu) {
+			ep = get_entry_in_dir(sb, &clu, i, NULL);
+			if (!ep)
+				return -2;
+
+			entry_type = p_fs->fs_func->get_entry_type(ep);
+			step = 1;
+
+			if ((entry_type == TYPE_UNUSED) || (entry_type == TYPE_DELETED)) {
+				is_feasible_entry = FALSE;
+
+				if (p_fs->hint_uentry.entry == -1) {
+					num_empty++;
+
+					if (num_empty == 1) {
+						p_fs->hint_uentry.clu.dir = clu.dir;
+						p_fs->hint_uentry.clu.size = clu.size;
+						p_fs->hint_uentry.clu.flags = clu.flags;
+					}
+					if ((num_empty >= num_entries) || (entry_type == TYPE_UNUSED))
+						p_fs->hint_uentry.entry = dentry - (num_empty-1);
+				}
+
+				if (entry_type == TYPE_UNUSED)
+					return -2;
+			} else {
+				num_empty = 0;
+
+				if ((entry_type == TYPE_FILE) || (entry_type == TYPE_DIR)) {
+					file_ep = (FILE_DENTRY_T *) ep;
+					if ((type == TYPE_ALL) || (type == entry_type)) {
+						num_ext_entries = file_ep->num_ext;
+						is_feasible_entry = TRUE;
+					} else {
+						is_feasible_entry = FALSE;
+						step = file_ep->num_ext + 1;
+					}
+				} else if (entry_type == TYPE_STREAM) {
+					if (is_feasible_entry) {
+						strm_ep = (STRM_DENTRY_T *) ep;
+						if (p_uniname->name_hash == GET16_A(strm_ep->name_hash) &&
+						    p_uniname->name_len == strm_ep->name_len) {
+							order = 1;
+						} else {
+							is_feasible_entry = FALSE;
+							step = num_ext_entries;
+						}
+					}
+				} else if (entry_type == TYPE_EXTEND) {
+					if (is_feasible_entry) {
+						name_ep = (NAME_DENTRY_T *) ep;
+
+						if ((++order) == 2)
+							uniname = p_uniname->name;
+						else
+							uniname += 15;
+
+						len = extract_uni_name_from_name_entry(name_ep, entry_uniname, order);
+
+						unichar = *(uniname+len);
+						*(uniname+len) = 0x0;
+
+						if (nls_uniname_cmp(sb, uniname, entry_uniname)) {
+							is_feasible_entry = FALSE;
+							step = num_ext_entries - order + 1;
+						} else if (order == num_ext_entries) {
+							p_fs->hint_uentry.dir = CLUSTER_32(~0);
+							p_fs->hint_uentry.entry = -1;
+							return dentry - (num_ext_entries);
+						}
+
+						*(uniname+len) = unichar;
+					}
+				} else {
+					is_feasible_entry = FALSE;
+				}
+			}
+
+			i += step;
+			dentry += step;
+		}
+
+		i -= dentries_per_clu;
+
+		if (p_dir->dir == CLUSTER_32(0))
+			break; /* FAT16 root_dir */
+
+		if (clu.flags == 0x03) {
+			if ((--clu.size) > 0)
+				clu.dir++;
+			else
+				clu.dir = CLUSTER_32(~0);
+		} else {
+			if (FAT_read(sb, clu.dir, &(clu.dir)) != 0)
+				return -2;
+		}
+	}
+
+	return -2;
+} /* end of exfat_find_dir_entry */
+
+/* returns -1 on error */
+s32 fat_count_ext_entries(struct super_block *sb, CHAIN_T *p_dir, s32 entry, DENTRY_T *p_entry)
+{
+	s32 count = 0;
+	u8 chksum;
+	DOS_DENTRY_T *dos_ep = (DOS_DENTRY_T *) p_entry;
+	EXT_DENTRY_T *ext_ep;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	chksum = calc_checksum_1byte((void *) dos_ep->name, DOS_NAME_LENGTH, 0);
+
+	for (entry--; entry >= 0; entry--) {
+		ext_ep = (EXT_DENTRY_T *) get_entry_in_dir(sb, p_dir, entry, NULL);
+		if (!ext_ep)
+			return -1;
+
+		if ((p_fs->fs_func->get_entry_type((DENTRY_T *) ext_ep) == TYPE_EXTEND) &&
+			(ext_ep->checksum == chksum)) {
+			count++;
+			if (ext_ep->order > 0x40)
+				return count;
+		} else {
+			return count;
+		}
+	}
+
+	return count;
+} /* end of fat_count_ext_entries */
+
+/* returns -1 on error */
+s32 exfat_count_ext_entries(struct super_block *sb, CHAIN_T *p_dir, s32 entry, DENTRY_T *p_entry)
+{
+	int i, count = 0;
+	u32 type;
+	FILE_DENTRY_T *file_ep = (FILE_DENTRY_T *) p_entry;
+	DENTRY_T *ext_ep;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	for (i = 0, entry++; i < file_ep->num_ext; i++, entry++) {
+		ext_ep = get_entry_in_dir(sb, p_dir, entry, NULL);
+		if (!ext_ep)
+			return -1;
+
+		type = p_fs->fs_func->get_entry_type(ext_ep);
+		if ((type == TYPE_EXTEND) || (type == TYPE_STREAM))
+			count++;
+		else
+			return count;
+	}
+
+	return count;
+} /* end of exfat_count_ext_entries */
+
+/* returns -1 on error */
+s32 count_dos_name_entries(struct super_block *sb, CHAIN_T *p_dir, u32 type)
+{
+	int i, count = 0;
+	s32 dentries_per_clu;
+	u32 entry_type;
+	CHAIN_T clu;
+	DENTRY_T *ep;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	if (p_dir->dir == CLUSTER_32(0)) /* FAT16 root_dir */
+		dentries_per_clu = p_fs->dentries_in_root;
+	else
+		dentries_per_clu = p_fs->dentries_per_clu;
+
+	clu.dir = p_dir->dir;
+	clu.size = p_dir->size;
+	clu.flags = p_dir->flags;
+
+	while (clu.dir != CLUSTER_32(~0)) {
+		if (p_fs->dev_ejected)
+			break;
+
+		for (i = 0; i < dentries_per_clu; i++) {
+			ep = get_entry_in_dir(sb, &clu, i, NULL);
+			if (!ep)
+				return -1;
+
+			entry_type = p_fs->fs_func->get_entry_type(ep);
+
+			if (entry_type == TYPE_UNUSED)
+				return count;
+			if (!(type & TYPE_CRITICAL_PRI) && !(type & TYPE_BENIGN_PRI))
+				continue;
+
+			if ((type == TYPE_ALL) || (type == entry_type))
+				count++;
+		}
+
+		if (p_dir->dir == CLUSTER_32(0))
+			break; /* FAT16 root_dir */
+
+		if (clu.flags == 0x03) {
+			if ((--clu.size) > 0)
+				clu.dir++;
+			else
+				clu.dir = CLUSTER_32(~0);
+		} else {
+			if (FAT_read(sb, clu.dir, &(clu.dir)) != 0)
+				return -1;
+		}
+	}
+
+	return count;
+} /* end of count_dos_name_entries */
+
+bool is_dir_empty(struct super_block *sb, CHAIN_T *p_dir)
+{
+	int i, count = 0;
+	s32 dentries_per_clu;
+	u32 type;
+	CHAIN_T clu;
+	DENTRY_T *ep;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	if (p_dir->dir == CLUSTER_32(0)) /* FAT16 root_dir */
+		dentries_per_clu = p_fs->dentries_in_root;
+	else
+		dentries_per_clu = p_fs->dentries_per_clu;
+
+	clu.dir = p_dir->dir;
+	clu.size = p_dir->size;
+	clu.flags = p_dir->flags;
+
+	while (clu.dir != CLUSTER_32(~0)) {
+		if (p_fs->dev_ejected)
+			break;
+
+		for (i = 0; i < dentries_per_clu; i++) {
+			ep = get_entry_in_dir(sb, &clu, i, NULL);
+			if (!ep)
+				break;
+
+			type = p_fs->fs_func->get_entry_type(ep);
+
+			if (type == TYPE_UNUSED)
+				return TRUE;
+			if ((type != TYPE_FILE) && (type != TYPE_DIR))
+				continue;
+
+			if (p_dir->dir == CLUSTER_32(0)) { /* FAT16 root_dir */
+				return FALSE;
+			} else {
+				if (p_fs->vol_type == EXFAT)
+					return FALSE;
+				if ((p_dir->dir == p_fs->root_dir) || ((++count) > 2))
+					return FALSE;
+			}
+		}
+
+		if (p_dir->dir == CLUSTER_32(0))
+			break; /* FAT16 root_dir */
+
+		if (clu.flags == 0x03) {
+			if ((--clu.size) > 0)
+				clu.dir++;
+			else
+				clu.dir = CLUSTER_32(~0);
+		} else {
+			if (FAT_read(sb, clu.dir, &(clu.dir)) != 0)
+				break;
+		}
+	}
+
+	return TRUE;
+} /* end of is_dir_empty */
+
+/*
+ *  Name Conversion Functions
+ */
+
+/* input  : dir, uni_name
+   output : num_of_entry, dos_name(format : aaaaaa~1.bbb) */
+s32 get_num_entries_and_dos_name(struct super_block *sb, CHAIN_T *p_dir, UNI_NAME_T *p_uniname, s32 *entries, DOS_NAME_T *p_dosname)
+{
+	s32 ret, num_entries, lossy = FALSE;
+	char **r;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	num_entries = p_fs->fs_func->calc_num_entries(p_uniname);
+	if (num_entries == 0)
+		return FFS_INVALIDPATH;
+
+	if (p_fs->vol_type != EXFAT) {
+		nls_uniname_to_dosname(sb, p_dosname, p_uniname, &lossy);
+
+		if (lossy) {
+			ret = fat_generate_dos_name(sb, p_dir, p_dosname);
+			if (ret)
+				return ret;
+		} else {
+			for (r = reserved_names; *r; r++) {
+				if (!strncmp((void *) p_dosname->name, *r, 8))
+					return FFS_INVALIDPATH;
+			}
+
+			if (p_dosname->name_case != 0xFF)
+				num_entries = 1;
+		}
+
+		if (num_entries > 1)
+			p_dosname->name_case = 0x0;
+	}
+
+	*entries = num_entries;
+
+	return FFS_SUCCESS;
+} /* end of get_num_entries_and_dos_name */
+
+void get_uni_name_from_dos_entry(struct super_block *sb, DOS_DENTRY_T *ep, UNI_NAME_T *p_uniname, u8 mode)
+{
+	DOS_NAME_T dos_name;
+
+	if (mode == 0x0)
+		dos_name.name_case = 0x0;
+	else
+		dos_name.name_case = ep->lcase;
+
+	memcpy(dos_name.name, ep->name, DOS_NAME_LENGTH);
+	nls_dosname_to_uniname(sb, p_uniname, &dos_name);
+} /* end of get_uni_name_from_dos_entry */
+
+void fat_get_uni_name_from_ext_entry(struct super_block *sb, CHAIN_T *p_dir, s32 entry, u16 *uniname)
+{
+	int i;
+	EXT_DENTRY_T *ep;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	for (entry--, i = 1; entry >= 0; entry--, i++) {
+		ep = (EXT_DENTRY_T *) get_entry_in_dir(sb, p_dir, entry, NULL);
+		if (!ep)
+			return;
+
+		if (p_fs->fs_func->get_entry_type((DENTRY_T *) ep) == TYPE_EXTEND) {
+			extract_uni_name_from_ext_entry(ep, uniname, i);
+			if (ep->order > 0x40)
+				return;
+		} else {
+			return;
+		}
+
+		uniname += 13;
+	}
+} /* end of fat_get_uni_name_from_ext_entry */
+
+void exfat_get_uni_name_from_ext_entry(struct super_block *sb, CHAIN_T *p_dir, s32 entry, u16 *uniname)
+{
+	int i;
+	DENTRY_T *ep;
+	ENTRY_SET_CACHE_T *es;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	es = get_entry_set_in_dir(sb, p_dir, entry, ES_ALL_ENTRIES, &ep);
+	if (es == NULL || es->num_entries < 3) {
+		if (es)
+			release_entry_set(es);
+		return;
+	}
+
+	ep += 2;
+
+	/*
+	* First entry  : file entry
+	* Second entry : stream-extension entry
+	* Third entry  : first file-name entry
+	* So, the index of first file-name dentry should start from 2.
+	*/
+	for (i = 2; i < es->num_entries; i++, ep++) {
+		if (p_fs->fs_func->get_entry_type(ep) == TYPE_EXTEND)
+			extract_uni_name_from_name_entry((NAME_DENTRY_T *)ep, uniname, i);
+		else
+			goto out;
+		uniname += 15;
+	}
+
+out:
+	release_entry_set(es);
+} /* end of exfat_get_uni_name_from_ext_entry */
+
+s32 extract_uni_name_from_ext_entry(EXT_DENTRY_T *ep, u16 *uniname, s32 order)
+{
+	int i, len = 0;
+
+	for (i = 0; i < 10; i += 2) {
+		*uniname = GET16(ep->unicode_0_4+i);
+		if (*uniname == 0x0)
+			return len;
+		uniname++;
+		len++;
+	}
+
+	if (order < 20) {
+		for (i = 0; i < 12; i += 2) {
+			*uniname = GET16_A(ep->unicode_5_10+i);
+			if (*uniname == 0x0)
+				return len;
+			uniname++;
+			len++;
+		}
+	} else {
+		for (i = 0; i < 8; i += 2) {
+			*uniname = GET16_A(ep->unicode_5_10+i);
+			if (*uniname == 0x0)
+				return len;
+			uniname++;
+			len++;
+		}
+		*uniname = 0x0; /* uniname[MAX_NAME_LENGTH-1] */
+		return len;
+	}
+
+	for (i = 0; i < 4; i += 2) {
+		*uniname = GET16_A(ep->unicode_11_12+i);
+		if (*uniname == 0x0)
+			return len;
+		uniname++;
+		len++;
+	}
+
+	*uniname = 0x0;
+	return len;
+
+} /* end of extract_uni_name_from_ext_entry */
+
+s32 extract_uni_name_from_name_entry(NAME_DENTRY_T *ep, u16 *uniname, s32 order)
+{
+	int i, len = 0;
+
+	for (i = 0; i < 30; i += 2) {
+		*uniname = GET16_A(ep->unicode_0_14+i);
+		if (*uniname == 0x0)
+			return len;
+		uniname++;
+		len++;
+	}
+
+	*uniname = 0x0;
+	return len;
+
+} /* end of extract_uni_name_from_name_entry */
+
+s32 fat_generate_dos_name(struct super_block *sb, CHAIN_T *p_dir, DOS_NAME_T *p_dosname)
+{
+	int i, j, count = 0, count_begin = FALSE;
+	s32 dentries_per_clu;
+	u32 type;
+	u8 bmap[128/* 1 ~ 1023 */];
+	CHAIN_T clu;
+	DOS_DENTRY_T *ep;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	memset(bmap, 0, sizeof bmap);
+	exfat_bitmap_set(bmap, 0);
+
+	if (p_dir->dir == CLUSTER_32(0)) /* FAT16 root_dir */
+		dentries_per_clu = p_fs->dentries_in_root;
+	else
+		dentries_per_clu = p_fs->dentries_per_clu;
+
+	clu.dir = p_dir->dir;
+	clu.flags = p_dir->flags;
+
+	while (clu.dir != CLUSTER_32(~0)) {
+		if (p_fs->dev_ejected)
+			break;
+
+		for (i = 0; i < dentries_per_clu; i++) {
+			ep = (DOS_DENTRY_T *) get_entry_in_dir(sb, &clu, i, NULL);
+			if (!ep)
+				return FFS_MEDIAERR;
+
+			type = p_fs->fs_func->get_entry_type((DENTRY_T *) ep);
+
+			if (type == TYPE_UNUSED)
+				break;
+			if ((type != TYPE_FILE) && (type != TYPE_DIR))
+				continue;
+
+			count = 0;
+			count_begin = FALSE;
+
+			for (j = 0; j < 8; j++) {
+				if (ep->name[j] == ' ')
+					break;
+
+				if (ep->name[j] == '~') {
+					count_begin = TRUE;
+				} else if (count_begin) {
+					if ((ep->name[j] >= '0') && (ep->name[j] <= '9')) {
+						count = count * 10 + (ep->name[j] - '0');
+					} else {
+						count = 0;
+						count_begin = FALSE;
+					}
+				}
+			}
+
+			if ((count > 0) && (count < 1024))
+				exfat_bitmap_set(bmap, count);
+		}
+
+		if (p_dir->dir == CLUSTER_32(0))
+			break; /* FAT16 root_dir */
+
+		if (FAT_read(sb, clu.dir, &(clu.dir)) != 0)
+			return FFS_MEDIAERR;
+	}
+
+	count = 0;
+	for (i = 0; i < 128; i++) {
+		if (bmap[i] != 0xFF) {
+			for (j = 0; j < 8; j++) {
+				if (exfat_bitmap_test(&(bmap[i]), j) == 0) {
+					count = (i << 3) + j;
+					break;
+				}
+			}
+			if (count != 0)
+				break;
+		}
+	}
+
+	if ((count == 0) || (count >= 1024))
+		return FFS_FILEEXIST;
+	else
+		fat_attach_count_to_dos_name(p_dosname->name, count);
+
+	/* Now dos_name has DOS~????.EXT */
+	return FFS_SUCCESS;
+} /* end of generate_dos_name */
+
+void fat_attach_count_to_dos_name(u8 *dosname, s32 count)
+{
+	int i, j, length;
+	char str_count[6];
+
+	snprintf(str_count, sizeof str_count, "~%d", count);
+	length = strlen(str_count);
+
+	i = j = 0;
+	while (j <= (8 - length)) {
+		i = j;
+		if (dosname[j] == ' ')
+			break;
+		if (dosname[j] & 0x80)
+			j += 2;
+		else
+			j++;
+	}
+
+	for (j = 0; j < length; i++, j++)
+		dosname[i] = (u8) str_count[j];
+
+	if (i == 7)
+		dosname[7] = ' ';
+
+} /* end of attach_count_to_dos_name */
+
+s32 fat_calc_num_entries(UNI_NAME_T *p_uniname)
+{
+	s32 len;
+
+	len = p_uniname->name_len;
+	if (len == 0)
+		return 0;
+
+	/* 1 dos name entry + extended entries */
+	return (len-1) / 13 + 2;
+
+} /* end of calc_num_enties */
+
+s32 exfat_calc_num_entries(UNI_NAME_T *p_uniname)
+{
+	s32 len;
+
+	len = p_uniname->name_len;
+	if (len == 0)
+		return 0;
+
+	/* 1 file entry + 1 stream entry + name entries */
+	return (len-1) / 15 + 3;
+
+} /* end of exfat_calc_num_enties */
+
+u8 calc_checksum_1byte(void *data, s32 len, u8 chksum)
+{
+	int i;
+	u8 *c = (u8 *) data;
+
+	for (i = 0; i < len; i++, c++)
+		chksum = (((chksum & 1) << 7) | ((chksum & 0xFE) >> 1)) + *c;
+
+	return chksum;
+} /* end of calc_checksum_1byte */
+
+u16 calc_checksum_2byte(void *data, s32 len, u16 chksum, s32 type)
+{
+	int i;
+	u8 *c = (u8 *) data;
+
+	switch (type) {
+	case CS_DIR_ENTRY:
+		for (i = 0; i < len; i++, c++) {
+			if ((i == 2) || (i == 3))
+				continue;
+			chksum = (((chksum & 1) << 15) | ((chksum & 0xFFFE) >> 1)) + (u16) *c;
+		}
+		break;
+	default
+			:
+		for (i = 0; i < len; i++, c++)
+			chksum = (((chksum & 1) << 15) | ((chksum & 0xFFFE) >> 1)) + (u16) *c;
+	}
+
+	return chksum;
+} /* end of calc_checksum_2byte */
+
+u32 calc_checksum_4byte(void *data, s32 len, u32 chksum, s32 type)
+{
+	int i;
+	u8 *c = (u8 *) data;
+
+	switch (type) {
+	case CS_PBR_SECTOR:
+		for (i = 0; i < len; i++, c++) {
+			if ((i == 106) || (i == 107) || (i == 112))
+				continue;
+			chksum = (((chksum & 1) << 31) | ((chksum & 0xFFFFFFFE) >> 1)) + (u32) *c;
+		}
+		break;
+	default
+			:
+		for (i = 0; i < len; i++, c++)
+			chksum = (((chksum & 1) << 31) | ((chksum & 0xFFFFFFFE) >> 1)) + (u32) *c;
+	}
+
+	return chksum;
+} /* end of calc_checksum_4byte */
+
+/*
+ *  Name Resolution Functions
+ */
+
+/* return values of resolve_path()
+   > 0 : return the length of the path
+   < 0 : return error */
+s32 resolve_path(struct inode *inode, char *path, CHAIN_T *p_dir, UNI_NAME_T *p_uniname)
+{
+	s32 lossy = FALSE;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	FILE_ID_T *fid = &(EXFAT_I(inode)->fid);
+
+	if (strlen(path) >= (MAX_NAME_LENGTH * MAX_CHARSET_SIZE))
+		return FFS_INVALIDPATH;
+
+	strcpy(name_buf, path);
+
+	nls_cstring_to_uniname(sb, p_uniname, name_buf, &lossy);
+	if (lossy)
+		return FFS_INVALIDPATH;
+
+	fid->size = i_size_read(inode);
+
+	p_dir->dir = fid->start_clu;
+	p_dir->size = (s32)(fid->size >> p_fs->cluster_size_bits);
+	p_dir->flags = fid->flags;
+
+	return FFS_SUCCESS;
+}
+
+/*
+ *  File Operation Functions
+ */
+static FS_FUNC_T fat_fs_func = {
+	.alloc_cluster = fat_alloc_cluster,
+	.free_cluster = fat_free_cluster,
+	.count_used_clusters = fat_count_used_clusters,
+
+	.init_dir_entry = fat_init_dir_entry,
+	.init_ext_entry = fat_init_ext_entry,
+	.find_dir_entry = fat_find_dir_entry,
+	.delete_dir_entry = fat_delete_dir_entry,
+	.get_uni_name_from_ext_entry = fat_get_uni_name_from_ext_entry,
+	.count_ext_entries = fat_count_ext_entries,
+	.calc_num_entries = fat_calc_num_entries,
+
+	.get_entry_type = fat_get_entry_type,
+	.set_entry_type = fat_set_entry_type,
+	.get_entry_attr = fat_get_entry_attr,
+	.set_entry_attr = fat_set_entry_attr,
+	.get_entry_flag = fat_get_entry_flag,
+	.set_entry_flag = fat_set_entry_flag,
+	.get_entry_clu0 = fat_get_entry_clu0,
+	.set_entry_clu0 = fat_set_entry_clu0,
+	.get_entry_size = fat_get_entry_size,
+	.set_entry_size = fat_set_entry_size,
+	.get_entry_time = fat_get_entry_time,
+	.set_entry_time = fat_set_entry_time,
+};
+
+
+s32 fat16_mount(struct super_block *sb, PBR_SECTOR_T *p_pbr)
+{
+	s32 num_reserved, num_root_sectors;
+	BPB16_T *p_bpb = (BPB16_T *) p_pbr->bpb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+
+	if (p_bpb->num_fats == 0)
+		return FFS_FORMATERR;
+
+	num_root_sectors = GET16(p_bpb->num_root_entries) << DENTRY_SIZE_BITS;
+	num_root_sectors = ((num_root_sectors-1) >> p_bd->sector_size_bits) + 1;
+
+	p_fs->sectors_per_clu = p_bpb->sectors_per_clu;
+	p_fs->sectors_per_clu_bits = ilog2(p_bpb->sectors_per_clu);
+	p_fs->cluster_size_bits = p_fs->sectors_per_clu_bits + p_bd->sector_size_bits;
+	p_fs->cluster_size = 1 << p_fs->cluster_size_bits;
+
+	p_fs->num_FAT_sectors = GET16(p_bpb->num_fat_sectors);
+
+	p_fs->FAT1_start_sector = p_fs->PBR_sector + GET16(p_bpb->num_reserved);
+	if (p_bpb->num_fats == 1)
+		p_fs->FAT2_start_sector = p_fs->FAT1_start_sector;
+	else
+		p_fs->FAT2_start_sector = p_fs->FAT1_start_sector + p_fs->num_FAT_sectors;
+
+	p_fs->root_start_sector = p_fs->FAT2_start_sector + p_fs->num_FAT_sectors;
+	p_fs->data_start_sector = p_fs->root_start_sector + num_root_sectors;
+
+	p_fs->num_sectors = GET16(p_bpb->num_sectors);
+	if (p_fs->num_sectors == 0)
+		p_fs->num_sectors = GET32(p_bpb->num_huge_sectors);
+
+	num_reserved = p_fs->data_start_sector - p_fs->PBR_sector;
+	p_fs->num_clusters = ((p_fs->num_sectors - num_reserved) >> p_fs->sectors_per_clu_bits) + 2;
+	/* because the cluster index starts with 2 */
+
+	if (p_fs->num_clusters < FAT12_THRESHOLD)
+		p_fs->vol_type = FAT12;
+	else
+		p_fs->vol_type = FAT16;
+	p_fs->vol_id = GET32(p_bpb->vol_serial);
+
+	p_fs->root_dir = 0;
+	p_fs->dentries_in_root = GET16(p_bpb->num_root_entries);
+	p_fs->dentries_per_clu = 1 << (p_fs->cluster_size_bits - DENTRY_SIZE_BITS);
+
+	p_fs->vol_flag = VOL_CLEAN;
+	p_fs->clu_srch_ptr = 2;
+	p_fs->used_clusters = (u32) ~0;
+
+	p_fs->fs_func = &fat_fs_func;
+
+	return FFS_SUCCESS;
+} /* end of fat16_mount */
+
+s32 fat32_mount(struct super_block *sb, PBR_SECTOR_T *p_pbr)
+{
+	s32 num_reserved;
+	BPB32_T *p_bpb = (BPB32_T *) p_pbr->bpb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+
+	if (p_bpb->num_fats == 0)
+		return FFS_FORMATERR;
+
+	p_fs->sectors_per_clu = p_bpb->sectors_per_clu;
+	p_fs->sectors_per_clu_bits = ilog2(p_bpb->sectors_per_clu);
+	p_fs->cluster_size_bits = p_fs->sectors_per_clu_bits + p_bd->sector_size_bits;
+	p_fs->cluster_size = 1 << p_fs->cluster_size_bits;
+
+	p_fs->num_FAT_sectors = GET32(p_bpb->num_fat32_sectors);
+
+	p_fs->FAT1_start_sector = p_fs->PBR_sector + GET16(p_bpb->num_reserved);
+	if (p_bpb->num_fats == 1)
+		p_fs->FAT2_start_sector = p_fs->FAT1_start_sector;
+	else
+		p_fs->FAT2_start_sector = p_fs->FAT1_start_sector + p_fs->num_FAT_sectors;
+
+	p_fs->root_start_sector = p_fs->FAT2_start_sector + p_fs->num_FAT_sectors;
+	p_fs->data_start_sector = p_fs->root_start_sector;
+
+	p_fs->num_sectors = GET32(p_bpb->num_huge_sectors);
+	num_reserved = p_fs->data_start_sector - p_fs->PBR_sector;
+
+	p_fs->num_clusters = ((p_fs->num_sectors-num_reserved) >> p_fs->sectors_per_clu_bits) + 2;
+	/* because the cluster index starts with 2 */
+
+	p_fs->vol_type = FAT32;
+	p_fs->vol_id = GET32(p_bpb->vol_serial);
+
+	p_fs->root_dir = GET32(p_bpb->root_cluster);
+	p_fs->dentries_in_root = 0;
+	p_fs->dentries_per_clu = 1 << (p_fs->cluster_size_bits - DENTRY_SIZE_BITS);
+
+	p_fs->vol_flag = VOL_CLEAN;
+	p_fs->clu_srch_ptr = 2;
+	p_fs->used_clusters = (u32) ~0;
+
+	p_fs->fs_func = &fat_fs_func;
+
+	return FFS_SUCCESS;
+} /* end of fat32_mount */
+
+static FS_FUNC_T exfat_fs_func = {
+	.alloc_cluster = exfat_alloc_cluster,
+	.free_cluster = exfat_free_cluster,
+	.count_used_clusters = exfat_count_used_clusters,
+
+	.init_dir_entry = exfat_init_dir_entry,
+	.init_ext_entry = exfat_init_ext_entry,
+	.find_dir_entry = exfat_find_dir_entry,
+	.delete_dir_entry = exfat_delete_dir_entry,
+	.get_uni_name_from_ext_entry = exfat_get_uni_name_from_ext_entry,
+	.count_ext_entries = exfat_count_ext_entries,
+	.calc_num_entries = exfat_calc_num_entries,
+
+	.get_entry_type = exfat_get_entry_type,
+	.set_entry_type = exfat_set_entry_type,
+	.get_entry_attr = exfat_get_entry_attr,
+	.set_entry_attr = exfat_set_entry_attr,
+	.get_entry_flag = exfat_get_entry_flag,
+	.set_entry_flag = exfat_set_entry_flag,
+	.get_entry_clu0 = exfat_get_entry_clu0,
+	.set_entry_clu0 = exfat_set_entry_clu0,
+	.get_entry_size = exfat_get_entry_size,
+	.set_entry_size = exfat_set_entry_size,
+	.get_entry_time = exfat_get_entry_time,
+	.set_entry_time = exfat_set_entry_time,
+};
+
+s32 exfat_mount(struct super_block *sb, PBR_SECTOR_T *p_pbr)
+{
+	BPBEX_T *p_bpb = (BPBEX_T *) p_pbr->bpb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+
+	if (p_bpb->num_fats == 0)
+		return FFS_FORMATERR;
+
+	p_fs->sectors_per_clu = 1 << p_bpb->sectors_per_clu_bits;
+	p_fs->sectors_per_clu_bits = p_bpb->sectors_per_clu_bits;
+	p_fs->cluster_size_bits = p_fs->sectors_per_clu_bits + p_bd->sector_size_bits;
+	p_fs->cluster_size = 1 << p_fs->cluster_size_bits;
+
+	p_fs->num_FAT_sectors = GET32(p_bpb->fat_length);
+
+	p_fs->FAT1_start_sector = p_fs->PBR_sector + GET32(p_bpb->fat_offset);
+	if (p_bpb->num_fats == 1)
+		p_fs->FAT2_start_sector = p_fs->FAT1_start_sector;
+	else
+		p_fs->FAT2_start_sector = p_fs->FAT1_start_sector + p_fs->num_FAT_sectors;
+
+	p_fs->root_start_sector = p_fs->PBR_sector + GET32(p_bpb->clu_offset);
+	p_fs->data_start_sector = p_fs->root_start_sector;
+
+	p_fs->num_sectors = GET64(p_bpb->vol_length);
+	p_fs->num_clusters = GET32(p_bpb->clu_count) + 2;
+	/* because the cluster index starts with 2 */
+
+	p_fs->vol_type = EXFAT;
+	p_fs->vol_id = GET32(p_bpb->vol_serial);
+
+	p_fs->root_dir = GET32(p_bpb->root_cluster);
+	p_fs->dentries_in_root = 0;
+	p_fs->dentries_per_clu = 1 << (p_fs->cluster_size_bits - DENTRY_SIZE_BITS);
+
+	p_fs->vol_flag = (u32) GET16(p_bpb->vol_flags);
+	p_fs->clu_srch_ptr = 2;
+	p_fs->used_clusters = (u32) ~0;
+
+	p_fs->fs_func = &exfat_fs_func;
+
+	return FFS_SUCCESS;
+} /* end of exfat_mount */
+
+s32 create_dir(struct inode *inode, CHAIN_T *p_dir, UNI_NAME_T *p_uniname, FILE_ID_T *fid)
+{
+	s32 ret, dentry, num_entries;
+	u64 size;
+	CHAIN_T clu;
+	DOS_NAME_T dos_name, dot_name;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	ret = get_num_entries_and_dos_name(sb, p_dir, p_uniname, &num_entries, &dos_name);
+	if (ret)
+		return ret;
+
+	/* find_empty_entry must be called before alloc_cluster */
+	dentry = find_empty_entry(inode, p_dir, num_entries);
+	if (dentry < 0)
+		return FFS_FULL;
+
+	clu.dir = CLUSTER_32(~0);
+	clu.size = 0;
+	clu.flags = (p_fs->vol_type == EXFAT) ? 0x03 : 0x01;
+
+	/* (1) allocate a cluster */
+	ret = p_fs->fs_func->alloc_cluster(sb, 1, &clu);
+	if (ret < 0)
+		return FFS_MEDIAERR;
+	else if (ret == 0)
+		return FFS_FULL;
+
+	ret = clear_cluster(sb, clu.dir);
+	if (ret != FFS_SUCCESS)
+		return ret;
+
+	if (p_fs->vol_type == EXFAT) {
+		size = p_fs->cluster_size;
+	} else {
+		size = 0;
+
+		/* initialize the . and .. entry
+		   Information for . points to itself
+		   Information for .. points to parent dir */
+
+		dot_name.name_case = 0x0;
+		memcpy(dot_name.name, DOS_CUR_DIR_NAME, DOS_NAME_LENGTH);
+
+		ret = p_fs->fs_func->init_dir_entry(sb, &clu, 0, TYPE_DIR, clu.dir, 0);
+		if (ret != FFS_SUCCESS)
+			return ret;
+
+		ret = p_fs->fs_func->init_ext_entry(sb, &clu, 0, 1, NULL, &dot_name);
+		if (ret != FFS_SUCCESS)
+			return ret;
+
+		memcpy(dot_name.name, DOS_PAR_DIR_NAME, DOS_NAME_LENGTH);
+
+		if (p_dir->dir == p_fs->root_dir)
+			ret = p_fs->fs_func->init_dir_entry(sb, &clu, 1, TYPE_DIR, CLUSTER_32(0), 0);
+		else
+			ret = p_fs->fs_func->init_dir_entry(sb, &clu, 1, TYPE_DIR, p_dir->dir, 0);
+
+		if (ret != FFS_SUCCESS)
+			return ret;
+
+		ret = p_fs->fs_func->init_ext_entry(sb, &clu, 1, 1, NULL, &dot_name);
+		if (ret != FFS_SUCCESS)
+			return ret;
+	}
+
+	/* (2) update the directory entry */
+	/* make sub-dir entry in parent directory */
+	ret = p_fs->fs_func->init_dir_entry(sb, p_dir, dentry, TYPE_DIR, clu.dir, size);
+	if (ret != FFS_SUCCESS)
+		return ret;
+
+	ret = p_fs->fs_func->init_ext_entry(sb, p_dir, dentry, num_entries, p_uniname, &dos_name);
+	if (ret != FFS_SUCCESS)
+		return ret;
+
+	fid->dir.dir = p_dir->dir;
+	fid->dir.size = p_dir->size;
+	fid->dir.flags = p_dir->flags;
+	fid->entry = dentry;
+
+	fid->attr = ATTR_SUBDIR;
+	fid->flags = (p_fs->vol_type == EXFAT) ? 0x03 : 0x01;
+	fid->size = size;
+	fid->start_clu = clu.dir;
+
+	fid->type = TYPE_DIR;
+	fid->rwoffset = 0;
+	fid->hint_last_off = -1;
+
+	return FFS_SUCCESS;
+} /* end of create_dir */
+
+s32 create_file(struct inode *inode, CHAIN_T *p_dir, UNI_NAME_T *p_uniname, u8 mode, FILE_ID_T *fid)
+{
+	s32 ret, dentry, num_entries;
+	DOS_NAME_T dos_name;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	ret = get_num_entries_and_dos_name(sb, p_dir, p_uniname, &num_entries, &dos_name);
+	if (ret)
+		return ret;
+
+	/* find_empty_entry must be called before alloc_cluster() */
+	dentry = find_empty_entry(inode, p_dir, num_entries);
+	if (dentry < 0)
+		return FFS_FULL;
+
+	/* (1) update the directory entry */
+	/* fill the dos name directory entry information of the created file.
+	   the first cluster is not determined yet. (0) */
+	ret = p_fs->fs_func->init_dir_entry(sb, p_dir, dentry, TYPE_FILE | mode, CLUSTER_32(0), 0);
+	if (ret != FFS_SUCCESS)
+		return ret;
+
+	ret = p_fs->fs_func->init_ext_entry(sb, p_dir, dentry, num_entries, p_uniname, &dos_name);
+	if (ret != FFS_SUCCESS)
+		return ret;
+
+	fid->dir.dir = p_dir->dir;
+	fid->dir.size = p_dir->size;
+	fid->dir.flags = p_dir->flags;
+	fid->entry = dentry;
+
+	fid->attr = ATTR_ARCHIVE | mode;
+	fid->flags = (p_fs->vol_type == EXFAT) ? 0x03 : 0x01;
+	fid->size = 0;
+	fid->start_clu = CLUSTER_32(~0);
+
+	fid->type = TYPE_FILE;
+	fid->rwoffset = 0;
+	fid->hint_last_off = -1;
+
+	return FFS_SUCCESS;
+} /* end of create_file */
+
+void remove_file(struct inode *inode, CHAIN_T *p_dir, s32 entry)
+{
+	s32 num_entries;
+	sector_t sector;
+	DENTRY_T *ep;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	ep = get_entry_in_dir(sb, p_dir, entry, &sector);
+	if (!ep)
+		return;
+
+	buf_lock(sb, sector);
+
+	/* buf_lock() before call count_ext_entries() */
+	num_entries = p_fs->fs_func->count_ext_entries(sb, p_dir, entry, ep);
+	if (num_entries < 0) {
+		buf_unlock(sb, sector);
+		return;
+	}
+	num_entries++;
+
+	buf_unlock(sb, sector);
+
+	/* (1) update the directory entry */
+	p_fs->fs_func->delete_dir_entry(sb, p_dir, entry, 0, num_entries);
+} /* end of remove_file */
+
+s32 rename_file(struct inode *inode, CHAIN_T *p_dir, s32 oldentry, UNI_NAME_T *p_uniname, FILE_ID_T *fid)
+{
+	s32 ret, newentry = -1, num_old_entries, num_new_entries;
+	sector_t sector_old, sector_new;
+	DOS_NAME_T dos_name;
+	DENTRY_T *epold, *epnew;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	epold = get_entry_in_dir(sb, p_dir, oldentry, &sector_old);
+	if (!epold)
+		return FFS_MEDIAERR;
+
+	buf_lock(sb, sector_old);
+
+	/* buf_lock() before call count_ext_entries() */
+	num_old_entries = p_fs->fs_func->count_ext_entries(sb, p_dir, oldentry, epold);
+	if (num_old_entries < 0) {
+		buf_unlock(sb, sector_old);
+		return FFS_MEDIAERR;
+	}
+	num_old_entries++;
+
+	ret = get_num_entries_and_dos_name(sb, p_dir, p_uniname, &num_new_entries, &dos_name);
+	if (ret) {
+		buf_unlock(sb, sector_old);
+		return ret;
+	}
+
+	if (num_old_entries < num_new_entries) {
+		newentry = find_empty_entry(inode, p_dir, num_new_entries);
+		if (newentry < 0) {
+			buf_unlock(sb, sector_old);
+			return FFS_FULL;
+		}
+
+		epnew = get_entry_in_dir(sb, p_dir, newentry, &sector_new);
+		if (!epnew) {
+			buf_unlock(sb, sector_old);
+			return FFS_MEDIAERR;
+		}
+
+		memcpy((void *) epnew, (void *) epold, DENTRY_SIZE);
+		if (p_fs->fs_func->get_entry_type(epnew) == TYPE_FILE) {
+			p_fs->fs_func->set_entry_attr(epnew, p_fs->fs_func->get_entry_attr(epnew) | ATTR_ARCHIVE);
+			fid->attr |= ATTR_ARCHIVE;
+		}
+		buf_modify(sb, sector_new);
+		buf_unlock(sb, sector_old);
+
+		if (p_fs->vol_type == EXFAT) {
+			epold = get_entry_in_dir(sb, p_dir, oldentry+1, &sector_old);
+			buf_lock(sb, sector_old);
+			epnew = get_entry_in_dir(sb, p_dir, newentry+1, &sector_new);
+
+			if (!epold || !epnew) {
+				buf_unlock(sb, sector_old);
+				return FFS_MEDIAERR;
+			}
+
+			memcpy((void *) epnew, (void *) epold, DENTRY_SIZE);
+			buf_modify(sb, sector_new);
+			buf_unlock(sb, sector_old);
+		}
+
+		ret = p_fs->fs_func->init_ext_entry(sb, p_dir, newentry, num_new_entries, p_uniname, &dos_name);
+		if (ret != FFS_SUCCESS)
+			return ret;
+
+		p_fs->fs_func->delete_dir_entry(sb, p_dir, oldentry, 0, num_old_entries);
+		fid->entry = newentry;
+	} else {
+		if (p_fs->fs_func->get_entry_type(epold) == TYPE_FILE) {
+			p_fs->fs_func->set_entry_attr(epold, p_fs->fs_func->get_entry_attr(epold) | ATTR_ARCHIVE);
+			fid->attr |= ATTR_ARCHIVE;
+		}
+		buf_modify(sb, sector_old);
+		buf_unlock(sb, sector_old);
+
+		ret = p_fs->fs_func->init_ext_entry(sb, p_dir, oldentry, num_new_entries, p_uniname, &dos_name);
+		if (ret != FFS_SUCCESS)
+			return ret;
+
+		p_fs->fs_func->delete_dir_entry(sb, p_dir, oldentry, num_new_entries, num_old_entries);
+	}
+
+	return FFS_SUCCESS;
+} /* end of rename_file */
+
+s32 move_file(struct inode *inode, CHAIN_T *p_olddir, s32 oldentry, CHAIN_T *p_newdir, UNI_NAME_T *p_uniname, FILE_ID_T *fid)
+{
+	s32 ret, newentry, num_new_entries, num_old_entries;
+	sector_t sector_mov, sector_new;
+	CHAIN_T clu;
+	DOS_NAME_T dos_name;
+	DENTRY_T *epmov, *epnew;
+	struct super_block *sb = inode->i_sb;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	epmov = get_entry_in_dir(sb, p_olddir, oldentry, &sector_mov);
+	if (!epmov)
+		return FFS_MEDIAERR;
+
+	/* check if the source and target directory is the same */
+	if (p_fs->fs_func->get_entry_type(epmov) == TYPE_DIR &&
+		p_fs->fs_func->get_entry_clu0(epmov) == p_newdir->dir)
+		return FFS_INVALIDPATH;
+
+	buf_lock(sb, sector_mov);
+
+	/* buf_lock() before call count_ext_entries() */
+	num_old_entries = p_fs->fs_func->count_ext_entries(sb, p_olddir, oldentry, epmov);
+	if (num_old_entries < 0) {
+		buf_unlock(sb, sector_mov);
+		return FFS_MEDIAERR;
+	}
+	num_old_entries++;
+
+	ret = get_num_entries_and_dos_name(sb, p_newdir, p_uniname, &num_new_entries, &dos_name);
+	if (ret) {
+		buf_unlock(sb, sector_mov);
+		return ret;
+	}
+
+	newentry = find_empty_entry(inode, p_newdir, num_new_entries);
+	if (newentry < 0) {
+		buf_unlock(sb, sector_mov);
+		return FFS_FULL;
+	}
+
+	epnew = get_entry_in_dir(sb, p_newdir, newentry, &sector_new);
+	if (!epnew) {
+		buf_unlock(sb, sector_mov);
+		return FFS_MEDIAERR;
+	}
+
+	memcpy((void *) epnew, (void *) epmov, DENTRY_SIZE);
+	if (p_fs->fs_func->get_entry_type(epnew) == TYPE_FILE) {
+		p_fs->fs_func->set_entry_attr(epnew, p_fs->fs_func->get_entry_attr(epnew) | ATTR_ARCHIVE);
+		fid->attr |= ATTR_ARCHIVE;
+	}
+	buf_modify(sb, sector_new);
+	buf_unlock(sb, sector_mov);
+
+	if (p_fs->vol_type == EXFAT) {
+		epmov = get_entry_in_dir(sb, p_olddir, oldentry+1, &sector_mov);
+		buf_lock(sb, sector_mov);
+		epnew = get_entry_in_dir(sb, p_newdir, newentry+1, &sector_new);
+		if (!epmov || !epnew) {
+			buf_unlock(sb, sector_mov);
+			return FFS_MEDIAERR;
+		}
+
+		memcpy((void *) epnew, (void *) epmov, DENTRY_SIZE);
+		buf_modify(sb, sector_new);
+		buf_unlock(sb, sector_mov);
+	} else if (p_fs->fs_func->get_entry_type(epnew) == TYPE_DIR) {
+		/* change ".." pointer to new parent dir */
+		clu.dir = p_fs->fs_func->get_entry_clu0(epnew);
+		clu.flags = 0x01;
+
+		epnew = get_entry_in_dir(sb, &clu, 1, &sector_new);
+		if (!epnew)
+			return FFS_MEDIAERR;
+
+		if (p_newdir->dir == p_fs->root_dir)
+			p_fs->fs_func->set_entry_clu0(epnew, CLUSTER_32(0));
+		else
+			p_fs->fs_func->set_entry_clu0(epnew, p_newdir->dir);
+		buf_modify(sb, sector_new);
+	}
+
+	ret = p_fs->fs_func->init_ext_entry(sb, p_newdir, newentry, num_new_entries, p_uniname, &dos_name);
+	if (ret != FFS_SUCCESS)
+		return ret;
+
+	p_fs->fs_func->delete_dir_entry(sb, p_olddir, oldentry, 0, num_old_entries);
+
+	fid->dir.dir = p_newdir->dir;
+	fid->dir.size = p_newdir->size;
+	fid->dir.flags = p_newdir->flags;
+
+	fid->entry = newentry;
+
+	return FFS_SUCCESS;
+} /* end of move_file */
+
+/*
+ *  Sector Read/Write Functions
+ */
+
+s32 sector_read(struct super_block *sb, sector_t sec, struct buffer_head **bh, s32 read)
+{
+	s32 ret = FFS_MEDIAERR;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	if ((sec >= (p_fs->PBR_sector+p_fs->num_sectors)) && (p_fs->num_sectors > 0)) {
+		printk("[EXFAT] sector_read: out of range error! (sec = %llu)\n", (unsigned long long)sec);
+		fs_error(sb);
+		return ret;
+	}
+
+	if (!p_fs->dev_ejected) {
+		ret = bdev_read(sb, sec, bh, 1, read);
+		if (ret != FFS_SUCCESS)
+			p_fs->dev_ejected = TRUE;
+	}
+
+	return ret;
+} /* end of sector_read */
+
+s32 sector_write(struct super_block *sb, sector_t sec, struct buffer_head *bh, s32 sync)
+{
+	s32 ret = FFS_MEDIAERR;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	if (sec >= (p_fs->PBR_sector+p_fs->num_sectors) && (p_fs->num_sectors > 0)) {
+		printk("[EXFAT] sector_write: out of range error! (sec = %llu)\n", (unsigned long long)sec);
+		fs_error(sb);
+		return ret;
+	}
+
+	if (bh == NULL) {
+		printk("[EXFAT] sector_write: bh is NULL!\n");
+		fs_error(sb);
+		return ret;
+	}
+
+	if (!p_fs->dev_ejected) {
+		ret = bdev_write(sb, sec, bh, 1, sync);
+		if (ret != FFS_SUCCESS)
+			p_fs->dev_ejected = TRUE;
+	}
+
+	return ret;
+} /* end of sector_write */
+
+s32 multi_sector_read(struct super_block *sb, sector_t sec, struct buffer_head **bh, s32 num_secs, s32 read)
+{
+	s32 ret = FFS_MEDIAERR;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	if (((sec+num_secs) > (p_fs->PBR_sector+p_fs->num_sectors)) && (p_fs->num_sectors > 0)) {
+		printk("[EXFAT] multi_sector_read: out of range error! (sec = %llu, num_secs = %d)\n",
+		       (unsigned long long)sec, num_secs);
+		fs_error(sb);
+		return ret;
+	}
+
+	if (!p_fs->dev_ejected) {
+		ret = bdev_read(sb, sec, bh, num_secs, read);
+		if (ret != FFS_SUCCESS)
+			p_fs->dev_ejected = TRUE;
+	}
+
+	return ret;
+} /* end of multi_sector_read */
+
+s32 multi_sector_write(struct super_block *sb, sector_t sec, struct buffer_head *bh, s32 num_secs, s32 sync)
+{
+	s32 ret = FFS_MEDIAERR;
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	if ((sec+num_secs) > (p_fs->PBR_sector+p_fs->num_sectors) && (p_fs->num_sectors > 0)) {
+		printk("[EXFAT] multi_sector_write: out of range error! (sec = %llu, num_secs = %d)\n",
+		       (unsigned long long)sec, num_secs);
+		fs_error(sb);
+		return ret;
+	}
+	if (bh == NULL) {
+		printk("[EXFAT] multi_sector_write: bh is NULL!\n");
+		fs_error(sb);
+		return ret;
+	}
+
+	if (!p_fs->dev_ejected) {
+		ret = bdev_write(sb, sec, bh, num_secs, sync);
+		if (ret != FFS_SUCCESS)
+			p_fs->dev_ejected = TRUE;
+	}
+
+	return ret;
+} /* end of multi_sector_write */
diff --git a/kernel/fs/exfat/exfat_core.h b/kernel/fs/exfat/exfat_core.h
new file mode 100755
index 0000000000..52d05c7007
--- /dev/null
+++ b/kernel/fs/exfat/exfat_core.h
@@ -0,0 +1,671 @@
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*  PROJECT : exFAT & FAT12/16/32 File System                           */
+/*  FILE    : exfat_core.h                                              */
+/*  PURPOSE : Header File for exFAT File Manager                        */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  NOTES                                                               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  REVISION HISTORY (Ver 0.9)                                          */
+/*                                                                      */
+/*  - 2010.11.15 [Joosun Hahn] : first writing                          */
+/*                                                                      */
+/************************************************************************/
+
+#ifndef _EXFAT_H
+#define _EXFAT_H
+
+#include "exfat_config.h"
+#include "exfat_data.h"
+#include "exfat_oal.h"
+
+#include "exfat_blkdev.h"
+#include "exfat_cache.h"
+#include "exfat_nls.h"
+#include "exfat_api.h"
+#include "exfat_cache.h"
+
+#ifdef CONFIG_EXFAT_KERNEL_DEBUG
+  /* For Debugging Purpose */
+	/* IOCTL code 'f' used by
+	 *   - file systems typically #0~0x1F
+	 *   - embedded terminal devices #128~
+	 *   - exts for debugging purpose #99
+	 * number 100 and 101 is availble now but has possible conflicts
+	 */
+#define EXFAT_IOC_GET_DEBUGFLAGS       _IOR('f', 100, long)
+#define EXFAT_IOC_SET_DEBUGFLAGS       _IOW('f', 101, long)
+
+#define EXFAT_DEBUGFLAGS_INVALID_UMOUNT        0x01
+#define EXFAT_DEBUGFLAGS_ERROR_RW              0x02
+#endif /* CONFIG_EXFAT_KERNEL_DEBUG */
+
+	/*----------------------------------------------------------------------*/
+	/*  Constant & Macro Definitions                                        */
+	/*----------------------------------------------------------------------*/
+
+#define DENTRY_SIZE             32          /* dir entry size */
+#define DENTRY_SIZE_BITS        5
+
+/* PBR entries */
+#define PBR_SIGNATURE           0xAA55
+#define EXT_SIGNATURE           0xAA550000
+#define VOL_LABEL               "NO NAME    " /* size should be 11 */
+#define OEM_NAME                "MSWIN4.1"  /* size should be 8 */
+#define STR_FAT12               "FAT12   "  /* size should be 8 */
+#define STR_FAT16               "FAT16   "  /* size should be 8 */
+#define STR_FAT32               "FAT32   "  /* size should be 8 */
+#define STR_EXFAT               "EXFAT   "  /* size should be 8 */
+#define VOL_CLEAN               0x0000
+#define VOL_DIRTY               0x0002
+
+/* max number of clusters */
+#define FAT12_THRESHOLD         4087        /* 2^12 - 1 + 2 (clu 0 & 1) */
+#define FAT16_THRESHOLD         65527       /* 2^16 - 1 + 2 */
+#define FAT32_THRESHOLD         268435457   /* 2^28 - 1 + 2 */
+#define EXFAT_THRESHOLD         268435457   /* 2^28 - 1 + 2 */
+
+/* file types */
+#define TYPE_UNUSED             0x0000
+#define TYPE_DELETED            0x0001
+#define TYPE_INVALID            0x0002
+#define TYPE_CRITICAL_PRI       0x0100
+#define TYPE_BITMAP             0x0101
+#define TYPE_UPCASE             0x0102
+#define TYPE_VOLUME             0x0103
+#define TYPE_DIR                0x0104
+#define TYPE_FILE               0x011F
+#define TYPE_SYMLINK            0x015F
+#define TYPE_CRITICAL_SEC       0x0200
+#define TYPE_STREAM             0x0201
+#define TYPE_EXTEND             0x0202
+#define TYPE_ACL                0x0203
+#define TYPE_BENIGN_PRI         0x0400
+#define TYPE_GUID               0x0401
+#define TYPE_PADDING            0x0402
+#define TYPE_ACLTAB             0x0403
+#define TYPE_BENIGN_SEC         0x0800
+#define TYPE_ALL                0x0FFF
+
+/* time modes */
+#define TM_CREATE               0
+#define TM_MODIFY               1
+#define TM_ACCESS               2
+
+/* checksum types */
+#define CS_DIR_ENTRY            0
+#define CS_PBR_SECTOR           1
+#define CS_DEFAULT              2
+
+#define CLUSTER_16(x)           ((u16)(x))
+#define CLUSTER_32(x)           ((u32)(x))
+
+#define FALSE			0
+#define TRUE			1
+
+#define MIN(a, b)		(((a) < (b)) ? (a) : (b))
+#define MAX(a, b)		(((a) > (b)) ? (a) : (b))
+
+#define START_SECTOR(x) \
+	((((sector_t)((x) - 2)) << p_fs->sectors_per_clu_bits) + p_fs->data_start_sector)
+
+#define IS_LAST_SECTOR_IN_CLUSTER(sec) \
+		((((sec) - p_fs->data_start_sector + 1) & ((1 <<  p_fs->sectors_per_clu_bits) - 1)) == 0)
+
+#define GET_CLUSTER_FROM_SECTOR(sec)			\
+		((u32)((((sec) - p_fs->data_start_sector) >> p_fs->sectors_per_clu_bits) + 2))
+
+#define GET16(p_src) \
+	(((u16)(p_src)[0]) | (((u16)(p_src)[1]) << 8))
+#define GET32(p_src) \
+	(((u32)(p_src)[0]) | (((u32)(p_src)[1]) << 8) | \
+	(((u32)(p_src)[2]) << 16) | (((u32)(p_src)[3]) << 24))
+#define GET64(p_src) \
+	(((u64)(p_src)[0]) | (((u64)(p_src)[1]) << 8) | \
+	(((u64)(p_src)[2]) << 16) | (((u64)(p_src)[3]) << 24) | \
+	(((u64)(p_src)[4]) << 32) | (((u64)(p_src)[5]) << 40) | \
+	(((u64)(p_src)[6]) << 48) | (((u64)(p_src)[7]) << 56))
+
+
+#define SET16(p_dst, src)                                  \
+	do {                                              \
+		(p_dst)[0] = (u8)(src);                     \
+		(p_dst)[1] = (u8)(((u16)(src)) >> 8);       \
+	} while (0)
+#define SET32(p_dst, src)                                  \
+	do {                                              \
+		(p_dst)[0] = (u8)(src);                     \
+		(p_dst)[1] = (u8)(((u32)(src)) >> 8);       \
+		(p_dst)[2] = (u8)(((u32)(src)) >> 16);      \
+		(p_dst)[3] = (u8)(((u32)(src)) >> 24);      \
+	} while (0)
+#define SET64(p_dst, src)                                  \
+	do {                                              \
+		(p_dst)[0] = (u8)(src);                   \
+		(p_dst)[1] = (u8)(((u64)(src)) >> 8);     \
+		(p_dst)[2] = (u8)(((u64)(src)) >> 16);    \
+		(p_dst)[3] = (u8)(((u64)(src)) >> 24);    \
+		(p_dst)[4] = (u8)(((u64)(src)) >> 32);    \
+		(p_dst)[5] = (u8)(((u64)(src)) >> 40);    \
+		(p_dst)[6] = (u8)(((u64)(src)) >> 48);    \
+		(p_dst)[7] = (u8)(((u64)(src)) >> 56);    \
+	} while (0)
+
+#ifdef __LITTLE_ENDIAN
+#define GET16_A(p_src)		(*((u16 *)(p_src)))
+#define GET32_A(p_src)		(*((u32 *)(p_src)))
+#define GET64_A(p_src)		(*((u64 *)(p_src)))
+#define SET16_A(p_dst, src)	(*((u16 *)(p_dst)) = (u16)(src))
+#define SET32_A(p_dst, src)	(*((u32 *)(p_dst)) = (u32)(src))
+#define SET64_A(p_dst, src)	(*((u64 *)(p_dst)) = (u64)(src))
+#else /* BIG_ENDIAN */
+#define GET16_A(p_src)		GET16(p_src)
+#define GET32_A(p_src)		GET32(p_src)
+#define GET64_A(p_src)		GET64(p_src)
+#define SET16_A(p_dst, src)	SET16(p_dst, src)
+#define SET32_A(p_dst, src)	SET32(p_dst, src)
+#define SET64_A(p_dst, src)	SET64(p_dst, src)
+#endif
+
+/* Upcase tabel mecro */
+#define HIGH_INDEX_BIT (8)
+#define HIGH_INDEX_MASK (0xFF00)
+#define LOW_INDEX_BIT (16-HIGH_INDEX_BIT)
+#define UTBL_ROW_COUNT (1<<LOW_INDEX_BIT)
+#define UTBL_COL_COUNT (1<<HIGH_INDEX_BIT)
+
+#if CONFIG_EXFAT_DEBUG_MSG
+#define DPRINTK(...)			\
+	do {								\
+		printk("[EXFAT] " __VA_ARGS__);	\
+	} while (0)
+#else
+#define DPRINTK(...)
+#endif
+
+static inline u16 get_col_index(u16 i)
+{
+	return i >> LOW_INDEX_BIT;
+}
+static inline u16 get_row_index(u16 i)
+{
+	return i & ~HIGH_INDEX_MASK;
+}
+/*----------------------------------------------------------------------*/
+/*  Type Definitions                                                    */
+/*----------------------------------------------------------------------*/
+
+/* MS_DOS FAT partition boot record (512 bytes) */
+typedef struct {
+	u8       jmp_boot[3];
+	u8       oem_name[8];
+	u8       bpb[109];
+	u8       boot_code[390];
+	u8       signature[2];
+} PBR_SECTOR_T;
+
+/* MS-DOS FAT12/16 BIOS parameter block (51 bytes) */
+typedef struct {
+	u8       sector_size[2];
+	u8       sectors_per_clu;
+	u8       num_reserved[2];
+	u8       num_fats;
+	u8       num_root_entries[2];
+	u8       num_sectors[2];
+	u8       media_type;
+	u8       num_fat_sectors[2];
+	u8       sectors_in_track[2];
+	u8       num_heads[2];
+	u8       num_hid_sectors[4];
+	u8       num_huge_sectors[4];
+
+	u8       phy_drv_no;
+	u8       reserved;
+	u8       ext_signature;
+	u8       vol_serial[4];
+	u8       vol_label[11];
+	u8       vol_type[8];
+} BPB16_T;
+
+/* MS-DOS FAT32 BIOS parameter block (79 bytes) */
+typedef struct {
+	u8       sector_size[2];
+	u8       sectors_per_clu;
+	u8       num_reserved[2];
+	u8       num_fats;
+	u8       num_root_entries[2];
+	u8       num_sectors[2];
+	u8       media_type;
+	u8       num_fat_sectors[2];
+	u8       sectors_in_track[2];
+	u8       num_heads[2];
+	u8       num_hid_sectors[4];
+	u8       num_huge_sectors[4];
+	u8       num_fat32_sectors[4];
+	u8       ext_flags[2];
+	u8       fs_version[2];
+	u8       root_cluster[4];
+	u8       fsinfo_sector[2];
+	u8       backup_sector[2];
+	u8       reserved[12];
+
+	u8       phy_drv_no;
+	u8       ext_reserved;
+	u8       ext_signature;
+	u8       vol_serial[4];
+	u8       vol_label[11];
+	u8       vol_type[8];
+} BPB32_T;
+
+/* MS-DOS EXFAT BIOS parameter block (109 bytes) */
+typedef struct {
+	u8       reserved1[53];
+	u8       vol_offset[8];
+	u8       vol_length[8];
+	u8       fat_offset[4];
+	u8       fat_length[4];
+	u8       clu_offset[4];
+	u8       clu_count[4];
+	u8       root_cluster[4];
+	u8       vol_serial[4];
+	u8       fs_version[2];
+	u8       vol_flags[2];
+	u8       sector_size_bits;
+	u8       sectors_per_clu_bits;
+	u8       num_fats;
+	u8       phy_drv_no;
+	u8       perc_in_use;
+	u8       reserved2[7];
+} BPBEX_T;
+
+/* MS-DOS FAT file system information sector (512 bytes) */
+typedef struct {
+	u8       signature1[4];
+	u8       reserved1[480];
+	u8       signature2[4];
+	u8       free_cluster[4];
+	u8       next_cluster[4];
+	u8       reserved2[14];
+	u8       signature3[2];
+} FSI_SECTOR_T;
+
+/* MS-DOS FAT directory entry (32 bytes) */
+typedef struct {
+	u8       dummy[32];
+} DENTRY_T;
+
+typedef struct {
+	u8       name[DOS_NAME_LENGTH];
+	u8       attr;
+	u8       lcase;
+	u8       create_time_ms;
+	u8       create_time[2];
+	u8       create_date[2];
+	u8       access_date[2];
+	u8       start_clu_hi[2];
+	u8       modify_time[2];
+	u8       modify_date[2];
+	u8       start_clu_lo[2];
+	u8       size[4];
+} DOS_DENTRY_T;
+
+/* MS-DOS FAT extended directory entry (32 bytes) */
+typedef struct {
+	u8       order;
+	u8       unicode_0_4[10];
+	u8       attr;
+	u8       sysid;
+	u8       checksum;
+	u8       unicode_5_10[12];
+	u8       start_clu[2];
+	u8       unicode_11_12[4];
+} EXT_DENTRY_T;
+
+/* MS-DOS EXFAT file directory entry (32 bytes) */
+typedef struct {
+	u8       type;
+	u8       num_ext;
+	u8       checksum[2];
+	u8       attr[2];
+	u8       reserved1[2];
+	u8       create_time[2];
+	u8       create_date[2];
+	u8       modify_time[2];
+	u8       modify_date[2];
+	u8       access_time[2];
+	u8       access_date[2];
+	u8       create_time_ms;
+	u8       modify_time_ms;
+	u8       access_time_ms;
+	u8       reserved2[9];
+} FILE_DENTRY_T;
+
+/* MS-DOS EXFAT stream extension directory entry (32 bytes) */
+typedef struct {
+	u8       type;
+	u8       flags;
+	u8       reserved1;
+	u8       name_len;
+	u8       name_hash[2];
+	u8       reserved2[2];
+	u8       valid_size[8];
+	u8       reserved3[4];
+	u8       start_clu[4];
+	u8       size[8];
+} STRM_DENTRY_T;
+
+/* MS-DOS EXFAT file name directory entry (32 bytes) */
+typedef struct {
+	u8       type;
+	u8       flags;
+	u8       unicode_0_14[30];
+} NAME_DENTRY_T;
+
+/* MS-DOS EXFAT allocation bitmap directory entry (32 bytes) */
+typedef struct {
+	u8       type;
+	u8       flags;
+	u8       reserved[18];
+	u8       start_clu[4];
+	u8       size[8];
+} BMAP_DENTRY_T;
+
+/* MS-DOS EXFAT up-case table directory entry (32 bytes) */
+typedef struct {
+	u8       type;
+	u8       reserved1[3];
+	u8       checksum[4];
+	u8       reserved2[12];
+	u8       start_clu[4];
+	u8       size[8];
+} CASE_DENTRY_T;
+
+/* MS-DOS EXFAT volume label directory entry (32 bytes) */
+typedef struct {
+	u8       type;
+	u8       label_len;
+	u8       unicode_0_10[22];
+	u8       reserved[8];
+} VOLM_DENTRY_T;
+
+/* unused entry hint information */
+typedef struct {
+	u32      dir;
+	s32       entry;
+	CHAIN_T     clu;
+} UENTRY_T;
+
+typedef struct {
+	s32       (*alloc_cluster)(struct super_block *sb, s32 num_alloc, CHAIN_T *p_chain);
+	void        (*free_cluster)(struct super_block *sb, CHAIN_T *p_chain, s32 do_relse);
+	s32       (*count_used_clusters)(struct super_block *sb);
+
+	s32      (*init_dir_entry)(struct super_block *sb, CHAIN_T *p_dir, s32 entry, u32 type,
+								 u32 start_clu, u64 size);
+	s32      (*init_ext_entry)(struct super_block *sb, CHAIN_T *p_dir, s32 entry, s32 num_entries,
+								 UNI_NAME_T *p_uniname, DOS_NAME_T *p_dosname);
+	s32       (*find_dir_entry)(struct super_block *sb, CHAIN_T *p_dir, UNI_NAME_T *p_uniname, s32 num_entries, DOS_NAME_T *p_dosname, u32 type);
+	void        (*delete_dir_entry)(struct super_block *sb, CHAIN_T *p_dir, s32 entry, s32 offset, s32 num_entries);
+	void        (*get_uni_name_from_ext_entry)(struct super_block *sb, CHAIN_T *p_dir, s32 entry, u16 *uniname);
+	s32       (*count_ext_entries)(struct super_block *sb, CHAIN_T *p_dir, s32 entry, DENTRY_T *p_entry);
+	s32       (*calc_num_entries)(UNI_NAME_T *p_uniname);
+
+	u32      (*get_entry_type)(DENTRY_T *p_entry);
+	void        (*set_entry_type)(DENTRY_T *p_entry, u32 type);
+	u32      (*get_entry_attr)(DENTRY_T *p_entry);
+	void        (*set_entry_attr)(DENTRY_T *p_entry, u32 attr);
+	u8       (*get_entry_flag)(DENTRY_T *p_entry);
+	void        (*set_entry_flag)(DENTRY_T *p_entry, u8 flag);
+	u32      (*get_entry_clu0)(DENTRY_T *p_entry);
+	void        (*set_entry_clu0)(DENTRY_T *p_entry, u32 clu0);
+	u64      (*get_entry_size)(DENTRY_T *p_entry);
+	void        (*set_entry_size)(DENTRY_T *p_entry, u64 size);
+	void        (*get_entry_time)(DENTRY_T *p_entry, TIMESTAMP_T *tp, u8 mode);
+	void        (*set_entry_time)(DENTRY_T *p_entry, TIMESTAMP_T *tp, u8 mode);
+} FS_FUNC_T;
+
+typedef struct __FS_INFO_T {
+	u32      drv;                    /* drive ID */
+	u32      vol_type;               /* volume FAT type */
+	u32      vol_id;                 /* volume serial number */
+
+	u64      num_sectors;            /* num of sectors in volume */
+	u32      num_clusters;           /* num of clusters in volume */
+	u32      cluster_size;           /* cluster size in bytes */
+	u32      cluster_size_bits;
+	u32      sectors_per_clu;        /* cluster size in sectors */
+	u32      sectors_per_clu_bits;
+
+	u32      PBR_sector;             /* PBR sector */
+	u32      FAT1_start_sector;      /* FAT1 start sector */
+	u32      FAT2_start_sector;      /* FAT2 start sector */
+	u32      root_start_sector;      /* root dir start sector */
+	u32      data_start_sector;      /* data area start sector */
+	u32      num_FAT_sectors;        /* num of FAT sectors */
+
+	u32      root_dir;               /* root dir cluster */
+	u32      dentries_in_root;       /* num of dentries in root dir */
+	u32      dentries_per_clu;       /* num of dentries per cluster */
+
+	u32      vol_flag;               /* volume dirty flag */
+	struct buffer_head *pbr_bh;         /* PBR sector */
+
+	u32      map_clu;                /* allocation bitmap start cluster */
+	u32      map_sectors;            /* num of allocation bitmap sectors */
+	struct buffer_head **vol_amap;      /* allocation bitmap */
+
+	u16      **vol_utbl;               /* upcase table */
+
+	u32      clu_srch_ptr;           /* cluster search pointer */
+	u32      used_clusters;          /* number of used clusters */
+	UENTRY_T    hint_uentry;         /* unused entry hint information */
+
+	u32      dev_ejected;            /* block device operation error flag */
+
+	FS_FUNC_T	*fs_func;
+	struct semaphore v_sem;
+
+	/* FAT cache */
+	BUF_CACHE_T FAT_cache_array[FAT_CACHE_SIZE];
+	BUF_CACHE_T FAT_cache_lru_list;
+	BUF_CACHE_T FAT_cache_hash_list[FAT_CACHE_HASH_SIZE];
+
+	/* buf cache */
+	BUF_CACHE_T buf_cache_array[BUF_CACHE_SIZE];
+	BUF_CACHE_T buf_cache_lru_list;
+	BUF_CACHE_T buf_cache_hash_list[BUF_CACHE_HASH_SIZE];
+} FS_INFO_T;
+
+#define ES_2_ENTRIES		2
+#define ES_3_ENTRIES		3
+#define ES_ALL_ENTRIES	0
+
+typedef struct {
+	sector_t	sector;	/* sector number that contains file_entry */
+	s32	offset;		/* byte offset in the sector */
+	s32	alloc_flag;	/* flag in stream entry. 01 for cluster chain, 03 for contig. clusteres. */
+	u32 num_entries;
+
+	/* __buf should be the last member */
+	void *__buf;
+} ENTRY_SET_CACHE_T;
+
+/*----------------------------------------------------------------------*/
+/*  External Function Declarations                                      */
+/*----------------------------------------------------------------------*/
+
+/* file system initialization & shutdown functions */
+s32 ffsInit(void);
+s32 ffsShutdown(void);
+
+/* volume management functions */
+s32 ffsMountVol(struct super_block *sb);
+s32 ffsUmountVol(struct super_block *sb);
+s32 ffsCheckVol(struct super_block *sb);
+s32 ffsGetVolInfo(struct super_block *sb, VOL_INFO_T *info);
+s32 ffsSyncVol(struct super_block *sb, s32 do_sync);
+
+/* file management functions */
+s32 ffsLookupFile(struct inode *inode, char *path, FILE_ID_T *fid);
+s32 ffsCreateFile(struct inode *inode, char *path, u8 mode, FILE_ID_T *fid);
+s32 ffsReadFile(struct inode *inode, FILE_ID_T *fid, void *buffer, u64 count, u64 *rcount);
+s32 ffsWriteFile(struct inode *inode, FILE_ID_T *fid, void *buffer, u64 count, u64 *wcount);
+s32 ffsTruncateFile(struct inode *inode, u64 old_size, u64 new_size);
+s32 ffsMoveFile(struct inode *old_parent_inode, FILE_ID_T *fid, struct inode *new_parent_inode, struct dentry *new_dentry);
+s32 ffsRemoveFile(struct inode *inode, FILE_ID_T *fid);
+s32 ffsSetAttr(struct inode *inode, u32 attr);
+s32 ffsGetStat(struct inode *inode, DIR_ENTRY_T *info);
+s32 ffsSetStat(struct inode *inode, DIR_ENTRY_T *info);
+s32 ffsMapCluster(struct inode *inode, s32 clu_offset, u32 *clu);
+
+/* directory management functions */
+s32 ffsCreateDir(struct inode *inode, char *path, FILE_ID_T *fid);
+s32 ffsReadDir(struct inode *inode, DIR_ENTRY_T *dir_ent);
+s32 ffsRemoveDir(struct inode *inode, FILE_ID_T *fid);
+
+/*----------------------------------------------------------------------*/
+/*  External Function Declarations (NOT TO UPPER LAYER)                 */
+/*----------------------------------------------------------------------*/
+
+/* fs management functions */
+s32  fs_init(void);
+s32  fs_shutdown(void);
+void   fs_set_vol_flags(struct super_block *sb, u32 new_flag);
+void   fs_sync(struct super_block *sb, s32 do_sync);
+void   fs_error(struct super_block *sb);
+
+/* cluster management functions */
+s32   clear_cluster(struct super_block *sb, u32 clu);
+s32  fat_alloc_cluster(struct super_block *sb, s32 num_alloc, CHAIN_T *p_chain);
+s32  exfat_alloc_cluster(struct super_block *sb, s32 num_alloc, CHAIN_T *p_chain);
+void   fat_free_cluster(struct super_block *sb, CHAIN_T *p_chain, s32 do_relse);
+void   exfat_free_cluster(struct super_block *sb, CHAIN_T *p_chain, s32 do_relse);
+u32 find_last_cluster(struct super_block *sb, CHAIN_T *p_chain);
+s32  count_num_clusters(struct super_block *sb, CHAIN_T *dir);
+s32  fat_count_used_clusters(struct super_block *sb);
+s32  exfat_count_used_clusters(struct super_block *sb);
+void   exfat_chain_cont_cluster(struct super_block *sb, u32 chain, s32 len);
+
+/* allocation bitmap management functions */
+s32  load_alloc_bitmap(struct super_block *sb);
+void   free_alloc_bitmap(struct super_block *sb);
+s32   set_alloc_bitmap(struct super_block *sb, u32 clu);
+s32   clr_alloc_bitmap(struct super_block *sb, u32 clu);
+u32 test_alloc_bitmap(struct super_block *sb, u32 clu);
+void   sync_alloc_bitmap(struct super_block *sb);
+
+/* upcase table management functions */
+s32  load_upcase_table(struct super_block *sb);
+void   free_upcase_table(struct super_block *sb);
+
+/* dir entry management functions */
+u32 fat_get_entry_type(DENTRY_T *p_entry);
+u32 exfat_get_entry_type(DENTRY_T *p_entry);
+void   fat_set_entry_type(DENTRY_T *p_entry, u32 type);
+void   exfat_set_entry_type(DENTRY_T *p_entry, u32 type);
+u32 fat_get_entry_attr(DENTRY_T *p_entry);
+u32 exfat_get_entry_attr(DENTRY_T *p_entry);
+void   fat_set_entry_attr(DENTRY_T *p_entry, u32 attr);
+void   exfat_set_entry_attr(DENTRY_T *p_entry, u32 attr);
+u8  fat_get_entry_flag(DENTRY_T *p_entry);
+u8  exfat_get_entry_flag(DENTRY_T *p_entry);
+void   fat_set_entry_flag(DENTRY_T *p_entry, u8 flag);
+void   exfat_set_entry_flag(DENTRY_T *p_entry, u8 flag);
+u32 fat_get_entry_clu0(DENTRY_T *p_entry);
+u32 exfat_get_entry_clu0(DENTRY_T *p_entry);
+void   fat_set_entry_clu0(DENTRY_T *p_entry, u32 start_clu);
+void   exfat_set_entry_clu0(DENTRY_T *p_entry, u32 start_clu);
+u64 fat_get_entry_size(DENTRY_T *p_entry);
+u64 exfat_get_entry_size(DENTRY_T *p_entry);
+void   fat_set_entry_size(DENTRY_T *p_entry, u64 size);
+void   exfat_set_entry_size(DENTRY_T *p_entry, u64 size);
+void   fat_get_entry_time(DENTRY_T *p_entry, TIMESTAMP_T *tp, u8 mode);
+void   exfat_get_entry_time(DENTRY_T *p_entry, TIMESTAMP_T *tp, u8 mode);
+void   fat_set_entry_time(DENTRY_T *p_entry, TIMESTAMP_T *tp, u8 mode);
+void   exfat_set_entry_time(DENTRY_T *p_entry, TIMESTAMP_T *tp, u8 mode);
+s32   fat_init_dir_entry(struct super_block *sb, CHAIN_T *p_dir, s32 entry, u32 type, u32 start_clu, u64 size);
+s32   exfat_init_dir_entry(struct super_block *sb, CHAIN_T *p_dir, s32 entry, u32 type, u32 start_clu, u64 size);
+s32   fat_init_ext_dir_entry(struct super_block *sb, CHAIN_T *p_dir, s32 entry, s32 num_entries, UNI_NAME_T *p_uniname, DOS_NAME_T *p_dosname);
+s32   exfat_init_ext_dir_entry(struct super_block *sb, CHAIN_T *p_dir, s32 entry, s32 num_entries, UNI_NAME_T *p_uniname, DOS_NAME_T *p_dosname);
+void   init_dos_entry(DOS_DENTRY_T *ep, u32 type, u32 start_clu);
+void   init_ext_entry(EXT_DENTRY_T *ep, s32 order, u8 chksum, u16 *uniname);
+void   init_file_entry(FILE_DENTRY_T *ep, u32 type);
+void   init_strm_entry(STRM_DENTRY_T *ep, u8 flags, u32 start_clu, u64 size);
+void   init_name_entry(NAME_DENTRY_T *ep, u16 *uniname);
+void   fat_delete_dir_entry(struct super_block *sb, CHAIN_T *p_dir, s32 entry, s32 order, s32 num_entries);
+void   exfat_delete_dir_entry(struct super_block *sb, CHAIN_T *p_dir, s32 entry, s32 order, s32 num_entries);
+
+s32   find_location(struct super_block *sb, CHAIN_T *p_dir, s32 entry, sector_t *sector, s32 *offset);
+DENTRY_T *get_entry_with_sector(struct super_block *sb, sector_t sector, s32 offset);
+DENTRY_T *get_entry_in_dir(struct super_block *sb, CHAIN_T *p_dir, s32 entry, sector_t *sector);
+ENTRY_SET_CACHE_T *get_entry_set_in_dir(struct super_block *sb, CHAIN_T *p_dir, s32 entry, u32 type, DENTRY_T **file_ep);
+void release_entry_set(ENTRY_SET_CACHE_T *es);
+s32 write_whole_entry_set(struct super_block *sb, ENTRY_SET_CACHE_T *es);
+s32 write_partial_entries_in_entry_set(struct super_block *sb, ENTRY_SET_CACHE_T *es, DENTRY_T *ep, u32 count);
+s32  search_deleted_or_unused_entry(struct super_block *sb, CHAIN_T *p_dir, s32 num_entries);
+s32  find_empty_entry(struct inode *inode, CHAIN_T *p_dir, s32 num_entries);
+s32  fat_find_dir_entry(struct super_block *sb, CHAIN_T *p_dir, UNI_NAME_T *p_uniname, s32 num_entries, DOS_NAME_T *p_dosname, u32 type);
+s32  exfat_find_dir_entry(struct super_block *sb, CHAIN_T *p_dir, UNI_NAME_T *p_uniname, s32 num_entries, DOS_NAME_T *p_dosname, u32 type);
+s32  fat_count_ext_entries(struct super_block *sb, CHAIN_T *p_dir, s32 entry, DENTRY_T *p_entry);
+s32  exfat_count_ext_entries(struct super_block *sb, CHAIN_T *p_dir, s32 entry, DENTRY_T *p_entry);
+s32  count_dos_name_entries(struct super_block *sb, CHAIN_T *p_dir, u32 type);
+void   update_dir_checksum(struct super_block *sb, CHAIN_T *p_dir, s32 entry);
+void update_dir_checksum_with_entry_set(struct super_block *sb, ENTRY_SET_CACHE_T *es);
+bool   is_dir_empty(struct super_block *sb, CHAIN_T *p_dir);
+
+/* name conversion functions */
+s32  get_num_entries_and_dos_name(struct super_block *sb, CHAIN_T *p_dir, UNI_NAME_T *p_uniname, s32 *entries, DOS_NAME_T *p_dosname);
+void   get_uni_name_from_dos_entry(struct super_block *sb, DOS_DENTRY_T *ep, UNI_NAME_T *p_uniname, u8 mode);
+void   fat_get_uni_name_from_ext_entry(struct super_block *sb, CHAIN_T *p_dir, s32 entry, u16 *uniname);
+void   exfat_get_uni_name_from_ext_entry(struct super_block *sb, CHAIN_T *p_dir, s32 entry, u16 *uniname);
+s32  extract_uni_name_from_ext_entry(EXT_DENTRY_T *ep, u16 *uniname, s32 order);
+s32  extract_uni_name_from_name_entry(NAME_DENTRY_T *ep, u16 *uniname, s32 order);
+s32  fat_generate_dos_name(struct super_block *sb, CHAIN_T *p_dir, DOS_NAME_T *p_dosname);
+void   fat_attach_count_to_dos_name(u8 *dosname, s32 count);
+s32  fat_calc_num_entries(UNI_NAME_T *p_uniname);
+s32  exfat_calc_num_entries(UNI_NAME_T *p_uniname);
+u8  calc_checksum_1byte(void *data, s32 len, u8 chksum);
+u16 calc_checksum_2byte(void *data, s32 len, u16 chksum, s32 type);
+u32 calc_checksum_4byte(void *data, s32 len, u32 chksum, s32 type);
+
+/* name resolution functions */
+s32  resolve_path(struct inode *inode, char *path, CHAIN_T *p_dir, UNI_NAME_T *p_uniname);
+s32  resolve_name(u8 *name, u8 **arg);
+
+/* file operation functions */
+s32  fat16_mount(struct super_block *sb, PBR_SECTOR_T *p_pbr);
+s32  fat32_mount(struct super_block *sb, PBR_SECTOR_T *p_pbr);
+s32  exfat_mount(struct super_block *sb, PBR_SECTOR_T *p_pbr);
+s32  create_dir(struct inode *inode, CHAIN_T *p_dir, UNI_NAME_T *p_uniname, FILE_ID_T *fid);
+s32  create_file(struct inode *inode, CHAIN_T *p_dir, UNI_NAME_T *p_uniname, u8 mode, FILE_ID_T *fid);
+void   remove_file(struct inode *inode, CHAIN_T *p_dir, s32 entry);
+s32  rename_file(struct inode *inode, CHAIN_T *p_dir, s32 old_entry, UNI_NAME_T *p_uniname, FILE_ID_T *fid);
+s32  move_file(struct inode *inode, CHAIN_T *p_olddir, s32 oldentry, CHAIN_T *p_newdir, UNI_NAME_T *p_uniname, FILE_ID_T *fid);
+
+/* sector read/write functions */
+s32   sector_read(struct super_block *sb, sector_t sec, struct buffer_head **bh, s32 read);
+s32   sector_write(struct super_block *sb, sector_t sec, struct buffer_head *bh, s32 sync);
+s32   multi_sector_read(struct super_block *sb, sector_t sec, struct buffer_head **bh, s32 num_secs, s32 read);
+s32   multi_sector_write(struct super_block *sb, sector_t sec, struct buffer_head *bh, s32 num_secs, s32 sync);
+
+#endif /* _EXFAT_H */
diff --git a/kernel/fs/exfat/exfat_data.c b/kernel/fs/exfat/exfat_data.c
new file mode 100755
index 0000000000..65da07aff5
--- /dev/null
+++ b/kernel/fs/exfat/exfat_data.c
@@ -0,0 +1,77 @@
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*  PROJECT : exFAT & FAT12/16/32 File System                           */
+/*  FILE    : exfat_data.c                                              */
+/*  PURPOSE : exFAT Configuable Data Definitions                        */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  NOTES                                                               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  REVISION HISTORY (Ver 0.9)                                          */
+/*                                                                      */
+/*  - 2010.11.15 [Joosun Hahn] : first writing                          */
+/*                                                                      */
+/************************************************************************/
+
+#include "exfat_config.h"
+#include "exfat_data.h"
+#include "exfat_oal.h"
+
+#include "exfat_blkdev.h"
+#include "exfat_cache.h"
+#include "exfat_nls.h"
+#include "exfat_super.h"
+#include "exfat_core.h"
+
+/*======================================================================*/
+/*                                                                      */
+/*                    GLOBAL VARIABLE DEFINITIONS                       */
+/*                                                                      */
+/*======================================================================*/
+
+/*----------------------------------------------------------------------*/
+/*  File Manager                                                        */
+/*----------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------*/
+/*  Buffer Manager                                                      */
+/*----------------------------------------------------------------------*/
+
+/* FAT cache */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+DECLARE_MUTEX(f_sem);
+#else
+DEFINE_SEMAPHORE(f_sem);
+#endif
+BUF_CACHE_T FAT_cache_array[FAT_CACHE_SIZE];
+BUF_CACHE_T FAT_cache_lru_list;
+BUF_CACHE_T FAT_cache_hash_list[FAT_CACHE_HASH_SIZE];
+
+/* buf cache */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+DECLARE_MUTEX(b_sem);
+#else
+DEFINE_SEMAPHORE(b_sem);
+#endif
+BUF_CACHE_T buf_cache_array[BUF_CACHE_SIZE];
+BUF_CACHE_T buf_cache_lru_list;
+BUF_CACHE_T buf_cache_hash_list[BUF_CACHE_HASH_SIZE];
diff --git a/kernel/fs/exfat/exfat_data.h b/kernel/fs/exfat/exfat_data.h
new file mode 100755
index 0000000000..53b0e39397
--- /dev/null
+++ b/kernel/fs/exfat/exfat_data.h
@@ -0,0 +1,58 @@
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*  PROJECT : exFAT & FAT12/16/32 File System                           */
+/*  FILE    : exfat_data.h                                              */
+/*  PURPOSE : Header File for exFAT Configuable Constants               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  NOTES                                                               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  REVISION HISTORY (Ver 0.9)                                          */
+/*                                                                      */
+/*  - 2010.11.15 [Joosun Hahn] : first writing                          */
+/*                                                                      */
+/************************************************************************/
+
+#ifndef _EXFAT_DATA_H
+#define _EXFAT_DATA_H
+
+#include "exfat_config.h"
+
+/*======================================================================*/
+/*                                                                      */
+/*                        FFS CONFIGURATIONS                            */
+/*                  (CHANGE THIS PART IF REQUIRED)                      */
+/*                                                                      */
+/*======================================================================*/
+
+/* max number of root directory entries in FAT12/16 */
+/* (should be an exponential value of 2)            */
+#define MAX_DENTRY              512
+
+/* cache size (in number of sectors)                */
+/* (should be an exponential value of 2)            */
+#define FAT_CACHE_SIZE          128
+#define FAT_CACHE_HASH_SIZE     64
+#define BUF_CACHE_SIZE          256
+#define BUF_CACHE_HASH_SIZE     64
+
+#endif /* _EXFAT_DATA_H */
diff --git a/kernel/fs/exfat/exfat_nls.c b/kernel/fs/exfat/exfat_nls.c
new file mode 100755
index 0000000000..a48b3d05a7
--- /dev/null
+++ b/kernel/fs/exfat/exfat_nls.c
@@ -0,0 +1,448 @@
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*  PROJECT : exFAT & FAT12/16/32 File System                           */
+/*  FILE    : exfat_nls.c                                               */
+/*  PURPOSE : exFAT NLS Manager                                         */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  NOTES                                                               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  REVISION HISTORY (Ver 0.9)                                          */
+/*                                                                      */
+/*  - 2010.11.15 [Joosun Hahn] : first writing                          */
+/*                                                                      */
+/************************************************************************/
+
+#include "exfat_config.h"
+#include "exfat_data.h"
+
+#include "exfat_nls.h"
+#include "exfat_api.h"
+#include "exfat_super.h"
+#include "exfat_core.h"
+
+#include <linux/nls.h>
+
+/*----------------------------------------------------------------------*/
+/*  Global Variable Definitions                                         */
+/*----------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------*/
+/*  Local Variable Definitions                                          */
+/*----------------------------------------------------------------------*/
+
+static u16 bad_dos_chars[] = {
+	/* + , ; = [ ] */
+	0x002B, 0x002C, 0x003B, 0x003D, 0x005B, 0x005D,
+	0xFF0B, 0xFF0C, 0xFF1B, 0xFF1D, 0xFF3B, 0xFF3D,
+	0
+};
+
+static u16 bad_uni_chars[] = {
+	/* " * / : < > ? \ | */
+	0x0022,         0x002A, 0x002F, 0x003A,
+	0x003C, 0x003E, 0x003F, 0x005C, 0x007C,
+	0
+};
+
+/*----------------------------------------------------------------------*/
+/*  Local Function Declarations                                         */
+/*----------------------------------------------------------------------*/
+
+static s32  convert_uni_to_ch(struct nls_table *nls, u8 *ch, u16 uni, s32 *lossy);
+static s32  convert_ch_to_uni(struct nls_table *nls, u16 *uni, u8 *ch, s32 *lossy);
+
+/*======================================================================*/
+/*  Global Function Definitions                                         */
+/*======================================================================*/
+
+u16 nls_upper(struct super_block *sb, u16 a)
+{
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+
+	if (EXFAT_SB(sb)->options.casesensitive)
+		return a;
+	if (p_fs->vol_utbl != NULL && (p_fs->vol_utbl)[get_col_index(a)] != NULL)
+		return (p_fs->vol_utbl)[get_col_index(a)][get_row_index(a)];
+	else
+		return a;
+}
+
+u16 *nls_wstrchr(u16 *str, u16 wchar)
+{
+	while (*str) {
+		if (*(str++) == wchar)
+			return str;
+	}
+
+	return 0;
+}
+
+s32 nls_dosname_cmp(struct super_block *sb, u8 *a, u8 *b)
+{
+	return strncmp((void *) a, (void *) b, DOS_NAME_LENGTH);
+} /* end of nls_dosname_cmp */
+
+s32 nls_uniname_cmp(struct super_block *sb, u16 *a, u16 *b)
+{
+	int i;
+
+	for (i = 0; i < MAX_NAME_LENGTH; i++, a++, b++) {
+		if (nls_upper(sb, *a) != nls_upper(sb, *b))
+			return 1;
+		if (*a == 0x0)
+			return 0;
+	}
+	return 0;
+} /* end of nls_uniname_cmp */
+
+void nls_uniname_to_dosname(struct super_block *sb, DOS_NAME_T *p_dosname, UNI_NAME_T *p_uniname, s32 *p_lossy)
+{
+	int i, j, len, lossy = FALSE;
+	u8 buf[MAX_CHARSET_SIZE];
+	u8 lower = 0, upper = 0;
+	u8 *dosname = p_dosname->name;
+	u16 *uniname = p_uniname->name;
+	u16 *p, *last_period;
+	struct nls_table *nls = EXFAT_SB(sb)->nls_disk;
+
+	for (i = 0; i < DOS_NAME_LENGTH; i++)
+		*(dosname+i) = ' ';
+
+	if (!nls_uniname_cmp(sb, uniname, (u16 *) UNI_CUR_DIR_NAME)) {
+		*(dosname) = '.';
+		p_dosname->name_case = 0x0;
+		if (p_lossy != NULL)
+			*p_lossy = FALSE;
+		return;
+	}
+
+	if (!nls_uniname_cmp(sb, uniname, (u16 *) UNI_PAR_DIR_NAME)) {
+		*(dosname) = '.';
+		*(dosname+1) = '.';
+		p_dosname->name_case = 0x0;
+		if (p_lossy != NULL)
+			*p_lossy = FALSE;
+		return;
+	}
+
+	/* search for the last embedded period */
+	last_period = NULL;
+	for (p = uniname; *p; p++) {
+		if (*p == (u16) '.')
+			last_period = p;
+	}
+
+	i = 0;
+	while (i < DOS_NAME_LENGTH) {
+		if (i == 8) {
+			if (last_period == NULL)
+				break;
+
+			if (uniname <= last_period) {
+				if (uniname < last_period)
+					lossy = TRUE;
+				uniname = last_period + 1;
+			}
+		}
+
+		if (*uniname == (u16) '\0') {
+			break;
+		} else if (*uniname == (u16) ' ') {
+			lossy = TRUE;
+		} else if (*uniname == (u16) '.') {
+			if (uniname < last_period)
+				lossy = TRUE;
+			else
+				i = 8;
+		} else if (nls_wstrchr(bad_dos_chars, *uniname)) {
+			lossy = TRUE;
+			*(dosname+i) = '_';
+			i++;
+		} else {
+			len = convert_uni_to_ch(nls, buf, *uniname, &lossy);
+
+			if (len > 1) {
+				if ((i >= 8) && ((i+len) > DOS_NAME_LENGTH))
+					break;
+
+				if ((i <  8) && ((i+len) > 8)) {
+					i = 8;
+					continue;
+				}
+
+				lower = 0xFF;
+
+				for (j = 0; j < len; j++, i++)
+					*(dosname+i) = *(buf+j);
+			} else { /* len == 1 */
+				if ((*buf >= 'a') && (*buf <= 'z')) {
+					*(dosname+i) = *buf - ('a' - 'A');
+
+					if (i < 8)
+						lower |= 0x08;
+					else
+						lower |= 0x10;
+				} else if ((*buf >= 'A') && (*buf <= 'Z')) {
+					*(dosname+i) = *buf;
+
+					if (i < 8)
+						upper |= 0x08;
+					else
+						upper |= 0x10;
+				} else {
+					*(dosname+i) = *buf;
+				}
+				i++;
+			}
+		}
+
+		uniname++;
+	}
+
+	if (*dosname == 0xE5)
+		*dosname = 0x05;
+
+	if (*uniname != 0x0)
+		lossy = TRUE;
+
+	if (upper & lower)
+		p_dosname->name_case = 0xFF;
+	else
+		p_dosname->name_case = lower;
+
+	if (p_lossy != NULL)
+		*p_lossy = lossy;
+} /* end of nls_uniname_to_dosname */
+
+void nls_dosname_to_uniname(struct super_block *sb, UNI_NAME_T *p_uniname, DOS_NAME_T *p_dosname)
+{
+	int i = 0, j, n = 0;
+	u8 buf[DOS_NAME_LENGTH+2];
+	u8 *dosname = p_dosname->name;
+	u16 *uniname = p_uniname->name;
+	struct nls_table *nls = EXFAT_SB(sb)->nls_disk;
+
+	if (*dosname == 0x05) {
+		*buf = 0xE5;
+		i++;
+		n++;
+	}
+
+	for (; i < 8; i++, n++) {
+		if (*(dosname+i) == ' ')
+			break;
+
+		if ((*(dosname+i) >= 'A') && (*(dosname+i) <= 'Z') && (p_dosname->name_case & 0x08))
+			*(buf+n) = *(dosname+i) + ('a' - 'A');
+		else
+			*(buf+n) = *(dosname+i);
+	}
+	if (*(dosname+8) != ' ') {
+		*(buf+n) = '.';
+		n++;
+	}
+
+	for (i = 8; i < DOS_NAME_LENGTH; i++, n++) {
+		if (*(dosname+i) == ' ')
+			break;
+
+		if ((*(dosname+i) >= 'A') && (*(dosname+i) <= 'Z') && (p_dosname->name_case & 0x10))
+			*(buf+n) = *(dosname+i) + ('a' - 'A');
+		else
+			*(buf+n) = *(dosname+i);
+	}
+	*(buf+n) = '\0';
+
+	i = j = 0;
+	while (j < (MAX_NAME_LENGTH-1)) {
+		if (*(buf+i) == '\0')
+			break;
+
+		i += convert_ch_to_uni(nls, uniname, (buf+i), NULL);
+
+		uniname++;
+		j++;
+	}
+
+	*uniname = (u16) '\0';
+} /* end of nls_dosname_to_uniname */
+
+void nls_uniname_to_cstring(struct super_block *sb, u8 *p_cstring, UNI_NAME_T *p_uniname)
+{
+	int i, j, len;
+	u8 buf[MAX_CHARSET_SIZE];
+	u16 *uniname = p_uniname->name;
+	struct nls_table *nls = EXFAT_SB(sb)->nls_io;
+
+	if (nls == NULL) {
+		len = utf16s_to_utf8s(uniname, MAX_NAME_LENGTH, UTF16_HOST_ENDIAN, p_cstring, MAX_NAME_LENGTH);
+		p_cstring[len] = 0;
+		return;
+	}
+
+	i = 0;
+	while (i < (MAX_NAME_LENGTH-1)) {
+		if (*uniname == (u16) '\0')
+			break;
+
+		len = convert_uni_to_ch(nls, buf, *uniname, NULL);
+
+		if (len > 1) {
+			for (j = 0; j < len; j++)
+				*p_cstring++ = (char) *(buf+j);
+		} else { /* len == 1 */
+			*p_cstring++ = (char) *buf;
+		}
+
+		uniname++;
+		i++;
+	}
+
+	*p_cstring = '\0';
+} /* end of nls_uniname_to_cstring */
+
+void nls_cstring_to_uniname(struct super_block *sb, UNI_NAME_T *p_uniname, u8 *p_cstring, s32 *p_lossy)
+{
+	int i, j, lossy = FALSE;
+	u8 *end_of_name;
+	u8 upname[MAX_NAME_LENGTH * 2];
+	u16 *uniname = p_uniname->name;
+	struct nls_table *nls = EXFAT_SB(sb)->nls_io;
+
+
+	/* strip all trailing spaces */
+	end_of_name = p_cstring + strlen((char *) p_cstring);
+
+	while (*(--end_of_name) == ' ') {
+		if (end_of_name < p_cstring)
+			break;
+	}
+	*(++end_of_name) = '\0';
+
+	if (strcmp((char *) p_cstring, ".") && strcmp((char *) p_cstring, "..")) {
+
+		/* strip all trailing periods */
+		while (*(--end_of_name) == '.') {
+			if (end_of_name < p_cstring)
+				break;
+		}
+		*(++end_of_name) = '\0';
+	}
+
+	if (*p_cstring == '\0')
+		lossy = TRUE;
+
+	if (nls == NULL) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,101)
+		i = utf8s_to_utf16s(p_cstring, MAX_NAME_LENGTH, uniname);
+#else
+		i = utf8s_to_utf16s(p_cstring, MAX_NAME_LENGTH, UTF16_HOST_ENDIAN, uniname, MAX_NAME_LENGTH);
+#endif
+		for (j = 0; j < i; j++)
+			SET16_A(upname + j * 2, nls_upper(sb, uniname[j]));
+		uniname[i] = '\0';
+	}
+	else {
+		i = j = 0;
+		while (j < (MAX_NAME_LENGTH-1)) {
+			if (*(p_cstring+i) == '\0')
+				break;
+
+			i += convert_ch_to_uni(nls, uniname, (u8 *)(p_cstring+i), &lossy);
+
+			if ((*uniname < 0x0020) || nls_wstrchr(bad_uni_chars, *uniname))
+				lossy = TRUE;
+
+			SET16_A(upname + j * 2, nls_upper(sb, *uniname));
+
+			uniname++;
+			j++;
+		}
+
+		if (*(p_cstring+i) != '\0')
+			lossy = TRUE;
+		*uniname = (u16) '\0';
+	}
+
+	p_uniname->name_len = j;
+	p_uniname->name_hash = calc_checksum_2byte((void *) upname, j<<1, 0, CS_DEFAULT);
+
+	if (p_lossy != NULL)
+		*p_lossy = lossy;
+} /* end of nls_cstring_to_uniname */
+
+/*======================================================================*/
+/*  Local Function Definitions                                          */
+/*======================================================================*/
+
+static s32 convert_ch_to_uni(struct nls_table *nls, u16 *uni, u8 *ch, s32 *lossy)
+{
+	int len;
+
+	*uni = 0x0;
+
+	if (ch[0] < 0x80) {
+		*uni = (u16) ch[0];
+		return 1;
+	}
+
+	len = nls->char2uni(ch, NLS_MAX_CHARSET_SIZE, uni);
+	if (len < 0) {
+		/* conversion failed */
+		printk("%s: fail to use nls\n", __func__);
+		if (lossy != NULL)
+			*lossy = TRUE;
+		*uni = (u16) '_';
+		if (!strcmp(nls->charset, "utf8"))
+			return 1;
+		else
+			return 2;
+	}
+
+	return len;
+} /* end of convert_ch_to_uni */
+
+static s32 convert_uni_to_ch(struct nls_table *nls, u8 *ch, u16 uni, s32 *lossy)
+{
+	int len;
+
+	ch[0] = 0x0;
+
+	if (uni < 0x0080) {
+		ch[0] = (u8) uni;
+		return 1;
+	}
+
+	len = nls->uni2char(uni, ch, NLS_MAX_CHARSET_SIZE);
+	if (len < 0) {
+		/* conversion failed */
+		printk("%s: fail to use nls\n", __func__);
+		if (lossy != NULL)
+			*lossy = TRUE;
+		ch[0] = '_';
+		return 1;
+	}
+
+	return len;
+
+} /* end of convert_uni_to_ch */
diff --git a/kernel/fs/exfat/exfat_nls.h b/kernel/fs/exfat/exfat_nls.h
new file mode 100755
index 0000000000..bc516d762e
--- /dev/null
+++ b/kernel/fs/exfat/exfat_nls.h
@@ -0,0 +1,91 @@
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*  PROJECT : exFAT & FAT12/16/32 File System                           */
+/*  FILE    : exfat_nls.h                                               */
+/*  PURPOSE : Header File for exFAT NLS Manager                         */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  NOTES                                                               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  REVISION HISTORY (Ver 0.9)                                          */
+/*                                                                      */
+/*  - 2010.11.15 [Joosun Hahn] : first writing                          */
+/*                                                                      */
+/************************************************************************/
+
+#ifndef _EXFAT_NLS_H
+#define _EXFAT_NLS_H
+
+#include <linux/types.h>
+#include <linux/nls.h>
+
+#include "exfat_config.h"
+#include "exfat_api.h"
+
+/*----------------------------------------------------------------------*/
+/*  Constant & Macro Definitions                                        */
+/*----------------------------------------------------------------------*/
+
+#define NUM_UPCASE              2918
+
+#define DOS_CUR_DIR_NAME        ".          "
+#define DOS_PAR_DIR_NAME        "..         "
+
+#ifdef __LITTLE_ENDIAN
+#define UNI_CUR_DIR_NAME        ".\0"
+#define UNI_PAR_DIR_NAME        ".\0.\0"
+#else
+#define UNI_CUR_DIR_NAME        "\0."
+#define UNI_PAR_DIR_NAME        "\0.\0."
+#endif
+
+/*----------------------------------------------------------------------*/
+/*  Type Definitions                                                    */
+/*----------------------------------------------------------------------*/
+
+/* DOS name stucture */
+typedef struct {
+	u8       name[DOS_NAME_LENGTH];
+	u8       name_case;
+} DOS_NAME_T;
+
+/* unicode name stucture */
+typedef struct {
+	u16      name[MAX_NAME_LENGTH];
+	u16      name_hash;
+	u8       name_len;
+} UNI_NAME_T;
+
+/*----------------------------------------------------------------------*/
+/*  External Function Declarations                                      */
+/*----------------------------------------------------------------------*/
+
+/* NLS management function */
+u16 nls_upper(struct super_block *sb, u16 a);
+s32  nls_dosname_cmp(struct super_block *sb, u8 *a, u8 *b);
+s32  nls_uniname_cmp(struct super_block *sb, u16 *a, u16 *b);
+void   nls_uniname_to_dosname(struct super_block *sb, DOS_NAME_T *p_dosname, UNI_NAME_T *p_uniname, s32 *p_lossy);
+void   nls_dosname_to_uniname(struct super_block *sb, UNI_NAME_T *p_uniname, DOS_NAME_T *p_dosname);
+void   nls_uniname_to_cstring(struct super_block *sb, u8 *p_cstring, UNI_NAME_T *p_uniname);
+void   nls_cstring_to_uniname(struct super_block *sb, UNI_NAME_T *p_uniname, u8 *p_cstring, s32 *p_lossy);
+
+#endif /* _EXFAT_NLS_H */
diff --git a/kernel/fs/exfat/exfat_oal.c b/kernel/fs/exfat/exfat_oal.c
new file mode 100755
index 0000000000..743544244c
--- /dev/null
+++ b/kernel/fs/exfat/exfat_oal.c
@@ -0,0 +1,196 @@
+/* Some of the source code in this file came from "linux/fs/fat/misc.c".  */
+/*
+ *  linux/fs/fat/misc.c
+ *
+ *  Written 1992,1993 by Werner Almesberger
+ *  22/11/2000 - Fixed fat_date_unix2dos for dates earlier than 01/01/1980
+ *         and date_dos2unix for date==0 by Igor Zhbanov(bsg@uniyar.ac.ru)
+ */
+
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*  PROJECT : exFAT & FAT12/16/32 File System                           */
+/*  FILE    : exfat_oal.c                                               */
+/*  PURPOSE : exFAT OS Adaptation Layer                                 */
+/*            (Semaphore Functions & Real-Time Clock Functions)         */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  NOTES                                                               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  REVISION HISTORY (Ver 0.9)                                          */
+/*                                                                      */
+/*  - 2010.11.15 [Joosun Hahn] : first writing                          */
+/*                                                                      */
+/************************************************************************/
+
+#include <linux/semaphore.h>
+#include <linux/time.h>
+
+#include "exfat_config.h"
+#include "exfat_api.h"
+#include "exfat_oal.h"
+
+/*======================================================================*/
+/*                                                                      */
+/*            SEMAPHORE FUNCTIONS                                       */
+/*                                                                      */
+/*======================================================================*/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+DECLARE_MUTEX(z_sem);
+#else
+DEFINE_SEMAPHORE(z_sem);
+#endif
+
+s32 sm_init(struct semaphore *sm)
+{
+	sema_init(sm, 1);
+	return 0;
+} /* end of sm_init */
+
+s32 sm_P(struct semaphore *sm)
+{
+	down(sm);
+	return 0;
+} /* end of sm_P */
+
+void sm_V(struct semaphore *sm)
+{
+	up(sm);
+} /* end of sm_V */
+
+
+/*======================================================================*/
+/*                                                                      */
+/*            REAL-TIME CLOCK FUNCTIONS                                 */
+/*                                                                      */
+/*======================================================================*/
+
+extern struct timezone sys_tz;
+
+/*
+ * The epoch of FAT timestamp is 1980.
+ *     :  bits  : value
+ * date:  0 -  4: day    (1 -  31)
+ * date:  5 -  8: month  (1 -  12)
+ * date:  9 - 15: year   (0 - 127) from 1980
+ * time:  0 -  4: sec    (0 -  29) 2sec counts
+ * time:  5 - 10: min    (0 -  59)
+ * time: 11 - 15: hour   (0 -  23)
+ */
+#define UNIX_SECS_1980   315532800L
+
+#if BITS_PER_LONG == 64
+#define UNIX_SECS_2108   4354819200L
+#endif
+/* days between 1.1.70 and 1.1.80 (2 leap days) */
+#define DAYS_DELTA_DECADE	(365 * 10 + 2)
+/* 120 (2100 - 1980) isn't leap year */
+#define NO_LEAP_YEAR_2100    (120)
+#define IS_LEAP_YEAR(y)  (!((y) & 3) && (y) != NO_LEAP_YEAR_2100)
+
+#define SECS_PER_MIN     (60)
+#define SECS_PER_HOUR    (60 * SECS_PER_MIN)
+#define SECS_PER_DAY     (24 * SECS_PER_HOUR)
+
+#define MAKE_LEAP_YEAR(leap_year, year)                         \
+	do {                                                    \
+		if (unlikely(year > NO_LEAP_YEAR_2100))         \
+			leap_year = ((year + 3) / 4) - 1;       \
+		else                                            \
+			leap_year = ((year + 3) / 4);           \
+	} while (0)
+
+/* Linear day numbers of the respective 1sts in non-leap years. */
+static time_t accum_days_in_year[] = {
+	/* Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec */
+	0,   0,  31,  59,  90, 120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0,
+};
+
+TIMESTAMP_T *tm_current(TIMESTAMP_T *tp)
+{
+	struct timespec ts;
+	time_t second, day, leap_day, month, year;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,8,0)
+	ts = CURRENT_TIME_SEC;
+#else
+	ktime_get_real_ts(&ts);
+#endif
+
+	second = ts.tv_sec;
+	second -= sys_tz.tz_minuteswest * SECS_PER_MIN;
+
+	/* Jan 1 GMT 00:00:00 1980. But what about another time zone? */
+	if (second < UNIX_SECS_1980) {
+		tp->sec  = 0;
+		tp->min  = 0;
+		tp->hour = 0;
+		tp->day  = 1;
+		tp->mon  = 1;
+		tp->year = 0;
+		return tp;
+	}
+#if BITS_PER_LONG == 64
+	if (second >= UNIX_SECS_2108) {
+		tp->sec  = 59;
+		tp->min  = 59;
+		tp->hour = 23;
+		tp->day  = 31;
+		tp->mon  = 12;
+		tp->year = 127;
+		return tp;
+	}
+#endif
+
+	day = second / SECS_PER_DAY - DAYS_DELTA_DECADE;
+	year = day / 365;
+
+	MAKE_LEAP_YEAR(leap_day, year);
+	if (year * 365 + leap_day > day)
+		year--;
+
+	MAKE_LEAP_YEAR(leap_day, year);
+
+	day -= year * 365 + leap_day;
+
+	if (IS_LEAP_YEAR(year) && day == accum_days_in_year[3]) {
+		month = 2;
+	} else {
+		if (IS_LEAP_YEAR(year) && day > accum_days_in_year[3])
+			day--;
+		for (month = 1; month < 12; month++) {
+			if (accum_days_in_year[month + 1] > day)
+				break;
+		}
+	}
+	day -= accum_days_in_year[month];
+
+	tp->sec  = second % SECS_PER_MIN;
+	tp->min  = (second / SECS_PER_MIN) % 60;
+	tp->hour = (second / SECS_PER_HOUR) % 24;
+	tp->day  = day + 1;
+	tp->mon  = month;
+	tp->year = year;
+
+	return tp;
+} /* end of tm_current */
diff --git a/kernel/fs/exfat/exfat_oal.h b/kernel/fs/exfat/exfat_oal.h
new file mode 100755
index 0000000000..b6dd7897ab
--- /dev/null
+++ b/kernel/fs/exfat/exfat_oal.h
@@ -0,0 +1,74 @@
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*  PROJECT : exFAT & FAT12/16/32 File System                           */
+/*  FILE    : exfat_oal.h                                               */
+/*  PURPOSE : Header File for exFAT OS Adaptation Layer                 */
+/*            (Semaphore Functions & Real-Time Clock Functions)         */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  NOTES                                                               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  REVISION HISTORY (Ver 0.9)                                          */
+/*                                                                      */
+/*  - 2010.11.15 [Joosun Hahn] : first writing                          */
+/*                                                                      */
+/************************************************************************/
+
+#ifndef _EXFAT_OAL_H
+#define _EXFAT_OAL_H
+
+#include <linux/semaphore.h>
+#include "exfat_config.h"
+#include <linux/version.h>
+
+/*----------------------------------------------------------------------*/
+/*  Constant & Macro Definitions (Configurable)                         */
+/*----------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------*/
+/*  Constant & Macro Definitions (Non-Configurable)                     */
+/*----------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------*/
+/*  Type Definitions                                                    */
+/*----------------------------------------------------------------------*/
+
+typedef struct {
+	u16      sec;        /* 0 ~ 59               */
+	u16      min;        /* 0 ~ 59               */
+	u16      hour;       /* 0 ~ 23               */
+	u16      day;        /* 1 ~ 31               */
+	u16      mon;        /* 1 ~ 12               */
+	u16      year;       /* 0 ~ 127 (since 1980) */
+} TIMESTAMP_T;
+
+/*----------------------------------------------------------------------*/
+/*  External Function Declarations                                      */
+/*----------------------------------------------------------------------*/
+
+s32 sm_init(struct semaphore *sm);
+s32 sm_P(struct semaphore *sm);
+void  sm_V(struct semaphore *sm);
+
+TIMESTAMP_T *tm_current(TIMESTAMP_T *tm);
+
+#endif /* _EXFAT_OAL_H */
diff --git a/kernel/fs/exfat/exfat_super.c b/kernel/fs/exfat/exfat_super.c
new file mode 100755
index 0000000000..312de36f49
--- /dev/null
+++ b/kernel/fs/exfat/exfat_super.c
@@ -0,0 +1,2711 @@
+/* Some of the source code in this file came from "linux/fs/fat/file.c","linux/fs/fat/inode.c" and "linux/fs/fat/misc.c".  */
+/*
+ *  linux/fs/fat/file.c
+ *
+ *  Written 1992,1993 by Werner Almesberger
+ *
+ *  regular file handling primitives for fat-based filesystems
+ */
+
+/*
+ *  linux/fs/fat/inode.c
+ *
+ *  Written 1992,1993 by Werner Almesberger
+ *  VFAT extensions by Gordon Chaffee, merged with msdos fs by Henrik Storner
+ *  Rewritten for the constant inumbers support by Al Viro
+ *
+ *  Fixes:
+ *
+ *    Max Cohan: Fixed invalid FSINFO offset when info_sector is 0
+ */
+
+/*
+ *  linux/fs/fat/misc.c
+ *
+ *  Written 1992,1993 by Werner Almesberger
+ *  22/11/2000 - Fixed fat_date_unix2dos for dates earlier than 01/01/1980
+ *         and date_dos2unix for date==0 by Igor Zhbanov(bsg@uniyar.ac.ru)
+ */
+
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/time.h>
+#include <linux/slab.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
+#include <linux/smp_lock.h>
+#endif
+#include <linux/seq_file.h>
+#include <linux/pagemap.h>
+#include <linux/mpage.h>
+#include <linux/buffer_head.h>
+#include <linux/exportfs.h>
+#include <linux/mount.h>
+#include <linux/vfs.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+#include <linux/aio.h>
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 16, 0)
+#include <linux/iversion.h>
+#endif
+#include <linux/parser.h>
+#include <linux/uio.h>
+#include <linux/writeback.h>
+#include <linux/log2.h>
+#include <linux/hash.h>
+#include <linux/backing-dev.h>
+#include <linux/sched.h>
+#include <linux/fs_struct.h>
+#include <linux/namei.h>
+#include <asm/current.h>
+#include <asm/unaligned.h>
+
+#include "exfat_version.h"
+#include "exfat_config.h"
+#include "exfat_data.h"
+#include "exfat_oal.h"
+
+#include "exfat_blkdev.h"
+#include "exfat_cache.h"
+#include "exfat_nls.h"
+#include "exfat_api.h"
+#include "exfat_core.h"
+
+#include "exfat_super.h"
+
+static struct kmem_cache *exfat_inode_cachep;
+
+static int exfat_default_codepage = CONFIG_EXFAT_DEFAULT_CODEPAGE;
+static char exfat_default_iocharset[] = CONFIG_EXFAT_DEFAULT_IOCHARSET;
+
+extern struct timezone sys_tz;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,8,0)
+#define current_time(x)	(CURRENT_TIME_SEC)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 16, 0)
+#define USE_NEW_IVERSION_API
+#define INC_IVERSION(x) (inode_inc_iversion(x))
+#define GET_IVERSION(x) (inode_peek_iversion_raw(x))
+#define SET_IVERSION(x,y) (inode_set_iversion(x, y))
+#else
+#define INC_IVERSION(x) (x->i_version++)
+#define GET_IVERSION(x) (x->i_version)
+#define SET_IVERSION(x,y) (x->i_version = y)
+#endif
+
+#define CHECK_ERR(x)	BUG_ON(x)
+
+#define UNIX_SECS_1980    315532800L
+
+#if BITS_PER_LONG == 64
+#define UNIX_SECS_2108    4354819200L
+#endif
+/* days between 1.1.70 and 1.1.80 (2 leap days) */
+#define DAYS_DELTA_DECADE    (365 * 10 + 2)
+/* 120 (2100 - 1980) isn't leap year */
+#define NO_LEAP_YEAR_2100    (120)
+#define IS_LEAP_YEAR(y)    (!((y) & 0x3) && (y) != NO_LEAP_YEAR_2100)
+
+#define SECS_PER_MIN    (60)
+#define SECS_PER_HOUR   (60 * SECS_PER_MIN)
+#define SECS_PER_DAY    (24 * SECS_PER_HOUR)
+
+#define MAKE_LEAP_YEAR(leap_year, year)                         \
+	do {                                                    \
+		if (unlikely(year > NO_LEAP_YEAR_2100))         \
+			leap_year = ((year + 3) / 4) - 1;       \
+		else                                            \
+			leap_year = ((year + 3) / 4);           \
+	} while (0)
+
+/* Linear day numbers of the respective 1sts in non-leap years. */
+static time_t accum_days_in_year[] = {
+	/* Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec */
+	0,   0,  31,  59,  90, 120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0,
+};
+
+static void _exfat_truncate(struct inode *inode, loff_t old_size);
+
+/* Convert a FAT time/date pair to a UNIX date (seconds since 1 1 70). */
+void exfat_time_fat2unix(struct exfat_sb_info *sbi, struct timespec *ts,
+						 DATE_TIME_T *tp)
+{
+	time_t year = tp->Year;
+	time_t ld;
+
+	MAKE_LEAP_YEAR(ld, year);
+
+	if (IS_LEAP_YEAR(year) && (tp->Month) > 2)
+		ld++;
+
+	ts->tv_sec =  tp->Second  + tp->Minute * SECS_PER_MIN
+				  + tp->Hour * SECS_PER_HOUR
+				  + (year * 365 + ld + accum_days_in_year[(tp->Month)] + (tp->Day - 1) + DAYS_DELTA_DECADE) * SECS_PER_DAY
+				  + sys_tz.tz_minuteswest * SECS_PER_MIN;
+	ts->tv_nsec = 0;
+}
+
+/* Convert linear UNIX date to a FAT time/date pair. */
+void exfat_time_unix2fat(struct exfat_sb_info *sbi, struct timespec *ts,
+						 DATE_TIME_T *tp)
+{
+	time_t second = ts->tv_sec;
+	time_t day, month, year;
+	time_t ld;
+
+	second -= sys_tz.tz_minuteswest * SECS_PER_MIN;
+
+	/* Jan 1 GMT 00:00:00 1980. But what about another time zone? */
+	if (second < UNIX_SECS_1980) {
+		tp->Second  = 0;
+		tp->Minute  = 0;
+		tp->Hour = 0;
+		tp->Day  = 1;
+		tp->Month  = 1;
+		tp->Year = 0;
+		return;
+	}
+#if (BITS_PER_LONG == 64)
+	if (second >= UNIX_SECS_2108) {
+		tp->Second  = 59;
+		tp->Minute  = 59;
+		tp->Hour = 23;
+		tp->Day  = 31;
+		tp->Month  = 12;
+		tp->Year = 127;
+		return;
+	}
+#endif
+	day = second / SECS_PER_DAY - DAYS_DELTA_DECADE;
+	year = day / 365;
+	MAKE_LEAP_YEAR(ld, year);
+	if (year * 365 + ld > day)
+		year--;
+
+	MAKE_LEAP_YEAR(ld, year);
+	day -= year * 365 + ld;
+
+	if (IS_LEAP_YEAR(year) && day == accum_days_in_year[3]) {
+		month = 2;
+	} else {
+		if (IS_LEAP_YEAR(year) && day > accum_days_in_year[3])
+			day--;
+		for (month = 1; month < 12; month++) {
+			if (accum_days_in_year[month + 1] > day)
+				break;
+		}
+	}
+	day -= accum_days_in_year[month];
+
+	tp->Second  = second % SECS_PER_MIN;
+	tp->Minute  = (second / SECS_PER_MIN) % 60;
+	tp->Hour = (second / SECS_PER_HOUR) % 24;
+	tp->Day  = day + 1;
+	tp->Month  = month;
+	tp->Year = year;
+}
+
+static struct inode *exfat_iget(struct super_block *sb, loff_t i_pos);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+static int exfat_generic_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg);
+#else
+static long exfat_generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+#endif
+static int exfat_sync_inode(struct inode *inode);
+static struct inode *exfat_build_inode(struct super_block *sb, FILE_ID_T *fid, loff_t i_pos);
+static void exfat_detach(struct inode *inode);
+static void exfat_attach(struct inode *inode, loff_t i_pos);
+static inline unsigned long exfat_hash(loff_t i_pos);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34)
+static int exfat_write_inode(struct inode *inode, int wait);
+#else
+static int exfat_write_inode(struct inode *inode, struct writeback_control *wbc);
+#endif
+static void exfat_write_super(struct super_block *sb);
+
+static void __lock_super(struct super_block *sb)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+	lock_super(sb);
+#else
+	struct exfat_sb_info *sbi = EXFAT_SB(sb);
+	mutex_lock(&sbi->s_lock);
+#endif
+}
+
+static void __unlock_super(struct super_block *sb)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+	unlock_super(sb);
+#else
+	struct exfat_sb_info *sbi = EXFAT_SB(sb);
+	mutex_unlock(&sbi->s_lock);
+#endif
+}
+
+static int __is_sb_dirty(struct super_block *sb)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+	return sb->s_dirt;
+#else
+	struct exfat_sb_info *sbi = EXFAT_SB(sb);
+	return sbi->s_dirt;
+#endif
+}
+
+static void __set_sb_clean(struct super_block *sb)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+	sb->s_dirt = 0;
+#else
+	struct exfat_sb_info *sbi = EXFAT_SB(sb);
+	sbi->s_dirt = 0;
+#endif
+}
+
+static int __exfat_revalidate(struct dentry *dentry)
+{
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,00)
+static int exfat_revalidate(struct dentry *dentry, unsigned int flags)
+#else
+static int exfat_revalidate(struct dentry *dentry, struct nameidata *nd)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,00)
+	if (flags & LOOKUP_RCU)
+		return -ECHILD;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,00)
+	if (nd && nd->flags & LOOKUP_RCU)
+		return -ECHILD;
+#endif
+
+	if (dentry->d_inode)
+		return 1;
+	return __exfat_revalidate(dentry);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,00)
+static int exfat_revalidate_ci(struct dentry *dentry, unsigned int flags)
+#else
+static int exfat_revalidate_ci(struct dentry *dentry, struct nameidata *nd)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,00)
+	if (flags & LOOKUP_RCU)
+		return -ECHILD;
+#else
+	unsigned int flags;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,00)
+	if (nd && nd->flags & LOOKUP_RCU)
+		return -ECHILD;
+#endif
+
+	flags = nd ? nd->flags : 0;
+#endif
+
+	if (dentry->d_inode)
+		return 1;
+
+	if (!flags)
+		return 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,00)
+	if (flags & (LOOKUP_CREATE | LOOKUP_RENAME_TARGET))
+		return 0;
+#else
+	if (!(nd->flags & (LOOKUP_CONTINUE | LOOKUP_PARENT))) {
+		if (nd->flags & (LOOKUP_CREATE | LOOKUP_RENAME_TARGET))
+			return 0;
+	}
+#endif
+
+	return __exfat_revalidate(dentry);
+}
+
+static unsigned int __exfat_striptail_len(unsigned int len, const char *name)
+{
+	while (len && name[len - 1] == '.')
+		len--;
+	return len;
+}
+
+static unsigned int exfat_striptail_len(const struct qstr *qstr)
+{
+	return __exfat_striptail_len(qstr->len, qstr->name);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+static int exfat_d_hash(const struct dentry *dentry, struct qstr *qstr)
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+static int exfat_d_hash(struct dentry *dentry, struct qstr *qstr)
+#else
+static int exfat_d_hash(const struct dentry *dentry, const struct inode *inode,
+		struct qstr *qstr)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,8,0)
+	qstr->hash = full_name_hash(dentry, qstr->name, exfat_striptail_len(qstr));
+#else
+	qstr->hash = full_name_hash(qstr->name, exfat_striptail_len(qstr));
+#endif
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+static int exfat_d_hashi(const struct dentry *dentry, struct qstr *qstr)
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+static int exfat_d_hashi(struct dentry *dentry, struct qstr *qstr)
+#else
+static int exfat_d_hashi(const struct dentry *dentry, const struct inode *inode,
+		struct qstr *qstr)
+#endif
+{
+	struct super_block *sb = dentry->d_sb;
+	const unsigned char *name;
+	unsigned int len;
+	unsigned long hash;
+
+	name = qstr->name;
+	len = exfat_striptail_len(qstr);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,8,0)
+	hash = init_name_hash(dentry);
+#else
+	hash = init_name_hash();
+#endif
+	while (len--)
+		hash = partial_name_hash(nls_upper(sb, *name++), hash);
+	qstr->hash = end_name_hash(hash);
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,8,0)
+static int exfat_cmpi(const struct dentry *dentry,
+		unsigned int len, const char *str, const struct qstr *name)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+static int exfat_cmpi(const struct dentry *parent, const struct dentry *dentry,
+		unsigned int len, const char *str, const struct qstr *name)
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+static int exfat_cmpi(struct dentry *parent, struct qstr *a, struct qstr *b)
+#else
+static int exfat_cmpi(const struct dentry *parent, const struct inode *pinode,
+		const struct dentry *dentry, const struct inode *inode,
+		unsigned int len, const char *str, const struct qstr *name)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,8,0)
+	struct nls_table *t = EXFAT_SB(dentry->d_sb)->nls_io;
+#else
+	struct nls_table *t = EXFAT_SB(parent->d_sb)->nls_io;
+#endif
+	unsigned int alen, blen;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	alen = exfat_striptail_len(a);
+	blen = exfat_striptail_len(b);
+#else
+	alen = exfat_striptail_len(name);
+	blen = __exfat_striptail_len(len, str);
+#endif
+	if (alen == blen) {
+		if (t == NULL) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+			if (strncasecmp(a->name, b->name, alen) == 0)
+#else
+			if (strncasecmp(name->name, str, alen) == 0)
+#endif
+				return 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+		} else if (nls_strnicmp(t, a->name, b->name, alen) == 0)
+#else
+		} else if (nls_strnicmp(t, name->name, str, alen) == 0)
+#endif
+			return 0;
+	}
+	return 1;
+}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,8,0)
+static int exfat_cmp(const struct dentry *dentry,
+		unsigned int len, const char *str, const struct qstr *name)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+static int exfat_cmp(const struct dentry *parent, const struct dentry *dentry,
+		unsigned int len, const char *str, const struct qstr *name)
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+static int exfat_cmp(struct dentry *parent, struct qstr *a,
+			struct qstr *b)
+#else
+static int exfat_cmp(const struct dentry *parent, const struct inode *pinode,
+		const struct dentry *dentry, const struct inode *inode,
+		unsigned int len, const char *str, const struct qstr *name)
+#endif
+{
+	unsigned int alen, blen;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	alen = exfat_striptail_len(a);
+	blen = exfat_striptail_len(b);
+#else
+	alen = exfat_striptail_len(name);
+	blen = __exfat_striptail_len(len, str);
+#endif
+	if (alen == blen) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+		if (strncmp(a->name, b->name, alen) == 0)
+#else
+		if (strncmp(name->name, str, alen) == 0)
+#endif
+			return 0;
+	}
+	return 1;
+}
+
+static const struct dentry_operations exfat_ci_dentry_ops = {
+	.d_revalidate   = exfat_revalidate_ci,
+	.d_hash         = exfat_d_hashi,
+	.d_compare      = exfat_cmpi,
+};
+
+static const struct dentry_operations exfat_dentry_ops = {
+	.d_revalidate   = exfat_revalidate,
+	.d_hash         = exfat_d_hash,
+	.d_compare      = exfat_cmp,
+};
+
+/*======================================================================*/
+/*  Directory Entry Operations                                          */
+/*======================================================================*/
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+static int exfat_readdir(struct file *filp, struct dir_context *ctx)
+#else
+static int exfat_readdir(struct file *filp, void *dirent, filldir_t filldir)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0)
+	struct inode *inode = file_inode(filp);
+#else
+	struct inode *inode = filp->f_path.dentry->d_inode;
+#endif
+	struct super_block *sb = inode->i_sb;
+	struct exfat_sb_info *sbi = EXFAT_SB(sb);
+	FS_INFO_T *p_fs = &(sbi->fs_info);
+	BD_INFO_T *p_bd = &(EXFAT_SB(sb)->bd_info);
+	DIR_ENTRY_T de;
+	unsigned long inum;
+	loff_t cpos;
+	int err = 0;
+
+	__lock_super(sb);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+	cpos = ctx->pos;
+#else
+	cpos = filp->f_pos;
+#endif
+	/* Fake . and .. for the root directory. */
+	if ((p_fs->vol_type == EXFAT) || (inode->i_ino == EXFAT_ROOT_INO)) {
+		while (cpos < 2) {
+			if (inode->i_ino == EXFAT_ROOT_INO)
+				inum = EXFAT_ROOT_INO;
+			else if (cpos == 0)
+				inum = inode->i_ino;
+			else /* (cpos == 1) */
+				inum = parent_ino(filp->f_path.dentry);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+			if (!dir_emit_dots(filp, ctx))
+#else
+			if (filldir(dirent, "..", cpos+1, cpos, inum, DT_DIR) < 0)
+#endif
+				goto out;
+			cpos++;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+			ctx->pos++;
+#else
+			filp->f_pos++;
+#endif
+		}
+		if (cpos == 2)
+			cpos = 0;
+	}
+	if (cpos & (DENTRY_SIZE - 1)) {
+		err = -ENOENT;
+		goto out;
+	}
+
+get_new:
+	EXFAT_I(inode)->fid.size = i_size_read(inode);
+	EXFAT_I(inode)->fid.rwoffset = cpos >> DENTRY_SIZE_BITS;
+
+	err = FsReadDir(inode, &de);
+	if (err) {
+		/* at least we tried to read a sector
+		 * move cpos to next sector position (should be aligned)
+		 */
+		if (err == FFS_MEDIAERR) {
+			cpos += 1 << p_bd->sector_size_bits;
+			cpos &= ~((1 << p_bd->sector_size_bits)-1);
+		}
+
+		err = -EIO;
+		goto end_of_dir;
+	}
+
+	cpos = EXFAT_I(inode)->fid.rwoffset << DENTRY_SIZE_BITS;
+
+	if (!de.Name[0])
+		goto end_of_dir;
+
+	if (!memcmp(de.ShortName, DOS_CUR_DIR_NAME, DOS_NAME_LENGTH)) {
+		inum = inode->i_ino;
+	} else if (!memcmp(de.ShortName, DOS_PAR_DIR_NAME, DOS_NAME_LENGTH)) {
+		inum = parent_ino(filp->f_path.dentry);
+	} else {
+		loff_t i_pos = ((loff_t) EXFAT_I(inode)->fid.start_clu << 32) |
+					   ((EXFAT_I(inode)->fid.rwoffset-1) & 0xffffffff);
+
+		struct inode *tmp = exfat_iget(sb, i_pos);
+		if (tmp) {
+			inum = tmp->i_ino;
+			iput(tmp);
+		} else {
+			inum = iunique(sb, EXFAT_ROOT_INO);
+		}
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+	if (!dir_emit(ctx, de.Name, strlen(de.Name), inum,
+		(de.Attr & ATTR_SUBDIR) ? DT_DIR : DT_REG))
+#else
+	if (filldir(dirent, de.Name, strlen(de.Name), cpos-1, inum,
+				(de.Attr & ATTR_SUBDIR) ? DT_DIR : DT_REG) < 0)
+#endif
+		goto out;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+	ctx->pos = cpos;
+#else
+	filp->f_pos = cpos;
+#endif
+	goto get_new;
+
+end_of_dir:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+	ctx->pos = cpos;
+#else
+	filp->f_pos = cpos;
+#endif
+out:
+	__unlock_super(sb);
+	return err;
+}
+
+static int exfat_ioctl_volume_id(struct inode *dir)
+{
+	struct super_block *sb = dir->i_sb;
+	struct exfat_sb_info *sbi = EXFAT_SB(sb);
+	FS_INFO_T *p_fs = &(sbi->fs_info);
+
+	return p_fs->vol_id;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+static int exfat_generic_ioctl(struct inode *inode, struct file *filp,
+							   unsigned int cmd, unsigned long arg)
+#else
+static long exfat_generic_ioctl(struct file *filp,
+								unsigned int cmd, unsigned long arg)
+#endif
+{
+#if !(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36))
+    #if !(LINUX_VERSION_CODE < KERNEL_VERSION(3,18,3))
+		  struct inode *inode = filp->f_path.dentry->d_inode;
+    #else
+		  struct inode *inode = filp->f_dentry->d_inode;
+	#endif
+#endif
+#ifdef CONFIG_EXFAT_KERNEL_DEBUG
+	unsigned int flags;
+#endif /* CONFIG_EXFAT_KERNEL_DEBUG */
+
+	switch (cmd) {
+	case EXFAT_IOCTL_GET_VOLUME_ID:
+		return exfat_ioctl_volume_id(inode);
+#ifdef CONFIG_EXFAT_KERNEL_DEBUG
+	case EXFAT_IOC_GET_DEBUGFLAGS: {
+		struct super_block *sb = inode->i_sb;
+		struct exfat_sb_info *sbi = EXFAT_SB(sb);
+
+		flags = sbi->debug_flags;
+		return put_user(flags, (int __user *)arg);
+	}
+	case EXFAT_IOC_SET_DEBUGFLAGS: {
+		struct super_block *sb = inode->i_sb;
+		struct exfat_sb_info *sbi = EXFAT_SB(sb);
+
+		if (!capable(CAP_SYS_ADMIN))
+			return -EPERM;
+
+		if (get_user(flags, (int __user *) arg))
+			return -EFAULT;
+
+		__lock_super(sb);
+		sbi->debug_flags = flags;
+		__unlock_super(sb);
+
+		return 0;
+	}
+#endif /* CONFIG_EXFAT_KERNEL_DEBUG */
+	default:
+		return -ENOTTY; /* Inappropriate ioctl for device */
+	}
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
+static int exfat_file_fsync(struct file *filp, struct dentry *dentry,
+				int datasync)
+#else
+static int exfat_file_fsync(struct file *filp, int datasync)
+#endif
+{
+	struct inode *inode = filp->f_mapping->host;
+	struct super_block *sb = inode->i_sb;
+	int res, err;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
+	res = simple_fsync(filp, dentry, datasync);
+#else
+	res = generic_file_fsync(filp, datasync);
+#endif
+	err = FsSyncVol(sb, 1);
+
+	return res ? res : err;
+}
+#endif
+
+const struct file_operations exfat_dir_operations = {
+	.llseek     = generic_file_llseek,
+	.read       = generic_read_dir,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+	.iterate    = exfat_readdir,
+#else
+	.readdir    = exfat_readdir,
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+	.ioctl      = exfat_generic_ioctl,
+	.fsync      = exfat_file_fsync,
+#else
+	.unlocked_ioctl = exfat_generic_ioctl,
+	.fsync      = generic_file_fsync,
+#endif
+};
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,00)
+static int exfat_create(struct inode *dir, struct dentry *dentry, umode_t mode,
+						bool excl)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0)
+static int exfat_create(struct inode *dir, struct dentry *dentry, umode_t mode,
+						struct nameidata *nd)
+#else
+static int exfat_create(struct inode *dir, struct dentry *dentry, int mode,
+						struct nameidata *nd)
+#endif
+{
+	struct super_block *sb = dir->i_sb;
+	struct inode *inode;
+	FILE_ID_T fid;
+	loff_t i_pos;
+	int err;
+
+	__lock_super(sb);
+
+	DPRINTK("exfat_create entered\n");
+
+	err = FsCreateFile(dir, (u8 *) dentry->d_name.name, FM_REGULAR, &fid);
+	if (err) {
+		if (err == FFS_INVALIDPATH)
+			err = -EINVAL;
+		else if (err == FFS_FILEEXIST)
+			err = -EEXIST;
+		else if (err == FFS_FULL)
+			err = -ENOSPC;
+		else if (err == FFS_NAMETOOLONG)
+			err = -ENAMETOOLONG;
+		else
+			err = -EIO;
+		goto out;
+	}
+	INC_IVERSION(dir);
+	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
+	if (IS_DIRSYNC(dir))
+		(void) exfat_sync_inode(dir);
+	else
+		mark_inode_dirty(dir);
+
+	i_pos = ((loff_t) fid.dir.dir << 32) | (fid.entry & 0xffffffff);
+
+	inode = exfat_build_inode(sb, &fid, i_pos);
+	if (IS_ERR(inode)) {
+		err = PTR_ERR(inode);
+		goto out;
+	}
+	INC_IVERSION(inode);
+	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
+	/* timestamp is already written, so mark_inode_dirty() is unnecessary. */
+
+	dentry->d_time = GET_IVERSION(dentry->d_parent->d_inode);
+	d_instantiate(dentry, inode);
+
+out:
+	__unlock_super(sb);
+	DPRINTK("exfat_create exited\n");
+	return err;
+}
+
+static int exfat_find(struct inode *dir, struct qstr *qname,
+					  FILE_ID_T *fid)
+{
+	int err;
+
+	if (qname->len == 0)
+		return -ENOENT;
+
+	err = FsLookupFile(dir, (u8 *) qname->name, fid);
+	if (err)
+		return -ENOENT;
+
+	return 0;
+}
+
+static int exfat_d_anon_disconn(struct dentry *dentry)
+{
+	return IS_ROOT(dentry) && (dentry->d_flags & DCACHE_DISCONNECTED);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,00)
+static struct dentry *exfat_lookup(struct inode *dir, struct dentry *dentry,
+						   unsigned int flags)
+#else
+static struct dentry *exfat_lookup(struct inode *dir, struct dentry *dentry,
+						   struct nameidata *nd)
+#endif
+{
+	struct super_block *sb = dir->i_sb;
+	struct inode *inode;
+	struct dentry *alias;
+	int err;
+	FILE_ID_T fid;
+	loff_t i_pos;
+	u64 ret;
+	mode_t i_mode;
+
+	__lock_super(sb);
+	DPRINTK("exfat_lookup entered\n");
+	err = exfat_find(dir, &dentry->d_name, &fid);
+	if (err) {
+		if (err == -ENOENT) {
+			inode = NULL;
+			goto out;
+		}
+		goto error;
+	}
+
+	i_pos = ((loff_t) fid.dir.dir << 32) | (fid.entry & 0xffffffff);
+	inode = exfat_build_inode(sb, &fid, i_pos);
+	if (IS_ERR(inode)) {
+		err = PTR_ERR(inode);
+		goto error;
+	}
+
+	i_mode = inode->i_mode;
+	if (S_ISLNK(i_mode) && !EXFAT_I(inode)->target) {
+		EXFAT_I(inode)->target = kmalloc(i_size_read(inode)+1, GFP_KERNEL);
+		if (!EXFAT_I(inode)->target) {
+			err = -ENOMEM;
+			goto error;
+		}
+		FsReadFile(dir, &fid, EXFAT_I(inode)->target, i_size_read(inode), &ret);
+		*(EXFAT_I(inode)->target + i_size_read(inode)) = '\0';
+	}
+
+	alias = d_find_alias(inode);
+	if (alias && !exfat_d_anon_disconn(alias)) {
+		CHECK_ERR(d_unhashed(alias));
+		if (!S_ISDIR(i_mode))
+			d_move(alias, dentry);
+		iput(inode);
+		__unlock_super(sb);
+		DPRINTK("exfat_lookup exited 1\n");
+		return alias;
+	} else {
+		dput(alias);
+	}
+out:
+	__unlock_super(sb);
+	dentry->d_time = GET_IVERSION(dentry->d_parent->d_inode);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	dentry->d_op = sb->s_root->d_op;
+	dentry = d_splice_alias(inode, dentry);
+	if (dentry) {
+		dentry->d_op = sb->s_root->d_op;
+		dentry->d_time = GET_IVERSION(dentry->d_parent->d_inode);
+	}
+#else
+	dentry = d_splice_alias(inode, dentry);
+	if (dentry)
+		dentry->d_time = GET_IVERSION(dentry->d_parent->d_inode);
+#endif
+	DPRINTK("exfat_lookup exited 2\n");
+	return dentry;
+
+error:
+	__unlock_super(sb);
+	DPRINTK("exfat_lookup exited 3\n");
+	return ERR_PTR(err);
+}
+
+static int exfat_unlink(struct inode *dir, struct dentry *dentry)
+{
+	struct inode *inode = dentry->d_inode;
+	struct super_block *sb = dir->i_sb;
+	int err;
+
+	__lock_super(sb);
+
+	DPRINTK("exfat_unlink entered\n");
+
+	EXFAT_I(inode)->fid.size = i_size_read(inode);
+
+	err = FsRemoveFile(dir, &(EXFAT_I(inode)->fid));
+	if (err) {
+		if (err == FFS_PERMISSIONERR)
+			err = -EPERM;
+		else
+			err = -EIO;
+		goto out;
+	}
+	INC_IVERSION(dir);
+	dir->i_mtime = dir->i_atime = current_time(dir);
+	if (IS_DIRSYNC(dir))
+		(void) exfat_sync_inode(dir);
+	else
+		mark_inode_dirty(dir);
+
+	clear_nlink(inode);
+	inode->i_mtime = inode->i_atime = current_time(inode);
+	exfat_detach(inode);
+	remove_inode_hash(inode);
+
+out:
+	__unlock_super(sb);
+	DPRINTK("exfat_unlink exited\n");
+	return err;
+}
+
+static int exfat_symlink(struct inode *dir, struct dentry *dentry, const char *target)
+{
+	struct super_block *sb = dir->i_sb;
+	struct inode *inode;
+	FILE_ID_T fid;
+	loff_t i_pos;
+	int err;
+	u64 len = (u64) strlen(target);
+	u64 ret;
+
+	__lock_super(sb);
+
+	DPRINTK("exfat_symlink entered\n");
+
+	err = FsCreateFile(dir, (u8 *) dentry->d_name.name, FM_SYMLINK, &fid);
+	if (err) {
+		if (err == FFS_INVALIDPATH)
+			err = -EINVAL;
+		else if (err == FFS_FILEEXIST)
+			err = -EEXIST;
+		else if (err == FFS_FULL)
+			err = -ENOSPC;
+		else
+			err = -EIO;
+		goto out;
+	}
+
+	err = FsWriteFile(dir, &fid, (char *) target, len, &ret);
+
+	if (err) {
+		FsRemoveFile(dir, &fid);
+
+		if (err == FFS_FULL)
+			err = -ENOSPC;
+		else
+			err = -EIO;
+		goto out;
+	}
+
+	INC_IVERSION(dir);
+	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
+	if (IS_DIRSYNC(dir))
+		(void) exfat_sync_inode(dir);
+	else
+		mark_inode_dirty(dir);
+
+	i_pos = ((loff_t) fid.dir.dir << 32) | (fid.entry & 0xffffffff);
+
+	inode = exfat_build_inode(sb, &fid, i_pos);
+	if (IS_ERR(inode)) {
+		err = PTR_ERR(inode);
+		goto out;
+	}
+	INC_IVERSION(inode);
+	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
+	/* timestamp is already written, so mark_inode_dirty() is unneeded. */
+
+	EXFAT_I(inode)->target = kmalloc(len+1, GFP_KERNEL);
+	if (!EXFAT_I(inode)->target) {
+		err = -ENOMEM;
+		goto out;
+	}
+	memcpy(EXFAT_I(inode)->target, target, len+1);
+
+	dentry->d_time = GET_IVERSION(dentry->d_parent->d_inode);
+	d_instantiate(dentry, inode);
+
+out:
+	__unlock_super(sb);
+	DPRINTK("exfat_symlink exited\n");
+	return err;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0)
+static int exfat_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
+#else
+static int exfat_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+#endif
+{
+	struct super_block *sb = dir->i_sb;
+	struct inode *inode;
+	FILE_ID_T fid;
+	loff_t i_pos;
+	int err;
+
+	__lock_super(sb);
+
+	DPRINTK("exfat_mkdir entered\n");
+
+	err = FsCreateDir(dir, (u8 *) dentry->d_name.name, &fid);
+	if (err) {
+		if (err == FFS_INVALIDPATH)
+			err = -EINVAL;
+		else if (err == FFS_FILEEXIST)
+			err = -EEXIST;
+		else if (err == FFS_FULL)
+			err = -ENOSPC;
+		else if (err == FFS_NAMETOOLONG)
+			err = -ENAMETOOLONG;
+		else
+			err = -EIO;
+		goto out;
+	}
+	INC_IVERSION(dir);
+	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
+	if (IS_DIRSYNC(dir))
+		(void) exfat_sync_inode(dir);
+	else
+		mark_inode_dirty(dir);
+	inc_nlink(dir);
+
+	i_pos = ((loff_t) fid.dir.dir << 32) | (fid.entry & 0xffffffff);
+
+	inode = exfat_build_inode(sb, &fid, i_pos);
+	if (IS_ERR(inode)) {
+		err = PTR_ERR(inode);
+		goto out;
+	}
+	INC_IVERSION(inode);
+	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
+	/* timestamp is already written, so mark_inode_dirty() is unneeded. */
+
+	dentry->d_time = GET_IVERSION(dentry->d_parent->d_inode);
+	d_instantiate(dentry, inode);
+
+out:
+	__unlock_super(sb);
+	DPRINTK("exfat_mkdir exited\n");
+	return err;
+}
+
+static int exfat_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	struct inode *inode = dentry->d_inode;
+	struct super_block *sb = dir->i_sb;
+	int err;
+
+	__lock_super(sb);
+
+	DPRINTK("exfat_rmdir entered\n");
+
+	EXFAT_I(inode)->fid.size = i_size_read(inode);
+
+	err = FsRemoveDir(dir, &(EXFAT_I(inode)->fid));
+	if (err) {
+		if (err == FFS_INVALIDPATH)
+			err = -EINVAL;
+		else if (err == FFS_FILEEXIST)
+			err = -ENOTEMPTY;
+		else if (err == FFS_NOTFOUND)
+			err = -ENOENT;
+		else if (err == FFS_DIRBUSY)
+			err = -EBUSY;
+		else
+			err = -EIO;
+		goto out;
+	}
+	INC_IVERSION(dir);
+	dir->i_mtime = dir->i_atime = current_time(dir);
+	if (IS_DIRSYNC(dir))
+		(void) exfat_sync_inode(dir);
+	else
+		mark_inode_dirty(dir);
+	drop_nlink(dir);
+
+	clear_nlink(inode);
+	inode->i_mtime = inode->i_atime = current_time(inode);
+	exfat_detach(inode);
+	remove_inode_hash(inode);
+
+out:
+	__unlock_super(sb);
+	DPRINTK("exfat_rmdir exited\n");
+	return err;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,9,0)
+static int exfat_rename(struct inode *old_dir, struct dentry *old_dentry,
+						struct inode *new_dir, struct dentry *new_dentry,
+						unsigned int flags)
+#else
+static int exfat_rename(struct inode *old_dir, struct dentry *old_dentry,
+						struct inode *new_dir, struct dentry *new_dentry)
+#endif
+{
+	struct inode *old_inode, *new_inode;
+	struct super_block *sb = old_dir->i_sb;
+	loff_t i_pos;
+	int err;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,9,0)
+	if (flags)
+		return -EINVAL;
+#endif
+
+	__lock_super(sb);
+
+	DPRINTK("exfat_rename entered\n");
+
+	old_inode = old_dentry->d_inode;
+	new_inode = new_dentry->d_inode;
+
+	EXFAT_I(old_inode)->fid.size = i_size_read(old_inode);
+
+	err = FsMoveFile(old_dir, &(EXFAT_I(old_inode)->fid), new_dir, new_dentry);
+	if (err) {
+		if (err == FFS_PERMISSIONERR)
+			err = -EPERM;
+		else if (err == FFS_INVALIDPATH)
+			err = -EINVAL;
+		else if (err == FFS_FILEEXIST)
+			err = -EEXIST;
+		else if (err == FFS_NOTFOUND)
+			err = -ENOENT;
+		else if (err == FFS_FULL)
+			err = -ENOSPC;
+		else
+			err = -EIO;
+		goto out;
+	}
+	INC_IVERSION(new_dir);
+	new_dir->i_ctime = new_dir->i_mtime = new_dir->i_atime = current_time(new_dir);
+	if (IS_DIRSYNC(new_dir))
+		(void) exfat_sync_inode(new_dir);
+	else
+		mark_inode_dirty(new_dir);
+
+	i_pos = ((loff_t) EXFAT_I(old_inode)->fid.dir.dir << 32) |
+			(EXFAT_I(old_inode)->fid.entry & 0xffffffff);
+
+	exfat_detach(old_inode);
+	exfat_attach(old_inode, i_pos);
+	if (IS_DIRSYNC(new_dir))
+		(void) exfat_sync_inode(old_inode);
+	else
+		mark_inode_dirty(old_inode);
+
+	if ((S_ISDIR(old_inode->i_mode)) && (old_dir != new_dir)) {
+		drop_nlink(old_dir);
+		if (!new_inode)
+			inc_nlink(new_dir);
+	}
+	INC_IVERSION(old_dir);
+	old_dir->i_ctime = old_dir->i_mtime = current_time(old_dir);
+	if (IS_DIRSYNC(old_dir))
+		(void) exfat_sync_inode(old_dir);
+	else
+		mark_inode_dirty(old_dir);
+
+	if (new_inode) {
+		exfat_detach(new_inode);
+		drop_nlink(new_inode);
+		if (S_ISDIR(new_inode->i_mode))
+			drop_nlink(new_inode);
+		new_inode->i_ctime = current_time(new_inode);
+	}
+
+out:
+	__unlock_super(sb);
+	DPRINTK("exfat_rename exited\n");
+	return err;
+}
+
+static int exfat_cont_expand(struct inode *inode, loff_t size)
+{
+	struct address_space *mapping = inode->i_mapping;
+	loff_t start = i_size_read(inode), count = size - i_size_read(inode);
+	int err, err2;
+
+	err = generic_cont_expand_simple(inode, size);
+	if (err != 0)
+		return err;
+
+	inode->i_ctime = inode->i_mtime = current_time(inode);
+	mark_inode_dirty(inode);
+
+	if (IS_SYNC(inode)) {
+		err = filemap_fdatawrite_range(mapping, start, start + count - 1);
+		err2 = sync_mapping_buffers(mapping);
+		err = (err) ? (err) : (err2);
+		err2 = write_inode_now(inode, 1);
+		err = (err) ? (err) : (err2);
+		if (!err)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+			err =  wait_on_page_writeback_range(mapping,
+					start >> PAGE_CACHE_SHIFT,
+					(start + count - 1) >> PAGE_CACHE_SHIFT);
+#else
+			err =  filemap_fdatawait_range(mapping, start, start + count - 1);
+#endif
+	}
+	return err;
+}
+
+static int exfat_allow_set_time(struct exfat_sb_info *sbi, struct inode *inode)
+{
+	mode_t allow_utime = sbi->options.allow_utime;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+	if (!uid_eq(current_fsuid(), inode->i_uid))
+#else
+	if (current_fsuid() != inode->i_uid)
+#endif
+	{
+		if (in_group_p(inode->i_gid))
+			allow_utime >>= 3;
+		if (allow_utime & MAY_WRITE)
+			return 1;
+	}
+
+	/* use a default check */
+	return 0;
+}
+
+static int exfat_sanitize_mode(const struct exfat_sb_info *sbi,
+							   struct inode *inode, umode_t *mode_ptr)
+{
+	mode_t i_mode, mask, perm;
+
+	i_mode = inode->i_mode;
+
+	if (S_ISREG(i_mode) || S_ISLNK(i_mode))
+		mask = sbi->options.fs_fmask;
+	else
+		mask = sbi->options.fs_dmask;
+
+	perm = *mode_ptr & ~(S_IFMT | mask);
+
+	/* Of the r and x bits, all (subject to umask) must be present.*/
+	if ((perm & (S_IRUGO | S_IXUGO)) != (i_mode & (S_IRUGO|S_IXUGO)))
+		return -EPERM;
+
+	if (exfat_mode_can_hold_ro(inode)) {
+		/* Of the w bits, either all (subject to umask) or none must be present. */
+		if ((perm & S_IWUGO) && ((perm & S_IWUGO) != (S_IWUGO & ~mask)))
+			return -EPERM;
+	} else {
+		/* If exfat_mode_can_hold_ro(inode) is false, can't change w bits. */
+		if ((perm & S_IWUGO) != (S_IWUGO & ~mask))
+			return -EPERM;
+	}
+
+	*mode_ptr &= S_IFMT | perm;
+
+	return 0;
+}
+
+static int exfat_setattr(struct dentry *dentry, struct iattr *attr)
+{
+
+	struct exfat_sb_info *sbi = EXFAT_SB(dentry->d_sb);
+	struct inode *inode = dentry->d_inode;
+	unsigned int ia_valid;
+	int error;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+	loff_t old_size;
+#endif
+
+	DPRINTK("exfat_setattr entered\n");
+
+	if ((attr->ia_valid & ATTR_SIZE)
+		&& (attr->ia_size > i_size_read(inode))) {
+		error = exfat_cont_expand(inode, attr->ia_size);
+		if (error || attr->ia_valid == ATTR_SIZE)
+			return error;
+		attr->ia_valid &= ~ATTR_SIZE;
+	}
+
+	ia_valid = attr->ia_valid;
+
+	if ((ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET))
+		&& exfat_allow_set_time(sbi, inode)) {
+		attr->ia_valid &= ~(ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET);
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,9,0)
+	error = setattr_prepare(dentry, attr);
+#else
+	error = inode_change_ok(inode, attr);
+#endif
+	attr->ia_valid = ia_valid;
+	if (error)
+		return error;
+
+	if (((attr->ia_valid & ATTR_UID) &&
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+		 (!uid_eq(attr->ia_uid, sbi->options.fs_uid))) ||
+		((attr->ia_valid & ATTR_GID) &&
+		 (!gid_eq(attr->ia_gid, sbi->options.fs_gid))) ||
+#else
+		 (attr->ia_uid != sbi->options.fs_uid)) ||
+		((attr->ia_valid & ATTR_GID) &&
+		 (attr->ia_gid != sbi->options.fs_gid)) ||
+#endif
+		((attr->ia_valid & ATTR_MODE) &&
+		 (attr->ia_mode & ~(S_IFREG | S_IFLNK | S_IFDIR | S_IRWXUGO)))) {
+		return -EPERM;
+	}
+
+	/*
+	 * We don't return -EPERM here. Yes, strange, but this is too
+	 * old behavior.
+	 */
+	if (attr->ia_valid & ATTR_MODE) {
+		if (exfat_sanitize_mode(sbi, inode, &attr->ia_mode) < 0)
+			attr->ia_valid &= ~ATTR_MODE;
+	}
+
+	EXFAT_I(inode)->fid.size = i_size_read(inode);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+	if (attr->ia_valid)
+		error = inode_setattr(inode, attr);
+#else
+	if (attr->ia_valid & ATTR_SIZE) {
+		old_size = i_size_read(inode);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,00)
+		down_write(&EXFAT_I(inode)->truncate_lock);
+		truncate_setsize(inode, attr->ia_size);
+		_exfat_truncate(inode, old_size);
+		up_write(&EXFAT_I(inode)->truncate_lock);
+#else
+		truncate_setsize(inode, attr->ia_size);
+		_exfat_truncate(inode, old_size);
+#endif
+	}
+	setattr_copy(inode, attr);
+	mark_inode_dirty(inode);
+#endif
+
+	DPRINTK("exfat_setattr exited\n");
+	return error;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+static int exfat_getattr(const struct path *path, struct kstat *stat,
+			 u32 request_mask, unsigned int flags)
+{
+	struct inode *inode = path->dentry->d_inode;
+#else
+static int exfat_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
+{
+	struct inode *inode = dentry->d_inode;
+#endif
+
+	DPRINTK("exfat_getattr entered\n");
+
+	generic_fillattr(inode, stat);
+	stat->blksize = EXFAT_SB(inode->i_sb)->fs_info.cluster_size;
+
+	DPRINTK("exfat_getattr exited\n");
+	return 0;
+}
+
+const struct inode_operations exfat_dir_inode_operations = {
+	.create        = exfat_create,
+	.lookup        = exfat_lookup,
+	.unlink        = exfat_unlink,
+	.symlink       = exfat_symlink,
+	.mkdir         = exfat_mkdir,
+	.rmdir         = exfat_rmdir,
+	.rename        = exfat_rename,
+	.setattr       = exfat_setattr,
+	.getattr       = exfat_getattr,
+};
+
+/*======================================================================*/
+/*  File Operations                                                     */
+/*======================================================================*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,5,0)
+static const char *exfat_get_link(struct dentry *dentry, struct inode *inode, struct delayed_call *done)
+{
+	struct exfat_inode_info *ei = EXFAT_I(inode);
+	if (ei->target != NULL) {
+		char *cookie = ei->target;
+		if (cookie != NULL) {
+			return (char *)(ei->target);
+		}
+	}
+	return NULL;
+}
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(4,1,0)
+static const char *exfat_follow_link(struct dentry *dentry, void **cookie)
+{
+	struct exfat_inode_info *ei = EXFAT_I(dentry->d_inode);
+	return *cookie = (char *)(ei->target);
+}
+#else
+static void *exfat_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	struct exfat_inode_info *ei = EXFAT_I(dentry->d_inode);
+	nd_set_link(nd, (char *)(ei->target));
+	return NULL;
+}
+#endif
+
+const struct inode_operations exfat_symlink_inode_operations = {
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+		.readlink    = generic_readlink,
+	#endif
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+		.follow_link = exfat_follow_link,
+	#endif
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,5,0)
+		.get_link = exfat_get_link,
+	#endif
+};
+
+static int exfat_file_release(struct inode *inode, struct file *filp)
+{
+	struct super_block *sb = inode->i_sb;
+
+	EXFAT_I(inode)->fid.size = i_size_read(inode);
+	FsSyncVol(sb, 0);
+	return 0;
+}
+
+const struct file_operations exfat_file_operations = {
+	.llseek      = generic_file_llseek,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,16,0)
+	.read        = do_sync_read,
+	.write       = do_sync_write,
+	.aio_read    = generic_file_aio_read,
+	.aio_write   = generic_file_aio_write,
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,1,0)
+	.read        = new_sync_read,
+	.write       = new_sync_write,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,16,0)
+	.read_iter   = generic_file_read_iter,
+	.write_iter  = generic_file_write_iter,
+#endif
+	.mmap        = generic_file_mmap,
+	.release     = exfat_file_release,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+	.ioctl       = exfat_generic_ioctl,
+	.fsync       = exfat_file_fsync,
+#else
+	.unlocked_ioctl  = exfat_generic_ioctl,
+	.fsync       = generic_file_fsync,
+#endif
+	.splice_read = generic_file_splice_read,
+};
+
+static void _exfat_truncate(struct inode *inode, loff_t old_size)
+{
+	struct super_block *sb = inode->i_sb;
+	struct exfat_sb_info *sbi = EXFAT_SB(sb);
+	FS_INFO_T *p_fs = &(sbi->fs_info);
+	int err;
+
+	__lock_super(sb);
+
+	/*
+	 * This protects against truncating a file bigger than it was then
+	 * trying to write into the hole.
+	 */
+	if (EXFAT_I(inode)->mmu_private > i_size_read(inode))
+		EXFAT_I(inode)->mmu_private = i_size_read(inode);
+
+	if (EXFAT_I(inode)->fid.start_clu == 0)
+		goto out;
+
+	err = FsTruncateFile(inode, old_size, i_size_read(inode));
+	if (err)
+		goto out;
+
+	inode->i_ctime = inode->i_mtime = current_time(inode);
+	if (IS_DIRSYNC(inode))
+		(void) exfat_sync_inode(inode);
+	else
+		mark_inode_dirty(inode);
+
+	inode->i_blocks = ((i_size_read(inode) + (p_fs->cluster_size - 1))
+					   & ~((loff_t)p_fs->cluster_size - 1)) >> 9;
+out:
+	__unlock_super(sb);
+}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,36)
+static void exfat_truncate(struct inode *inode)
+{
+	_exfat_truncate(inode, i_size_read(inode));
+}
+#endif
+
+const struct inode_operations exfat_file_inode_operations = {
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,36)
+	.truncate    = exfat_truncate,
+#endif
+	.setattr     = exfat_setattr,
+	.getattr     = exfat_getattr,
+};
+
+/*======================================================================*/
+/*  Address Space Operations                                            */
+/*======================================================================*/
+
+static int exfat_bmap(struct inode *inode, sector_t sector, sector_t *phys,
+					  unsigned long *mapped_blocks, int *create)
+{
+	struct super_block *sb = inode->i_sb;
+	struct exfat_sb_info *sbi = EXFAT_SB(sb);
+	FS_INFO_T *p_fs = &(sbi->fs_info);
+	BD_INFO_T *p_bd = &(sbi->bd_info);
+	const unsigned long blocksize = sb->s_blocksize;
+	const unsigned char blocksize_bits = sb->s_blocksize_bits;
+	sector_t last_block;
+	int err, clu_offset, sec_offset;
+	unsigned int cluster;
+
+	*phys = 0;
+	*mapped_blocks = 0;
+
+	if ((p_fs->vol_type == FAT12) || (p_fs->vol_type == FAT16)) {
+		if (inode->i_ino == EXFAT_ROOT_INO) {
+			if (sector < (p_fs->dentries_in_root >> (p_bd->sector_size_bits-DENTRY_SIZE_BITS))) {
+				*phys = sector + p_fs->root_start_sector;
+				*mapped_blocks = 1;
+			}
+			return 0;
+		}
+	}
+
+	last_block = (i_size_read(inode) + (blocksize - 1)) >> blocksize_bits;
+	if (sector >= last_block) {
+		if (*create == 0)
+			return 0;
+	} else {
+		*create = 0;
+	}
+
+	clu_offset = sector >> p_fs->sectors_per_clu_bits;  /* cluster offset */
+	sec_offset = sector & (p_fs->sectors_per_clu - 1);  /* sector offset in cluster */
+
+	EXFAT_I(inode)->fid.size = i_size_read(inode);
+
+	err = FsMapCluster(inode, clu_offset, &cluster);
+
+	if (err) {
+		if (err == FFS_FULL)
+			return -ENOSPC;
+		else
+			return -EIO;
+	} else if (cluster != CLUSTER_32(~0)) {
+		*phys = START_SECTOR(cluster) + sec_offset;
+		*mapped_blocks = p_fs->sectors_per_clu - sec_offset;
+	}
+
+	return 0;
+}
+
+static int exfat_get_block(struct inode *inode, sector_t iblock,
+						   struct buffer_head *bh_result, int create)
+{
+	struct super_block *sb = inode->i_sb;
+	unsigned long max_blocks = bh_result->b_size >> inode->i_blkbits;
+	int err;
+	unsigned long mapped_blocks;
+	sector_t phys;
+
+	__lock_super(sb);
+
+	err = exfat_bmap(inode, iblock, &phys, &mapped_blocks, &create);
+	if (err) {
+		__unlock_super(sb);
+		return err;
+	}
+
+	if (phys) {
+		max_blocks = min(mapped_blocks, max_blocks);
+		if (create) {
+			EXFAT_I(inode)->mmu_private += max_blocks << sb->s_blocksize_bits;
+			set_buffer_new(bh_result);
+		}
+		map_bh(bh_result, sb, phys);
+	}
+
+	bh_result->b_size = max_blocks << sb->s_blocksize_bits;
+	__unlock_super(sb);
+
+	return 0;
+}
+
+static int exfat_readpage(struct file *file, struct page *page)
+{
+	int ret;
+	ret =  mpage_readpage(page, exfat_get_block);
+	return ret;
+}
+
+static int exfat_readpages(struct file *file, struct address_space *mapping,
+				   struct list_head *pages, unsigned nr_pages)
+{
+	int ret;
+	ret =  mpage_readpages(mapping, pages, nr_pages, exfat_get_block);
+	return ret;
+}
+
+static int exfat_writepage(struct page *page, struct writeback_control *wbc)
+{
+	int ret;
+	ret = block_write_full_page(page, exfat_get_block, wbc);
+	return ret;
+}
+
+static int exfat_writepages(struct address_space *mapping,
+						struct writeback_control *wbc)
+{
+	int ret;
+	ret = mpage_writepages(mapping, wbc, exfat_get_block);
+	return ret;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,34)
+static void exfat_write_failed(struct address_space *mapping, loff_t to)
+{
+	struct inode *inode = mapping->host;
+	if (to > i_size_read(inode)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0)
+		truncate_pagecache(inode, i_size_read(inode));
+#else
+		truncate_pagecache(inode, to, i_size_read(inode));
+#endif
+		EXFAT_I(inode)->fid.size = i_size_read(inode);
+		_exfat_truncate(inode, i_size_read(inode));
+	}
+}
+#endif
+
+static int exfat_write_begin(struct file *file, struct address_space *mapping,
+				 loff_t pos, unsigned len, unsigned flags,
+					 struct page **pagep, void **fsdata)
+{
+	int ret;
+	*pagep = NULL;
+	ret = cont_write_begin(file, mapping, pos, len, flags, pagep, fsdata,
+				   exfat_get_block,
+				   &EXFAT_I(mapping->host)->mmu_private);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,34)
+	if (ret < 0)
+		exfat_write_failed(mapping, pos+len);
+#endif
+	return ret;
+}
+
+static int exfat_write_end(struct file *file, struct address_space *mapping,
+				   loff_t pos, unsigned len, unsigned copied,
+					   struct page *pagep, void *fsdata)
+{
+	struct inode *inode = mapping->host;
+	FILE_ID_T *fid = &(EXFAT_I(inode)->fid);
+	int err;
+
+	err = generic_write_end(file, mapping, pos, len, copied, pagep, fsdata);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,34)
+	if (err < len)
+		exfat_write_failed(mapping, pos+len);
+#endif
+
+	if (!(err < 0) && !(fid->attr & ATTR_ARCHIVE)) {
+		inode->i_mtime = inode->i_ctime = current_time(inode);
+		fid->attr |= ATTR_ARCHIVE;
+		mark_inode_dirty(inode);
+	}
+	return err;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,16,0)
+#ifdef CONFIG_AIO_OPTIMIZATION
+static ssize_t exfat_direct_IO(int rw, struct kiocb *iocb,
+						struct iov_iter *iter, loff_t offset)
+#else
+static ssize_t exfat_direct_IO(int rw, struct kiocb *iocb,
+					   const struct iovec *iov,
+					   loff_t offset, unsigned long nr_segs)
+#endif
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,2,0)
+static ssize_t exfat_direct_IO(int rw, struct kiocb *iocb,
+					   struct iov_iter *iter, loff_t offset)
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+static ssize_t exfat_direct_IO(struct kiocb *iocb,
+					   struct iov_iter *iter, loff_t offset)
+#else /* >= 4.7.x */
+static ssize_t exfat_direct_IO(struct kiocb *iocb, struct iov_iter *iter)
+#endif
+{
+	struct inode *inode = iocb->ki_filp->f_mapping->host;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,34)
+	struct address_space *mapping = iocb->ki_filp->f_mapping;
+#endif
+	ssize_t ret;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,2,0)
+	int rw;
+
+	rw = iov_iter_rw(iter);
+#endif
+
+	if (rw == WRITE) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,16,0)
+#ifdef CONFIG_AIO_OPTIMIZATION
+		if (EXFAT_I(inode)->mmu_private <
+					(offset + iov_iter_count(iter)))
+#else
+		if (EXFAT_I(inode)->mmu_private < (offset + iov_length(iov, nr_segs)))
+#endif
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+		if (EXFAT_I(inode)->mmu_private < (offset + iov_iter_count(iter)))
+#else
+		if (EXFAT_I(inode)->mmu_private < iov_iter_count(iter))
+#endif
+			return 0;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,7,0)
+	ret = blockdev_direct_IO(iocb, inode, iter, exfat_get_block);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0)
+	ret = blockdev_direct_IO(iocb, inode, iter,
+					offset, exfat_get_block);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3,16,0)
+	ret = blockdev_direct_IO(rw, iocb, inode, iter,
+					offset, exfat_get_block);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3,1,0)
+#ifdef CONFIG_AIO_OPTIMIZATION
+	ret = blockdev_direct_IO(rw, iocb, inode, iter,
+					offset, exfat_get_block);
+#else
+	ret = blockdev_direct_IO(rw, iocb, inode, iov,
+					offset, nr_segs, exfat_get_block);
+#endif
+#else
+        ret = blockdev_direct_IO(rw, iocb, inode, inode->i_sb->s_bdev, iov,
+					offset, nr_segs, exfat_get_block, NULL);
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,7,0)
+	if ((ret < 0) && (rw & WRITE))
+		exfat_write_failed(mapping, iov_iter_count(iter));
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3,16,0)
+	if ((ret < 0) && (rw & WRITE))
+		exfat_write_failed(mapping, offset+iov_iter_count(iter));
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,6,34)
+	if ((ret < 0) && (rw & WRITE))
+#ifdef CONFIG_AIO_OPTIMIZATION
+		exfat_write_failed(mapping, offset+iov_iter_count(iter));
+#else
+		exfat_write_failed(mapping, offset+iov_length(iov, nr_segs));
+#endif
+#endif
+	return ret;
+}
+
+static sector_t _exfat_bmap(struct address_space *mapping, sector_t block)
+{
+	sector_t blocknr;
+
+	/* exfat_get_cluster() assumes the requested blocknr isn't truncated. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,00)
+	down_read(&EXFAT_I(mapping->host)->truncate_lock);
+	blocknr = generic_block_bmap(mapping, block, exfat_get_block);
+	up_read(&EXFAT_I(mapping->host)->truncate_lock);
+#else
+	down_read(&EXFAT_I(mapping->host)->i_alloc_sem);
+	blocknr = generic_block_bmap(mapping, block, exfat_get_block);
+	up_read(&EXFAT_I(mapping->host)->i_alloc_sem);
+#endif
+
+	return blocknr;
+}
+
+const struct address_space_operations exfat_aops = {
+	.readpage    = exfat_readpage,
+	.readpages   = exfat_readpages,
+	.writepage   = exfat_writepage,
+	.writepages  = exfat_writepages,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)
+	.sync_page   = block_sync_page,
+#endif
+	.write_begin = exfat_write_begin,
+	.write_end   = exfat_write_end,
+	.direct_IO   = exfat_direct_IO,
+	.bmap        = _exfat_bmap
+};
+
+/*======================================================================*/
+/*  Super Operations                                                    */
+/*======================================================================*/
+
+static inline unsigned long exfat_hash(loff_t i_pos)
+{
+	return hash_32(i_pos, EXFAT_HASH_BITS);
+}
+
+static struct inode *exfat_iget(struct super_block *sb, loff_t i_pos)
+{
+	struct exfat_sb_info *sbi = EXFAT_SB(sb);
+	struct exfat_inode_info *info;
+	struct hlist_head *head = sbi->inode_hashtable + exfat_hash(i_pos);
+	struct inode *inode = NULL;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,9,0)
+	struct hlist_node *node;
+
+	spin_lock(&sbi->inode_hash_lock);
+	hlist_for_each_entry(info, node, head, i_hash_fat) {
+#else
+	spin_lock(&sbi->inode_hash_lock);
+	hlist_for_each_entry(info, head, i_hash_fat) {
+#endif
+		CHECK_ERR(info->vfs_inode.i_sb != sb);
+
+		if (i_pos != info->i_pos)
+			continue;
+		inode = igrab(&info->vfs_inode);
+		if (inode)
+			break;
+	}
+	spin_unlock(&sbi->inode_hash_lock);
+	return inode;
+}
+
+static void exfat_attach(struct inode *inode, loff_t i_pos)
+{
+	struct exfat_sb_info *sbi = EXFAT_SB(inode->i_sb);
+	struct hlist_head *head = sbi->inode_hashtable + exfat_hash(i_pos);
+
+	spin_lock(&sbi->inode_hash_lock);
+	EXFAT_I(inode)->i_pos = i_pos;
+	hlist_add_head(&EXFAT_I(inode)->i_hash_fat, head);
+	spin_unlock(&sbi->inode_hash_lock);
+}
+
+static void exfat_detach(struct inode *inode)
+{
+	struct exfat_sb_info *sbi = EXFAT_SB(inode->i_sb);
+
+	spin_lock(&sbi->inode_hash_lock);
+	hlist_del_init(&EXFAT_I(inode)->i_hash_fat);
+	EXFAT_I(inode)->i_pos = 0;
+	spin_unlock(&sbi->inode_hash_lock);
+}
+
+/* doesn't deal with root inode */
+static int exfat_fill_inode(struct inode *inode, FILE_ID_T *fid)
+{
+	struct exfat_sb_info *sbi = EXFAT_SB(inode->i_sb);
+	FS_INFO_T *p_fs = &(sbi->fs_info);
+	DIR_ENTRY_T info;
+
+	memcpy(&(EXFAT_I(inode)->fid), fid, sizeof(FILE_ID_T));
+
+	FsReadStat(inode, &info);
+
+	EXFAT_I(inode)->i_pos = 0;
+	EXFAT_I(inode)->target = NULL;
+	inode->i_uid = sbi->options.fs_uid;
+	inode->i_gid = sbi->options.fs_gid;
+	INC_IVERSION(inode);
+	inode->i_generation = get_seconds();
+
+	if (info.Attr & ATTR_SUBDIR) { /* directory */
+		inode->i_generation &= ~1;
+		inode->i_mode = exfat_make_mode(sbi, info.Attr, S_IRWXUGO);
+		inode->i_op = &exfat_dir_inode_operations;
+		inode->i_fop = &exfat_dir_operations;
+
+		i_size_write(inode, info.Size);
+		EXFAT_I(inode)->mmu_private = i_size_read(inode);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,00)
+		set_nlink(inode, info.NumSubdirs);
+#else
+		inode->i_nlink = info.NumSubdirs;
+#endif
+	} else if (info.Attr & ATTR_SYMLINK) { /* symbolic link */
+		inode->i_generation |= 1;
+		inode->i_mode = exfat_make_mode(sbi, info.Attr, S_IRWXUGO);
+		inode->i_op = &exfat_symlink_inode_operations;
+
+		i_size_write(inode, info.Size);
+		EXFAT_I(inode)->mmu_private = i_size_read(inode);
+	} else { /* regular file */
+		inode->i_generation |= 1;
+		inode->i_mode = exfat_make_mode(sbi, info.Attr, S_IRWXUGO);
+		inode->i_op = &exfat_file_inode_operations;
+		inode->i_fop = &exfat_file_operations;
+		inode->i_mapping->a_ops = &exfat_aops;
+		inode->i_mapping->nrpages = 0;
+
+		i_size_write(inode, info.Size);
+		EXFAT_I(inode)->mmu_private = i_size_read(inode);
+	}
+	exfat_save_attr(inode, info.Attr);
+
+	inode->i_blocks = ((i_size_read(inode) + (p_fs->cluster_size - 1))
+					   & ~((loff_t)p_fs->cluster_size - 1)) >> 9;
+
+	exfat_time_fat2unix(sbi, &inode->i_mtime, &info.ModifyTimestamp);
+	exfat_time_fat2unix(sbi, &inode->i_ctime, &info.CreateTimestamp);
+	exfat_time_fat2unix(sbi, &inode->i_atime, &info.AccessTimestamp);
+
+	return 0;
+}
+
+static struct inode *exfat_build_inode(struct super_block *sb,
+									   FILE_ID_T *fid, loff_t i_pos) {
+	struct inode *inode;
+	int err;
+
+	inode = exfat_iget(sb, i_pos);
+	if (inode)
+		goto out;
+	inode = new_inode(sb);
+	if (!inode) {
+		inode = ERR_PTR(-ENOMEM);
+		goto out;
+	}
+	inode->i_ino = iunique(sb, EXFAT_ROOT_INO);
+	SET_IVERSION(inode, 1);
+	err = exfat_fill_inode(inode, fid);
+	if (err) {
+		iput(inode);
+		inode = ERR_PTR(err);
+		goto out;
+	}
+	exfat_attach(inode, i_pos);
+	insert_inode_hash(inode);
+out:
+	return inode;
+}
+
+static int exfat_sync_inode(struct inode *inode)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34)
+	return exfat_write_inode(inode, 0);
+#else
+	return exfat_write_inode(inode, NULL);
+#endif
+}
+
+static struct inode *exfat_alloc_inode(struct super_block *sb)
+{
+	struct exfat_inode_info *ei;
+
+	ei = kmem_cache_alloc(exfat_inode_cachep, GFP_NOFS);
+	if (!ei)
+		return NULL;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,00)
+	init_rwsem(&ei->truncate_lock);
+#endif
+
+	return &ei->vfs_inode;
+}
+
+static void exfat_destroy_inode(struct inode *inode)
+{
+	if (EXFAT_I(inode)->target)
+		kfree(EXFAT_I(inode)->target);
+	EXFAT_I(inode)->target = NULL;
+
+	kmem_cache_free(exfat_inode_cachep, EXFAT_I(inode));
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34)
+static int exfat_write_inode(struct inode *inode, int wait)
+#else
+static int exfat_write_inode(struct inode *inode, struct writeback_control *wbc)
+#endif
+{
+	struct super_block *sb = inode->i_sb;
+	struct exfat_sb_info *sbi = EXFAT_SB(sb);
+	DIR_ENTRY_T info;
+
+	if (inode->i_ino == EXFAT_ROOT_INO)
+		return 0;
+
+	info.Attr = exfat_make_attr(inode);
+	info.Size = i_size_read(inode);
+
+	exfat_time_unix2fat(sbi, &inode->i_mtime, &info.ModifyTimestamp);
+	exfat_time_unix2fat(sbi, &inode->i_ctime, &info.CreateTimestamp);
+	exfat_time_unix2fat(sbi, &inode->i_atime, &info.AccessTimestamp);
+
+	FsWriteStat(inode, &info);
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+static void exfat_delete_inode(struct inode *inode)
+{
+	truncate_inode_pages(&inode->i_data, 0);
+	clear_inode(inode);
+}
+
+static void exfat_clear_inode(struct inode *inode)
+{
+	exfat_detach(inode);
+	remove_inode_hash(inode);
+}
+#else
+static void exfat_evict_inode(struct inode *inode)
+{
+	truncate_inode_pages(&inode->i_data, 0);
+
+	if (!inode->i_nlink)
+		i_size_write(inode, 0);
+	invalidate_inode_buffers(inode);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
+	end_writeback(inode);
+#else
+	clear_inode(inode);
+#endif
+	exfat_detach(inode);
+
+	remove_inode_hash(inode);
+}
+#endif
+
+static void exfat_free_super(struct exfat_sb_info *sbi)
+{
+	if (sbi->nls_disk)
+		unload_nls(sbi->nls_disk);
+	if (sbi->nls_io)
+		unload_nls(sbi->nls_io);
+	if (sbi->options.iocharset != exfat_default_iocharset)
+		kfree(sbi->options.iocharset);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0)
+	/* mutex_init is in exfat_fill_super function. only for 3.7+ */
+	mutex_destroy(&sbi->s_lock);
+#endif
+	kfree(sbi);
+}
+
+static void exfat_put_super(struct super_block *sb)
+{
+	struct exfat_sb_info *sbi = EXFAT_SB(sb);
+	if (__is_sb_dirty(sb))
+		exfat_write_super(sb);
+
+	FsUmountVol(sb);
+
+	sb->s_fs_info = NULL;
+	exfat_free_super(sbi);
+}
+
+static void exfat_write_super(struct super_block *sb)
+{
+	__lock_super(sb);
+
+	__set_sb_clean(sb);
+
+	if (!(sb->s_flags & MS_RDONLY))
+		FsSyncVol(sb, 1);
+
+	__unlock_super(sb);
+}
+
+static int exfat_sync_fs(struct super_block *sb, int wait)
+{
+	int err = 0;
+
+	if (__is_sb_dirty(sb)) {
+		__lock_super(sb);
+		__set_sb_clean(sb);
+		err = FsSyncVol(sb, 1);
+		__unlock_super(sb);
+	}
+
+	return err;
+}
+
+static int exfat_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	struct super_block *sb = dentry->d_sb;
+	u64 id = huge_encode_dev(sb->s_bdev->bd_dev);
+	FS_INFO_T *p_fs = &(EXFAT_SB(sb)->fs_info);
+	VOL_INFO_T info;
+
+	if (p_fs->used_clusters == (u32) ~0) {
+		if (FFS_MEDIAERR == FsGetVolInfo(sb, &info))
+			return -EIO;
+
+	} else {
+		info.FatType = p_fs->vol_type;
+		info.ClusterSize = p_fs->cluster_size;
+		info.NumClusters = p_fs->num_clusters - 2;
+		info.UsedClusters = p_fs->used_clusters;
+		info.FreeClusters = info.NumClusters - info.UsedClusters;
+
+		if (p_fs->dev_ejected)
+			printk("[EXFAT] statfs on device is ejected\n");
+	}
+
+	buf->f_type = sb->s_magic;
+	buf->f_bsize = info.ClusterSize;
+	buf->f_blocks = info.NumClusters;
+	buf->f_bfree = info.FreeClusters;
+	buf->f_bavail = info.FreeClusters;
+	buf->f_fsid.val[0] = (u32)id;
+	buf->f_fsid.val[1] = (u32)(id >> 32);
+	buf->f_namelen = 260;
+
+	return 0;
+}
+
+static int exfat_remount(struct super_block *sb, int *flags, char *data)
+{
+	*flags |= MS_NODIRATIME;
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0)
+static int exfat_show_options(struct seq_file *m, struct dentry *root)
+{
+	struct exfat_sb_info *sbi = EXFAT_SB(root->d_sb);
+#else
+static int exfat_show_options(struct seq_file *m, struct vfsmount *mnt)
+{
+	struct exfat_sb_info *sbi = EXFAT_SB(mnt->mnt_sb);
+#endif
+	struct exfat_mount_options *opts = &sbi->options;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+	if (__kuid_val(opts->fs_uid))
+		seq_printf(m, ",uid=%u", __kuid_val(opts->fs_uid));
+	if (__kgid_val(opts->fs_gid))
+		seq_printf(m, ",gid=%u", __kgid_val(opts->fs_gid));
+#else
+	if (opts->fs_uid != 0)
+		seq_printf(m, ",uid=%u", opts->fs_uid);
+	if (opts->fs_gid != 0)
+		seq_printf(m, ",gid=%u", opts->fs_gid);
+#endif
+	seq_printf(m, ",fmask=%04o", opts->fs_fmask);
+	seq_printf(m, ",dmask=%04o", opts->fs_dmask);
+	if (opts->allow_utime)
+		seq_printf(m, ",allow_utime=%04o", opts->allow_utime);
+	if (sbi->nls_disk)
+		seq_printf(m, ",codepage=%s", sbi->nls_disk->charset);
+	if (sbi->nls_io)
+		seq_printf(m, ",iocharset=%s", sbi->nls_io->charset);
+	seq_printf(m, ",namecase=%u", opts->casesensitive);
+	if (opts->errors == EXFAT_ERRORS_CONT)
+		seq_puts(m, ",errors=continue");
+	else if (opts->errors == EXFAT_ERRORS_PANIC)
+		seq_puts(m, ",errors=panic");
+	else
+		seq_puts(m, ",errors=remount-ro");
+#ifdef CONFIG_EXFAT_DISCARD
+	if (opts->discard)
+		seq_printf(m, ",discard");
+#endif
+	return 0;
+}
+
+const struct super_operations exfat_sops = {
+	.alloc_inode   = exfat_alloc_inode,
+	.destroy_inode = exfat_destroy_inode,
+	.write_inode   = exfat_write_inode,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+	.delete_inode  = exfat_delete_inode,
+	.clear_inode   = exfat_clear_inode,
+#else
+	.evict_inode  = exfat_evict_inode,
+#endif
+	.put_super     = exfat_put_super,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+	.write_super   = exfat_write_super,
+#endif
+	.sync_fs       = exfat_sync_fs,
+	.statfs        = exfat_statfs,
+	.remount_fs    = exfat_remount,
+	.show_options  = exfat_show_options,
+};
+
+/*======================================================================*/
+/*  Export Operations                                                   */
+/*======================================================================*/
+
+static struct inode *exfat_nfs_get_inode(struct super_block *sb,
+				       u64 ino, u32 generation)
+{
+	struct inode *inode = NULL;
+	if (ino < EXFAT_ROOT_INO)
+		return inode;
+	inode = ilookup(sb, ino);
+
+	if (inode && generation && (inode->i_generation != generation)) {
+		iput(inode);
+		inode = NULL;
+	}
+
+	return inode;
+}
+
+static struct dentry *exfat_fh_to_dentry(struct super_block *sb, struct fid *fid,
+				int fh_len, int fh_type)
+{
+	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
+				    exfat_nfs_get_inode);
+}
+
+static struct dentry *exfat_fh_to_parent(struct super_block *sb, struct fid *fid,
+				int fh_len, int fh_type)
+{
+	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
+				    exfat_nfs_get_inode);
+}
+
+const struct export_operations exfat_export_ops = {
+	.fh_to_dentry   = exfat_fh_to_dentry,
+	.fh_to_parent   = exfat_fh_to_parent,
+};
+
+/*======================================================================*/
+/*  Super Block Read Operations                                         */
+/*======================================================================*/
+
+enum {
+	Opt_uid,
+	Opt_gid,
+	Opt_umask,
+	Opt_dmask,
+	Opt_fmask,
+	Opt_allow_utime,
+	Opt_codepage,
+	Opt_charset,
+	Opt_namecase,
+	Opt_debug,
+	Opt_err_cont,
+	Opt_err_panic,
+	Opt_err_ro,
+	Opt_utf8_hack,
+	Opt_err,
+#ifdef CONFIG_EXFAT_DISCARD
+	Opt_discard,
+#endif /* EXFAT_CONFIG_DISCARD */
+};
+
+static const match_table_t exfat_tokens = {
+	{Opt_uid, "uid=%u"},
+	{Opt_gid, "gid=%u"},
+	{Opt_umask, "umask=%o"},
+	{Opt_dmask, "dmask=%o"},
+	{Opt_fmask, "fmask=%o"},
+	{Opt_allow_utime, "allow_utime=%o"},
+	{Opt_codepage, "codepage=%u"},
+	{Opt_charset, "iocharset=%s"},
+	{Opt_namecase, "namecase=%u"},
+	{Opt_debug, "debug"},
+	{Opt_err_cont, "errors=continue"},
+	{Opt_err_panic, "errors=panic"},
+	{Opt_err_ro, "errors=remount-ro"},
+	{Opt_utf8_hack, "utf8"},
+#ifdef CONFIG_EXFAT_DISCARD
+	{Opt_discard, "discard"},
+#endif /* CONFIG_EXFAT_DISCARD */
+	{Opt_err, NULL}
+};
+
+static int parse_options(char *options, int silent, int *debug,
+						 struct exfat_mount_options *opts)
+{
+	char *p;
+	substring_t args[MAX_OPT_ARGS];
+	int option;
+	char *iocharset;
+
+	opts->fs_uid = current_uid();
+	opts->fs_gid = current_gid();
+	opts->fs_fmask = opts->fs_dmask = current->fs->umask;
+	opts->allow_utime = (unsigned short) -1;
+	opts->codepage = exfat_default_codepage;
+	opts->iocharset = exfat_default_iocharset;
+	opts->casesensitive = 0;
+	opts->errors = EXFAT_ERRORS_RO;
+#ifdef CONFIG_EXFAT_DISCARD
+	opts->discard = 0;
+#endif
+	*debug = 0;
+
+	if (!options)
+		goto out;
+
+	while ((p = strsep(&options, ",")) != NULL) {
+		int token;
+		if (!*p)
+			continue;
+
+		token = match_token(p, exfat_tokens, args);
+		switch (token) {
+		case Opt_uid:
+			if (match_int(&args[0], &option))
+				return 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+			opts->fs_uid = KUIDT_INIT(option);
+#else
+			opts->fs_uid = option;
+#endif
+			break;
+		case Opt_gid:
+			if (match_int(&args[0], &option))
+				return 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+			opts->fs_gid = KGIDT_INIT(option);
+#else
+			opts->fs_gid = option;
+#endif
+			break;
+		case Opt_umask:
+		case Opt_dmask:
+		case Opt_fmask:
+			if (match_octal(&args[0], &option))
+				return 0;
+			if (token != Opt_dmask)
+				opts->fs_fmask = option;
+			if (token != Opt_fmask)
+				opts->fs_dmask = option;
+			break;
+		case Opt_allow_utime:
+			if (match_octal(&args[0], &option))
+				return 0;
+			opts->allow_utime = option & (S_IWGRP | S_IWOTH);
+			break;
+		case Opt_codepage:
+			if (match_int(&args[0], &option))
+				return 0;
+			opts->codepage = option;
+			break;
+		case Opt_charset:
+			if (opts->iocharset != exfat_default_iocharset)
+				kfree(opts->iocharset);
+			iocharset = match_strdup(&args[0]);
+			if (!iocharset)
+				return -ENOMEM;
+			opts->iocharset = iocharset;
+			break;
+		case Opt_namecase:
+			if (match_int(&args[0], &option))
+				return 0;
+			opts->casesensitive = option;
+			break;
+		case Opt_err_cont:
+			opts->errors = EXFAT_ERRORS_CONT;
+			break;
+		case Opt_err_panic:
+			opts->errors = EXFAT_ERRORS_PANIC;
+			break;
+		case Opt_err_ro:
+			opts->errors = EXFAT_ERRORS_RO;
+			break;
+		case Opt_debug:
+			*debug = 1;
+			break;
+#ifdef CONFIG_EXFAT_DISCARD
+		case Opt_discard:
+			opts->discard = 1;
+			break;
+#endif /* CONFIG_EXFAT_DISCARD */
+		case Opt_utf8_hack:
+			break;
+		default:
+			if (!silent)
+				printk(KERN_ERR "[EXFAT] Unrecognized mount option %s or missing value\n", p);
+			return -EINVAL;
+		}
+	}
+
+out:
+	if (opts->allow_utime == (unsigned short) -1)
+		opts->allow_utime = ~opts->fs_dmask & (S_IWGRP | S_IWOTH);
+
+	return 0;
+}
+
+static void exfat_hash_init(struct super_block *sb)
+{
+	struct exfat_sb_info *sbi = EXFAT_SB(sb);
+	int i;
+
+	spin_lock_init(&sbi->inode_hash_lock);
+	for (i = 0; i < EXFAT_HASH_SIZE; i++)
+		INIT_HLIST_HEAD(&sbi->inode_hashtable[i]);
+}
+
+static int exfat_read_root(struct inode *inode)
+{
+	struct super_block *sb = inode->i_sb;
+	struct exfat_sb_info *sbi = EXFAT_SB(sb);
+	FS_INFO_T *p_fs = &(sbi->fs_info);
+	DIR_ENTRY_T info;
+
+	EXFAT_I(inode)->fid.dir.dir = p_fs->root_dir;
+	EXFAT_I(inode)->fid.dir.flags = 0x01;
+	EXFAT_I(inode)->fid.entry = -1;
+	EXFAT_I(inode)->fid.start_clu = p_fs->root_dir;
+	EXFAT_I(inode)->fid.flags = 0x01;
+	EXFAT_I(inode)->fid.type = TYPE_DIR;
+	EXFAT_I(inode)->fid.rwoffset = 0;
+	EXFAT_I(inode)->fid.hint_last_off = -1;
+
+	EXFAT_I(inode)->target = NULL;
+
+	FsReadStat(inode, &info);
+
+	inode->i_uid = sbi->options.fs_uid;
+	inode->i_gid = sbi->options.fs_gid;
+	INC_IVERSION(inode);
+	inode->i_generation = 0;
+	inode->i_mode = exfat_make_mode(sbi, ATTR_SUBDIR, S_IRWXUGO);
+	inode->i_op = &exfat_dir_inode_operations;
+	inode->i_fop = &exfat_dir_operations;
+
+	i_size_write(inode, info.Size);
+	inode->i_blocks = ((i_size_read(inode) + (p_fs->cluster_size - 1))
+					   & ~((loff_t)p_fs->cluster_size - 1)) >> 9;
+	EXFAT_I(inode)->i_pos = ((loff_t) p_fs->root_dir << 32) | 0xffffffff;
+	EXFAT_I(inode)->mmu_private = i_size_read(inode);
+
+	exfat_save_attr(inode, ATTR_SUBDIR);
+	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,00)
+	set_nlink(inode, info.NumSubdirs + 2);
+#else
+	inode->i_nlink = info.NumSubdirs + 2;
+#endif
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,37)
+static void setup_dops(struct super_block *sb)
+{
+	if (EXFAT_SB(sb)->options.casesensitive == 0)
+		sb->s_d_op = &exfat_ci_dentry_ops;
+	else
+		sb->s_d_op = &exfat_dentry_ops;
+}
+#endif
+
+static int exfat_fill_super(struct super_block *sb, void *data, int silent)
+{
+	struct inode *root_inode = NULL;
+	struct exfat_sb_info *sbi;
+	int debug, ret;
+	long error;
+	char buf[50];
+
+	/*
+	 * GFP_KERNEL is ok here, because while we do hold the
+	 * supeblock lock, memory pressure can't call back into
+	 * the filesystem, since we're only just about to mount
+	 * it and have no inodes etc active!
+	 */
+	sbi = kzalloc(sizeof(struct exfat_sb_info), GFP_KERNEL);
+	if (!sbi)
+		return -ENOMEM;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0)
+	mutex_init(&sbi->s_lock);
+#endif
+	sb->s_fs_info = sbi;
+	sb->s_flags |= MS_NODIRATIME;
+	sb->s_magic = EXFAT_SUPER_MAGIC;
+	sb->s_op = &exfat_sops;
+	sb->s_export_op = &exfat_export_ops;
+
+	error = parse_options(data, silent, &debug, &sbi->options);
+	if (error)
+		goto out_fail;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,37)
+	setup_dops(sb);
+#endif
+
+	error = -EIO;
+	sb_min_blocksize(sb, 512);
+	sb->s_maxbytes = 0x7fffffffffffffffLL;    /* maximum file size */
+
+	ret = FsMountVol(sb);
+	if (ret) {
+		if (!silent)
+			printk(KERN_ERR "[EXFAT] FsMountVol failed\n");
+
+		goto out_fail;
+	}
+
+	/* set up enough so that it can read an inode */
+	exfat_hash_init(sb);
+
+	/*
+	 * The low byte of FAT's first entry must have same value with
+	 * media-field.  But in real world, too many devices is
+	 * writing wrong value.  So, removed that validity check.
+	 *
+	 * if (FAT_FIRST_ENT(sb, media) != first)
+	 */
+
+	/* codepage is not meaningful in exfat */
+	if (sbi->fs_info.vol_type != EXFAT) {
+		error = -EINVAL;
+		sprintf(buf, "cp%d", sbi->options.codepage);
+		sbi->nls_disk = load_nls(buf);
+		if (!sbi->nls_disk) {
+			printk(KERN_ERR "[EXFAT] Codepage %s not found\n", buf);
+			goto out_fail2;
+		}
+	}
+
+	sbi->nls_io = load_nls(sbi->options.iocharset);
+
+	error = -ENOMEM;
+	root_inode = new_inode(sb);
+	if (!root_inode)
+		goto out_fail2;
+	root_inode->i_ino = EXFAT_ROOT_INO;
+	SET_IVERSION(root_inode, 1);
+
+	error = exfat_read_root(root_inode);
+	if (error < 0)
+		goto out_fail2;
+	error = -ENOMEM;
+	exfat_attach(root_inode, EXFAT_I(root_inode)->i_pos);
+	insert_inode_hash(root_inode);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,00)
+	sb->s_root = d_make_root(root_inode);
+#else
+	sb->s_root = d_alloc_root(root_inode);
+#endif
+	if (!sb->s_root) {
+		printk(KERN_ERR "[EXFAT] Getting the root inode failed\n");
+		goto out_fail2;
+	}
+
+	return 0;
+
+out_fail2:
+	FsUmountVol(sb);
+out_fail:
+	if (root_inode)
+		iput(root_inode);
+	sb->s_fs_info = NULL;
+	exfat_free_super(sbi);
+	return error;
+}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
+static int exfat_get_sb(struct file_system_type *fs_type,
+						int flags, const char *dev_name,
+						void *data, struct vfsmount *mnt)
+{
+	return get_sb_bdev(fs_type, flags, dev_name, data, exfat_fill_super, mnt);
+}
+#else
+static struct dentry *exfat_fs_mount(struct file_system_type *fs_type,
+									 int flags, const char *dev_name,
+									 void *data) {
+	return mount_bdev(fs_type, flags, dev_name, data, exfat_fill_super);
+}
+#endif
+
+static void init_once(void *foo)
+{
+	struct exfat_inode_info *ei = (struct exfat_inode_info *)foo;
+
+	INIT_HLIST_NODE(&ei->i_hash_fat);
+	inode_init_once(&ei->vfs_inode);
+}
+
+static int __init exfat_init_inodecache(void)
+{
+	exfat_inode_cachep = kmem_cache_create("exfat_inode_cache",
+										   sizeof(struct exfat_inode_info),
+										   0, (SLAB_RECLAIM_ACCOUNT|
+												   SLAB_MEM_SPREAD),
+										   init_once);
+	if (exfat_inode_cachep == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+static void __exit exfat_destroy_inodecache(void)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+	/*
+	 * Make sure all delayed rcu free inodes are flushed before we
+	 * destroy cache.
+	 */
+	rcu_barrier();
+#endif
+	kmem_cache_destroy(exfat_inode_cachep);
+}
+
+#ifdef CONFIG_EXFAT_KERNEL_DEBUG
+static void exfat_debug_kill_sb(struct super_block *sb)
+{
+	struct exfat_sb_info *sbi = EXFAT_SB(sb);
+	struct block_device *bdev = sb->s_bdev;
+
+	long flags;
+
+	if (sbi) {
+		flags = sbi->debug_flags;
+
+		if (flags & EXFAT_DEBUGFLAGS_INVALID_UMOUNT) {
+			/* invalidate_bdev drops all device cache include dirty.
+			   we use this to simulate device removal */
+			FsReleaseCache(sb);
+			invalidate_bdev(bdev);
+		}
+	}
+
+	kill_block_super(sb);
+}
+#endif /* CONFIG_EXFAT_KERNEL_DEBUG */
+
+static struct file_system_type exfat_fs_type = {
+	.owner       = THIS_MODULE,
+#if defined(CONFIG_MACH_LGE) || defined(CONFIG_HTC_BATT_CORE)
+	.name        = "texfat",
+#else
+	.name        = "exfat",
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
+	.get_sb      = exfat_get_sb,
+#else
+	.mount       = exfat_fs_mount,
+#endif
+#ifdef CONFIG_EXFAT_KERNEL_DEBUG
+	.kill_sb    = exfat_debug_kill_sb,
+#else
+	.kill_sb    = kill_block_super,
+#endif /* CONFIG_EXFAT_KERNEL_DEBUG */
+	.fs_flags    = FS_REQUIRES_DEV,
+};
+
+static int __init init_exfat(void)
+{
+	int err;
+
+	err = FsInit();
+	if (err) {
+		if (err == FFS_MEMORYERR)
+			return -ENOMEM;
+		else
+			return -EIO;
+	}
+
+	printk(KERN_INFO "exFAT: Version %s\n", EXFAT_VERSION);
+
+	err = exfat_init_inodecache();
+	if (err)
+		goto out;
+
+	err = register_filesystem(&exfat_fs_type);
+	if (err)
+		goto out;
+
+	return 0;
+out:
+	FsShutdown();
+	return err;
+}
+
+static void __exit exit_exfat(void)
+{
+	exfat_destroy_inodecache();
+	unregister_filesystem(&exfat_fs_type);
+	FsShutdown();
+}
+
+module_init(init_exfat);
+module_exit(exit_exfat);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("exFAT Filesystem Driver");
+#ifdef MODULE_ALIAS_FS
+#if defined(CONFIG_MACH_LGE) || defined(CONFIG_HTC_BATT_CORE)
+MODULE_ALIAS_FS("texfat");
+#else
+MODULE_ALIAS_FS("exfat");
+#endif
+#endif
diff --git a/kernel/fs/exfat/exfat_super.h b/kernel/fs/exfat/exfat_super.h
new file mode 100755
index 0000000000..916811e3d3
--- /dev/null
+++ b/kernel/fs/exfat/exfat_super.h
@@ -0,0 +1,171 @@
+/* Some of the source code in this file came from "linux/fs/fat/fat.h".  */
+
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef _EXFAT_LINUX_H
+#define _EXFAT_LINUX_H
+
+#include <linux/buffer_head.h>
+#include <linux/string.h>
+#include <linux/nls.h>
+#include <linux/fs.h>
+#include <linux/mutex.h>
+#include <linux/swap.h>
+
+#include "exfat_config.h"
+#include "exfat_data.h"
+#include "exfat_oal.h"
+
+#include "exfat_blkdev.h"
+#include "exfat_cache.h"
+#include "exfat_nls.h"
+#include "exfat_api.h"
+#include "exfat_core.h"
+
+#define EXFAT_ERRORS_CONT  1    /* ignore error and continue */
+#define EXFAT_ERRORS_PANIC 2    /* panic on error */
+#define EXFAT_ERRORS_RO    3    /* remount r/o on error */
+
+/* ioctl command */
+#define EXFAT_IOCTL_GET_VOLUME_ID _IOR('r', 0x12, __u32)
+
+struct exfat_mount_options {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+	kuid_t fs_uid;
+	kgid_t fs_gid;
+#else
+	uid_t fs_uid;
+	gid_t fs_gid;
+#endif
+	unsigned short fs_fmask;
+	unsigned short fs_dmask;
+	unsigned short allow_utime; /* permission for setting the [am]time */
+	unsigned short codepage;    /* codepage for shortname conversions */
+	char *iocharset;            /* charset for filename input/display */
+	unsigned char casesensitive;
+	unsigned char errors;       /* on error: continue, panic, remount-ro */
+#ifdef CONFIG_EXFAT_DISCARD
+	unsigned char discard;      /* flag on if -o dicard specified and device support discard() */
+#endif /* CONFIG_EXFAT_DISCARD */
+};
+
+#define EXFAT_HASH_BITS    8
+#define EXFAT_HASH_SIZE    (1UL << EXFAT_HASH_BITS)
+
+/*
+ * EXFAT file system in-core superblock data
+ */
+struct exfat_sb_info {
+	FS_INFO_T fs_info;
+	BD_INFO_T bd_info;
+
+	struct exfat_mount_options options;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,00)
+	int s_dirt;
+	struct mutex s_lock;
+#endif
+	struct nls_table *nls_disk; /* Codepage used on disk */
+	struct nls_table *nls_io;   /* Charset used for input and display */
+
+	struct inode *fat_inode;
+
+	spinlock_t inode_hash_lock;
+	struct hlist_head inode_hashtable[EXFAT_HASH_SIZE];
+#ifdef CONFIG_EXFAT_KERNEL_DEBUG
+	long debug_flags;
+#endif /* CONFIG_EXFAT_KERNEL_DEBUG */
+};
+
+/*
+ * EXFAT file system inode data in memory
+ */
+struct exfat_inode_info {
+	FILE_ID_T fid;
+	char  *target;
+	/* NOTE: mmu_private is 64bits, so must hold ->i_mutex to access */
+	loff_t mmu_private;         /* physically allocated size */
+	loff_t i_pos;               /* on-disk position of directory entry or 0 */
+	struct hlist_node i_hash_fat;	/* hash by i_location */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,00)
+	struct rw_semaphore truncate_lock;
+#endif
+	struct inode vfs_inode;
+	struct rw_semaphore i_alloc_sem; /* protect bmap against truncate */
+};
+
+#define EXFAT_SB(sb)		((struct exfat_sb_info *)((sb)->s_fs_info))
+
+static inline struct exfat_inode_info *EXFAT_I(struct inode *inode)
+{
+	return container_of(inode, struct exfat_inode_info, vfs_inode);
+}
+
+/*
+ * If ->i_mode can't hold S_IWUGO (i.e. ATTR_RO), we use ->i_attrs to
+ * save ATTR_RO instead of ->i_mode.
+ *
+ * If it's directory and !sbi->options.rodir, ATTR_RO isn't read-only
+ * bit, it's just used as flag for app.
+ */
+static inline int exfat_mode_can_hold_ro(struct inode *inode)
+{
+	struct exfat_sb_info *sbi = EXFAT_SB(inode->i_sb);
+
+	if (S_ISDIR(inode->i_mode))
+		return 0;
+
+	if ((~sbi->options.fs_fmask) & S_IWUGO)
+		return 1;
+	return 0;
+}
+
+/* Convert attribute bits and a mask to the UNIX mode. */
+static inline mode_t exfat_make_mode(struct exfat_sb_info *sbi,
+									 u32 attr, mode_t mode)
+{
+	if ((attr & ATTR_READONLY) && !(attr & ATTR_SUBDIR))
+		mode &= ~S_IWUGO;
+
+	if (attr & ATTR_SUBDIR)
+		return (mode & ~sbi->options.fs_dmask) | S_IFDIR;
+	else if (attr & ATTR_SYMLINK)
+		return (mode & ~sbi->options.fs_dmask) | S_IFLNK;
+	else
+		return (mode & ~sbi->options.fs_fmask) | S_IFREG;
+}
+
+/* Return the FAT attribute byte for this inode */
+static inline u32 exfat_make_attr(struct inode *inode)
+{
+	if (exfat_mode_can_hold_ro(inode) && !(inode->i_mode & S_IWUGO))
+		return (EXFAT_I(inode)->fid.attr) | ATTR_READONLY;
+	else
+		return EXFAT_I(inode)->fid.attr;
+}
+
+static inline void exfat_save_attr(struct inode *inode, u32 attr)
+{
+	if (exfat_mode_can_hold_ro(inode))
+		EXFAT_I(inode)->fid.attr = attr & ATTR_RWMASK;
+	else
+		EXFAT_I(inode)->fid.attr = attr & (ATTR_RWMASK | ATTR_READONLY);
+}
+
+#endif /* _EXFAT_LINUX_H */
diff --git a/kernel/fs/exfat/exfat_upcase.c b/kernel/fs/exfat/exfat_upcase.c
new file mode 100755
index 0000000000..3807f37caa
--- /dev/null
+++ b/kernel/fs/exfat/exfat_upcase.c
@@ -0,0 +1,405 @@
+/*
+ *  Copyright (C) 2012-2013 Samsung Electronics Co., Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/************************************************************************/
+/*                                                                      */
+/*  PROJECT : exFAT & FAT12/16/32 File System                           */
+/*  FILE    : exfat_upcase.c                                            */
+/*  PURPOSE : exFAT Up-case Table                                       */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  NOTES                                                               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  REVISION HISTORY (Ver 0.9)                                          */
+/*                                                                      */
+/*  - 2010.11.15 [Joosun Hahn] : first writing                          */
+/*                                                                      */
+/************************************************************************/
+
+#include "exfat_config.h"
+
+#include "exfat_nls.h"
+
+const u8 uni_upcase[NUM_UPCASE<<1] = {
+	0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x04, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07, 0x00,
+	0x08, 0x00, 0x09, 0x00, 0x0A, 0x00, 0x0B, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x0E, 0x00, 0x0F, 0x00,
+	0x10, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13, 0x00, 0x14, 0x00, 0x15, 0x00, 0x16, 0x00, 0x17, 0x00,
+	0x18, 0x00, 0x19, 0x00, 0x1A, 0x00, 0x1B, 0x00, 0x1C, 0x00, 0x1D, 0x00, 0x1E, 0x00, 0x1F, 0x00,
+	0x20, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x00, 0x24, 0x00, 0x25, 0x00, 0x26, 0x00, 0x27, 0x00,
+	0x28, 0x00, 0x29, 0x00, 0x2A, 0x00, 0x2B, 0x00, 0x2C, 0x00, 0x2D, 0x00, 0x2E, 0x00, 0x2F, 0x00,
+	0x30, 0x00, 0x31, 0x00, 0x32, 0x00, 0x33, 0x00, 0x34, 0x00, 0x35, 0x00, 0x36, 0x00, 0x37, 0x00,
+	0x38, 0x00, 0x39, 0x00, 0x3A, 0x00, 0x3B, 0x00, 0x3C, 0x00, 0x3D, 0x00, 0x3E, 0x00, 0x3F, 0x00,
+	0x40, 0x00, 0x41, 0x00, 0x42, 0x00, 0x43, 0x00, 0x44, 0x00, 0x45, 0x00, 0x46, 0x00, 0x47, 0x00,
+	0x48, 0x00, 0x49, 0x00, 0x4A, 0x00, 0x4B, 0x00, 0x4C, 0x00, 0x4D, 0x00, 0x4E, 0x00, 0x4F, 0x00,
+	0x50, 0x00, 0x51, 0x00, 0x52, 0x00, 0x53, 0x00, 0x54, 0x00, 0x55, 0x00, 0x56, 0x00, 0x57, 0x00,
+	0x58, 0x00, 0x59, 0x00, 0x5A, 0x00, 0x5B, 0x00, 0x5C, 0x00, 0x5D, 0x00, 0x5E, 0x00, 0x5F, 0x00,
+	0x60, 0x00, 0x41, 0x00, 0x42, 0x00, 0x43, 0x00, 0x44, 0x00, 0x45, 0x00, 0x46, 0x00, 0x47, 0x00,
+	0x48, 0x00, 0x49, 0x00, 0x4A, 0x00, 0x4B, 0x00, 0x4C, 0x00, 0x4D, 0x00, 0x4E, 0x00, 0x4F, 0x00,
+	0x50, 0x00, 0x51, 0x00, 0x52, 0x00, 0x53, 0x00, 0x54, 0x00, 0x55, 0x00, 0x56, 0x00, 0x57, 0x00,
+	0x58, 0x00, 0x59, 0x00, 0x5A, 0x00, 0x7B, 0x00, 0x7C, 0x00, 0x7D, 0x00, 0x7E, 0x00, 0x7F, 0x00,
+	0x80, 0x00, 0x81, 0x00, 0x82, 0x00, 0x83, 0x00, 0x84, 0x00, 0x85, 0x00, 0x86, 0x00, 0x87, 0x00,
+	0x88, 0x00, 0x89, 0x00, 0x8A, 0x00, 0x8B, 0x00, 0x8C, 0x00, 0x8D, 0x00, 0x8E, 0x00, 0x8F, 0x00,
+	0x90, 0x00, 0x91, 0x00, 0x92, 0x00, 0x93, 0x00, 0x94, 0x00, 0x95, 0x00, 0x96, 0x00, 0x97, 0x00,
+	0x98, 0x00, 0x99, 0x00, 0x9A, 0x00, 0x9B, 0x00, 0x9C, 0x00, 0x9D, 0x00, 0x9E, 0x00, 0x9F, 0x00,
+	0xA0, 0x00, 0xA1, 0x00, 0xA2, 0x00, 0xA3, 0x00, 0xA4, 0x00, 0xA5, 0x00, 0xA6, 0x00, 0xA7, 0x00,
+	0xA8, 0x00, 0xA9, 0x00, 0xAA, 0x00, 0xAB, 0x00, 0xAC, 0x00, 0xAD, 0x00, 0xAE, 0x00, 0xAF, 0x00,
+	0xB0, 0x00, 0xB1, 0x00, 0xB2, 0x00, 0xB3, 0x00, 0xB4, 0x00, 0xB5, 0x00, 0xB6, 0x00, 0xB7, 0x00,
+	0xB8, 0x00, 0xB9, 0x00, 0xBA, 0x00, 0xBB, 0x00, 0xBC, 0x00, 0xBD, 0x00, 0xBE, 0x00, 0xBF, 0x00,
+	0xC0, 0x00, 0xC1, 0x00, 0xC2, 0x00, 0xC3, 0x00, 0xC4, 0x00, 0xC5, 0x00, 0xC6, 0x00, 0xC7, 0x00,
+	0xC8, 0x00, 0xC9, 0x00, 0xCA, 0x00, 0xCB, 0x00, 0xCC, 0x00, 0xCD, 0x00, 0xCE, 0x00, 0xCF, 0x00,
+	0xD0, 0x00, 0xD1, 0x00, 0xD2, 0x00, 0xD3, 0x00, 0xD4, 0x00, 0xD5, 0x00, 0xD6, 0x00, 0xD7, 0x00,
+	0xD8, 0x00, 0xD9, 0x00, 0xDA, 0x00, 0xDB, 0x00, 0xDC, 0x00, 0xDD, 0x00, 0xDE, 0x00, 0xDF, 0x00,
+	0xC0, 0x00, 0xC1, 0x00, 0xC2, 0x00, 0xC3, 0x00, 0xC4, 0x00, 0xC5, 0x00, 0xC6, 0x00, 0xC7, 0x00,
+	0xC8, 0x00, 0xC9, 0x00, 0xCA, 0x00, 0xCB, 0x00, 0xCC, 0x00, 0xCD, 0x00, 0xCE, 0x00, 0xCF, 0x00,
+	0xD0, 0x00, 0xD1, 0x00, 0xD2, 0x00, 0xD3, 0x00, 0xD4, 0x00, 0xD5, 0x00, 0xD6, 0x00, 0xF7, 0x00,
+	0xD8, 0x00, 0xD9, 0x00, 0xDA, 0x00, 0xDB, 0x00, 0xDC, 0x00, 0xDD, 0x00, 0xDE, 0x00, 0x78, 0x01,
+	0x00, 0x01, 0x00, 0x01, 0x02, 0x01, 0x02, 0x01, 0x04, 0x01, 0x04, 0x01, 0x06, 0x01, 0x06, 0x01,
+	0x08, 0x01, 0x08, 0x01, 0x0A, 0x01, 0x0A, 0x01, 0x0C, 0x01, 0x0C, 0x01, 0x0E, 0x01, 0x0E, 0x01,
+	0x10, 0x01, 0x10, 0x01, 0x12, 0x01, 0x12, 0x01, 0x14, 0x01, 0x14, 0x01, 0x16, 0x01, 0x16, 0x01,
+	0x18, 0x01, 0x18, 0x01, 0x1A, 0x01, 0x1A, 0x01, 0x1C, 0x01, 0x1C, 0x01, 0x1E, 0x01, 0x1E, 0x01,
+	0x20, 0x01, 0x20, 0x01, 0x22, 0x01, 0x22, 0x01, 0x24, 0x01, 0x24, 0x01, 0x26, 0x01, 0x26, 0x01,
+	0x28, 0x01, 0x28, 0x01, 0x2A, 0x01, 0x2A, 0x01, 0x2C, 0x01, 0x2C, 0x01, 0x2E, 0x01, 0x2E, 0x01,
+	0x30, 0x01, 0x31, 0x01, 0x32, 0x01, 0x32, 0x01, 0x34, 0x01, 0x34, 0x01, 0x36, 0x01, 0x36, 0x01,
+	0x38, 0x01, 0x39, 0x01, 0x39, 0x01, 0x3B, 0x01, 0x3B, 0x01, 0x3D, 0x01, 0x3D, 0x01, 0x3F, 0x01,
+	0x3F, 0x01, 0x41, 0x01, 0x41, 0x01, 0x43, 0x01, 0x43, 0x01, 0x45, 0x01, 0x45, 0x01, 0x47, 0x01,
+	0x47, 0x01, 0x49, 0x01, 0x4A, 0x01, 0x4A, 0x01, 0x4C, 0x01, 0x4C, 0x01, 0x4E, 0x01, 0x4E, 0x01,
+	0x50, 0x01, 0x50, 0x01, 0x52, 0x01, 0x52, 0x01, 0x54, 0x01, 0x54, 0x01, 0x56, 0x01, 0x56, 0x01,
+	0x58, 0x01, 0x58, 0x01, 0x5A, 0x01, 0x5A, 0x01, 0x5C, 0x01, 0x5C, 0x01, 0x5E, 0x01, 0x5E, 0x01,
+	0x60, 0x01, 0x60, 0x01, 0x62, 0x01, 0x62, 0x01, 0x64, 0x01, 0x64, 0x01, 0x66, 0x01, 0x66, 0x01,
+	0x68, 0x01, 0x68, 0x01, 0x6A, 0x01, 0x6A, 0x01, 0x6C, 0x01, 0x6C, 0x01, 0x6E, 0x01, 0x6E, 0x01,
+	0x70, 0x01, 0x70, 0x01, 0x72, 0x01, 0x72, 0x01, 0x74, 0x01, 0x74, 0x01, 0x76, 0x01, 0x76, 0x01,
+	0x78, 0x01, 0x79, 0x01, 0x79, 0x01, 0x7B, 0x01, 0x7B, 0x01, 0x7D, 0x01, 0x7D, 0x01, 0x7F, 0x01,
+	0x43, 0x02, 0x81, 0x01, 0x82, 0x01, 0x82, 0x01, 0x84, 0x01, 0x84, 0x01, 0x86, 0x01, 0x87, 0x01,
+	0x87, 0x01, 0x89, 0x01, 0x8A, 0x01, 0x8B, 0x01, 0x8B, 0x01, 0x8D, 0x01, 0x8E, 0x01, 0x8F, 0x01,
+	0x90, 0x01, 0x91, 0x01, 0x91, 0x01, 0x93, 0x01, 0x94, 0x01, 0xF6, 0x01, 0x96, 0x01, 0x97, 0x01,
+	0x98, 0x01, 0x98, 0x01, 0x3D, 0x02, 0x9B, 0x01, 0x9C, 0x01, 0x9D, 0x01, 0x20, 0x02, 0x9F, 0x01,
+	0xA0, 0x01, 0xA0, 0x01, 0xA2, 0x01, 0xA2, 0x01, 0xA4, 0x01, 0xA4, 0x01, 0xA6, 0x01, 0xA7, 0x01,
+	0xA7, 0x01, 0xA9, 0x01, 0xAA, 0x01, 0xAB, 0x01, 0xAC, 0x01, 0xAC, 0x01, 0xAE, 0x01, 0xAF, 0x01,
+	0xAF, 0x01, 0xB1, 0x01, 0xB2, 0x01, 0xB3, 0x01, 0xB3, 0x01, 0xB5, 0x01, 0xB5, 0x01, 0xB7, 0x01,
+	0xB8, 0x01, 0xB8, 0x01, 0xBA, 0x01, 0xBB, 0x01, 0xBC, 0x01, 0xBC, 0x01, 0xBE, 0x01, 0xF7, 0x01,
+	0xC0, 0x01, 0xC1, 0x01, 0xC2, 0x01, 0xC3, 0x01, 0xC4, 0x01, 0xC5, 0x01, 0xC4, 0x01, 0xC7, 0x01,
+	0xC8, 0x01, 0xC7, 0x01, 0xCA, 0x01, 0xCB, 0x01, 0xCA, 0x01, 0xCD, 0x01, 0xCD, 0x01, 0xCF, 0x01,
+	0xCF, 0x01, 0xD1, 0x01, 0xD1, 0x01, 0xD3, 0x01, 0xD3, 0x01, 0xD5, 0x01, 0xD5, 0x01, 0xD7, 0x01,
+	0xD7, 0x01, 0xD9, 0x01, 0xD9, 0x01, 0xDB, 0x01, 0xDB, 0x01, 0x8E, 0x01, 0xDE, 0x01, 0xDE, 0x01,
+	0xE0, 0x01, 0xE0, 0x01, 0xE2, 0x01, 0xE2, 0x01, 0xE4, 0x01, 0xE4, 0x01, 0xE6, 0x01, 0xE6, 0x01,
+	0xE8, 0x01, 0xE8, 0x01, 0xEA, 0x01, 0xEA, 0x01, 0xEC, 0x01, 0xEC, 0x01, 0xEE, 0x01, 0xEE, 0x01,
+	0xF0, 0x01, 0xF1, 0x01, 0xF2, 0x01, 0xF1, 0x01, 0xF4, 0x01, 0xF4, 0x01, 0xF6, 0x01, 0xF7, 0x01,
+	0xF8, 0x01, 0xF8, 0x01, 0xFA, 0x01, 0xFA, 0x01, 0xFC, 0x01, 0xFC, 0x01, 0xFE, 0x01, 0xFE, 0x01,
+	0x00, 0x02, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x04, 0x02, 0x04, 0x02, 0x06, 0x02, 0x06, 0x02,
+	0x08, 0x02, 0x08, 0x02, 0x0A, 0x02, 0x0A, 0x02, 0x0C, 0x02, 0x0C, 0x02, 0x0E, 0x02, 0x0E, 0x02,
+	0x10, 0x02, 0x10, 0x02, 0x12, 0x02, 0x12, 0x02, 0x14, 0x02, 0x14, 0x02, 0x16, 0x02, 0x16, 0x02,
+	0x18, 0x02, 0x18, 0x02, 0x1A, 0x02, 0x1A, 0x02, 0x1C, 0x02, 0x1C, 0x02, 0x1E, 0x02, 0x1E, 0x02,
+	0x20, 0x02, 0x21, 0x02, 0x22, 0x02, 0x22, 0x02, 0x24, 0x02, 0x24, 0x02, 0x26, 0x02, 0x26, 0x02,
+	0x28, 0x02, 0x28, 0x02, 0x2A, 0x02, 0x2A, 0x02, 0x2C, 0x02, 0x2C, 0x02, 0x2E, 0x02, 0x2E, 0x02,
+	0x30, 0x02, 0x30, 0x02, 0x32, 0x02, 0x32, 0x02, 0x34, 0x02, 0x35, 0x02, 0x36, 0x02, 0x37, 0x02,
+	0x38, 0x02, 0x39, 0x02, 0x65, 0x2C, 0x3B, 0x02, 0x3B, 0x02, 0x3D, 0x02, 0x66, 0x2C, 0x3F, 0x02,
+	0x40, 0x02, 0x41, 0x02, 0x41, 0x02, 0x43, 0x02, 0x44, 0x02, 0x45, 0x02, 0x46, 0x02, 0x46, 0x02,
+	0x48, 0x02, 0x48, 0x02, 0x4A, 0x02, 0x4A, 0x02, 0x4C, 0x02, 0x4C, 0x02, 0x4E, 0x02, 0x4E, 0x02,
+	0x50, 0x02, 0x51, 0x02, 0x52, 0x02, 0x81, 0x01, 0x86, 0x01, 0x55, 0x02, 0x89, 0x01, 0x8A, 0x01,
+	0x58, 0x02, 0x8F, 0x01, 0x5A, 0x02, 0x90, 0x01, 0x5C, 0x02, 0x5D, 0x02, 0x5E, 0x02, 0x5F, 0x02,
+	0x93, 0x01, 0x61, 0x02, 0x62, 0x02, 0x94, 0x01, 0x64, 0x02, 0x65, 0x02, 0x66, 0x02, 0x67, 0x02,
+	0x97, 0x01, 0x96, 0x01, 0x6A, 0x02, 0x62, 0x2C, 0x6C, 0x02, 0x6D, 0x02, 0x6E, 0x02, 0x9C, 0x01,
+	0x70, 0x02, 0x71, 0x02, 0x9D, 0x01, 0x73, 0x02, 0x74, 0x02, 0x9F, 0x01, 0x76, 0x02, 0x77, 0x02,
+	0x78, 0x02, 0x79, 0x02, 0x7A, 0x02, 0x7B, 0x02, 0x7C, 0x02, 0x64, 0x2C, 0x7E, 0x02, 0x7F, 0x02,
+	0xA6, 0x01, 0x81, 0x02, 0x82, 0x02, 0xA9, 0x01, 0x84, 0x02, 0x85, 0x02, 0x86, 0x02, 0x87, 0x02,
+	0xAE, 0x01, 0x44, 0x02, 0xB1, 0x01, 0xB2, 0x01, 0x45, 0x02, 0x8D, 0x02, 0x8E, 0x02, 0x8F, 0x02,
+	0x90, 0x02, 0x91, 0x02, 0xB7, 0x01, 0x93, 0x02, 0x94, 0x02, 0x95, 0x02, 0x96, 0x02, 0x97, 0x02,
+	0x98, 0x02, 0x99, 0x02, 0x9A, 0x02, 0x9B, 0x02, 0x9C, 0x02, 0x9D, 0x02, 0x9E, 0x02, 0x9F, 0x02,
+	0xA0, 0x02, 0xA1, 0x02, 0xA2, 0x02, 0xA3, 0x02, 0xA4, 0x02, 0xA5, 0x02, 0xA6, 0x02, 0xA7, 0x02,
+	0xA8, 0x02, 0xA9, 0x02, 0xAA, 0x02, 0xAB, 0x02, 0xAC, 0x02, 0xAD, 0x02, 0xAE, 0x02, 0xAF, 0x02,
+	0xB0, 0x02, 0xB1, 0x02, 0xB2, 0x02, 0xB3, 0x02, 0xB4, 0x02, 0xB5, 0x02, 0xB6, 0x02, 0xB7, 0x02,
+	0xB8, 0x02, 0xB9, 0x02, 0xBA, 0x02, 0xBB, 0x02, 0xBC, 0x02, 0xBD, 0x02, 0xBE, 0x02, 0xBF, 0x02,
+	0xC0, 0x02, 0xC1, 0x02, 0xC2, 0x02, 0xC3, 0x02, 0xC4, 0x02, 0xC5, 0x02, 0xC6, 0x02, 0xC7, 0x02,
+	0xC8, 0x02, 0xC9, 0x02, 0xCA, 0x02, 0xCB, 0x02, 0xCC, 0x02, 0xCD, 0x02, 0xCE, 0x02, 0xCF, 0x02,
+	0xD0, 0x02, 0xD1, 0x02, 0xD2, 0x02, 0xD3, 0x02, 0xD4, 0x02, 0xD5, 0x02, 0xD6, 0x02, 0xD7, 0x02,
+	0xD8, 0x02, 0xD9, 0x02, 0xDA, 0x02, 0xDB, 0x02, 0xDC, 0x02, 0xDD, 0x02, 0xDE, 0x02, 0xDF, 0x02,
+	0xE0, 0x02, 0xE1, 0x02, 0xE2, 0x02, 0xE3, 0x02, 0xE4, 0x02, 0xE5, 0x02, 0xE6, 0x02, 0xE7, 0x02,
+	0xE8, 0x02, 0xE9, 0x02, 0xEA, 0x02, 0xEB, 0x02, 0xEC, 0x02, 0xED, 0x02, 0xEE, 0x02, 0xEF, 0x02,
+	0xF0, 0x02, 0xF1, 0x02, 0xF2, 0x02, 0xF3, 0x02, 0xF4, 0x02, 0xF5, 0x02, 0xF6, 0x02, 0xF7, 0x02,
+	0xF8, 0x02, 0xF9, 0x02, 0xFA, 0x02, 0xFB, 0x02, 0xFC, 0x02, 0xFD, 0x02, 0xFE, 0x02, 0xFF, 0x02,
+	0x00, 0x03, 0x01, 0x03, 0x02, 0x03, 0x03, 0x03, 0x04, 0x03, 0x05, 0x03, 0x06, 0x03, 0x07, 0x03,
+	0x08, 0x03, 0x09, 0x03, 0x0A, 0x03, 0x0B, 0x03, 0x0C, 0x03, 0x0D, 0x03, 0x0E, 0x03, 0x0F, 0x03,
+	0x10, 0x03, 0x11, 0x03, 0x12, 0x03, 0x13, 0x03, 0x14, 0x03, 0x15, 0x03, 0x16, 0x03, 0x17, 0x03,
+	0x18, 0x03, 0x19, 0x03, 0x1A, 0x03, 0x1B, 0x03, 0x1C, 0x03, 0x1D, 0x03, 0x1E, 0x03, 0x1F, 0x03,
+	0x20, 0x03, 0x21, 0x03, 0x22, 0x03, 0x23, 0x03, 0x24, 0x03, 0x25, 0x03, 0x26, 0x03, 0x27, 0x03,
+	0x28, 0x03, 0x29, 0x03, 0x2A, 0x03, 0x2B, 0x03, 0x2C, 0x03, 0x2D, 0x03, 0x2E, 0x03, 0x2F, 0x03,
+	0x30, 0x03, 0x31, 0x03, 0x32, 0x03, 0x33, 0x03, 0x34, 0x03, 0x35, 0x03, 0x36, 0x03, 0x37, 0x03,
+	0x38, 0x03, 0x39, 0x03, 0x3A, 0x03, 0x3B, 0x03, 0x3C, 0x03, 0x3D, 0x03, 0x3E, 0x03, 0x3F, 0x03,
+	0x40, 0x03, 0x41, 0x03, 0x42, 0x03, 0x43, 0x03, 0x44, 0x03, 0x45, 0x03, 0x46, 0x03, 0x47, 0x03,
+	0x48, 0x03, 0x49, 0x03, 0x4A, 0x03, 0x4B, 0x03, 0x4C, 0x03, 0x4D, 0x03, 0x4E, 0x03, 0x4F, 0x03,
+	0x50, 0x03, 0x51, 0x03, 0x52, 0x03, 0x53, 0x03, 0x54, 0x03, 0x55, 0x03, 0x56, 0x03, 0x57, 0x03,
+	0x58, 0x03, 0x59, 0x03, 0x5A, 0x03, 0x5B, 0x03, 0x5C, 0x03, 0x5D, 0x03, 0x5E, 0x03, 0x5F, 0x03,
+	0x60, 0x03, 0x61, 0x03, 0x62, 0x03, 0x63, 0x03, 0x64, 0x03, 0x65, 0x03, 0x66, 0x03, 0x67, 0x03,
+	0x68, 0x03, 0x69, 0x03, 0x6A, 0x03, 0x6B, 0x03, 0x6C, 0x03, 0x6D, 0x03, 0x6E, 0x03, 0x6F, 0x03,
+	0x70, 0x03, 0x71, 0x03, 0x72, 0x03, 0x73, 0x03, 0x74, 0x03, 0x75, 0x03, 0x76, 0x03, 0x77, 0x03,
+	0x78, 0x03, 0x79, 0x03, 0x7A, 0x03, 0xFD, 0x03, 0xFE, 0x03, 0xFF, 0x03, 0x7E, 0x03, 0x7F, 0x03,
+	0x80, 0x03, 0x81, 0x03, 0x82, 0x03, 0x83, 0x03, 0x84, 0x03, 0x85, 0x03, 0x86, 0x03, 0x87, 0x03,
+	0x88, 0x03, 0x89, 0x03, 0x8A, 0x03, 0x8B, 0x03, 0x8C, 0x03, 0x8D, 0x03, 0x8E, 0x03, 0x8F, 0x03,
+	0x90, 0x03, 0x91, 0x03, 0x92, 0x03, 0x93, 0x03, 0x94, 0x03, 0x95, 0x03, 0x96, 0x03, 0x97, 0x03,
+	0x98, 0x03, 0x99, 0x03, 0x9A, 0x03, 0x9B, 0x03, 0x9C, 0x03, 0x9D, 0x03, 0x9E, 0x03, 0x9F, 0x03,
+	0xA0, 0x03, 0xA1, 0x03, 0xA2, 0x03, 0xA3, 0x03, 0xA4, 0x03, 0xA5, 0x03, 0xA6, 0x03, 0xA7, 0x03,
+	0xA8, 0x03, 0xA9, 0x03, 0xAA, 0x03, 0xAB, 0x03, 0x86, 0x03, 0x88, 0x03, 0x89, 0x03, 0x8A, 0x03,
+	0xB0, 0x03, 0x91, 0x03, 0x92, 0x03, 0x93, 0x03, 0x94, 0x03, 0x95, 0x03, 0x96, 0x03, 0x97, 0x03,
+	0x98, 0x03, 0x99, 0x03, 0x9A, 0x03, 0x9B, 0x03, 0x9C, 0x03, 0x9D, 0x03, 0x9E, 0x03, 0x9F, 0x03,
+	0xA0, 0x03, 0xA1, 0x03, 0xA3, 0x03, 0xA3, 0x03, 0xA4, 0x03, 0xA5, 0x03, 0xA6, 0x03, 0xA7, 0x03,
+	0xA8, 0x03, 0xA9, 0x03, 0xAA, 0x03, 0xAB, 0x03, 0x8C, 0x03, 0x8E, 0x03, 0x8F, 0x03, 0xCF, 0x03,
+	0xD0, 0x03, 0xD1, 0x03, 0xD2, 0x03, 0xD3, 0x03, 0xD4, 0x03, 0xD5, 0x03, 0xD6, 0x03, 0xD7, 0x03,
+	0xD8, 0x03, 0xD8, 0x03, 0xDA, 0x03, 0xDA, 0x03, 0xDC, 0x03, 0xDC, 0x03, 0xDE, 0x03, 0xDE, 0x03,
+	0xE0, 0x03, 0xE0, 0x03, 0xE2, 0x03, 0xE2, 0x03, 0xE4, 0x03, 0xE4, 0x03, 0xE6, 0x03, 0xE6, 0x03,
+	0xE8, 0x03, 0xE8, 0x03, 0xEA, 0x03, 0xEA, 0x03, 0xEC, 0x03, 0xEC, 0x03, 0xEE, 0x03, 0xEE, 0x03,
+	0xF0, 0x03, 0xF1, 0x03, 0xF9, 0x03, 0xF3, 0x03, 0xF4, 0x03, 0xF5, 0x03, 0xF6, 0x03, 0xF7, 0x03,
+	0xF7, 0x03, 0xF9, 0x03, 0xFA, 0x03, 0xFA, 0x03, 0xFC, 0x03, 0xFD, 0x03, 0xFE, 0x03, 0xFF, 0x03,
+	0x00, 0x04, 0x01, 0x04, 0x02, 0x04, 0x03, 0x04, 0x04, 0x04, 0x05, 0x04, 0x06, 0x04, 0x07, 0x04,
+	0x08, 0x04, 0x09, 0x04, 0x0A, 0x04, 0x0B, 0x04, 0x0C, 0x04, 0x0D, 0x04, 0x0E, 0x04, 0x0F, 0x04,
+	0x10, 0x04, 0x11, 0x04, 0x12, 0x04, 0x13, 0x04, 0x14, 0x04, 0x15, 0x04, 0x16, 0x04, 0x17, 0x04,
+	0x18, 0x04, 0x19, 0x04, 0x1A, 0x04, 0x1B, 0x04, 0x1C, 0x04, 0x1D, 0x04, 0x1E, 0x04, 0x1F, 0x04,
+	0x20, 0x04, 0x21, 0x04, 0x22, 0x04, 0x23, 0x04, 0x24, 0x04, 0x25, 0x04, 0x26, 0x04, 0x27, 0x04,
+	0x28, 0x04, 0x29, 0x04, 0x2A, 0x04, 0x2B, 0x04, 0x2C, 0x04, 0x2D, 0x04, 0x2E, 0x04, 0x2F, 0x04,
+	0x10, 0x04, 0x11, 0x04, 0x12, 0x04, 0x13, 0x04, 0x14, 0x04, 0x15, 0x04, 0x16, 0x04, 0x17, 0x04,
+	0x18, 0x04, 0x19, 0x04, 0x1A, 0x04, 0x1B, 0x04, 0x1C, 0x04, 0x1D, 0x04, 0x1E, 0x04, 0x1F, 0x04,
+	0x20, 0x04, 0x21, 0x04, 0x22, 0x04, 0x23, 0x04, 0x24, 0x04, 0x25, 0x04, 0x26, 0x04, 0x27, 0x04,
+	0x28, 0x04, 0x29, 0x04, 0x2A, 0x04, 0x2B, 0x04, 0x2C, 0x04, 0x2D, 0x04, 0x2E, 0x04, 0x2F, 0x04,
+	0x00, 0x04, 0x01, 0x04, 0x02, 0x04, 0x03, 0x04, 0x04, 0x04, 0x05, 0x04, 0x06, 0x04, 0x07, 0x04,
+	0x08, 0x04, 0x09, 0x04, 0x0A, 0x04, 0x0B, 0x04, 0x0C, 0x04, 0x0D, 0x04, 0x0E, 0x04, 0x0F, 0x04,
+	0x60, 0x04, 0x60, 0x04, 0x62, 0x04, 0x62, 0x04, 0x64, 0x04, 0x64, 0x04, 0x66, 0x04, 0x66, 0x04,
+	0x68, 0x04, 0x68, 0x04, 0x6A, 0x04, 0x6A, 0x04, 0x6C, 0x04, 0x6C, 0x04, 0x6E, 0x04, 0x6E, 0x04,
+	0x70, 0x04, 0x70, 0x04, 0x72, 0x04, 0x72, 0x04, 0x74, 0x04, 0x74, 0x04, 0x76, 0x04, 0x76, 0x04,
+	0x78, 0x04, 0x78, 0x04, 0x7A, 0x04, 0x7A, 0x04, 0x7C, 0x04, 0x7C, 0x04, 0x7E, 0x04, 0x7E, 0x04,
+	0x80, 0x04, 0x80, 0x04, 0x82, 0x04, 0x83, 0x04, 0x84, 0x04, 0x85, 0x04, 0x86, 0x04, 0x87, 0x04,
+	0x88, 0x04, 0x89, 0x04, 0x8A, 0x04, 0x8A, 0x04, 0x8C, 0x04, 0x8C, 0x04, 0x8E, 0x04, 0x8E, 0x04,
+	0x90, 0x04, 0x90, 0x04, 0x92, 0x04, 0x92, 0x04, 0x94, 0x04, 0x94, 0x04, 0x96, 0x04, 0x96, 0x04,
+	0x98, 0x04, 0x98, 0x04, 0x9A, 0x04, 0x9A, 0x04, 0x9C, 0x04, 0x9C, 0x04, 0x9E, 0x04, 0x9E, 0x04,
+	0xA0, 0x04, 0xA0, 0x04, 0xA2, 0x04, 0xA2, 0x04, 0xA4, 0x04, 0xA4, 0x04, 0xA6, 0x04, 0xA6, 0x04,
+	0xA8, 0x04, 0xA8, 0x04, 0xAA, 0x04, 0xAA, 0x04, 0xAC, 0x04, 0xAC, 0x04, 0xAE, 0x04, 0xAE, 0x04,
+	0xB0, 0x04, 0xB0, 0x04, 0xB2, 0x04, 0xB2, 0x04, 0xB4, 0x04, 0xB4, 0x04, 0xB6, 0x04, 0xB6, 0x04,
+	0xB8, 0x04, 0xB8, 0x04, 0xBA, 0x04, 0xBA, 0x04, 0xBC, 0x04, 0xBC, 0x04, 0xBE, 0x04, 0xBE, 0x04,
+	0xC0, 0x04, 0xC1, 0x04, 0xC1, 0x04, 0xC3, 0x04, 0xC3, 0x04, 0xC5, 0x04, 0xC5, 0x04, 0xC7, 0x04,
+	0xC7, 0x04, 0xC9, 0x04, 0xC9, 0x04, 0xCB, 0x04, 0xCB, 0x04, 0xCD, 0x04, 0xCD, 0x04, 0xC0, 0x04,
+	0xD0, 0x04, 0xD0, 0x04, 0xD2, 0x04, 0xD2, 0x04, 0xD4, 0x04, 0xD4, 0x04, 0xD6, 0x04, 0xD6, 0x04,
+	0xD8, 0x04, 0xD8, 0x04, 0xDA, 0x04, 0xDA, 0x04, 0xDC, 0x04, 0xDC, 0x04, 0xDE, 0x04, 0xDE, 0x04,
+	0xE0, 0x04, 0xE0, 0x04, 0xE2, 0x04, 0xE2, 0x04, 0xE4, 0x04, 0xE4, 0x04, 0xE6, 0x04, 0xE6, 0x04,
+	0xE8, 0x04, 0xE8, 0x04, 0xEA, 0x04, 0xEA, 0x04, 0xEC, 0x04, 0xEC, 0x04, 0xEE, 0x04, 0xEE, 0x04,
+	0xF0, 0x04, 0xF0, 0x04, 0xF2, 0x04, 0xF2, 0x04, 0xF4, 0x04, 0xF4, 0x04, 0xF6, 0x04, 0xF6, 0x04,
+	0xF8, 0x04, 0xF8, 0x04, 0xFA, 0x04, 0xFA, 0x04, 0xFC, 0x04, 0xFC, 0x04, 0xFE, 0x04, 0xFE, 0x04,
+	0x00, 0x05, 0x00, 0x05, 0x02, 0x05, 0x02, 0x05, 0x04, 0x05, 0x04, 0x05, 0x06, 0x05, 0x06, 0x05,
+	0x08, 0x05, 0x08, 0x05, 0x0A, 0x05, 0x0A, 0x05, 0x0C, 0x05, 0x0C, 0x05, 0x0E, 0x05, 0x0E, 0x05,
+	0x10, 0x05, 0x10, 0x05, 0x12, 0x05, 0x12, 0x05, 0x14, 0x05, 0x15, 0x05, 0x16, 0x05, 0x17, 0x05,
+	0x18, 0x05, 0x19, 0x05, 0x1A, 0x05, 0x1B, 0x05, 0x1C, 0x05, 0x1D, 0x05, 0x1E, 0x05, 0x1F, 0x05,
+	0x20, 0x05, 0x21, 0x05, 0x22, 0x05, 0x23, 0x05, 0x24, 0x05, 0x25, 0x05, 0x26, 0x05, 0x27, 0x05,
+	0x28, 0x05, 0x29, 0x05, 0x2A, 0x05, 0x2B, 0x05, 0x2C, 0x05, 0x2D, 0x05, 0x2E, 0x05, 0x2F, 0x05,
+	0x30, 0x05, 0x31, 0x05, 0x32, 0x05, 0x33, 0x05, 0x34, 0x05, 0x35, 0x05, 0x36, 0x05, 0x37, 0x05,
+	0x38, 0x05, 0x39, 0x05, 0x3A, 0x05, 0x3B, 0x05, 0x3C, 0x05, 0x3D, 0x05, 0x3E, 0x05, 0x3F, 0x05,
+	0x40, 0x05, 0x41, 0x05, 0x42, 0x05, 0x43, 0x05, 0x44, 0x05, 0x45, 0x05, 0x46, 0x05, 0x47, 0x05,
+	0x48, 0x05, 0x49, 0x05, 0x4A, 0x05, 0x4B, 0x05, 0x4C, 0x05, 0x4D, 0x05, 0x4E, 0x05, 0x4F, 0x05,
+	0x50, 0x05, 0x51, 0x05, 0x52, 0x05, 0x53, 0x05, 0x54, 0x05, 0x55, 0x05, 0x56, 0x05, 0x57, 0x05,
+	0x58, 0x05, 0x59, 0x05, 0x5A, 0x05, 0x5B, 0x05, 0x5C, 0x05, 0x5D, 0x05, 0x5E, 0x05, 0x5F, 0x05,
+	0x60, 0x05, 0x31, 0x05, 0x32, 0x05, 0x33, 0x05, 0x34, 0x05, 0x35, 0x05, 0x36, 0x05, 0x37, 0x05,
+	0x38, 0x05, 0x39, 0x05, 0x3A, 0x05, 0x3B, 0x05, 0x3C, 0x05, 0x3D, 0x05, 0x3E, 0x05, 0x3F, 0x05,
+	0x40, 0x05, 0x41, 0x05, 0x42, 0x05, 0x43, 0x05, 0x44, 0x05, 0x45, 0x05, 0x46, 0x05, 0x47, 0x05,
+	0x48, 0x05, 0x49, 0x05, 0x4A, 0x05, 0x4B, 0x05, 0x4C, 0x05, 0x4D, 0x05, 0x4E, 0x05, 0x4F, 0x05,
+	0x50, 0x05, 0x51, 0x05, 0x52, 0x05, 0x53, 0x05, 0x54, 0x05, 0x55, 0x05, 0x56, 0x05, 0xFF, 0xFF,
+	0xF6, 0x17, 0x63, 0x2C, 0x7E, 0x1D, 0x7F, 0x1D, 0x80, 0x1D, 0x81, 0x1D, 0x82, 0x1D, 0x83, 0x1D,
+	0x84, 0x1D, 0x85, 0x1D, 0x86, 0x1D, 0x87, 0x1D, 0x88, 0x1D, 0x89, 0x1D, 0x8A, 0x1D, 0x8B, 0x1D,
+	0x8C, 0x1D, 0x8D, 0x1D, 0x8E, 0x1D, 0x8F, 0x1D, 0x90, 0x1D, 0x91, 0x1D, 0x92, 0x1D, 0x93, 0x1D,
+	0x94, 0x1D, 0x95, 0x1D, 0x96, 0x1D, 0x97, 0x1D, 0x98, 0x1D, 0x99, 0x1D, 0x9A, 0x1D, 0x9B, 0x1D,
+	0x9C, 0x1D, 0x9D, 0x1D, 0x9E, 0x1D, 0x9F, 0x1D, 0xA0, 0x1D, 0xA1, 0x1D, 0xA2, 0x1D, 0xA3, 0x1D,
+	0xA4, 0x1D, 0xA5, 0x1D, 0xA6, 0x1D, 0xA7, 0x1D, 0xA8, 0x1D, 0xA9, 0x1D, 0xAA, 0x1D, 0xAB, 0x1D,
+	0xAC, 0x1D, 0xAD, 0x1D, 0xAE, 0x1D, 0xAF, 0x1D, 0xB0, 0x1D, 0xB1, 0x1D, 0xB2, 0x1D, 0xB3, 0x1D,
+	0xB4, 0x1D, 0xB5, 0x1D, 0xB6, 0x1D, 0xB7, 0x1D, 0xB8, 0x1D, 0xB9, 0x1D, 0xBA, 0x1D, 0xBB, 0x1D,
+	0xBC, 0x1D, 0xBD, 0x1D, 0xBE, 0x1D, 0xBF, 0x1D, 0xC0, 0x1D, 0xC1, 0x1D, 0xC2, 0x1D, 0xC3, 0x1D,
+	0xC4, 0x1D, 0xC5, 0x1D, 0xC6, 0x1D, 0xC7, 0x1D, 0xC8, 0x1D, 0xC9, 0x1D, 0xCA, 0x1D, 0xCB, 0x1D,
+	0xCC, 0x1D, 0xCD, 0x1D, 0xCE, 0x1D, 0xCF, 0x1D, 0xD0, 0x1D, 0xD1, 0x1D, 0xD2, 0x1D, 0xD3, 0x1D,
+	0xD4, 0x1D, 0xD5, 0x1D, 0xD6, 0x1D, 0xD7, 0x1D, 0xD8, 0x1D, 0xD9, 0x1D, 0xDA, 0x1D, 0xDB, 0x1D,
+	0xDC, 0x1D, 0xDD, 0x1D, 0xDE, 0x1D, 0xDF, 0x1D, 0xE0, 0x1D, 0xE1, 0x1D, 0xE2, 0x1D, 0xE3, 0x1D,
+	0xE4, 0x1D, 0xE5, 0x1D, 0xE6, 0x1D, 0xE7, 0x1D, 0xE8, 0x1D, 0xE9, 0x1D, 0xEA, 0x1D, 0xEB, 0x1D,
+	0xEC, 0x1D, 0xED, 0x1D, 0xEE, 0x1D, 0xEF, 0x1D, 0xF0, 0x1D, 0xF1, 0x1D, 0xF2, 0x1D, 0xF3, 0x1D,
+	0xF4, 0x1D, 0xF5, 0x1D, 0xF6, 0x1D, 0xF7, 0x1D, 0xF8, 0x1D, 0xF9, 0x1D, 0xFA, 0x1D, 0xFB, 0x1D,
+	0xFC, 0x1D, 0xFD, 0x1D, 0xFE, 0x1D, 0xFF, 0x1D, 0x00, 0x1E, 0x00, 0x1E, 0x02, 0x1E, 0x02, 0x1E,
+	0x04, 0x1E, 0x04, 0x1E, 0x06, 0x1E, 0x06, 0x1E, 0x08, 0x1E, 0x08, 0x1E, 0x0A, 0x1E, 0x0A, 0x1E,
+	0x0C, 0x1E, 0x0C, 0x1E, 0x0E, 0x1E, 0x0E, 0x1E, 0x10, 0x1E, 0x10, 0x1E, 0x12, 0x1E, 0x12, 0x1E,
+	0x14, 0x1E, 0x14, 0x1E, 0x16, 0x1E, 0x16, 0x1E, 0x18, 0x1E, 0x18, 0x1E, 0x1A, 0x1E, 0x1A, 0x1E,
+	0x1C, 0x1E, 0x1C, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x20, 0x1E, 0x20, 0x1E, 0x22, 0x1E, 0x22, 0x1E,
+	0x24, 0x1E, 0x24, 0x1E, 0x26, 0x1E, 0x26, 0x1E, 0x28, 0x1E, 0x28, 0x1E, 0x2A, 0x1E, 0x2A, 0x1E,
+	0x2C, 0x1E, 0x2C, 0x1E, 0x2E, 0x1E, 0x2E, 0x1E, 0x30, 0x1E, 0x30, 0x1E, 0x32, 0x1E, 0x32, 0x1E,
+	0x34, 0x1E, 0x34, 0x1E, 0x36, 0x1E, 0x36, 0x1E, 0x38, 0x1E, 0x38, 0x1E, 0x3A, 0x1E, 0x3A, 0x1E,
+	0x3C, 0x1E, 0x3C, 0x1E, 0x3E, 0x1E, 0x3E, 0x1E, 0x40, 0x1E, 0x40, 0x1E, 0x42, 0x1E, 0x42, 0x1E,
+	0x44, 0x1E, 0x44, 0x1E, 0x46, 0x1E, 0x46, 0x1E, 0x48, 0x1E, 0x48, 0x1E, 0x4A, 0x1E, 0x4A, 0x1E,
+	0x4C, 0x1E, 0x4C, 0x1E, 0x4E, 0x1E, 0x4E, 0x1E, 0x50, 0x1E, 0x50, 0x1E, 0x52, 0x1E, 0x52, 0x1E,
+	0x54, 0x1E, 0x54, 0x1E, 0x56, 0x1E, 0x56, 0x1E, 0x58, 0x1E, 0x58, 0x1E, 0x5A, 0x1E, 0x5A, 0x1E,
+	0x5C, 0x1E, 0x5C, 0x1E, 0x5E, 0x1E, 0x5E, 0x1E, 0x60, 0x1E, 0x60, 0x1E, 0x62, 0x1E, 0x62, 0x1E,
+	0x64, 0x1E, 0x64, 0x1E, 0x66, 0x1E, 0x66, 0x1E, 0x68, 0x1E, 0x68, 0x1E, 0x6A, 0x1E, 0x6A, 0x1E,
+	0x6C, 0x1E, 0x6C, 0x1E, 0x6E, 0x1E, 0x6E, 0x1E, 0x70, 0x1E, 0x70, 0x1E, 0x72, 0x1E, 0x72, 0x1E,
+	0x74, 0x1E, 0x74, 0x1E, 0x76, 0x1E, 0x76, 0x1E, 0x78, 0x1E, 0x78, 0x1E, 0x7A, 0x1E, 0x7A, 0x1E,
+	0x7C, 0x1E, 0x7C, 0x1E, 0x7E, 0x1E, 0x7E, 0x1E, 0x80, 0x1E, 0x80, 0x1E, 0x82, 0x1E, 0x82, 0x1E,
+	0x84, 0x1E, 0x84, 0x1E, 0x86, 0x1E, 0x86, 0x1E, 0x88, 0x1E, 0x88, 0x1E, 0x8A, 0x1E, 0x8A, 0x1E,
+	0x8C, 0x1E, 0x8C, 0x1E, 0x8E, 0x1E, 0x8E, 0x1E, 0x90, 0x1E, 0x90, 0x1E, 0x92, 0x1E, 0x92, 0x1E,
+	0x94, 0x1E, 0x94, 0x1E, 0x96, 0x1E, 0x97, 0x1E, 0x98, 0x1E, 0x99, 0x1E, 0x9A, 0x1E, 0x9B, 0x1E,
+	0x9C, 0x1E, 0x9D, 0x1E, 0x9E, 0x1E, 0x9F, 0x1E, 0xA0, 0x1E, 0xA0, 0x1E, 0xA2, 0x1E, 0xA2, 0x1E,
+	0xA4, 0x1E, 0xA4, 0x1E, 0xA6, 0x1E, 0xA6, 0x1E, 0xA8, 0x1E, 0xA8, 0x1E, 0xAA, 0x1E, 0xAA, 0x1E,
+	0xAC, 0x1E, 0xAC, 0x1E, 0xAE, 0x1E, 0xAE, 0x1E, 0xB0, 0x1E, 0xB0, 0x1E, 0xB2, 0x1E, 0xB2, 0x1E,
+	0xB4, 0x1E, 0xB4, 0x1E, 0xB6, 0x1E, 0xB6, 0x1E, 0xB8, 0x1E, 0xB8, 0x1E, 0xBA, 0x1E, 0xBA, 0x1E,
+	0xBC, 0x1E, 0xBC, 0x1E, 0xBE, 0x1E, 0xBE, 0x1E, 0xC0, 0x1E, 0xC0, 0x1E, 0xC2, 0x1E, 0xC2, 0x1E,
+	0xC4, 0x1E, 0xC4, 0x1E, 0xC6, 0x1E, 0xC6, 0x1E, 0xC8, 0x1E, 0xC8, 0x1E, 0xCA, 0x1E, 0xCA, 0x1E,
+	0xCC, 0x1E, 0xCC, 0x1E, 0xCE, 0x1E, 0xCE, 0x1E, 0xD0, 0x1E, 0xD0, 0x1E, 0xD2, 0x1E, 0xD2, 0x1E,
+	0xD4, 0x1E, 0xD4, 0x1E, 0xD6, 0x1E, 0xD6, 0x1E, 0xD8, 0x1E, 0xD8, 0x1E, 0xDA, 0x1E, 0xDA, 0x1E,
+	0xDC, 0x1E, 0xDC, 0x1E, 0xDE, 0x1E, 0xDE, 0x1E, 0xE0, 0x1E, 0xE0, 0x1E, 0xE2, 0x1E, 0xE2, 0x1E,
+	0xE4, 0x1E, 0xE4, 0x1E, 0xE6, 0x1E, 0xE6, 0x1E, 0xE8, 0x1E, 0xE8, 0x1E, 0xEA, 0x1E, 0xEA, 0x1E,
+	0xEC, 0x1E, 0xEC, 0x1E, 0xEE, 0x1E, 0xEE, 0x1E, 0xF0, 0x1E, 0xF0, 0x1E, 0xF2, 0x1E, 0xF2, 0x1E,
+	0xF4, 0x1E, 0xF4, 0x1E, 0xF6, 0x1E, 0xF6, 0x1E, 0xF8, 0x1E, 0xF8, 0x1E, 0xFA, 0x1E, 0xFB, 0x1E,
+	0xFC, 0x1E, 0xFD, 0x1E, 0xFE, 0x1E, 0xFF, 0x1E, 0x08, 0x1F, 0x09, 0x1F, 0x0A, 0x1F, 0x0B, 0x1F,
+	0x0C, 0x1F, 0x0D, 0x1F, 0x0E, 0x1F, 0x0F, 0x1F, 0x08, 0x1F, 0x09, 0x1F, 0x0A, 0x1F, 0x0B, 0x1F,
+	0x0C, 0x1F, 0x0D, 0x1F, 0x0E, 0x1F, 0x0F, 0x1F, 0x18, 0x1F, 0x19, 0x1F, 0x1A, 0x1F, 0x1B, 0x1F,
+	0x1C, 0x1F, 0x1D, 0x1F, 0x16, 0x1F, 0x17, 0x1F, 0x18, 0x1F, 0x19, 0x1F, 0x1A, 0x1F, 0x1B, 0x1F,
+	0x1C, 0x1F, 0x1D, 0x1F, 0x1E, 0x1F, 0x1F, 0x1F, 0x28, 0x1F, 0x29, 0x1F, 0x2A, 0x1F, 0x2B, 0x1F,
+	0x2C, 0x1F, 0x2D, 0x1F, 0x2E, 0x1F, 0x2F, 0x1F, 0x28, 0x1F, 0x29, 0x1F, 0x2A, 0x1F, 0x2B, 0x1F,
+	0x2C, 0x1F, 0x2D, 0x1F, 0x2E, 0x1F, 0x2F, 0x1F, 0x38, 0x1F, 0x39, 0x1F, 0x3A, 0x1F, 0x3B, 0x1F,
+	0x3C, 0x1F, 0x3D, 0x1F, 0x3E, 0x1F, 0x3F, 0x1F, 0x38, 0x1F, 0x39, 0x1F, 0x3A, 0x1F, 0x3B, 0x1F,
+	0x3C, 0x1F, 0x3D, 0x1F, 0x3E, 0x1F, 0x3F, 0x1F, 0x48, 0x1F, 0x49, 0x1F, 0x4A, 0x1F, 0x4B, 0x1F,
+	0x4C, 0x1F, 0x4D, 0x1F, 0x46, 0x1F, 0x47, 0x1F, 0x48, 0x1F, 0x49, 0x1F, 0x4A, 0x1F, 0x4B, 0x1F,
+	0x4C, 0x1F, 0x4D, 0x1F, 0x4E, 0x1F, 0x4F, 0x1F, 0x50, 0x1F, 0x59, 0x1F, 0x52, 0x1F, 0x5B, 0x1F,
+	0x54, 0x1F, 0x5D, 0x1F, 0x56, 0x1F, 0x5F, 0x1F, 0x58, 0x1F, 0x59, 0x1F, 0x5A, 0x1F, 0x5B, 0x1F,
+	0x5C, 0x1F, 0x5D, 0x1F, 0x5E, 0x1F, 0x5F, 0x1F, 0x68, 0x1F, 0x69, 0x1F, 0x6A, 0x1F, 0x6B, 0x1F,
+	0x6C, 0x1F, 0x6D, 0x1F, 0x6E, 0x1F, 0x6F, 0x1F, 0x68, 0x1F, 0x69, 0x1F, 0x6A, 0x1F, 0x6B, 0x1F,
+	0x6C, 0x1F, 0x6D, 0x1F, 0x6E, 0x1F, 0x6F, 0x1F, 0xBA, 0x1F, 0xBB, 0x1F, 0xC8, 0x1F, 0xC9, 0x1F,
+	0xCA, 0x1F, 0xCB, 0x1F, 0xDA, 0x1F, 0xDB, 0x1F, 0xF8, 0x1F, 0xF9, 0x1F, 0xEA, 0x1F, 0xEB, 0x1F,
+	0xFA, 0x1F, 0xFB, 0x1F, 0x7E, 0x1F, 0x7F, 0x1F, 0x88, 0x1F, 0x89, 0x1F, 0x8A, 0x1F, 0x8B, 0x1F,
+	0x8C, 0x1F, 0x8D, 0x1F, 0x8E, 0x1F, 0x8F, 0x1F, 0x88, 0x1F, 0x89, 0x1F, 0x8A, 0x1F, 0x8B, 0x1F,
+	0x8C, 0x1F, 0x8D, 0x1F, 0x8E, 0x1F, 0x8F, 0x1F, 0x98, 0x1F, 0x99, 0x1F, 0x9A, 0x1F, 0x9B, 0x1F,
+	0x9C, 0x1F, 0x9D, 0x1F, 0x9E, 0x1F, 0x9F, 0x1F, 0x98, 0x1F, 0x99, 0x1F, 0x9A, 0x1F, 0x9B, 0x1F,
+	0x9C, 0x1F, 0x9D, 0x1F, 0x9E, 0x1F, 0x9F, 0x1F, 0xA8, 0x1F, 0xA9, 0x1F, 0xAA, 0x1F, 0xAB, 0x1F,
+	0xAC, 0x1F, 0xAD, 0x1F, 0xAE, 0x1F, 0xAF, 0x1F, 0xA8, 0x1F, 0xA9, 0x1F, 0xAA, 0x1F, 0xAB, 0x1F,
+	0xAC, 0x1F, 0xAD, 0x1F, 0xAE, 0x1F, 0xAF, 0x1F, 0xB8, 0x1F, 0xB9, 0x1F, 0xB2, 0x1F, 0xBC, 0x1F,
+	0xB4, 0x1F, 0xB5, 0x1F, 0xB6, 0x1F, 0xB7, 0x1F, 0xB8, 0x1F, 0xB9, 0x1F, 0xBA, 0x1F, 0xBB, 0x1F,
+	0xBC, 0x1F, 0xBD, 0x1F, 0xBE, 0x1F, 0xBF, 0x1F, 0xC0, 0x1F, 0xC1, 0x1F, 0xC2, 0x1F, 0xC3, 0x1F,
+	0xC4, 0x1F, 0xC5, 0x1F, 0xC6, 0x1F, 0xC7, 0x1F, 0xC8, 0x1F, 0xC9, 0x1F, 0xCA, 0x1F, 0xCB, 0x1F,
+	0xC3, 0x1F, 0xCD, 0x1F, 0xCE, 0x1F, 0xCF, 0x1F, 0xD8, 0x1F, 0xD9, 0x1F, 0xD2, 0x1F, 0xD3, 0x1F,
+	0xD4, 0x1F, 0xD5, 0x1F, 0xD6, 0x1F, 0xD7, 0x1F, 0xD8, 0x1F, 0xD9, 0x1F, 0xDA, 0x1F, 0xDB, 0x1F,
+	0xDC, 0x1F, 0xDD, 0x1F, 0xDE, 0x1F, 0xDF, 0x1F, 0xE8, 0x1F, 0xE9, 0x1F, 0xE2, 0x1F, 0xE3, 0x1F,
+	0xE4, 0x1F, 0xEC, 0x1F, 0xE6, 0x1F, 0xE7, 0x1F, 0xE8, 0x1F, 0xE9, 0x1F, 0xEA, 0x1F, 0xEB, 0x1F,
+	0xEC, 0x1F, 0xED, 0x1F, 0xEE, 0x1F, 0xEF, 0x1F, 0xF0, 0x1F, 0xF1, 0x1F, 0xF2, 0x1F, 0xF3, 0x1F,
+	0xF4, 0x1F, 0xF5, 0x1F, 0xF6, 0x1F, 0xF7, 0x1F, 0xF8, 0x1F, 0xF9, 0x1F, 0xFA, 0x1F, 0xFB, 0x1F,
+	0xF3, 0x1F, 0xFD, 0x1F, 0xFE, 0x1F, 0xFF, 0x1F, 0x00, 0x20, 0x01, 0x20, 0x02, 0x20, 0x03, 0x20,
+	0x04, 0x20, 0x05, 0x20, 0x06, 0x20, 0x07, 0x20, 0x08, 0x20, 0x09, 0x20, 0x0A, 0x20, 0x0B, 0x20,
+	0x0C, 0x20, 0x0D, 0x20, 0x0E, 0x20, 0x0F, 0x20, 0x10, 0x20, 0x11, 0x20, 0x12, 0x20, 0x13, 0x20,
+	0x14, 0x20, 0x15, 0x20, 0x16, 0x20, 0x17, 0x20, 0x18, 0x20, 0x19, 0x20, 0x1A, 0x20, 0x1B, 0x20,
+	0x1C, 0x20, 0x1D, 0x20, 0x1E, 0x20, 0x1F, 0x20, 0x20, 0x20, 0x21, 0x20, 0x22, 0x20, 0x23, 0x20,
+	0x24, 0x20, 0x25, 0x20, 0x26, 0x20, 0x27, 0x20, 0x28, 0x20, 0x29, 0x20, 0x2A, 0x20, 0x2B, 0x20,
+	0x2C, 0x20, 0x2D, 0x20, 0x2E, 0x20, 0x2F, 0x20, 0x30, 0x20, 0x31, 0x20, 0x32, 0x20, 0x33, 0x20,
+	0x34, 0x20, 0x35, 0x20, 0x36, 0x20, 0x37, 0x20, 0x38, 0x20, 0x39, 0x20, 0x3A, 0x20, 0x3B, 0x20,
+	0x3C, 0x20, 0x3D, 0x20, 0x3E, 0x20, 0x3F, 0x20, 0x40, 0x20, 0x41, 0x20, 0x42, 0x20, 0x43, 0x20,
+	0x44, 0x20, 0x45, 0x20, 0x46, 0x20, 0x47, 0x20, 0x48, 0x20, 0x49, 0x20, 0x4A, 0x20, 0x4B, 0x20,
+	0x4C, 0x20, 0x4D, 0x20, 0x4E, 0x20, 0x4F, 0x20, 0x50, 0x20, 0x51, 0x20, 0x52, 0x20, 0x53, 0x20,
+	0x54, 0x20, 0x55, 0x20, 0x56, 0x20, 0x57, 0x20, 0x58, 0x20, 0x59, 0x20, 0x5A, 0x20, 0x5B, 0x20,
+	0x5C, 0x20, 0x5D, 0x20, 0x5E, 0x20, 0x5F, 0x20, 0x60, 0x20, 0x61, 0x20, 0x62, 0x20, 0x63, 0x20,
+	0x64, 0x20, 0x65, 0x20, 0x66, 0x20, 0x67, 0x20, 0x68, 0x20, 0x69, 0x20, 0x6A, 0x20, 0x6B, 0x20,
+	0x6C, 0x20, 0x6D, 0x20, 0x6E, 0x20, 0x6F, 0x20, 0x70, 0x20, 0x71, 0x20, 0x72, 0x20, 0x73, 0x20,
+	0x74, 0x20, 0x75, 0x20, 0x76, 0x20, 0x77, 0x20, 0x78, 0x20, 0x79, 0x20, 0x7A, 0x20, 0x7B, 0x20,
+	0x7C, 0x20, 0x7D, 0x20, 0x7E, 0x20, 0x7F, 0x20, 0x80, 0x20, 0x81, 0x20, 0x82, 0x20, 0x83, 0x20,
+	0x84, 0x20, 0x85, 0x20, 0x86, 0x20, 0x87, 0x20, 0x88, 0x20, 0x89, 0x20, 0x8A, 0x20, 0x8B, 0x20,
+	0x8C, 0x20, 0x8D, 0x20, 0x8E, 0x20, 0x8F, 0x20, 0x90, 0x20, 0x91, 0x20, 0x92, 0x20, 0x93, 0x20,
+	0x94, 0x20, 0x95, 0x20, 0x96, 0x20, 0x97, 0x20, 0x98, 0x20, 0x99, 0x20, 0x9A, 0x20, 0x9B, 0x20,
+	0x9C, 0x20, 0x9D, 0x20, 0x9E, 0x20, 0x9F, 0x20, 0xA0, 0x20, 0xA1, 0x20, 0xA2, 0x20, 0xA3, 0x20,
+	0xA4, 0x20, 0xA5, 0x20, 0xA6, 0x20, 0xA7, 0x20, 0xA8, 0x20, 0xA9, 0x20, 0xAA, 0x20, 0xAB, 0x20,
+	0xAC, 0x20, 0xAD, 0x20, 0xAE, 0x20, 0xAF, 0x20, 0xB0, 0x20, 0xB1, 0x20, 0xB2, 0x20, 0xB3, 0x20,
+	0xB4, 0x20, 0xB5, 0x20, 0xB6, 0x20, 0xB7, 0x20, 0xB8, 0x20, 0xB9, 0x20, 0xBA, 0x20, 0xBB, 0x20,
+	0xBC, 0x20, 0xBD, 0x20, 0xBE, 0x20, 0xBF, 0x20, 0xC0, 0x20, 0xC1, 0x20, 0xC2, 0x20, 0xC3, 0x20,
+	0xC4, 0x20, 0xC5, 0x20, 0xC6, 0x20, 0xC7, 0x20, 0xC8, 0x20, 0xC9, 0x20, 0xCA, 0x20, 0xCB, 0x20,
+	0xCC, 0x20, 0xCD, 0x20, 0xCE, 0x20, 0xCF, 0x20, 0xD0, 0x20, 0xD1, 0x20, 0xD2, 0x20, 0xD3, 0x20,
+	0xD4, 0x20, 0xD5, 0x20, 0xD6, 0x20, 0xD7, 0x20, 0xD8, 0x20, 0xD9, 0x20, 0xDA, 0x20, 0xDB, 0x20,
+	0xDC, 0x20, 0xDD, 0x20, 0xDE, 0x20, 0xDF, 0x20, 0xE0, 0x20, 0xE1, 0x20, 0xE2, 0x20, 0xE3, 0x20,
+	0xE4, 0x20, 0xE5, 0x20, 0xE6, 0x20, 0xE7, 0x20, 0xE8, 0x20, 0xE9, 0x20, 0xEA, 0x20, 0xEB, 0x20,
+	0xEC, 0x20, 0xED, 0x20, 0xEE, 0x20, 0xEF, 0x20, 0xF0, 0x20, 0xF1, 0x20, 0xF2, 0x20, 0xF3, 0x20,
+	0xF4, 0x20, 0xF5, 0x20, 0xF6, 0x20, 0xF7, 0x20, 0xF8, 0x20, 0xF9, 0x20, 0xFA, 0x20, 0xFB, 0x20,
+	0xFC, 0x20, 0xFD, 0x20, 0xFE, 0x20, 0xFF, 0x20, 0x00, 0x21, 0x01, 0x21, 0x02, 0x21, 0x03, 0x21,
+	0x04, 0x21, 0x05, 0x21, 0x06, 0x21, 0x07, 0x21, 0x08, 0x21, 0x09, 0x21, 0x0A, 0x21, 0x0B, 0x21,
+	0x0C, 0x21, 0x0D, 0x21, 0x0E, 0x21, 0x0F, 0x21, 0x10, 0x21, 0x11, 0x21, 0x12, 0x21, 0x13, 0x21,
+	0x14, 0x21, 0x15, 0x21, 0x16, 0x21, 0x17, 0x21, 0x18, 0x21, 0x19, 0x21, 0x1A, 0x21, 0x1B, 0x21,
+	0x1C, 0x21, 0x1D, 0x21, 0x1E, 0x21, 0x1F, 0x21, 0x20, 0x21, 0x21, 0x21, 0x22, 0x21, 0x23, 0x21,
+	0x24, 0x21, 0x25, 0x21, 0x26, 0x21, 0x27, 0x21, 0x28, 0x21, 0x29, 0x21, 0x2A, 0x21, 0x2B, 0x21,
+	0x2C, 0x21, 0x2D, 0x21, 0x2E, 0x21, 0x2F, 0x21, 0x30, 0x21, 0x31, 0x21, 0x32, 0x21, 0x33, 0x21,
+	0x34, 0x21, 0x35, 0x21, 0x36, 0x21, 0x37, 0x21, 0x38, 0x21, 0x39, 0x21, 0x3A, 0x21, 0x3B, 0x21,
+	0x3C, 0x21, 0x3D, 0x21, 0x3E, 0x21, 0x3F, 0x21, 0x40, 0x21, 0x41, 0x21, 0x42, 0x21, 0x43, 0x21,
+	0x44, 0x21, 0x45, 0x21, 0x46, 0x21, 0x47, 0x21, 0x48, 0x21, 0x49, 0x21, 0x4A, 0x21, 0x4B, 0x21,
+	0x4C, 0x21, 0x4D, 0x21, 0x32, 0x21, 0x4F, 0x21, 0x50, 0x21, 0x51, 0x21, 0x52, 0x21, 0x53, 0x21,
+	0x54, 0x21, 0x55, 0x21, 0x56, 0x21, 0x57, 0x21, 0x58, 0x21, 0x59, 0x21, 0x5A, 0x21, 0x5B, 0x21,
+	0x5C, 0x21, 0x5D, 0x21, 0x5E, 0x21, 0x5F, 0x21, 0x60, 0x21, 0x61, 0x21, 0x62, 0x21, 0x63, 0x21,
+	0x64, 0x21, 0x65, 0x21, 0x66, 0x21, 0x67, 0x21, 0x68, 0x21, 0x69, 0x21, 0x6A, 0x21, 0x6B, 0x21,
+	0x6C, 0x21, 0x6D, 0x21, 0x6E, 0x21, 0x6F, 0x21, 0x60, 0x21, 0x61, 0x21, 0x62, 0x21, 0x63, 0x21,
+	0x64, 0x21, 0x65, 0x21, 0x66, 0x21, 0x67, 0x21, 0x68, 0x21, 0x69, 0x21, 0x6A, 0x21, 0x6B, 0x21,
+	0x6C, 0x21, 0x6D, 0x21, 0x6E, 0x21, 0x6F, 0x21, 0x80, 0x21, 0x81, 0x21, 0x82, 0x21, 0x83, 0x21,
+	0x83, 0x21, 0xFF, 0xFF, 0x4B, 0x03, 0xB6, 0x24, 0xB7, 0x24, 0xB8, 0x24, 0xB9, 0x24, 0xBA, 0x24,
+	0xBB, 0x24, 0xBC, 0x24, 0xBD, 0x24, 0xBE, 0x24, 0xBF, 0x24, 0xC0, 0x24, 0xC1, 0x24, 0xC2, 0x24,
+	0xC3, 0x24, 0xC4, 0x24, 0xC5, 0x24, 0xC6, 0x24, 0xC7, 0x24, 0xC8, 0x24, 0xC9, 0x24, 0xCA, 0x24,
+	0xCB, 0x24, 0xCC, 0x24, 0xCD, 0x24, 0xCE, 0x24, 0xCF, 0x24, 0xFF, 0xFF, 0x46, 0x07, 0x00, 0x2C,
+	0x01, 0x2C, 0x02, 0x2C, 0x03, 0x2C, 0x04, 0x2C, 0x05, 0x2C, 0x06, 0x2C, 0x07, 0x2C, 0x08, 0x2C,
+	0x09, 0x2C, 0x0A, 0x2C, 0x0B, 0x2C, 0x0C, 0x2C, 0x0D, 0x2C, 0x0E, 0x2C, 0x0F, 0x2C, 0x10, 0x2C,
+	0x11, 0x2C, 0x12, 0x2C, 0x13, 0x2C, 0x14, 0x2C, 0x15, 0x2C, 0x16, 0x2C, 0x17, 0x2C, 0x18, 0x2C,
+	0x19, 0x2C, 0x1A, 0x2C, 0x1B, 0x2C, 0x1C, 0x2C, 0x1D, 0x2C, 0x1E, 0x2C, 0x1F, 0x2C, 0x20, 0x2C,
+	0x21, 0x2C, 0x22, 0x2C, 0x23, 0x2C, 0x24, 0x2C, 0x25, 0x2C, 0x26, 0x2C, 0x27, 0x2C, 0x28, 0x2C,
+	0x29, 0x2C, 0x2A, 0x2C, 0x2B, 0x2C, 0x2C, 0x2C, 0x2D, 0x2C, 0x2E, 0x2C, 0x5F, 0x2C, 0x60, 0x2C,
+	0x60, 0x2C, 0x62, 0x2C, 0x63, 0x2C, 0x64, 0x2C, 0x65, 0x2C, 0x66, 0x2C, 0x67, 0x2C, 0x67, 0x2C,
+	0x69, 0x2C, 0x69, 0x2C, 0x6B, 0x2C, 0x6B, 0x2C, 0x6D, 0x2C, 0x6E, 0x2C, 0x6F, 0x2C, 0x70, 0x2C,
+	0x71, 0x2C, 0x72, 0x2C, 0x73, 0x2C, 0x74, 0x2C, 0x75, 0x2C, 0x75, 0x2C, 0x77, 0x2C, 0x78, 0x2C,
+	0x79, 0x2C, 0x7A, 0x2C, 0x7B, 0x2C, 0x7C, 0x2C, 0x7D, 0x2C, 0x7E, 0x2C, 0x7F, 0x2C, 0x80, 0x2C,
+	0x80, 0x2C, 0x82, 0x2C, 0x82, 0x2C, 0x84, 0x2C, 0x84, 0x2C, 0x86, 0x2C, 0x86, 0x2C, 0x88, 0x2C,
+	0x88, 0x2C, 0x8A, 0x2C, 0x8A, 0x2C, 0x8C, 0x2C, 0x8C, 0x2C, 0x8E, 0x2C, 0x8E, 0x2C, 0x90, 0x2C,
+	0x90, 0x2C, 0x92, 0x2C, 0x92, 0x2C, 0x94, 0x2C, 0x94, 0x2C, 0x96, 0x2C, 0x96, 0x2C, 0x98, 0x2C,
+	0x98, 0x2C, 0x9A, 0x2C, 0x9A, 0x2C, 0x9C, 0x2C, 0x9C, 0x2C, 0x9E, 0x2C, 0x9E, 0x2C, 0xA0, 0x2C,
+	0xA0, 0x2C, 0xA2, 0x2C, 0xA2, 0x2C, 0xA4, 0x2C, 0xA4, 0x2C, 0xA6, 0x2C, 0xA6, 0x2C, 0xA8, 0x2C,
+	0xA8, 0x2C, 0xAA, 0x2C, 0xAA, 0x2C, 0xAC, 0x2C, 0xAC, 0x2C, 0xAE, 0x2C, 0xAE, 0x2C, 0xB0, 0x2C,
+	0xB0, 0x2C, 0xB2, 0x2C, 0xB2, 0x2C, 0xB4, 0x2C, 0xB4, 0x2C, 0xB6, 0x2C, 0xB6, 0x2C, 0xB8, 0x2C,
+	0xB8, 0x2C, 0xBA, 0x2C, 0xBA, 0x2C, 0xBC, 0x2C, 0xBC, 0x2C, 0xBE, 0x2C, 0xBE, 0x2C, 0xC0, 0x2C,
+	0xC0, 0x2C, 0xC2, 0x2C, 0xC2, 0x2C, 0xC4, 0x2C, 0xC4, 0x2C, 0xC6, 0x2C, 0xC6, 0x2C, 0xC8, 0x2C,
+	0xC8, 0x2C, 0xCA, 0x2C, 0xCA, 0x2C, 0xCC, 0x2C, 0xCC, 0x2C, 0xCE, 0x2C, 0xCE, 0x2C, 0xD0, 0x2C,
+	0xD0, 0x2C, 0xD2, 0x2C, 0xD2, 0x2C, 0xD4, 0x2C, 0xD4, 0x2C, 0xD6, 0x2C, 0xD6, 0x2C, 0xD8, 0x2C,
+	0xD8, 0x2C, 0xDA, 0x2C, 0xDA, 0x2C, 0xDC, 0x2C, 0xDC, 0x2C, 0xDE, 0x2C, 0xDE, 0x2C, 0xE0, 0x2C,
+	0xE0, 0x2C, 0xE2, 0x2C, 0xE2, 0x2C, 0xE4, 0x2C, 0xE5, 0x2C, 0xE6, 0x2C, 0xE7, 0x2C, 0xE8, 0x2C,
+	0xE9, 0x2C, 0xEA, 0x2C, 0xEB, 0x2C, 0xEC, 0x2C, 0xED, 0x2C, 0xEE, 0x2C, 0xEF, 0x2C, 0xF0, 0x2C,
+	0xF1, 0x2C, 0xF2, 0x2C, 0xF3, 0x2C, 0xF4, 0x2C, 0xF5, 0x2C, 0xF6, 0x2C, 0xF7, 0x2C, 0xF8, 0x2C,
+	0xF9, 0x2C, 0xFA, 0x2C, 0xFB, 0x2C, 0xFC, 0x2C, 0xFD, 0x2C, 0xFE, 0x2C, 0xFF, 0x2C, 0xA0, 0x10,
+	0xA1, 0x10, 0xA2, 0x10, 0xA3, 0x10, 0xA4, 0x10, 0xA5, 0x10, 0xA6, 0x10, 0xA7, 0x10, 0xA8, 0x10,
+	0xA9, 0x10, 0xAA, 0x10, 0xAB, 0x10, 0xAC, 0x10, 0xAD, 0x10, 0xAE, 0x10, 0xAF, 0x10, 0xB0, 0x10,
+	0xB1, 0x10, 0xB2, 0x10, 0xB3, 0x10, 0xB4, 0x10, 0xB5, 0x10, 0xB6, 0x10, 0xB7, 0x10, 0xB8, 0x10,
+	0xB9, 0x10, 0xBA, 0x10, 0xBB, 0x10, 0xBC, 0x10, 0xBD, 0x10, 0xBE, 0x10, 0xBF, 0x10, 0xC0, 0x10,
+	0xC1, 0x10, 0xC2, 0x10, 0xC3, 0x10, 0xC4, 0x10, 0xC5, 0x10, 0xFF, 0xFF, 0x1B, 0xD2, 0x21, 0xFF,
+	0x22, 0xFF, 0x23, 0xFF, 0x24, 0xFF, 0x25, 0xFF, 0x26, 0xFF, 0x27, 0xFF, 0x28, 0xFF, 0x29, 0xFF,
+	0x2A, 0xFF, 0x2B, 0xFF, 0x2C, 0xFF, 0x2D, 0xFF, 0x2E, 0xFF, 0x2F, 0xFF, 0x30, 0xFF, 0x31, 0xFF,
+	0x32, 0xFF, 0x33, 0xFF, 0x34, 0xFF, 0x35, 0xFF, 0x36, 0xFF, 0x37, 0xFF, 0x38, 0xFF, 0x39, 0xFF,
+	0x3A, 0xFF, 0x5B, 0xFF, 0x5C, 0xFF, 0x5D, 0xFF, 0x5E, 0xFF, 0x5F, 0xFF, 0x60, 0xFF, 0x61, 0xFF,
+	0x62, 0xFF, 0x63, 0xFF, 0x64, 0xFF, 0x65, 0xFF, 0x66, 0xFF, 0x67, 0xFF, 0x68, 0xFF, 0x69, 0xFF,
+	0x6A, 0xFF, 0x6B, 0xFF, 0x6C, 0xFF, 0x6D, 0xFF, 0x6E, 0xFF, 0x6F, 0xFF, 0x70, 0xFF, 0x71, 0xFF,
+	0x72, 0xFF, 0x73, 0xFF, 0x74, 0xFF, 0x75, 0xFF, 0x76, 0xFF, 0x77, 0xFF, 0x78, 0xFF, 0x79, 0xFF,
+	0x7A, 0xFF, 0x7B, 0xFF, 0x7C, 0xFF, 0x7D, 0xFF, 0x7E, 0xFF, 0x7F, 0xFF, 0x80, 0xFF, 0x81, 0xFF,
+	0x82, 0xFF, 0x83, 0xFF, 0x84, 0xFF, 0x85, 0xFF, 0x86, 0xFF, 0x87, 0xFF, 0x88, 0xFF, 0x89, 0xFF,
+	0x8A, 0xFF, 0x8B, 0xFF, 0x8C, 0xFF, 0x8D, 0xFF, 0x8E, 0xFF, 0x8F, 0xFF, 0x90, 0xFF, 0x91, 0xFF,
+	0x92, 0xFF, 0x93, 0xFF, 0x94, 0xFF, 0x95, 0xFF, 0x96, 0xFF, 0x97, 0xFF, 0x98, 0xFF, 0x99, 0xFF,
+	0x9A, 0xFF, 0x9B, 0xFF, 0x9C, 0xFF, 0x9D, 0xFF, 0x9E, 0xFF, 0x9F, 0xFF, 0xA0, 0xFF, 0xA1, 0xFF,
+	0xA2, 0xFF, 0xA3, 0xFF, 0xA4, 0xFF, 0xA5, 0xFF, 0xA6, 0xFF, 0xA7, 0xFF, 0xA8, 0xFF, 0xA9, 0xFF,
+	0xAA, 0xFF, 0xAB, 0xFF, 0xAC, 0xFF, 0xAD, 0xFF, 0xAE, 0xFF, 0xAF, 0xFF, 0xB0, 0xFF, 0xB1, 0xFF,
+	0xB2, 0xFF, 0xB3, 0xFF, 0xB4, 0xFF, 0xB5, 0xFF, 0xB6, 0xFF, 0xB7, 0xFF, 0xB8, 0xFF, 0xB9, 0xFF,
+	0xBA, 0xFF, 0xBB, 0xFF, 0xBC, 0xFF, 0xBD, 0xFF, 0xBE, 0xFF, 0xBF, 0xFF, 0xC0, 0xFF, 0xC1, 0xFF,
+	0xC2, 0xFF, 0xC3, 0xFF, 0xC4, 0xFF, 0xC5, 0xFF, 0xC6, 0xFF, 0xC7, 0xFF, 0xC8, 0xFF, 0xC9, 0xFF,
+	0xCA, 0xFF, 0xCB, 0xFF, 0xCC, 0xFF, 0xCD, 0xFF, 0xCE, 0xFF, 0xCF, 0xFF, 0xD0, 0xFF, 0xD1, 0xFF,
+	0xD2, 0xFF, 0xD3, 0xFF, 0xD4, 0xFF, 0xD5, 0xFF, 0xD6, 0xFF, 0xD7, 0xFF, 0xD8, 0xFF, 0xD9, 0xFF,
+	0xDA, 0xFF, 0xDB, 0xFF, 0xDC, 0xFF, 0xDD, 0xFF, 0xDE, 0xFF, 0xDF, 0xFF, 0xE0, 0xFF, 0xE1, 0xFF,
+	0xE2, 0xFF, 0xE3, 0xFF, 0xE4, 0xFF, 0xE5, 0xFF, 0xE6, 0xFF, 0xE7, 0xFF, 0xE8, 0xFF, 0xE9, 0xFF,
+	0xEA, 0xFF, 0xEB, 0xFF, 0xEC, 0xFF, 0xED, 0xFF, 0xEE, 0xFF, 0xEF, 0xFF, 0xF0, 0xFF, 0xF1, 0xFF,
+	0xF2, 0xFF, 0xF3, 0xFF, 0xF4, 0xFF, 0xF5, 0xFF, 0xF6, 0xFF, 0xF7, 0xFF, 0xF8, 0xFF, 0xF9, 0xFF,
+	0xFA, 0xFF, 0xFB, 0xFF, 0xFC, 0xFF, 0xFD, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF
+};
diff --git a/kernel/fs/exfat/exfat_version.h b/kernel/fs/exfat/exfat_version.h
new file mode 100755
index 0000000000..a93fa46be0
--- /dev/null
+++ b/kernel/fs/exfat/exfat_version.h
@@ -0,0 +1,19 @@
+/************************************************************************/
+/*                                                                      */
+/*  PROJECT : exFAT & FAT12/16/32 File System                           */
+/*  FILE    : exfat_version.h                                           */
+/*  PURPOSE : exFAT File Manager                                        */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  NOTES                                                               */
+/*                                                                      */
+/*----------------------------------------------------------------------*/
+/*  REVISION HISTORY                                                    */
+/*                                                                      */
+/*  - 2012.02.10 : Release Version 1.1.0                                */
+/*  - 2012.04.02 : P1 : Change Module License to Samsung Proprietary    */
+/*  - 2012.06.07 : P2 : Fixed incorrect filename problem                */
+/*                                                                      */
+/************************************************************************/
+
+#define EXFAT_VERSION  "1.2.9"
